<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"planarg.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="PlanarG&#39;s blog">
<meta property="og:url" content="https://planarg.top/page/15/index.html">
<meta property="og:site_name" content="PlanarG&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="PlanarG">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://planarg.top/page/15/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>PlanarG's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">PlanarG's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section">首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section">标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section">分类</a>

  </li>
        <li class="menu-item menu-item-友链">

    <a href="/friends/" rel="section">友链</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section">归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger">搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/09/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/09/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/" class="post-title-link" itemprop="url">二次剩余</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-09 10:20:40" itemprop="dateCreated datePublished" datetime="2019-04-09T10:20:40+08:00">2019-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:34:44" itemprop="dateModified" datetime="2020-04-23T09:34:44+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>若方程$x^2\equiv a\pmod p$有解，那么称$a$为$p$的二次剩余，否则$a$为$p$的非二次剩余</p>
<h1 id="勒让德符号及欧拉判别法"><a href="#勒让德符号及欧拉判别法" class="headerlink" title="勒让德符号及欧拉判别法"></a>勒让德符号及欧拉判别法</h1><p>定义勒让德符号为</p>
<script type="math/tex; mode=display">
\left(\frac{a}{p}\right)=\begin{cases}1&a为p的二次剩余\\\ -1&a为p的非二次剩余\\\ 0 &a能被p整除\end{cases}</script><p>欧拉判别法就是：如果$a$不能被$p$整除，那么有</p>
<script type="math/tex; mode=display">
\left(\frac{a}{p}\right)=a^{\frac{p-1}{2}}</script><h2 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h2><blockquote>
<p>对于方程$x^2\equiv a\pmod p$ ，共有$\frac{p-1}{2}$个不同的$a$使得该方程有解</p>
</blockquote>
<p>我们忽略$x=0$，如果枚举$x$再求出$a$，那么$x$一共有$p-1$个不同的值，也就产生了$p-1$个$a$</p>
<p>我们知道一个二次剩余恰好会产生两个解，那么这$p-1$个$a$就被分配到了$\frac{p-1}{2}$个不同的桶里面</p>
<p>所以共有$\frac{p-1}{2}$个$a$</p>
<h2 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h2><blockquote>
<p>$(x+y)^p\equiv x^p+y^p\pmod p$</p>
</blockquote>
<p>我们将其二项式展开</p>
<script type="math/tex; mode=display">
(x+y)^p=\sum_{i=0}^p{p\choose i}x^iy^{p-i}</script><p>当$i\not=0$且$i\not=p$时，$p\choose i$一定包含因数$p$，所以可以忽略</p>
<p>只剩下第一项和最后一项</p>
<h1 id="Cipolla算法"><a href="#Cipolla算法" class="headerlink" title="Cipolla算法"></a>Cipolla算法</h1><p>现在要求出方程$x^2\equiv n\pmod p$的一个解</p>
<p>我们找出一个$a​$，使得$(a^2-n)^{\frac{p-1}{2}}\equiv-1\pmod p​$</p>
<p>设$\omega=\sqrt{a^2-n}$</p>
<blockquote>
<p>结论：$x=(a+\omega)^{\frac{p+1}{2}}$</p>
</blockquote>
<p>证明如下：</p>
<p>我们知道</p>
<script type="math/tex; mode=display">
(a^2-n)^{\frac{p-1}{2}}\equiv-1\pmod p\Rightarrow (\omega^2)^{\frac{p-1}{2}}\equiv -1\pmod p\\\
\omega^{p-1}\equiv -1\pmod p</script><p>那么有</p>
<script type="math/tex; mode=display">
\begin{aligned}
x&\equiv (a+\omega)^{\frac{p+1}{2}}\\\
x^2&\equiv (a+\omega)^{p+1}\equiv(a+\omega)^p(a+\omega)\\\
&\equiv(a^p+\omega^p)(a+\omega)\\\
&\equiv(a-\omega)(a+\omega)\\\
&\equiv a^2-\omega^2\equiv a^2-a^2+n\equiv n
\end{aligned}</script><p>我们可以通过实现一个类似复数的结构体来进行运算</p>
<p>由于$p$的二次剩余一共有$\frac{p-1}{2}$个，而$a$在$[0,p)$中随机选取</p>
<p>那么成功的概率就是$\frac{1}{2}$</p>
<p>此时答案中$\omega$部分的系数必然为0</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/09/BSGS%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/09/BSGS%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95/" class="post-title-link" itemprop="url">BSGS及其拓展</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-09 09:25:08" itemprop="dateCreated datePublished" datetime="2019-04-09T09:25:08+08:00">2019-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:21:34" itemprop="dateModified" datetime="2020-04-23T09:21:34+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a>BSGS</h1><p>解高次同余方程</p>
<script type="math/tex; mode=display">
A^x\equiv B\mod C且A\bot B</script><p>根据费马小定理，我们直到$A^{C-1}\equiv B\mod C$</p>
<p>那么如果这个方程有解，那么解的周期一定不会大于$C$，所以必然存在一个不大于$C$的解</p>
<p>如果$C$比较小，那么我们可以直接枚举$x$然后暴力判断</p>
<p>考虑$C$比较大的情况，这时就需要使用<code>BSGS</code>了</p>
<p>我们设$x=i*m-j$，其中$j&lt;m$，这个$m$是一个常量，我们设为$\sqrt{C}$</p>
<p>那么有</p>
<script type="math/tex; mode=display">
A^{i\*m-j}\equiv B\mod C\\\
A^{i\*m}\equiv B\*A^j\mod C</script><p>我们开一个<code>map</code>，枚举$j$，将$B*A^j$放到这个<code>map</code>里面</p>
<p>然后我们枚举$i*m$，在<code>map</code>中查找是否存在$A^{i*m}​$即可</p>
<p>注意这样枚举是取不到$x=0$的，这种情况我们需要特判</p>
<p>如果$i*m$此时已经大于$C$了，那么就无解</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">BSGS</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (B % C == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; s.clear();</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(C)), ls = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++, ls = (LL)ls * A % C)</span><br><span class="line">        s[(LL)B * ls % C] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, t = ls;i &lt;= C;i += m, t = (LL)t * ls % C) </span><br><span class="line">        <span class="keyword">if</span> (s.count(t)) <span class="keyword">return</span> i - s[t];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="exBSGS"><a href="#exBSGS" class="headerlink" title="exBSGS"></a>exBSGS</h1><p>同样是解上面那个方程</p>
<p>但是如果$A,C$不互质呢</p>
<p>原方程等价于</p>
<script type="math/tex; mode=display">
A^x+Cy=B</script><p>我们不停地消去$A,C$的非1因子，可以使得方程变为</p>
<script type="math/tex; mode=display">
aA^z+C'y=B'</script><p>每消去一次，我们就从$A^x$里面拿一个$A$出来，消完之后乘到系数$a$里面去</p>
<p>注意在消去过程中时，如果存在某个时刻使得$a=B’$，那么直接返回此时的消去次数就可以了</p>
<p>如果在消去过程中，$B’$没有当前要消去的那个因子，那么直接返回$-1$</p>
<p>我们设消去次数为$k$</p>
<p>那么此时方程就变成了</p>
<script type="math/tex; mode=display">
aA^z\equiv B'\mod C'(A\bot C')</script><p>使用普通的<code>BSGS</code>可以解出$z$，注意此时前面还有一个系数$a$</p>
<p>最后我们将解出的$z$加上$k$即可，因为最开始拿出了$k$个$A$来消去因数</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> b ? gcd(b, a % b) : a;&#125;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">BSGS</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C, <span class="keyword">int</span> basic)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (B % C == basic) <span class="keyword">return</span> <span class="number">0</span>; s.clear();</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(C)), ls = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++, ls = (LL)ls * A % C)</span><br><span class="line">        s[(LL)B * ls % C] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, t = (LL)ls * basic % C;i &lt;= C;i += m, t = (LL)t * ls % C) </span><br><span class="line">        <span class="keyword">if</span> (s.count(t)) <span class="keyword">return</span> i - s[t];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">exBSGS</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, cnt = <span class="number">0</span>, d; A %= C, B %= C;</span><br><span class="line">    <span class="keyword">while</span> ((d = gcd(A, C)) != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (B % d) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        a = (LL)a * (A / d) % C, C /= d, B /= d, cnt++;</span><br><span class="line">        <span class="keyword">if</span> (a == B) <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = BSGS(A, B, C, a);</span><br><span class="line">    <span class="keyword">return</span> ~res ? res + cnt : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/08/12%E7%9C%81%E8%81%94%E8%80%832019-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/08/12%E7%9C%81%E8%81%94%E8%80%832019-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">12省联考2019 字符串问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-08 21:26:15" itemprop="dateCreated datePublished" datetime="2019-04-08T21:26:15+08:00">2019-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:23:48" itemprop="dateModified" datetime="2020-04-23T09:23:48+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A2%98%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">题解</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给出一个字符串$S$， 现在要选取它的$n_a$个子串作为$A$类串，选取$n_b$个子串作为$B$类串</p>
<p>其中第$i$个$A$类串为$S(la_i,ra_i)$，第$i$个$B$类串为$S(lb_i,rb_i)$，$la_i,ra_i,lb_i,rb_i,n_a,n_b$均已给出</p>
<p>现额外给定$m$组支配关系，每组关系$(x,y)$表示第$x$个$A$类串支配第$y$个$B$类串</p>
<p>求出一个长度最大的字符串$T$，满足$T$是由$A$类串拼接而成的。我们假设$T$被划分成了$t_1,t_2,\cdots,t_k$（都是$A$类串），要求满足对于任意的$i&lt;k$，$t_i$所支配的串中至少有一个是$t_{i+1}$的前缀</p>
<p><img src="https://i.loli.net/2019/04/08/5cab4fcbe56e2.png" alt="1554730942968"></p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>对于这种要求所求值最大的问题，不是动态规划就是最长路</p>
<p>那么对于这道题显然就只能是最长路了</p>
<p>如果最后构建出来的图有环，那么$T$就可以无限长</p>
<p>否则我们拓扑排序，然后跑一个<code>dp</code>就可以了</p>
<p>首先我们将$S$串翻转，将所有的$A$串与$B$串都翻转</p>
<p>这样限制条件就可以变为我们熟悉的后缀</p>
<p>我们先考虑一种暴力连边方式</p>
<p>每个$A$串建一个点，每个$B$串建一个点</p>
<p>对于$A_i$，将所有是其后缀的$B$连向$A_i$，权值为$|A_i|$</p>
<p>对于一组支配$(A_i,B_i)$，$A_i$往$B_i$连一条权值为0的边</p>
<p>但是这样最坏会连$n_a*n_b$条边，需要优化</p>
<p>我们考虑这样一种优化方案</p>
<p>对于任意的$A_i,B_i$，如果$B_i$是$A_i$的后缀，那么$B_i$的后缀也是$A_i$的后缀</p>
<p>我们对于$B$单独建一个子图，这个子图需要满足如果$B_i$是$B_j$的后缀，那么所有能走到$B_i$的路径都可以走到$B_j$</p>
<p>这样的话$A_i$只需要从它包含的那个最长的$B$串后缀连边就可以了</p>
<p>那么什么图满足这个性质呢？</p>
<p>很明显是<code>parent</code>树</p>
<p>我们建出<code>parent</code>树，然后从父亲往儿子节点连边</p>
<p>因为父亲对应的点一定是儿子的后缀</p>
<p>对于每个串$A_i,B_i$，找到它在树上的位置，这个可以通过倍增实现</p>
<p>实际上我们不需要对于每个串$A$，都找到那个最长的且是它后缀的$B$</p>
<p>直接从<code>parent</code>树上$A_i$的对应节点往$A_i$连边就可以了</p>
<p>因为这样同样可以保证最长的且是它后缀的$B$可以走到$A_i$</p>
<p>兴奋地写完，发现第三个样例过不去($-1$)</p>
<p>事实上是我们少考虑了一种情况</p>
<p><code>parent</code>树上的某个节点可以表示长度在一段区间的串</p>
<p>如果一条路径是从父亲走向儿子，那么当然没有问题，因为此时它代表的串是这个节点所能代表的最短的串</p>
<p>如果有一个串$A_i$以及另一个串$B_j$，它们对应着树上的同一个点</p>
<p>在之前的建图方式中，$B_j$一定能到达$A_i$</p>
<p>但是如果$|B_j|&gt;|A_i|$呢，显然这种转移是不合法的</p>
<p>解决方法是对于树上的一个点$u$，假如有$a_u$个$A$串挂在上面</p>
<p>那么我们将这些$A$串按照长度从小到大排序，将$u$拆成$a_u+1$个点，第$i$个点往$i+1$个点连边，父亲的最右边那个点往儿子的最左边那个点连边</p>
<p>对于一个串$B$，它就对应着它在树上的那个点所拆成的点中，第一个长度不小于它的点</p>
<p>这样就没有问题了</p>
<p>注意开<code>long long</code></p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> P = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="keyword">int</span> LEN;</span><br><span class="line"><span class="keyword">namespace</span> SAM &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; next; </span><br><span class="line">        <span class="keyword">int</span> link, len;</span><br><span class="line">    &#125; st[N * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ncnt, last;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;st[<span class="number">0</span>].link = <span class="number">-1</span>, st[<span class="number">0</span>].len = ncnt = last = <span class="number">0</span>, st[<span class="number">0</span>].next.clear();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">extend</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = ++ncnt, p; st[cur].len = st[last].len + <span class="number">1</span>, st[cur].link = <span class="number">0</span>, st[cur].next.clear();</span><br><span class="line">        <span class="keyword">for</span> (p = last;p != <span class="number">-1</span> &amp;&amp; !st[p].next.count(c);p = st[p].link)</span><br><span class="line">            st[p].next[c] = cur;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> q = st[p].next[c];</span><br><span class="line">            <span class="keyword">if</span> (st[q].len == st[p].len + <span class="number">1</span>) st[cur].link = q;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> clone = ++ncnt; st[clone].len = st[p].len + <span class="number">1</span>, st[clone].next = st[q].next, st[clone].link = st[q].link;</span><br><span class="line">                <span class="keyword">for</span> (;p != <span class="number">-1</span> &amp;&amp; st[p].next[c] == q;p = st[p].link)</span><br><span class="line">                    st[p].next[c] = clone;</span><br><span class="line">                st[q].link = st[cur].link = clone;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= ncnt;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : st[i].next)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"sam: "</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; v.second &lt;&lt; <span class="string">' '</span> &lt;&lt; v.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> SUF_Tree &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to, next;&#125; e[N * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> head[N * <span class="number">2</span>], ecnt, len[N * <span class="number">2</span>], fa[<span class="number">18</span>][N * <span class="number">2</span>]; </span><br><span class="line">    <span class="built_in">vector</span>&lt;P&gt; nodes[N * <span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">        fa[<span class="number">0</span>][u] = f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">17</span>;i++) fa[i][u] = fa[i - <span class="number">1</span>][fa[i - <span class="number">1</span>][u]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">            <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">2</span> * LEN;i++) head[i] = <span class="number">0</span>, nodes[i].clear(), nodes[i].push_back(P(<span class="number">1e9</span>, <span class="number">-1</span>));</span><br><span class="line">        ecnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>;i &gt;= <span class="number">0</span>;i--) <span class="keyword">if</span> (fa[i][u])</span><br><span class="line">            <span class="keyword">if</span> (l &lt;= len[fa[i][now]])</span><br><span class="line">                now = fa[i][now];</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> id[N], tot, onT[N], sz[N], onT2[N], na;</span><br><span class="line"><span class="keyword">namespace</span> GRAPH &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to, next, w;&#125; e[N * <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">int</span> head[N * <span class="number">4</span>], ecnt, ind[N * <span class="number">4</span>], st[N * <span class="number">4</span>], top, ncnt; LL dp[N * <span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        e[++ecnt] = (edge)&#123;to, head[from], w&#125;, ind[to]++, head[from] = ecnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Topsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        top = <span class="number">0</span>; <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= ncnt;i++) <span class="keyword">if</span> (!ind[i]) q.push(i), st[++top] = i;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next) </span><br><span class="line">                <span class="keyword">if</span> (!(--ind[e[i].to])) q.push(e[i].to), st[++top] = e[i].to;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> top == ncnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= ncnt;i++) head[i] = ind[i] = dp[i] = <span class="number">0</span>;</span><br><span class="line">        ecnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">DP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = top;i &gt;= <span class="number">1</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = st[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = head[u];j;j = e[j].next)</span><br><span class="line">                dp[u] = max(dp[u], dp[e[j].to] + e[j].w);</span><br><span class="line">            <span class="keyword">if</span> (u &lt;= na) res = max(res, dp[u] + sz[u]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p[N * <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    p[u].clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : SUF_Tree::nodes[u]) &#123;</span><br><span class="line">        p[u].push_back(++tot);</span><br><span class="line">        <span class="keyword">if</span> (v.second &gt; <span class="number">0</span>) onT[v.second] = tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i + <span class="number">1</span> &lt; p[u].size();i++)</span><br><span class="line">        GRAPH::adde(p[u][i], p[u][i + <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = SUF_Tree::head[u];i;i = SUF_Tree::e[i].next) &#123;</span><br><span class="line">        dfs(SUF_Tree::e[i].to);</span><br><span class="line">        GRAPH::adde(*p[u].rbegin(), *p[SUF_Tree::e[i].to].begin(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; read(T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>), LEN = <span class="built_in">strlen</span>(s + <span class="number">1</span>), reverse(s + <span class="number">1</span>, s + LEN + <span class="number">1</span>), SAM::init(), SUF_Tree::init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= LEN;i++) id[i] = SAM::extend(s[i]);</span><br><span class="line"><span class="comment">//        cout &lt;&lt; SAM::ncnt &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= SAM::ncnt;i++) SUF_Tree::adde(SAM::st[i].link, i), SUF_Tree::len[i] = SAM::st[i].len;</span><br><span class="line">        SUF_Tree::dfs(<span class="number">0</span>, <span class="number">0</span>); read(na), tot = na;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; "ok" &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l, r;i &lt;= na;i++) &#123;</span><br><span class="line">            read(l), read(r), l = LEN - l + <span class="number">1</span>, r = LEN - r + <span class="number">1</span>, swap(l, r), sz[i] = r - l + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> t = SUF_Tree::find(id[r], r - l + <span class="number">1</span>); </span><br><span class="line">            SUF_Tree::nodes[t].push_back(P(r - l + <span class="number">1</span>, i));</span><br><span class="line">        &#125;</span><br><span class="line">        GRAPH::ncnt = na * <span class="number">2</span> + SAM::ncnt + <span class="number">1</span>, GRAPH::init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= SAM::ncnt;i++) sort(SUF_Tree::nodes[i].begin(), SUF_Tree::nodes[i].end());</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= na;i++) GRAPH::adde(onT[i], i, sz[i]);</span><br><span class="line">        <span class="keyword">int</span> nb; read(nb);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l, r;i &lt;= nb;i++) &#123;</span><br><span class="line">            read(l), read(r), l = LEN - l + <span class="number">1</span>, r = LEN - r + <span class="number">1</span>, swap(l, r);</span><br><span class="line">            <span class="keyword">int</span> t = SUF_Tree::find(id[r], r - l + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> pos = lower_bound(SUF_Tree::nodes[t].begin(), SUF_Tree::nodes[t].end(), P(r - l + <span class="number">1</span>, <span class="number">-2</span>)) - SUF_Tree::nodes[t].begin();</span><br><span class="line">            onT2[i] = p[t][pos];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> matches; read(matches);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= matches;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b; read(a), read(b), GRAPH::adde(a, onT2[b], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        GRAPH::ncnt = tot;</span><br><span class="line">        <span class="keyword">if</span> (!GRAPH::Topsort()) &#123;<span class="built_in">puts</span>(<span class="string">"-1"</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, GRAPH::DP());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/07/BJOI2018-%E5%8F%8C%E4%BA%BA%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/07/BJOI2018-%E5%8F%8C%E4%BA%BA%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/" class="post-title-link" itemprop="url">BJOI2018 双人猜数游戏</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-07 11:53:41" itemprop="dateCreated datePublished" datetime="2019-04-07T11:53:41+08:00">2019-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:21:47" itemprop="dateModified" datetime="2020-04-23T09:21:47+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A2%98%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">题解</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://www.luogu.org/problemnew/show/P4459" target="_blank" rel="noopener">题目链接</a></p>
<p>神仙题啊</p>
<p>首先来模拟一下样例</p>
<p><code>Alice</code>知道乘积是60，<code>Bob</code>知道和是16，且两个数均不小于5</p>
<p><code>Bob</code>：此时两个数有可能为</p>
<p>$(5, 11), (6, 10), (7, 9), (8, 8)$</p>
<p>而<code>Bob</code>在第一轮没有猜出来，也就是说，这两个数的和不是10或11</p>
<p><code>Alice</code>：此时两个数有可能为</p>
<p>$(5, 12), (6, 10)$</p>
<p>由于Alice也没有猜出来，所以对于Bob来说，以下情况就被排除了</p>
<p>$(5, 11), (7, 9), (8, 8)$</p>
<p>对于$(5, 11)$而言，55只有这一种分解方式，而<code>Alice</code>在第一轮中没有猜出来，所以不是</p>
<p>对于$(7, 9)$而言，63还可以被分解成$(3, 21)$，但是不满足两个数都大于等于5，而<code>Alice</code>没有猜出来，所以也不是</p>
<p>$(8, 8)​$同理</p>
<p>所以对于<code>Bob</code>来说，这两个数只有可能是$(6, 10)$，他也就确定了答案</p>
<p><code>Alice</code>知道，<code>Bob</code>已经猜出来了，所以$(5, 12)$就被排除了，因为在这种情况下，$Bob​$不可能这么早就猜出答案</p>
<p>所以<code>Alice</code>也知道答案是$(6, 10)​$了</p>
<p>我们用<code>dp</code>来描述这个过程，<code>dp[i][n][m]</code>表示，当前是第i轮，且两个答案分别是$n,m$，在$1-i​$轮中，是否能决定答案</p>
<p>如果这一轮是<code>Bob</code>猜，那么我们就枚举$n+m$的划分方式。如果每一种合法的划分方式都能在$1-(i-1)$轮被猜出来，那么<code>Bob</code>一定能确定这两个数分别为$n, m$</p>
<p>否则，我们则枚举$n*m$的约数， 判断方式与<code>Bob</code>的相同</p>
<p>但是这样可能会出现一种特殊情况，就是已经到了$t$轮，第一个人猜出来了，而第二个人没有猜出来</p>
<p>那么我们就多进行一轮转移，这次转移与之前的转移相反，如果每一种合法的划分方式在$1-t$轮都不能被猜出来，那么才能确定答案</p>
<p>$n,m$的最大值不会超过500，直接枚举</p>
<p>直接交程序，数组只开500的话是秒跑</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500</span></span><br><span class="line"><span class="keyword">int</span> dp[N + <span class="number">10</span>][N + <span class="number">10</span>][<span class="number">16</span>], m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, tmpa, tmpb;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, j;i &lt;= a + b - i &amp;&amp; cnt &lt; <span class="number">2</span>;i++) </span><br><span class="line">        <span class="keyword">if</span> (!dp[i][j = a + b - i][c - <span class="number">1</span>] || c == <span class="number">1</span>) </span><br><span class="line">            cnt++, tmpa = i, tmpb = j;</span><br><span class="line">    <span class="keyword">return</span> cnt == <span class="number">1</span> &amp;&amp; a == tmpa &amp;&amp; b == tmpb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, tmpa, tmpb;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, j;i * i &lt;= a * b &amp;&amp; cnt &lt; <span class="number">2</span>;i++)</span><br><span class="line">        <span class="keyword">if</span> (a * b % i == <span class="number">0</span> &amp;&amp; (!dp[i][j = a * b / i][c - <span class="number">1</span>] || c == <span class="number">1</span>))</span><br><span class="line">            cnt++, tmpa = i, tmpb = j;</span><br><span class="line">    <span class="keyword">return</span> cnt == <span class="number">1</span> &amp;&amp; a == tmpa &amp;&amp; b == tmpb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, tmpa, tmpb;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, j;i &lt;= a + b - i &amp;&amp; cnt &lt; <span class="number">2</span>;i++) </span><br><span class="line">        <span class="keyword">if</span> (dp[i][j = a + b - i][c] &amp;&amp; !dp[i][j][c - <span class="number">2</span>]) </span><br><span class="line">            cnt++, tmpa = i, tmpb = j;</span><br><span class="line">    <span class="keyword">return</span> cnt == <span class="number">1</span> &amp;&amp; a == tmpa &amp;&amp; b == tmpb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check4</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, tmpa, tmpb;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, j;i * i &lt;= a * b &amp;&amp; cnt &lt; <span class="number">2</span>;i++)</span><br><span class="line">        <span class="keyword">if</span> (a * b % i == <span class="number">0</span> &amp;&amp; dp[i][j = a * b / i][c] &amp;&amp; !dp[i][j][c - <span class="number">2</span>])</span><br><span class="line">            cnt++, tmpa = i, tmpb = j;</span><br><span class="line">    <span class="keyword">return</span> cnt == <span class="number">1</span> &amp;&amp; a == tmpa &amp;&amp; b == tmpb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">8</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, flag; <span class="built_in">scanf</span>(<span class="string">"%d%s%d"</span>, &amp;m, name + <span class="number">1</span>, &amp;t), flag = name[<span class="number">1</span>] == <span class="string">'B'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= t + <span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = m;a &lt;= N / <span class="number">2</span>;a++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = a;b &lt;= N;b++)</span><br><span class="line">                dp[a][b][i] = dp[a][b][i - <span class="number">2</span>] | (((i &amp; <span class="number">1</span>) ^ flag ^ <span class="number">1</span>) ? check1(a, b, i) : check2(a, b, i));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = m * <span class="number">2</span>;s;s++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = m, b = s - a;a * <span class="number">2</span> &lt;= s;a++, b = s - a)</span><br><span class="line">            <span class="keyword">if</span> (dp[a][b][t + <span class="number">1</span>] &amp;&amp; !(dp[a][b][t - <span class="number">1</span>] | dp[a][b][t])) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = t &amp; <span class="number">1</span> ^ flag;</span><br><span class="line">                <span class="keyword">if</span> (!(tmp ? check4(a, b, t + <span class="number">1</span>) : check3(a, b, t + <span class="number">1</span>))) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">' '</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/07/BJOI2018-%E4%BA%8C%E8%BF%9B%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/07/BJOI2018-%E4%BA%8C%E8%BF%9B%E5%88%B6/" class="post-title-link" itemprop="url">BJOI2018 二进制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-07 11:50:09" itemprop="dateCreated datePublished" datetime="2019-04-07T11:50:09+08:00">2019-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:21:57" itemprop="dateModified" datetime="2020-04-23T09:21:57+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A2%98%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">题解</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://www.luogu.org/problemnew/show/P4428" target="_blank" rel="noopener">题目链接</a></p>
<p>先考虑哪些二进制在重新排列之后可以是3的倍数</p>
<p>我们分3种情况讨论：</p>
<ol>
<li>0 ：模3的余数是0</li>
<li>10 ：就是1出现在下标为偶数的地方，模3余2</li>
<li>01 ：1出现在下标为奇数的地方，模3余1</li>
</ol>
<p>那么，我们就可以用这三种余数来进行组合</p>
<p>考虑以下情况：</p>
<ol>
<li>有偶数个1 ：显然，通过情况2与3组合可以成为3的倍数</li>
<li>有奇数个1 ：注意到3个情况2或者情况3的叠加仍然可以成为3的倍数，而这样至少需要2个0和3个1（10101）</li>
</ol>
<p>那么综合上面两种情况，我们可以得出结论，一段区间为不合法的区间当且仅当：</p>
<ol>
<li>区间内只有1个1</li>
<li>区间中有奇数个1且没有0</li>
<li>区间中有奇数个1且有1个0</li>
</ol>
<p>这道题是带修改的，所以需要将<code>dp</code>放到线段树上统计</p>
<p>那么我们考虑一段区间应该维护什么</p>
<p>首先将第一种情况分开，先不管</p>
<p>那么对于一段区间，我们可以用<code>dp[i][j(0/1)][k(0/1)]</code>表示</p>
<p>即状态为$i$，1的个数是奇数还是偶数，出现了0个0还是1个0的区间总数</p>
<p>线段树<code>pushup</code>的时候子区间也是可以跨<code>mid</code>合并的</p>
<p>具体来说，就是一个左子树的以<code>mid</code>为右端点的区间和一个右子树的以<code>mid + 1</code>为左端点的区间合并</p>
<p>所以，对于状态i，我们这样设计</p>
<p><code>i = 0</code> 表示不取左端点和右端点</p>
<p><code>i = 1</code> 表示必须取左端点，不能取右端点</p>
<p><code>i = 2</code> 表示必须取右端点，不能取左端点</p>
<p><code>i = 3</code> 表示必须左右端点都取</p>
<p>合并的时候枚举一下有几个0以及1的奇偶性就可以了</p>
<p>我们另外开一个数组，单独统计情况1，也就是只有1个1的区间的数量</p>
<p>转移与上面的类似</p>
<p><code>g[i][j(0/1)]</code>表示状态为$i$，出没出现1的区间的总数</p>
<p>但是统计的时候不能直接将两个加起来</p>
<p>注意到这两个统计是有重复的，当我们进行第一次统计时也顺便统计了区间内有1个1，只有0/1个0的数量，需要去重</p>
<p>对于有1个1，0个0的区间数量，显然也就是区间内1的数量</p>
<p>对于有1个1，1个0的区间数量，我们用一个树状数组维护，在这个01区间的第一位维护即可</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    LL f[<span class="number">4</span>][<span class="number">2</span>][<span class="number">2</span>], g[<span class="number">4</span>][<span class="number">2</span>];</span><br><span class="line">    Data() &#123;<span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)), <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span>(g));&#125;</span><br><span class="line">&#125; T[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Data <span class="title">UN</span><span class="params">(Data a, Data b)</span> </span>&#123;</span><br><span class="line">    Data c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= <span class="number">1</span>;j++) &#123;</span><br><span class="line">            c.f[<span class="number">0</span>][i][j] += a.f[<span class="number">0</span>][i][j] + b.f[<span class="number">0</span>][i][j] + a.f[<span class="number">2</span>][i][j] + b.f[<span class="number">1</span>][i][j];</span><br><span class="line">            c.f[<span class="number">1</span>][i][j] += a.f[<span class="number">1</span>][i][j] + a.f[<span class="number">3</span>][i][j], c.f[<span class="number">2</span>][i][j] += b.f[<span class="number">2</span>][i][j] + b.f[<span class="number">3</span>][i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        c.g[<span class="number">0</span>][i] += a.g[<span class="number">0</span>][i] + b.g[<span class="number">0</span>][i] + a.g[<span class="number">2</span>][i] + b.g[<span class="number">1</span>][i];</span><br><span class="line">        c.g[<span class="number">1</span>][i] += a.g[<span class="number">1</span>][i] + a.g[<span class="number">3</span>][i], c.g[<span class="number">2</span>][i] += b.g[<span class="number">2</span>][i] + b.g[<span class="number">3</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= <span class="number">1</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + j &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                c.g[<span class="number">0</span>][i + j] += a.g[<span class="number">2</span>][i] * b.g[<span class="number">1</span>][j], c.g[<span class="number">1</span>][i + j] += a.g[<span class="number">3</span>][i] * b.g[<span class="number">1</span>][j];</span><br><span class="line">                c.g[<span class="number">2</span>][i + j] += a.g[<span class="number">2</span>][i] * b.g[<span class="number">3</span>][j], c.g[<span class="number">3</span>][i + j] += a.g[<span class="number">3</span>][i] * b.g[<span class="number">3</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= <span class="number">1</span>;k++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>;k + l &lt;= <span class="number">1</span>;l++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> ti = (i + j) &amp; <span class="number">1</span>, tj = k + l;</span><br><span class="line">                    c.f[<span class="number">0</span>][ti][tj] += a.f[<span class="number">2</span>][i][k] * b.f[<span class="number">1</span>][j][l], c.f[<span class="number">1</span>][ti][tj] += a.f[<span class="number">3</span>][i][k] * b.f[<span class="number">1</span>][j][l];</span><br><span class="line">                    c.f[<span class="number">2</span>][ti][tj] += a.f[<span class="number">2</span>][i][k] * b.f[<span class="number">3</span>][j][l], c.f[<span class="number">3</span>][ti][tj] += a.f[<span class="number">3</span>][i][k] * b.f[<span class="number">3</span>][j][l];</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> val[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="keyword">void</span>(T[rt].f[<span class="number">3</span>][val[l]][val[l] ^ <span class="number">1</span>] = T[rt].g[<span class="number">3</span>][val[l]] = <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; build(rt &lt;&lt; <span class="number">1</span>, l, mid), build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    T[rt] = UN(T[rt &lt;&lt; <span class="number">1</span>], T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> at)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        val[l] ^= <span class="number">1</span>, T[rt] = Data();</span><br><span class="line">        T[rt].f[<span class="number">3</span>][val[l]][val[l] ^ <span class="number">1</span>] = T[rt].g[<span class="number">3</span>][val[l]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (at &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, at); <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, at);</span><br><span class="line">    T[rt] = UN(T[rt &lt;&lt; <span class="number">1</span>], T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Data <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> T[rt];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (end &lt;= mid) <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span>, l, mid, start, end);</span><br><span class="line">    <span class="keyword">if</span> (start &gt; mid) <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, start, end);</span><br><span class="line">    <span class="keyword">return</span> UN(query(rt &lt;&lt; <span class="number">1</span>, l, mid, start, mid), query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, end));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tree[<span class="number">2</span>][N], n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> at, <span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">for</span> (;at &lt;= n;at += at &amp; -at) tree[id][at] += x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> at)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;at;at -= at &amp; -at) res += tree[id][at];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val[i]), update(<span class="number">0</span>, i, val[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) <span class="keyword">if</span> (val[i] != val[i + <span class="number">1</span>]) update(<span class="number">1</span>, i, <span class="number">1</span>);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n); <span class="keyword">int</span> q; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b != n) update(<span class="number">1</span>, b, <span class="number">-2</span> * (val[b] != val[b + <span class="number">1</span>]) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="number">1</span>) update(<span class="number">1</span>, b - <span class="number">1</span>, <span class="number">-2</span> * (val[b - <span class="number">1</span>] != val[b]) + <span class="number">1</span>);</span><br><span class="line">            update(<span class="number">0</span>, b, <span class="number">-2</span> * val[b] + <span class="number">1</span>), update(<span class="number">1</span>, <span class="number">1</span>, n, b);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c); Data tmp = query(<span class="number">1</span>, <span class="number">1</span>, n, b, c); LL res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">3</span>;i++) res += tmp.f[i][<span class="number">1</span>][<span class="number">0</span>] + tmp.f[i][<span class="number">1</span>][<span class="number">1</span>] + tmp.g[i][<span class="number">1</span>];</span><br><span class="line">            res -= query(<span class="number">0</span>, c) - query(<span class="number">0</span>, b - <span class="number">1</span>) + query(<span class="number">1</span>, c - <span class="number">1</span>) - query(<span class="number">1</span>, b - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (LL)(c - b + <span class="number">1</span>) * (c - b + <span class="number">2</span>) / <span class="number">2</span> - res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/07/FFT%E4%B8%8ENTT%E4%B8%93%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/07/FFT%E4%B8%8ENTT%E4%B8%93%E9%A2%98/" class="post-title-link" itemprop="url">FFT与NTT专题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-07 11:27:43" itemprop="dateCreated datePublished" datetime="2019-04-07T11:27:43+08:00">2019-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:16:53" itemprop="dateModified" datetime="2020-04-23T09:16:53+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A2%98%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">题解</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="A-–-礼物"><a href="#A-–-礼物" class="headerlink" title="A – 礼物"></a>A – 礼物</h1><p>先不管旋转操作，考虑化简这个差异值</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^n(x_i-y_i-c)^2
&=\sum_{i=1}^n(x_i-y_i)^2+nc^2-2c\sum_{i=1}^n(x_i-y_i)\\\
&=\sum_{i=1}^nx_i^2+\sum_{i=1}^ny_i^2+nc^2-2c\sum_{i=1}^n(x_i-y_i)-2\sum_{i=1}^nx_iy_i
\end{aligned}</script><p>注意到$\sum x^2+\sum y^2$是常数，先不管</p>
<p>可以发现，这是一个关于$c$的二次函数</p>
<p>那么我们知道，此时$c$的极值点就在$-\frac{b}{2a}$处</p>
<p>所以，我们可以得出$c$的最优值是</p>
<script type="math/tex; mode=display">
\frac{\sum_{i=1}^n x_i-\sum_{i=1}^n y_i}{n}</script><p>而分子的两个数均与旋转无关</p>
<p>但是$c$只能是整数</p>
<p>所以判一下$c, c-1, c+1$哪个与上面的式子更接近</p>
<p>注意到旋转唯一能改变的是$\sum xy$</p>
<p>而我们要让这个值尽量小</p>
<p>设</p>
<script type="math/tex; mode=display">
F(m)=\sum_{i=1}^nx_iy_{i+m}</script><p>我们可以看出，这是一个类似卷积的东西</p>
<p>但是一般的卷积是后两式下标的和不变</p>
<p>而这个是差不变</p>
<p>所以把这个式子变一下</p>
<p>设</p>
<script type="math/tex; mode=display">
x_{n-i+1}=x_i</script><p>就是将x倒序一下</p>
<p>可以得到 </p>
<script type="math/tex; mode=display">
F(m)=\sum_{i=1}^nx_{n-i+1}y_{i+m}</script><p>不妨设后面$xy$的卷积是$A$，也就是</p>
<script type="math/tex; mode=display">
A(n+m+1)=\sum_{i=1}^nx_{n-i+1}y_{i+m}</script><p>可以发现，这个$A$就是将$F$整体向右平移了$n+1$</p>
<p>所以</p>
<script type="math/tex; mode=display">
F(m)=A(n+m+1)</script><p>为了不丢精度，NTT即可（保证答案不会超过mod）</p>
<p>代码如下 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">int</span> r[N &lt;&lt; <span class="number">2</span>]; <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> type, <span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, w = <span class="number">1</span>, t;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w = (LL)w * Wn % mod)</span><br><span class="line">                t = (LL)w * a[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x[N], y[N], A[N &lt;&lt; <span class="number">2</span>], B[N &lt;&lt; <span class="number">2</span>], res[N];</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; <span class="keyword">inline</span> T <span class="title">Abs</span><span class="params">(<span class="keyword">const</span> T x)</span> </span>&#123;<span class="keyword">return</span> x &gt; <span class="number">0</span> ? x : -x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, sumx = <span class="number">0</span>, sumy = <span class="number">0</span>, sumx2 = <span class="number">0</span>, sumy2 = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x[i]), A[i] = x[i], sumx += x[i], sumx2 += x[i] * x[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;y[i]), B[<span class="number">2</span> * n - i] = B[n - i] = y[i], sumy += y[i], sumy2 += y[i] * y[i];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= <span class="number">3</span> * n) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    NTT(len, <span class="number">1</span>, A), NTT(len, <span class="number">1</span>, B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) A[i] = (LL)A[i] * B[i] % mod;</span><br><span class="line">    NTT(len, <span class="number">0</span>, A); <span class="keyword">int</span> Inv = Pow(len, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) res[i] = (LL)A[<span class="number">2</span> * n - i] * Inv % mod;</span><br><span class="line">    <span class="keyword">int</span> c = (sumx - sumy) / n; LL ans = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">if</span> (Abs((LL)c * n - sumx + sumy) &gt; Abs(((LL)c * n + n - sumx + sumy))) c++;</span><br><span class="line">    <span class="keyword">if</span> (Abs((LL)c * n - sumx + sumy) &gt; Abs(((LL)c * n - n - sumx + sumy))) c--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        LL tmp = (LL)sumx2 + sumy2 - <span class="number">2</span> * res[i] - (LL)<span class="number">2</span> * c * (sumx - sumy) + (LL)n * c * c;</span><br><span class="line">        <span class="keyword">if</span> (tmp &lt; ans) ans = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-–-求和"><a href="#B-–-求和" class="headerlink" title="B – 求和"></a>B – 求和</h1><p>我们知道</p>
<script type="math/tex; mode=display">
S(n,m)=\sum_{i=0}^m(-1)^i{m\choose i}(m-i)^n\frac{1}{m!}</script><p>原理很简单，容斥有几个盒子没有放球，有$m\choose i$种选法，再将$n$个球放入$m-i$个盒子。由于盒子是无序的，最后除以$m$的阶乘</p>
<p>那么我们用这个化简原式</p>
<p>注意到第二个$\sum$的上界是$i$，非常讨厌</p>
<p>由于斯特林数的性质，把这个$i$换成$n$也没有问题</p>
<p>因为当$m&gt;n$时，$S(n,m)=0$</p>
<p>所以有</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=0}^n\sum_{j=0}^nS(i,j)\*2^j\*j!
&=\sum_{j=0}^n2^j\*j!\sum_{i=0}^n\sum_{k=0}^j(-1)^k{j\choose k}(j-k)^i\frac{1}{j!}\\\
&=\sum_{j=0}^n2^j\*j!\sum_{k=0}^j\frac{(-1)^k}{k!}\*\frac{\sum_{i=0}^n(j-k)^i}{(j-k)!}
\end{aligned}</script><p>注意到后面那个是卷积的形式</p>
<p>第一个多项式很好求，第二个的分子是等比数列</p>
<p>我们设$B$是第二个多项式</p>
<p>显然有</p>
<script type="math/tex; mode=display">
B(0)=0, B(1)=n+1</script><p>对于其它情况，直接用等比数列求和公式算出来就行了</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">int</span> r[N &lt;&lt; <span class="number">2</span>]; <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> type, <span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, w = <span class="number">1</span>, t;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w = (LL)w * Wn % mod)</span><br><span class="line">                t = (LL)w * a[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> A[N &lt;&lt; <span class="number">2</span>], B[N &lt;&lt; <span class="number">2</span>], frac[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, len = <span class="number">1</span>, l = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    frac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= <span class="number">2</span> * n) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    A[<span class="number">0</span>] = B[<span class="number">0</span>] = <span class="number">1</span>, B[<span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) A[i] = (i &amp; <span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span>) * Pow(frac[i], mod - <span class="number">2</span>), A[i] = (A[i] + mod) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) B[i] = ((LL)(Pow(i, n + <span class="number">1</span>) - <span class="number">1</span>) * Pow(i - <span class="number">1</span>, mod - <span class="number">2</span>) % mod * Pow(frac[i], mod - <span class="number">2</span>) % mod + mod) % mod;</span><br><span class="line">    NTT(len, <span class="number">1</span>, A), NTT(len, <span class="number">1</span>, B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) A[i] = (LL)A[i] * B[i] % mod;</span><br><span class="line">    NTT(len, <span class="number">0</span>, A); <span class="keyword">int</span> Inv = Pow(len, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) res = (res + (LL)tmp * frac[i] % mod * A[i]) % mod, tmp = tmp * <span class="number">2</span> % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL)res * Inv % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-–-序列统计"><a href="#C-–-序列统计" class="headerlink" title="C – 序列统计"></a>C – 序列统计</h1><p>这题的难点在于转化成原根</p>
<p>注意到要求的是所有数的乘积而非和</p>
<p>如果是和的话直接NTT就好了</p>
<p>那么我们就将乘积转化成和的形式</p>
<p>如果两个数都是某个数的某次方，那么这两个数乘起来就是指数相加</p>
<p>而原根恰好可以表示模$m$剩余系下的每个数</p>
<p>所以把每个数转化成原根的某次方就好了</p>
<p>求原根代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">G</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, flg = <span class="number">1</span>;i;i++, flg = <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>;j * j &lt; x;j++) </span><br><span class="line">            <span class="keyword">if</span> ((x - <span class="number">1</span>) % j == <span class="number">0</span> &amp;&amp; Pow(i, (x - <span class="number">1</span>) / j, x) == <span class="number">1</span>) &#123;flg = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (flg) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-–-残缺的字符串"><a href="#D-–-残缺的字符串" class="headerlink" title="D – 残缺的字符串"></a>D – 残缺的字符串</h1><p>带通配符的字符串匹配问题</p>
<p>首先考虑不带通配符的怎么做</p>
<p>那么拓展KMP， 后缀数组都可以</p>
<p>但是我们有一个更高级的方法：FFT求字符串匹配</p>
<p>首先我们需要定义“匹配”</p>
<p>所以设差异函数$g(i)$表示从$B$串的$i$位置开始，与$A$串的差异程度</p>
<p>有</p>
<script type="math/tex; mode=display">
g(x)=\sum_{i=x}^{x+m-1}(B_i-A_{i-x+1})^2</script><p>显然，只有当$A$串从$x$位置开始与$B$串完全相同，$g$的值才为0</p>
<p>化简原式</p>
<script type="math/tex; mode=display">
\begin{aligned}
g(x)&=\sum_{i=x}^{x+m-1}A_{i-x+1}^2+\sum_{i=x}^{x+m-1}B_i^2-2\sum_{i=x}^{x+m-1}B_iA_{i-x+1}\\\
&=\sum_{i=1}^mA_i^2+\sum_{i=1}^mB_{i+x-1}^2-2\sum_{i=1}^mA_iB_{i+x-1}
\end{aligned}</script><p>前两项可以通过预处理前缀和得出，后面的是一个下标差相等的卷积</p>
<p>那么模仿之前的套路，我们将$A$序列倒序一下再求卷积就行了</p>
<p>解决了不带通配符的问题，再考虑带通配符</p>
<p>这个通配符是可以匹配任意字符的，所以把差异函数改一下</p>
<script type="math/tex; mode=display">
g(x)=\sum_{i=x}^{x+m-1}(B_i-A_{i-x+1})^2A_{i-x+1}B_i</script><p>当$i$处的字符是$*$时，我们设那个地方的值为0</p>
<p>化简得</p>
<script type="math/tex; mode=display">
=\sum_{i=1}^mA_i^3B_{i-x+1}+\sum_{i=1}^mA_iB_{i-x+1}^3-2\sum_{i=1}^xA_i^2B_{i-x+1}^2</script><p>做3次FFT即可</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300010</span></span><br><span class="line"><span class="keyword">int</span> r[N &lt;&lt; <span class="number">2</span>]; <span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> type, <span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; <span class="title">Wn</span><span class="params">(<span class="built_in">cos</span>(<span class="number">2</span> * PI / mid), type * <span class="built_in">sin</span>(<span class="number">2</span> * PI / mid))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid) &#123;</span><br><span class="line">            complex&lt;double&gt; w(1), t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w *= Wn) </span><br><span class="line">                t = w * a[j + (mid &gt;&gt; <span class="number">1</span>)], a[j + (mid &gt;&gt; <span class="number">1</span>)] = a[j] - t, a[j] += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> a[N], b[N]; <span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; A[N &lt;&lt; <span class="number">2</span>], B[N &lt;&lt; <span class="number">2</span>]; <span class="keyword">int</span> a1[N], b1[N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line">LL res[N]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Clear(x) for (int i = 0;i &lt; len;i++) x[i] = 0;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    FFT(len, <span class="number">1</span>, A), FFT(len, <span class="number">1</span>, B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) A[i] *= B[i];</span><br><span class="line">    FFT(len, <span class="number">-1</span>, A);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) res[i] += k * (LL)(A[i].real() / len + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d%s%s"</span>, &amp;m, &amp;n, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) a1[m - i] = a[i] == <span class="string">'*'</span> ? <span class="number">0</span> : a[i] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) b1[i] = b[i] == <span class="string">'*'</span> ? <span class="number">0</span> : b[i] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= m + n) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) A[i] = a1[i] * a1[i] * a1[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) B[i] = b1[i];</span><br><span class="line">    mul(len, n, <span class="number">1</span>); Clear(A) Clear(B)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) A[i] = a1[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) B[i] = b1[i] * b1[i] * b1[i];</span><br><span class="line">    mul(len, n, <span class="number">1</span>); Clear(A) Clear(B)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) A[i] = a1[i] * a1[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) B[i] = b1[i] * b1[i];</span><br><span class="line">    mul(len, n, <span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">if</span> (res[i] == <span class="number">0</span>) ans.push_back(i - m + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : ans) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-–-万径人踪灭"><a href="#E-–-万径人踪灭" class="headerlink" title="E – 万径人踪灭"></a>E – 万径人踪灭</h1><p>假设当前确定了一个对称中心$i$</p>
<p>那么当两个位置$j,k$关于i对称且这两个位置的字母相同时对答案有贡献</p>
<p>对称则意味着$j+k=i*2​$，可以FFT</p>
<p>枚举字符，然后FFT</p>
<p>假设这个中心有x对这样的位置</p>
<p>那么每一对都是独立的，可以选也可以不选，但是不能都不选</p>
<p>所以此时的答案为$2^x-1$</p>
<p>题目要求不能全部连续，那么最后再跑一边<code>manacher</code>，减去全部连续的答案即可</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">int</span> r[N &lt;&lt; <span class="number">2</span>]; <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> p = mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % p) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % p;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> type, <span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, t, w = <span class="number">1</span>;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w = (LL) w * Wn % mod)</span><br><span class="line">                t = (LL)w * a[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> A[N &lt;&lt; <span class="number">2</span>], B[N &lt;&lt; <span class="number">2</span>], pal[N &lt;&lt; <span class="number">2</span>], Pow2[N]; <span class="keyword">char</span> s[N], t[N * <span class="number">2</span>]; <span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">manacher</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    t[<span class="number">0</span>] = <span class="string">'#'</span>, t[n * <span class="number">2</span> + <span class="number">1</span>] = <span class="string">'$'</span>, t[n * <span class="number">2</span> + <span class="number">2</span>] = <span class="string">'@'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) t[i * <span class="number">2</span> - <span class="number">1</span>] = <span class="string">'$'</span>, t[i * <span class="number">2</span>] = s[i]; </span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">1</span>, mx = <span class="number">1</span>, res = <span class="number">0</span>; pal[<span class="number">1</span>] = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n * <span class="number">2</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= mx) pal[i] = min(mx - i + <span class="number">1</span>, pal[<span class="number">2</span> * pos - i]);</span><br><span class="line">        <span class="keyword">else</span> pal[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (t[i - pal[i]] == t[i + pal[i]]) pal[i]++;</span><br><span class="line">        <span class="keyword">if</span> (i + pal[i] - <span class="number">1</span> &gt; mx) mx = i + pal[i] - <span class="number">1</span>, pos = i;</span><br><span class="line">        res = (res + pal[i] / <span class="number">2</span>) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>); <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span> (s[i] == <span class="string">'a'</span>) A[i] = <span class="number">1</span>; <span class="keyword">else</span> B[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>, ans = <span class="number">0</span>; Pow2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Pow2[i] = Pow2[i - <span class="number">1</span>] * <span class="number">2</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n * <span class="number">2</span>) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    NTT(len, <span class="number">1</span>, A), NTT(len, <span class="number">1</span>, B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) A[i] = (LL)A[i] * A[i] % mod, B[i] = (LL)B[i] * B[i] % mod;</span><br><span class="line">    NTT(len, <span class="number">0</span>, A), NTT(len, <span class="number">0</span>, B); <span class="keyword">int</span> Inv = Pow(len, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, t;i &lt;= n * <span class="number">2</span>;i++) &#123;</span><br><span class="line">        t = (LL)(A[i] + B[i]) * Inv % mod + (i &amp; <span class="number">1</span> ^ <span class="number">1</span>);</span><br><span class="line">        ans = (ans + Pow2[t / <span class="number">2</span>] - <span class="number">1</span>) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (ans - manacher(n) + p) % p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F-–-性能优化"><a href="#F-–-性能优化" class="headerlink" title="F – 性能优化"></a>F – 性能优化</h1><p>这道题利用到了FFT的原理</p>
<p>如果模数是质数，那么非常好办</p>
<p>但是这题不仅模数不是质数，而且求的是循环卷积，直接FFT会爆炸</p>
<p>贴一篇我觉得很好的题解</p>
<p><img src="https://0x131cc05home.files.wordpress.com/2019/02/1.jpg?w=700" alt="img"></p>
<p>这个rev数组可以模拟FFT的过程，递归地求出来</p>
<p>单位根满足消去律，上面的$F(\omega_n^i)$指的是$i\leq \frac{n}{p}$的情况</p>
<p>对于剩余的情况，有$\omega_{\frac{n}{p}}^i=\omega_{\frac{n}{p}}^{i-\frac{n}{p}}$</p>
<p>也就是说，代入的$F^{[0]},F^{[1]},\cdots,F^{[p-1]}$都相同，但是系数不同</p>
<p>然后分治就可以了</p>
<p>同样地，最后需要除以<code>len</code>，也就是模数$-1$</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tot, prime[N], r[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetPos</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> dep, <span class="keyword">int</span> len, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep == tot + <span class="number">1</span>) <span class="keyword">return</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> tmp = len / prime[dep], s = x % prime[dep];</span><br><span class="line">    <span class="keyword">return</span> GetPos((x - s) / prime[dep], dep + <span class="number">1</span>, tmp, cnt + tmp * s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp[N], g;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> a[], <span class="keyword">int</span> mod, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) tmp[r[i]] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) a[i] = tmp[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tot, block = <span class="number">1</span>;i &gt;= <span class="number">1</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = block; block *= prime[i];</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(g, type ? (mod - <span class="number">1</span>) / block : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / block, mod);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; len;j++) tmp[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, Wk = <span class="number">1</span>;j &lt; len;j += block, Wk = <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; block;k++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = k % mid, w = <span class="number">1</span>;l &lt; block;l += mid, w = (LL)w * Wk % mod)</span><br><span class="line">                    tmp[j + k] = (tmp[j + k] + (LL)w * a[j + l]) % mod;</span><br><span class="line">                Wk = (LL)Wk * Wn % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; len;j++) a[j] = tmp[j];</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">GetG</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, flag = <span class="number">1</span>;i;i++, flag = <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>;j * j &lt; x;j++)</span><br><span class="line">            <span class="keyword">if</span> (Pow(i, (x - <span class="number">1</span>) / j, x) == <span class="number">1</span>) &#123;flag = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> A[N &lt;&lt; <span class="number">2</span>], B[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, C; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;C);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;B[i]);</span><br><span class="line">    <span class="keyword">int</span> tmp = n; g = GetG(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i * i &lt;= tmp;i++)</span><br><span class="line">        <span class="keyword">while</span> (tmp % i == <span class="number">0</span>) prime[++tot] = i, tmp /= i;</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="number">1</span>) prime[++tot] = tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) r[i] = GetPos(i, <span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line">    NTT(n, A, n + <span class="number">1</span>, <span class="number">1</span>), NTT(n, B, n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) A[i] = (LL)A[i] * Pow(B[i], C, n + <span class="number">1</span>) % (n + <span class="number">1</span>);</span><br><span class="line">    NTT(n, A, n + <span class="number">1</span>, <span class="number">0</span>); <span class="keyword">int</span> Inv = Pow(n, n - <span class="number">1</span>, n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL)A[i] * Inv % (n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="H-–-Frightful-Formula"><a href="#H-–-Frightful-Formula" class="headerlink" title="H – Frightful Formula"></a>H – Frightful Formula</h1><p>算是比较简单的一道题</p>
<p>公式等价于一个表格，往右走有$a$种方法，往下走有$b$种方法，还可以直接从这个格子开始走，有$c$种方法</p>
<p>先不考虑第一行和第一列格子</p>
<p>假设是从$i,j$这个格子开始走的</p>
<p>那么，这个格子需要向右走$n-j$步，向下走$n-i$步</p>
<p>对答案的贡献是</p>
<script type="math/tex; mode=display">
c\*a^{n-i}\*b^{n-j}\*{n-i+n-j\choose n-i}</script><p>含义是，从这个格子开始，有$c$种走法，向有走$n-j$次，向下走$n-i$次，在$n-j+n-i$步中，有$n-i​$步是往下走的</p>
<p>那么，把这些空白的格子加起来，我们可以得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
c\sum_{i=2}^n\sum_{j=2}^na^{n-i}b^{n-j}{n-i+n-j\choose n-i}
&=c\sum_{i=0}^{n-2}\sum_{j=0}^{n-2}a^ib^j{i+j\choose i}\\\
&=c\sum_{i=0}^{n-2}\frac{a^i}{i!}\sum_{j=0}^{n-2}(i+j)!\frac{b^j}{j!}
\end{aligned}</script><p>我们可以枚举$i$，后面的是一个下标差相等的卷积</p>
<p>将多项式逆序一下就可以了</p>
<p>这道题没有给模数，而答案又很大</p>
<p>为了防止丢精度，所以使用MTT</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e6</span> + <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> p = mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % p) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % p;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ZJK = (<span class="number">1</span> &lt;&lt; <span class="number">19</span>) + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> frac[N * <span class="number">2</span>], f[<span class="number">2</span>][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;<span class="keyword">return</span> (LL)frac[n] * Pow(frac[r], mod - <span class="number">2</span>) % mod * Pow(frac[n - r], mod - <span class="number">2</span>) % mod;&#125;</span><br><span class="line"><span class="comment">// #define double long double</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CP</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    CP(<span class="keyword">double</span> _x = <span class="number">0</span>, <span class="keyword">double</span> _y = <span class="number">0</span>) : x(_x), y(_y) &#123;&#125;</span><br><span class="line">    CP <span class="keyword">operator</span> * (<span class="keyword">const</span> CP &amp;b) &#123;<span class="keyword">return</span> CP(x * b.x - y * b.y, x * b.y + y * b.x);&#125;</span><br><span class="line">    CP <span class="keyword">operator</span> + (<span class="keyword">const</span> CP &amp;b) &#123;<span class="keyword">return</span> CP(x + b.x, y + b.y);&#125;</span><br><span class="line">    CP <span class="keyword">operator</span> - (<span class="keyword">const</span> CP &amp;b) &#123;<span class="keyword">return</span> CP(x - b.x, y - b.y);&#125;</span><br><span class="line">    CP <span class="keyword">operator</span> / (<span class="keyword">const</span> <span class="keyword">double</span> b) &#123;<span class="keyword">return</span> CP(x / b, y / b);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> r[ZJK]; <span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> type, CP a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">CP <span class="title">Wn</span><span class="params">(<span class="built_in">cos</span>(<span class="number">2</span> * PI / mid), type * <span class="built_in">sin</span>(<span class="number">2</span> * PI / mid))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid) &#123;</span><br><span class="line">            CP w(1), t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w = w * Wn) </span><br><span class="line">                t = w * a[j + (mid &gt;&gt; <span class="number">1</span>)], a[j + (mid &gt;&gt; <span class="number">1</span>)] = a[j] - t, a[j] = a[j] + t; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">-1</span>) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) a[i] = a[i] / len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line">CP a[ZJK], b[ZJK], c[ZJK], d[ZJK];</span><br><span class="line"><span class="keyword">int</span> A[ZJK], B[ZJK];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MTT</span><span class="params">(<span class="keyword">int</span> len, LL m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) a[i] = A[i] / m, b[i] = A[i] % m, c[i] = B[i] / m, d[i] = B[i] % m;</span><br><span class="line">    FFT(len, <span class="number">1</span>, a), FFT(len, <span class="number">1</span>, b), FFT(len, <span class="number">1</span>, c), FFT(len, <span class="number">1</span>, d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) &#123;</span><br><span class="line">        CP a1 = a[i], b1 = b[i], c1 = c[i], d1 = d[i];</span><br><span class="line">        a[i] = a1 * c1, b[i] = a1 * d1, c[i] = b1 * c1, d[i] = b1 * d1;</span><br><span class="line">    &#125;</span><br><span class="line">    FFT(len, <span class="number">-1</span>, a), FFT(len, <span class="number">-1</span>, b), FFT(len, <span class="number">-1</span>, c), FFT(len, <span class="number">-1</span>, d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) </span><br><span class="line">        A[i] = ((LL)(a[i].x + <span class="number">0.5</span>) * m % mod * m % mod + (LL)(b[i].x + <span class="number">0.5</span>) * m % mod + (LL)(c[i].x + <span class="number">0.5</span>) * m % mod</span><br><span class="line">            + (LL)(d[i].x + <span class="number">0.5</span>)) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c, n; <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;a, &amp;b, &amp;c), frac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;f[<span class="number">1</span>][i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;f[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n * <span class="number">2</span>;i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, tmp1 = Pow(b, n - <span class="number">1</span>), tmp2 = Pow(a, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) ans = (ans + (LL)f[<span class="number">0</span>][i] * C(<span class="number">2</span> * n - <span class="number">2</span> - i, n - i) % mod * tmp1 % mod * Pow(a, n - i)) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) ans = (ans + (LL)f[<span class="number">1</span>][i] * C(<span class="number">2</span> * n - <span class="number">2</span> - i, n - i) % mod * tmp2 % mod * Pow(b, n - i)) % mod;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= <span class="number">2</span> * n) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t;i &lt;= n - <span class="number">2</span>;i++) t = Pow(frac[i], mod - <span class="number">2</span>), A[i] = (LL)Pow(a, i) * t % mod, B[i] = (LL)Pow(b, i) * t % mod;</span><br><span class="line">    MTT(len, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">2</span> * n - <span class="number">4</span>;i++) ans = (ans + (LL)c * A[i] % mod * frac[i]) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/06/4-3%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/06/4-3%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/" class="post-title-link" itemprop="url">4.3省选模拟</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-06 16:12:46" itemprop="dateCreated datePublished" datetime="2019-04-06T16:12:46+08:00">2019-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:27:50" itemprop="dateModified" datetime="2020-04-23T09:27:50+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="T1-Diyiti"><a href="#T1-Diyiti" class="headerlink" title="T1 Diyiti"></a>T1 Diyiti</h1><p><img src="https://i.loli.net/2019/04/06/5ca8652f32552.png" alt="1554539772376"></p>
<p><img src="https://i.loli.net/2019/04/06/5ca8654c9255c.png" alt="1554539844233"></p>
<p>我们先考虑这样一个问题：给出$x,y$，如何计算$f(x,y)$</p>
<p>分析一下第一个操作的本质，就是将$x$末尾连续的0都变成1，将第一处1变成0</p>
<p>考虑一种特殊情况：$y$是$x$的子集</p>
<p>也就是说，我们可以只通过操作2将$x$变成$y$</p>
<p>如果我们使用了操作1，可以将最后一个1变成0</p>
<p>但是这样有一个副作用，就是后面所有的数都变成了1</p>
<p>根据之前的限制：$y$是$x$的子集，而$x$在这一位之后都是0</p>
<p>也就是说，$y$在这一位之后也全部是0</p>
<p>在这次操作之后，后面的数都变成了1</p>
<p>如果这次操作在第$i$位，那么我们至少还需要$i-1$次操作2才能将后面的位变得与$y$相同</p>
<p>只有在$i=1$即操作第一位的时候，$-1$操作才与操作2等价</p>
<p>否则$-1$操作一定没有操作2优秀</p>
<p>也就是说，如果我们能用操作2，就尽量用操作2</p>
<p>那么什么情况不能用操作2呢</p>
<p>就是$x$在某一位上为0，而$y$在这一位上为1</p>
<p>这个时候我们只能用$-1$操作</p>
<p>如果第$i$位是这样的情况，就意味着，我们必须将这一位之后的第一个$1-0$对前面的所有位都变成0，然后在这个$1-0$对位置使用一次$-1$操作</p>
<p>比如$x=(10010)_2,y=(00101)_2$</p>
<p>注意“第$k$位”指的是从右边开始的第$k$位</p>
<p>对于第一位来说，我们至少需要将第一位变成0</p>
<p>对于第三位来说，我们至少需要将第四位到第一位变成0</p>
<p>为了让操作数尽量小，我们选择将第一位至第四位都变成0</p>
<p>之后就变成了第一种情况，即$y$是$x$的子集</p>
<hr>
<p>总结一下流程：</p>
<ul>
<li>我们找到最高的满足$x_i=0,y_i=1$的位置</li>
<li>找到第一个比这一位高的，满足$x_i=1,y_i=0$的位置$j$</li>
<li>通过操作2，将位置$1-(j-1)$全部变成0</li>
<li>在$j$位置使用一次$-1$操作</li>
<li>对于每一处$x_i=1,y_i=0$的位置使用操作2</li>
</ul>
<p>所以，我们可以得出</p>
<script type="math/tex; mode=display">
f(x,y)=\begin{cases}\sum_{k>j}[x_k\not=y_k]+1+\sum_{k<j}[x_k=1]+\sum_{k<j}[y_k=0]&y\not\in x\\\ \sum_k[x_k\not=y_k]&y\in x\end{cases}</script><p>那么我们现在将它扩展到$x&lt;N$</p>
<p>显然，我们可以使用数位<code>dp</code></p>
<p>根据我们之前的计算过程，我们从高位向低位<code>dp</code>，将$x$分为3个状态</p>
<ul>
<li>还没有遇到$x_i=0,y_i=1$，即此时$y\in x$，这个状态可以作为终止状态</li>
<li><p>钦定此时会有一个$-1$操作，这个状态的起点必须是$x_i=1,y_i=0$且在这个状态中不能再出现其它的$x_i=1,y_i=0$以及$x_i=0,y_i=1$，这个状态<strong>不能</strong>作为终止状态 </p>
</li>
<li><p>遇到了第一个$x_i=0,y_i=1$，然后就可以随便转移了，这个状态可以作为终止状态</p>
</li>
</ul>
<p>第二个状态之所以不能成为终止状态，是因为必须至少有一个$x_i=0,y_i-1$，否则就不应该进入2状态</p>
<p>那么我们可以设<code>f[2][2][3][N], g[2][2][3][N]</code>表示当前在第$i$位，此时$x$是否等于$N$，$y$是否等于$x$，当前在第几个状态时的答案以及转移到结尾的方案数</p>
<p>为了偷懒，我们也可以只用一个<code>dp</code></p>
<p><code>dp[2][2][3][N][N]</code>表示当前到了第$i$位，之前已经用了$j$次操作，此时$x$是否等于$N$，$y$是否等于$x$，当前在第几个状态时的答案</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 510</span></span><br><span class="line"><span class="keyword">int</span> num[N], dp[<span class="number">2</span>][<span class="number">2</span>][<span class="number">3</span>][N][N * <span class="number">2</span>], len; <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x += y, x -= x &gt;= mod ? mod : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">bool</span> flag1, <span class="keyword">bool</span> flag2, <span class="keyword">int</span> state, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == len + <span class="number">1</span>) <span class="keyword">return</span> state == <span class="number">1</span> ? <span class="number">0</span> : cnt;</span><br><span class="line">    <span class="keyword">int</span> &amp;sum = dp[flag1][flag2][state][cur][cnt];</span><br><span class="line">    <span class="keyword">if</span> (~sum) <span class="keyword">return</span> sum;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>;x &lt; <span class="number">4</span>;x++) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = x &amp; <span class="number">1</span>, j = x &gt;&gt; <span class="number">1</span> &amp; <span class="number">1</span>, tflag1 = flag1 &amp;&amp; (i == num[cur]), tflag2 = flag2 &amp;&amp; (j == i);</span><br><span class="line">        <span class="keyword">if</span> (flag1 &amp;&amp; i &gt; num[cur]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag2 &amp;&amp; j &gt; i) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (state == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) <span class="keyword">continue</span>;</span><br><span class="line">            Inc(sum, DP(cur + <span class="number">1</span>, tflag1, tflag2, <span class="number">0</span>, cnt + (i &gt; j)));</span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) Inc(sum, DP(cur + <span class="number">1</span>, tflag1, tflag2, <span class="number">1</span>, cnt + <span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == j) Inc(sum, DP(cur + <span class="number">1</span>, tflag1, tflag2, <span class="number">1</span>, cnt + (i == <span class="number">1</span>) + (j == <span class="number">0</span>)));</span><br><span class="line">            <span class="keyword">else</span> Inc(sum, DP(cur + <span class="number">1</span>, tflag1, tflag2, <span class="number">2</span>, cnt)); </span><br><span class="line">        &#125; <span class="keyword">else</span> Inc(sum, DP(cur + <span class="number">1</span>, tflag1, tflag2, <span class="number">2</span>, cnt + (i == <span class="number">1</span>) + (j == <span class="number">0</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> input[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"diyiti.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"diyiti.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, input + <span class="number">1</span>), len = <span class="built_in">strlen</span>(input + <span class="number">1</span>), <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++) num[i] = input[i] - <span class="string">'0'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, DP(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-Dierti"><a href="#T2-Dierti" class="headerlink" title="T2 Dierti"></a>T2 Dierti</h1><p><img src="https://i.loli.net/2019/04/06/5ca89802d6f00.png" alt="1554552801425"></p>
<p><img src="https://i.loli.net/2019/04/06/5ca8981514ccf.png" alt="1554552819955"></p>
<p>看起来是一道好题，可惜没有题解</p>
<p>这里讲一下部分分做法（只会部分分）</p>
<p>首先我们可以枚举最后选到的是哪个$n$以及哪个$m$，求这个东西的$k$阶中心矩，最后再求期望</p>
<p>这里的$x$就是实际选的袋子中球的数量</p>
<p>考虑</p>
<script type="math/tex; mode=display">
\begin{aligned}
E((x-E(x))^k)&=E(\sum_{i=0}^k{k\choose i}x^k(-1)^{k-i}E(x)^{k-i})\\\
&=\sum_{i=0}^k{k\choose i}(-1)^{k}E(x)^{k}E(x^{k-i})
\end{aligned}</script><p>显然$E(x)=\frac{m}{n}$，所以关键是要求出$E(x^k)$</p>
<p>这等价于有一个数，现在要对这个数进行$m$次操作，每次操作都有$\frac{1}{n}$的概率会加1，否则不变</p>
<p>很像一道题<a href="https://www.luogu.org/problemnew/show/P1654" target="_blank" rel="noopener">osu</a></p>
<p>我们分别维护$E(x),E(x^2),\cdots,E(x^k)$，转移的时候再次使用二项式展开</p>
<p>这样一次转移是$k^3$的，可以使用矩阵乘法优化</p>
<p>可以拿到60分</p>
<h1 id="T3-Disanti"><a href="#T3-Disanti" class="headerlink" title="T3 Disanti"></a>T3 Disanti</h1><p><img src="https://i.loli.net/2019/04/07/5ca9b44761e6a.png" alt="1554625591423"></p>
<p><img src="https://i.loli.net/2019/04/07/5ca9b465f25d6.png" alt="1554625629573"></p>
<p>我不会啊，而且没有题解</p>
<p>先咕在这里吧</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/06/4-2%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/06/4-2%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/" class="post-title-link" itemprop="url">4.2省选模拟</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-06 15:22:26" itemprop="dateCreated datePublished" datetime="2019-04-06T15:22:26+08:00">2019-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:28:04" itemprop="dateModified" datetime="2020-04-23T09:28:04+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="T1-Painting"><a href="#T1-Painting" class="headerlink" title="T1 Painting"></a>T1 Painting</h1><p><img src="https://i.loli.net/2019/04/06/5ca853e21983b.png" alt="1554535371227"></p>
<p><img src="https://i.loli.net/2019/04/06/5ca853fe09737.png" alt="1554535413371"></p>
<p>我们考虑这样一种情况：<code>122133441</code></p>
<p>显然，<code>1</code>必须在最开始就刷上，如果先刷其它的数再刷<code>1</code>，那么颜色<code>2,3,4</code>不可能被<code>1</code>包含</p>
<p>颜色<code>3,4</code>刷的顺序无关紧要</p>
<p>我们考虑更一般的情况</p>
<p>如果存在颜色序列<code>a...b...b...a</code>，其中省略号的部分可能代表其它颜色，那么<code>a</code>一定在<code>b</code>之前被刷上</p>
<p>对于颜色序列<code>a..ab...b</code>，<code>a,b</code>被刷的顺序可以随意</p>
<p>我们可以通过这两个条件将拓扑关系建出来，可以发现，这是一棵树</p>
<p>树的祖先与后代刷的顺序是确定的，同一个父亲的儿子节点刷的顺序可以随意</p>
<p>于是我们考虑分治，假设当前分治到了区间<code>[l,r]</code>，这要求这个区间的左右两个端点的颜色相同</p>
<p>比如上面那个例子中，这个颜色就是<code>1</code></p>
<p>这个颜色将这个区间分成了若干段，对于每一段我们只关心当前颜色的儿子节点，将每一个颜色序列都缩成一个点</p>
<p>比如序列<code>12332144551</code>，<code>1</code>将序列分成了两个部分<code>2332,4455</code></p>
<p>对于颜色<code>2</code>，我们将它缩成一个长度为4的点，它在第一段</p>
<p>对于颜色<code>3</code>，我们不管它，因为它不是<code>1</code>的儿子，它在第二段</p>
<p>对于颜色<code>4,5</code>，我们将它们各缩成长度为2的点，它在第二段</p>
<p>对于每一段，我们分别进行<code>dp</code>，算出答案的最大值，因为段与段之间不能相互跨越，否则中间那个<code>1</code>就永远都刷不上了</p>
<p>我们用<code>dp[i][j]</code>表示已经刷好了<code>[i,j]</code>这些点，能获得的最大收益</p>
<p>如果我们假设第$i$个点缩成的长度是$b_i$，那么这个<code>dp</code>就满足</p>
<script type="math/tex; mode=display">
dp_{i,j}=\sum_{l=i}^jb_l+\max_{mid=i}^j\{dp_{i,mid-1}+dp_{mid+1,j}\}</script><p>含义是我们枚举第一次刷的颜色$mid$，这会将序列分成两段独立的区间，分别刷即可</p>
<p>这个<code>dp</code>是$m^3$的</p>
<p>如果我们打出这个<code>dp</code>取最优值的位置，可以发现它一定在左端点或者右端点转移</p>
<p>不会证明</p>
<p>此时<code>dp</code>就是$m^2$的了</p>
<p>题解的证明过程如下</p>
<div class="pdfobject-container" data-target="Color.pdf" data-height="500px"></div>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 5010</span></span><br><span class="line"><span class="keyword">int</span> num[N], nxt[N], lst[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp; <span class="keyword">int</span> dp[M][M], pre[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">DP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tmp.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) pre[i] = pre[i - <span class="number">1</span>] + tmp[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= n;j++) dp[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) dp[i][i] = tmp[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>;len &lt;= n;len++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">1</span>;start + len - <span class="number">1</span> &lt;= n;start++) &#123;</span><br><span class="line">            <span class="keyword">int</span> end = start + len - <span class="number">1</span>;</span><br><span class="line">            dp[start][end] = max(dp[start + <span class="number">1</span>][end], dp[start][end - <span class="number">1</span>]) + pre[end] - pre[start - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ls = l, cur = nxt[l];ls != r;cur = nxt[ls = cur]) &#123;</span><br><span class="line">        tmp.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> at = ls + <span class="number">1</span>;at != cur;at = lst[at] + <span class="number">1</span>) </span><br><span class="line">            tmp.push_back(lst[at] - at + <span class="number">1</span>);</span><br><span class="line">        res += DP();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ls = l, cur = nxt[l];ls != r;cur = nxt[ls = cur]) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> at = ls + <span class="number">1</span>;at != cur;at = lst[at] + <span class="number">1</span>) </span><br><span class="line">            solve(at, lst[at]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp1[N], beg[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"color.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"color.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">        <span class="keyword">if</span> (tmp1[num[i]]) nxt[tmp1[num[i]]] = i;</span><br><span class="line">        <span class="keyword">else</span> beg[num[i]] = i;</span><br><span class="line">        tmp1[num[i]] = i, lst[beg[num[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    nxt[<span class="number">0</span>] = n + <span class="number">1</span>, solve(<span class="number">0</span>, n + <span class="number">1</span>), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-Path"><a href="#T2-Path" class="headerlink" title="T2 Path"></a>T2 Path</h1><p><img src="https://i.loli.net/2019/04/06/5ca85b7f898f3.png" alt="1554537333909"></p>
<p><img src="https://i.loli.net/2019/04/06/5ca85b9a727e4.png" alt="1554537361628"></p>
<p>假设当前点是$u$</p>
<p>可以发现，最优策略一定是选择一个点集$v$，然后一直在$u$点等待，直到$u$和$v$连通，然后走这条出现的边</p>
<p>我们用<code>dp[u]</code>表示在最优策略下，$u$点到$n$需要的期望时间</p>
<p>我们将$u$点能到达的边按照<code>dp</code>值排序，可以发现选择的点集一定是一段前缀</p>
<p>我们枚举这个前缀，对于一个前缀$v_i$，如果选择这个前缀的点集，那么有转移</p>
<script type="math/tex; mode=display">
dp_u=\min_{i=1}^{|v|}\{\frac{1}{i}\sum_{t\in v_i}dp_t+\frac{m}{i}\}</script><p>含义是，如果选择了这个前缀，那么所选择的点中作为第一个出现的点的概率是相等的，为了走这一条边，我们期望要等$\frac{m}{i}$轮</p>
<p>由于有$\min$，所以无法高斯消元</p>
<p>一种方法是进行若干次迭代，每次迭代枚举每个点更新</p>
<p>另一种方法是使用一个类似<code>SPFA</code>的方法，将这次更新的点放进队列，继续拓展</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="keyword">double</span> dp[N]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dp[i] &lt; dp[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"path.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"path.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b;i &lt;= m;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), G[a].push_back(b), G[b].push_back(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) dp[i] = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>;t &lt;= <span class="number">2000000</span> / m;t++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">            sort(G[i].begin(), G[i].end(), cmp); <span class="keyword">double</span> tmp = <span class="number">0</span>, ans = <span class="number">0</span>, ls = <span class="number">1e9</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= G[i].size();j++) &#123;</span><br><span class="line">                tmp += dp[G[i][j - <span class="number">1</span>]], ans = tmp / j + (<span class="keyword">double</span>)m / j;</span><br><span class="line">                <span class="keyword">if</span> (ans &gt; ls) <span class="keyword">break</span>;</span><br><span class="line">                dp[i] = min(dp[i], ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.7lf\n"</span>, dp[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-Tree"><a href="#T3-Tree" class="headerlink" title="T3 Tree"></a>T3 Tree</h1><p><img src="https://i.loli.net/2019/04/06/5ca85d84910e7.png" alt="1554537850931"></p>
<p><img src="https://i.loli.net/2019/04/06/5ca85da120c4b.png" alt="1554537880643"></p>
<p>如果最远点的距离是$x$，那么所选择的点数必须不小于$\frac{n}{x}$</p>
<p>这个式子看上去就很像分块</p>
<p>我们暴力枚举答案$1-\sqrt{n}$，找到答案为当前值的关键点数的区间</p>
<p>对于现在还没有确定答案的那些关键点数，我们直接二分，然后暴力算答案</p>
<p>所谓暴力就是直接树上贪心</p>
<p>这样可以获得60分的好成绩</p>
<p>贴一下题解</p>
<p><img src="https://i.loli.net/2019/04/06/5ca85eea90a02.jpg" alt="sol_tree"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/03/4-1%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/03/4-1%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/" class="post-title-link" itemprop="url">4.1省选模拟</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-03 19:38:27" itemprop="dateCreated datePublished" datetime="2019-04-03T19:38:27+08:00">2019-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:28:15" itemprop="dateModified" datetime="2020-04-23T09:28:15+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="T1-Line"><a href="#T1-Line" class="headerlink" title="T1 Line"></a>T1 Line</h1><p><img src="https://i.loli.net/2019/04/03/5ca49b8c8003d.png" alt="1554291556372"></p>
<p><img src="https://i.loli.net/2019/04/03/5ca49babedb1e.png" alt="1554291616688"></p>
<p>如果我们知道了这条直线在$y$轴上的截距，那么我们就可以通过这$n$个点确定最终斜率的区间</p>
<p>假设这条直线是$kx+b$，现在我们已知$b$</p>
<p>对于一个$r_i$，我们知道有</p>
<script type="math/tex; mode=display">
ki+b\leq r_i\Rightarrow k\leq\lfloor\frac{r_i-b}{i}\rfloor</script><p>对于一个$l_i$，我们知道有</p>
<script type="math/tex; mode=display">
ki+b\geq l_i\Rightarrow k\geq\lceil\frac{l_i-b}{i}\rceil</script><p>那么对于一个$b$，它对答案的贡献就是</p>
<script type="math/tex; mode=display">
\max\{0,\min_{i=1}^n\{\lfloor\frac{r_i-b}{i}\rfloor\}-\max_{j=1}^n\{\lceil\frac{l_j-b}{j}\rceil\}+1\}</script><p>如果我们知道此时$\min$取的是哪个位置，$\max$取的是哪个位置，我们就可以$O(1)$计算答案</p>
<p>由于我们之前是枚举的$b$，现在就把$b$看作自变量$x$</p>
<p>对于$\min,\max$我们分开考虑</p>
<p>以$\min$为例</p>
<p>此时我们要求$\frac{r_i-x}{i}$的最小值</p>
<p>可以使用斜率优化，即将这个东西看作一条斜率为$-\frac{1}{i}$，截距是$\frac{r_i}{i}$的直线</p>
<p>此时我们就得到了当$b$<strong>在一个范围内</strong>的时候，最小值的位置</p>
<p>同样，我们可以得出当$b$在一个范围内的时候，最大值的位置</p>
<p>我们将这两个范围合并，就可以得出当$b$在一个范围内时，最小值以及最大值的位置</p>
<p>现在考虑对于一个区间的$b$，如何计算答案</p>
<p>此时我们已经确定了$\min,\max$的位置</p>
<p>首先考虑将前面那个0搞掉</p>
<p>我们发现这对应着收紧一下区间</p>
<p>解方程</p>
<script type="math/tex; mode=display">
\begin{align}
\frac{r_i-x}{i}&=\frac{l_j-x}{j}\\\
r_ij-xj&=l_ji-xi\\\
x(i-j)&=l_ji-r_ij\\\
\Rightarrow x&=\frac{l_ji-r_ij}{i-j}
\end{align}</script><p>当$i=j$时，我们不做处理</p>
<p>当$i&gt;j$时，这对应着$b$的新下界</p>
<p>当$i&lt;j$时，这对应着$b$的新上界</p>
<p>此时我们就可以把前面的0搞掉了</p>
<p>考虑如何计算</p>
<script type="math/tex; mode=display">
\sum_{i=L}^R\lfloor\frac{a-i}{b}\rfloor</script><p>我们发现如果不考虑边角上的数，这其实是一个每个数都重复了$b$次的等差数列</p>
<p>如果$\lfloor\frac{a}{b}\rfloor=k$，那么有$bk\leq a\leq (b+1)k-1$</p>
<p>我们对边角特殊处理即可</p>
<p>考试的时候由于某些未知的地方没有开<code>long long</code>，导致只有33.3分</p>
<p>听说可以算出斜率的区间</p>
<p>好像我写毒瘤了</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">calc</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    L = -L, R = -R, swap(L, R);</span><br><span class="line">    <span class="keyword">int</span> l1 = <span class="built_in">floor</span>((L + a) / (<span class="keyword">double</span>)b) + <span class="number">1</span>, r1 = <span class="built_in">floor</span>((R + a) / (<span class="keyword">double</span>)b); LL res = (LL)(r1 - l1 + <span class="number">1</span>) * (l1 + r1) * b / <span class="number">2</span>;</span><br><span class="line">    l1 = l1 * b - <span class="number">1</span>, r1 = (r1 + <span class="number">1</span>) * b;</span><br><span class="line">    res += <span class="built_in">floor</span>((a + L) / (<span class="keyword">double</span>)b) * (LL)(l1 - L - a + <span class="number">1</span>) + <span class="built_in">floor</span>((a + R) / (<span class="keyword">double</span>)b) * (LL)(R + a - r1 + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">calc</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> lj, <span class="keyword">int</span> ri, <span class="keyword">int</span> j, <span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">// L &lt;= x &lt;= R</span></span><br><span class="line">    <span class="keyword">if</span> (i == j) <span class="keyword">return</span> calc(L, R, ri, i) - calc(L, R, lj + j - <span class="number">1</span>, j) + R - L + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> k = (ri - lj) / (<span class="keyword">double</span>)(i - j), y = lj - k * j;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; i) L = max(L, (<span class="keyword">int</span>)<span class="built_in">ceil</span>(y)); <span class="keyword">else</span> R = min(R, (<span class="keyword">int</span>)<span class="built_in">floor</span>(y));</span><br><span class="line">    <span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> calc(L, R, ri, i) - calc(L, R, lj + j - <span class="number">1</span>, j) + R - L + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span><span class="keyword">int</span> b, kinv;&#125; l1[N], l2[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">inter</span><span class="params">(Line a, Line b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((LL)a.b * b.kinv - (LL)b.b * a.kinv) / (<span class="keyword">double</span>)(a.kinv - b.kinv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(Line a, Line b, Line c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dcmp(inter(a, b) - inter(a, c)) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> l[N], r[N], head, tail; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span><span class="keyword">int</span> l, r, at;&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;data&gt; tmp1, tmp2;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"line.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"line.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;l[i], &amp;r[i]);</span><br><span class="line">    head = <span class="number">1</span>, tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        Line now = (Line)&#123;-l[i], -i&#125;;</span><br><span class="line">        <span class="keyword">while</span> (head &lt; tail &amp;&amp; !check(l1[tail - <span class="number">1</span>], l1[tail], now)) tail--;</span><br><span class="line">        l1[++tail] = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head, ls = <span class="number">-2e9</span>, cur;i &lt;= tail;i++, ls = cur + <span class="number">1</span>) &#123;</span><br><span class="line">        cur = i != tail ? <span class="built_in">floor</span>(inter(l1[i], l1[i + <span class="number">1</span>])) : <span class="number">2e9</span>;</span><br><span class="line">        <span class="keyword">if</span> (ls &lt;= cur) tmp1.push_back((data)&#123;ls, cur, -l1[i].kinv&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    head = <span class="number">1</span>, tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n;i &gt;= <span class="number">1</span>;i--) &#123;</span><br><span class="line">        Line now = (Line)&#123;-r[i], -i&#125;;</span><br><span class="line">        <span class="keyword">while</span> (head &lt; tail &amp;&amp; !check(l2[tail - <span class="number">1</span>], l2[tail], now)) tail--;</span><br><span class="line">        l2[++tail] = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head, ls = <span class="number">-2e9</span>, cur;i &lt;= tail;i++, ls = cur + <span class="number">1</span>) &#123;</span><br><span class="line">        cur = i != tail ? <span class="built_in">floor</span>(inter(l2[i], l2[i + <span class="number">1</span>])) : <span class="number">2e9</span>;</span><br><span class="line">        <span class="keyword">if</span> (ls &lt;= cur) tmp2.push_back((data)&#123;ls, cur, -l2[i].kinv&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cur1 = <span class="number">0</span>, cur2 = <span class="number">0</span>, ls = <span class="number">-2e9</span>; LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">233</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> nxt, at1 = tmp1[cur1].at, at2 = tmp2[cur2].at, R;</span><br><span class="line">        <span class="keyword">if</span> (cur1 != tmp1.size() - <span class="number">1</span> &amp;&amp; cur2 != tmp2.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp1[cur1].r &lt; tmp2[cur2].r) nxt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> nxt = <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> nxt = (cur1 == tmp1.size() - <span class="number">1</span>) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">        R = nxt == <span class="number">1</span> ? tmp1[cur1].r : tmp2[cur2].r;</span><br><span class="line">        ans += calc(ls, R, l[tmp1[cur1].at], r[tmp2[cur2].at], tmp1[cur1].at, tmp2[cur2].at), ls = R + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur1 == tmp1.size() - <span class="number">1</span> &amp;&amp; cur2 == tmp2.size() - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (nxt == <span class="number">1</span>) cur1++; <span class="keyword">else</span> cur2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-Seat"><a href="#T2-Seat" class="headerlink" title="T2 Seat"></a>T2 Seat</h1><p><img src="https://i.loli.net/2019/04/03/5ca4a9500598d.png" alt="1554295110222"></p>
<p><img src="https://i.loli.net/2019/04/03/5ca4a96b93e7a.png" alt="1554295138493"></p>
<p>不会，先放题解</p>
<div class="pdfobject-container" data-target="sol.pdf" data-height="500px"></div>
<h1 id="T3-Dist"><a href="#T3-Dist" class="headerlink" title="T3 Dist"></a>T3 Dist</h1><p><img src="https://i.loli.net/2019/04/03/5ca4a9d7eafd3.png" alt="1554295246669"></p>
<p><img src="https://i.loli.net/2019/04/03/5ca4a9ef2d574.png" alt="1554295270358"></p>
<p>如果我们将每个集合看作一个点，那么一共只有18个点，我们在这个图上跑最短路</p>
<p>那么对于两个点$a,b$，$a$到$b$的最短路径等于</p>
<script type="math/tex; mode=display">
\min_{a\in U,b\in V}dis(U,V)</script><p>我们枚举起点$a$，将所有集合按照离$a$的距离排序，然后从小到大依次加入</p>
<p>当加入一个新的集合$y$时，它对答案的贡献就是$y$集合中包含的点减去被$y$和之前的集合包含的点</p>
<p>这个我们处理出一个子集和就可以了，就是半个<code>FWT</code></p>
<p>注意某个点离自己的距离是0，这种方法会将这个距离算成包含$a$的集合的点权最小值</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/02/FWT%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/02/FWT%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">FWT基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-02 21:10:02" itemprop="dateCreated datePublished" datetime="2019-04-02T21:10:02+08:00">2019-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:16:26" itemprop="dateModified" datetime="2020-04-23T09:16:26+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="FWT有啥用啊"><a href="#FWT有啥用啊" class="headerlink" title="FWT有啥用啊"></a>FWT有啥用啊</h1><p>我们知道，<code>FFT</code>可以解决多项式的卷积，即</p>
<script type="math/tex; mode=display">
C_k=\sum_{i+j=k}A_i\*B_j</script><p>如果将操作符换一下，换成集合运算符</p>
<p>比如</p>
<script type="math/tex; mode=display">
C_k=\sum_{i|j=k}A_i\*B_j\\\
C_k=\sum_{i\&j=k}A_i\*B_j\\\
C_k=\sum_{i\oplus j=k}A_i\*B_j</script><p>这时就不能使用<code>FFT</code>了</p>
<p>但是<code>FFT</code>使我们产生了一种想法</p>
<p>我们能不能用一种类似<code>FFT</code>的方法，用另一个多项式来表示$A,B$，然后再对应相乘，最后再变换回来呢</p>
<p>答案是可以的，这就是<code>FWT</code>，即快速沃尔什变换</p>
<h1 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h1><p>令$A,B$为两个向量，且维数为$n$，$n$是$2$的整数次幂</p>
<p>定义记号</p>
<ul>
<li><p>$A\pm B=(A_0\pm B_0,A_1\pm B_1,A_2\pm B_2,\cdots,A_{n-1}\pm B_{n-1})$</p>
</li>
<li><p>$A\oplus B=(\sum\limits_{i\oplus j=0}A_i*B_j,\sum\limits_{i\oplus j=1}A_i*B_j,\sum\limits_{i\oplus j=3}A_i*B_j,\cdots,\sum\limits_{i\oplus j=n-1}A_i*B_j)​$</p>
</li>
</ul>
<p>这里的$\oplus$代表集合运算</p>
<h1 id="或卷积及其逆运算"><a href="#或卷积及其逆运算" class="headerlink" title="或卷积及其逆运算"></a>或卷积及其逆运算</h1><p>我们定义$FWT$变换，有</p>
<script type="math/tex; mode=display">
FWT(A)[i]=\sum_{j|i=i}A_j</script><blockquote>
<p>性质1：$FWT(A\pm B)=FWT(A)\pm FWT(B)$</p>
</blockquote>
<p>根据此时$FWT​$变换的定义我们知道这是一个$A​$数组的线性组合，故加减法满足分配律</p>
<p>我们断言，此时的$FWT$满足</p>
<script type="math/tex; mode=display">
FWT(A)=\begin{cases}(FWT(A_0),FWT(A_0)+FWT(A_1))& n>1\\\ A & n=0\end{cases}</script><p>$A_0,A_1$分别代表$A$数组的前半部分、后半部分</p>
<p>证明如下：</p>
<p>实际上此时$A_0,A_1$的下标只有最高位是不同的</p>
<p>根据$FWT$的定义，合并之后左半部分的最高位仍然是0，右半部分的最高位仍然是1</p>
<p>由于$FWT(A_1)$的最高位一定为1，而此时$j|i$的最高位不可能为0，所以右半部分对于合并之后是没有贡献的</p>
<p>而对于右半边，如果左半边的数满足$j|i=i​$，那么在$i​$加上最高位1之和，这个式子仍然成立</p>
<p>而此时右半边原来的$FWT$本来就对右半边的数有贡献</p>
<p>所以这个式子成立</p>
<blockquote>
<p>性质2：$FWT(A|B)=FWT(A)*FWT(B)\ \ (对应相乘)$</p>
</blockquote>
<p>我们采用归纳法证明</p>
<script type="math/tex; mode=display">
\begin{aligned}
FWT(A|B)&=FWT((A|B)_0,(A|B)_1)\\\
&=FWT(A_0|B_0,A_1|B_0+A_0|B_1+A_1|B_1)\\\
&=(FWT(A_0|B_0),FWT(A_0|B_0+A_1|B_0+A_0|B_1+A_1|B_1))\\\
&=(FWT(A_0)\*FWT(B_0),FWT(A_0)\*FWT(B_0)+FWT(A_1)\*FWT(B_0)\\\
&+FWT(A_0)\*FWT(B_1)+FWT(A_1)\*FWT(B_1))\\\
&=(FWT(A_0)\*FWT(B_0),(FWT(A_0)+FWT(A_1)\*(FWT(B_0)+FWT(B_1))))\\\
&=(FWT(A_0),FWT(A_0)+FWT(A_1))\*(FWT(B_0),FWT(B_0)+FWT(B_1))\\\
&=FWT(A)\*FWT(B)
\end{aligned}</script><p>定义$IFWT$变换为$FWT$变换的逆变换</p>
<p>我们断言，$IFWT$满足</p>
<script type="math/tex; mode=display">
IFWT(A)=\begin{cases}(IFWT(A_0),IFWT(A_1)-IFWT(A_0))&n>1\\\ A&n=0\end{cases}</script><p>证明如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
IFWT(FWT(A))&=IFWT(FWT(A_0),FWT(A_0)+FWT(A_1))\\\
&=(IFWT(FWT(A_0)),IFWT(FWT(A_1)))\\\
&=(A_0,A_1)\\\
&=A
\end{aligned}</script><h1 id="与卷积及其逆运算"><a href="#与卷积及其逆运算" class="headerlink" title="与卷积及其逆运算"></a>与卷积及其逆运算</h1><p>定义$FWT$变换为</p>
<script type="math/tex; mode=display">
FWT(A)[i]=\sum_{i\&j=j}A_i</script><p>类似或卷积，我们可以得出此时$FWT$的递推式</p>
<script type="math/tex; mode=display">
FWT(A)=\begin{cases}(FWT(A_0)+FWT(A_1),FWT(A_1))&n>1\\\ A &n=0\end{cases}</script><p>证明很简单，$A$数组的右半部分与上一个首位为0的数，得到的结果一定在$A$的左半部分</p>
<p>显然，它们仍然对自己所在的部分有贡献</p>
<p>$FWT(A\&amp;B)=FWT(A)*FWT(B)$在此时成立</p>
<p>证明如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
FWT(A\&B)&=FWT((A\&B)_0,(A\&B)_1)\\\
&=FWT(A_0\&B_0+A_0\&B_1+A_1\&B_0,A_1\&B_1)\\\
&=(FWT(A_0\&B_0+A_0\&B_1+A_1\&B_0+A_1\&B_1),FWT(A_1\&B_1))\\\
&=((FWT(A_0)+FWT(A_1))\*(FWT(B_0)+FWT(B_1)),FWT(A_1)\*FWT(B_1))\\\
&=(FWT(A_0)+FWT(A_1),FWT(A_1))\*(FWT(B_0)+FWT(B_1),FWT(B_1))\\\
&=FWT(A)\*FWT(B)
\end{aligned}</script><p>定义$IFWT$变换为</p>
<script type="math/tex; mode=display">
IFWT(A)=\begin{cases}(IFWT(A_0)-IFWT(A_1),IFWT(A_1))&n>1\\\ A&n=0\end{cases}</script><p>证明如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
IFWT(FWT(A))&=IFWT(FWT(A_0)+FWT(A_1),FWT(A_1))\\\
&=(IFWT(FWT(A_0)),IFWT(FWT(A_1))\\\
&=(A_0,A_1)\\\
&=A
\end{aligned}</script><h1 id="异或卷积及其逆运算"><a href="#异或卷积及其逆运算" class="headerlink" title="异或卷积及其逆运算"></a>异或卷积及其逆运算</h1><p>异或卷积的$FWT$稍微麻烦一点</p>
<p>我们定义函数$d(x)$表示$x$<strong>在二进制下</strong>1的数量</p>
<p>定义$FWT$变换为</p>
<script type="math/tex; mode=display">
FWT(A)[i]=\sum_{d(j\&i)\equiv0\mod 2}A_j-\sum_{d(k\&i)\equiv1\mod 2}A_k</script><p>那么此时，它的递推式为</p>
<script type="math/tex; mode=display">
FWT(A)=\begin{cases}(FWT(A_0)+FWT(A_1),FWT(A_0)-FWT(A_1))&n>0\\\ A&n=0\end{cases}</script><p>我们考虑这个式子是怎么来的</p>
<p>先看这个式子左边的$FWT(A_0)+FWT(A_1)$</p>
<p>$A_0$的下标没有变化，所以要加上$FWT(A_0)$，而现在$A_1$的下标的最高位变成了1，但是与上一个最高位为0的数之后是不变的</p>
<p>所以这个式子是正确的</p>
<p>我们看右边的$FWT(A_0)-FWT(A_1)$</p>
<p>$A_0$的最高位不变，与上一个最高位为1的数之后结果仍然不变</p>
<p>$A_1$的下标的最高位多了一个1，与上一个最高位为1的数之后奇偶性就变了，所以要取反</p>
<p>所以这个也是成立的</p>
<p>$FWT(A\oplus B)=FWT(A)*FWT(B)$在此时成立</p>
<p>证明如下</p>
<script type="math/tex; mode=display">
\begin{aligned}
FWT(A\oplus B)&=FWT((A\oplus B)_0,(A\oplus B)_1)\\\
&=FWT(A_0\oplus B_0+A_1\oplus B_1,A_0\oplus B_1+A_1\oplus B_0)\\\
&=(FWT(A_0\oplus B_0+A_1\oplus B_1+A_0\oplus B_1+A_1\oplus B_0),\\\
&FWT(A_0\oplus B_0+A_1\oplus B_1-A_0\oplus B_1-A_1\oplus B_0))\\\
&=((FWT(A_0)+FWT(A_1))\*(FWT(B_0)+FWT(B_1)),\\\
&(FWT(A_0)-FWT(A_1))\*(FWT(B_0)-FWT(B_1)))\\\
&=(FWT(A_0+A_1),FWT(A_0-A_1))\*(FWT(B_0+B_1),FWT(B_0-B_1))\\\
&=FWT(A)\*FWT(B)
\end{aligned}</script><p>定义$IFWT$为</p>
<script type="math/tex; mode=display">
IFWT(A)=\begin{cases}(\frac{IFWT(A_0+A_1)}{2},\frac{IFWT(A_0-A_1)}{2})&n>1\\\ A&n=0\end{cases}</script><p>证明如下：</p>
<script type="math/tex; mode=display">
\begin{aligned}
IFWT(FWT(A))&=IFWT(FWT(A_0)+FWT(A_1),FWT(A_0)-FWT(A_1))\\\
&=(IFWT(FWT(A_0)),IFWT(FWT(A_1)))\\\
&=(A_0,A_1)\\\
&=A
\end{aligned}</script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/16/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="PlanarG"
      src="/images/77041874_p0_master12001.jpg">
  <p class="site-author-name" itemprop="name">PlanarG</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">185</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">65</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://planarg.top/" title="https:&#x2F;&#x2F;planarg.top&#x2F;">Title</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">PlanarG</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1.5,"jsonPath":"/live2dw/assets/histoire.model.json"},"display":{"position":"left","width":150,"height":300,"hOffset":35,"vOffset":-25},"mobile":{"show":false},"log":false});</script></body>
</html>
