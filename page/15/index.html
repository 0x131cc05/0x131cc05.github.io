<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"planarg.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="PlanarG&#39;s blog">
<meta property="og:url" content="https://planarg.top/page/15/index.html">
<meta property="og:site_name" content="PlanarG&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="PlanarG">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://planarg.top/page/15/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>PlanarG's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">PlanarG's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section">首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section">标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section">分类</a>

  </li>
        <li class="menu-item menu-item-友链">

    <a href="/friends/" rel="section">友链</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section">归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger">搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/05/05/5-4%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/05/5-4%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/" class="post-title-link" itemprop="url">5.4省选模拟</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-05 21:04:08" itemprop="dateCreated datePublished" datetime="2019-05-05T21:04:08+08:00">2019-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:26:53" itemprop="dateModified" datetime="2020-04-23T09:26:53+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><div class="pdfobject-container" data-target="prob-new.pdf" data-height="500px"></div>
<h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>有一棵树，每条边都有$50\%$的概率被删除，问在所有情况中，这棵树的邻接矩阵的秩的和</p>
<p>邻接矩阵的秩的含义是在初等行变换后的非自由元数量</p>
<p>首先有一个性质：树的邻接矩阵的秩等于其最大匹配数乘以$2$</p>
<p>那么这道题就相当于让我们统计所有情况下的最大匹配数的和乘以$2$</p>
<p>先考虑一棵给定的树可以用什么方法求最大匹配数</p>
<p><code>dp</code>是可以的，但是这里我们不能使用<code>dp</code>的方式来推，因为这样不好维护</p>
<p>那么我们考虑使用贪心的策略：即优先让儿子匹配，如果匹配完了之后这个点还能和儿子匹配就让这个点和那个儿子配对</p>
<p>也就是要让匹配尽量靠下，儿子能匹配就不要往父亲匹配</p>
<p>我们可以设<code>dp[u][0/1]</code>表示考虑$u$以及它的子树，$u$这个点是否匹配的方案数</p>
<p>转移比较显然</p>
<p>所以这道题的关键还是看出是最大匹配数乘$2$</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][N], sz[N], pw[N], ans, n; <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    sz[u] = dp[<span class="number">0</span>][u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next) </span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) &#123;</span><br><span class="line">            dfs(e[i].to, u), sz[u] += sz[e[i].to];</span><br><span class="line">            dp[<span class="number">1</span>][u] = ((LL)dp[<span class="number">1</span>][u] * pw[sz[e[i].to]] + (LL)dp[<span class="number">0</span>][u] * dp[<span class="number">0</span>][e[i].to]) % mod;</span><br><span class="line">            dp[<span class="number">0</span>][u] = (LL)dp[<span class="number">0</span>][u] * (pw[sz[e[i].to] - <span class="number">1</span>] + dp[<span class="number">1</span>][e[i].to]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    ans = (ans + (LL)dp[<span class="number">1</span>][u] * (pw[n - sz[u]] &lt;&lt; <span class="number">1</span>)) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"rank.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"rank.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), pw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) pw[i] = pw[i - <span class="number">1</span>] * <span class="number">2</span> % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>有一个$n$个节点的完全二叉树，$i$的父亲是$\lfloor\frac i2\rfloor$，现在这棵树上又多了$m(m\leq 6)$条边，求简单路径总数</p>
<p>我们首先考虑这样一个性质：如果$u,v$在树上的路径只有一条，并且中间没有边的端点，那么从这两个点出发，答案相同</p>
<p>因为对于任意一条路径，我们对这条路径在$u,v$段上的覆盖情况取反，就能得到从另一个点出发的一条合法路径，所以方案数是相等的</p>
<p>那么我们可以将所有关键点以及它们的祖先提出来，建一棵虚树，虚树上的每个点存一个<code>sz</code>，表示它在原树上的儿子中，不在虚树上的节点的个数</p>
<p>然后就可以从每个虚树上的点开始暴力<code>dfs</code>，然后分类统计答案，即每个虚树上的点的答案都是这个点以及它的不在虚树上的儿子的答案</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ID;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ID[u]) <span class="keyword">return</span> ID[u];</span><br><span class="line">    <span class="keyword">return</span> ID[u] = ID.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 360</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[N], sz[N], n;</span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    LL res = sz[u]; vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to]) res += dfs(e[i].to);</span><br><span class="line">    <span class="keyword">return</span> vis[u] = <span class="number">0</span>, res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dep</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> tmp = <span class="number">1</span>;;tmp++)</span><br><span class="line">        <span class="keyword">if</span> (u &lt; <span class="number">1</span> &lt;&lt; tmp) <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = dep(u), res = (<span class="number">1</span> &lt;&lt; (tot - now + <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = now + <span class="number">1</span>;i &lt;= tot;i++) u = u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res - max(min(u - n, <span class="number">1</span> &lt;&lt; tot - now), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) sz[u] -= sz[e[i].to], dfs1(e[i].to, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ID.count(u)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != <span class="number">1</span>) adde(idx(u), idx(u &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    link(u &lt;&lt; <span class="number">1</span>), link(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> from[N], to[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"route.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"route.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> m, mxdep; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m), mxdep = dep(n), idx(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;from[i], &amp;to[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = from[i];j;j &gt;&gt;= <span class="number">1</span>) idx(j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = to[i];j;j &gt;&gt;= <span class="number">1</span>) idx(j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : ID) sz[v.second] = get(v.first, mxdep);</span><br><span class="line">    link(idx(<span class="number">1</span>)), dfs1(idx(<span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) adde(idx(from[i]), idx(to[i]));</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : ID) res = (res + dfs(v.second) * sz[v.second]) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p>有一棵树，每个点都有权值，定义一个点$u$的价值为$\sum\limits_{i=1}^nw_idis(i,u)^{\frac{3}{2}}$，找到一个点使得价值最小</p>
<p>我们先考虑一个序列上的情况</p>
<p>假设有一排点$a_1,a_2,\cdots,a_n$</p>
<p>我们先钦定一个端点$p$</p>
<p>如果你有一个指针，从$a_1$扫到$a_n$</p>
<p>那么得到的$w_pf(p,a_i)$是一个凸函数</p>
<p>我们现在固定另一个端点，让$p$动起来</p>
<p>我们会得到很多凸函数的叠加，而这些凸函数的叠加仍然是凸函数</p>
<p>所以这个序列上的$g$也是凸的</p>
<p>在一个序列上，我们可以使用二分</p>
<p>放在树上，就可以使用点分治</p>
<p>具体来说，对于点分树上$u$的每个儿子，找到$g$比$g(u)$小的那个$v$，移动到$v$去，直到不能移动为止</p>
<p>代码就咕了</p>
<h1 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h1><p>有一个离散随机变量$x$，最开始它有$p_i$的概率为$i$</p>
<p>现在要对$x$进行$m$次操作，每次会将$x$等概率变成$[1,x]$中的一个整数</p>
<p>问最后$x$变成每个数的概率</p>
<p>很妙的一道题</p>
<p>我们考虑一开始$x$的概率生成函数$f(x)$</p>
<p>此时$x^i$的系数就是$p_i$</p>
<p>考虑一次操作之后它变成了什么，我们假设一次操作之后的概率生成函数是$f^*(x)$</p>
<p>那么显然有</p>
<script type="math/tex; mode=display">
\begin{aligned}\
[x^i]f^\*(x)&=\sum_{j=i}^n\frac{[x^j]f(x)}{j+1}\\\
f^\*(x)&=\sum_{i=0}^nx^i\sum_{j=i}^n\frac{[x^j]f(x)}{j+1}\\\
&=\sum_{j=0}^n\frac{[x^j]f(x)}{j+1}\sum_{i=0}^j
x^i\\\
&=\sum_{j=0}^n\frac{[x^j]f(x)}{j+1}\frac{x^{j+1}-1}{x-1}\\\
&=\frac{1}{x-1}\sum_{j=0}^n[x^j]f(x)\frac{x^{j+1}-1}{j+1}
\end{aligned}</script><p>注意到</p>
<script type="math/tex; mode=display">
\frac{x^{j+1}-1}{j+1}=[\frac{t^{j+1}}{j+1}]_1^x=\int_1^xt^j\mathrm{d}t</script><p>所以</p>
<script type="math/tex; mode=display">
\begin{aligned}
f^\*(x)&=\frac{1}{x-1}\sum_{j=0}^n[x^j]f(x)\int_1^xt^j\mathrm{d}t\\\
&=\frac{1}{x-1}\int_1^x\sum_{j=0}^n[x^j]f(x)t^j\mathrm{d}t\\\
&=\frac{1}{x-1}\int_1^xf(t)\mathrm{d}t
\end{aligned}</script><p>现在很不爽的一点是积分是从$1$开始积的，而且前面分数的分母是$x-1$而不是$x$，我们要把这个弄掉</p>
<p>考虑设$g(x)=f(x+1),g^*(x)=f^*(x+1)$</p>
<p>那么有</p>
<script type="math/tex; mode=display">
g^\*(x)=f^\*(x+1)=\frac{1}{x}\int_1^{x+1}f(t)\mathrm{d}t=\frac{1}{x}\int_0^xg(t)\mathrm{d}t</script><p>分析一些最后那个</p>
<p>设</p>
<script type="math/tex; mode=display">
g(x)=\sum_{i=0}^na_ix^i</script><p>那么</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{1}{x}\int_0^xg(t)\mathrm{d}t&=\frac{1}{x}\int_0^x\sum_{i=0}^na_it^i\mathrm{d}t\\\
&=\frac{1}{x}\sum_{i=0}^n\int_0^xa_it^i\mathrm{d}t\\\
&=\frac{1}{x}\sum_{i=0}^n[\frac{a_i}{i+1}t^{i+1}]_0^x\\\
&=\frac{1}{x}\sum_{i=0}^n\frac{a_i}{i+1}x^{i+1}\\\
&=\sum_{i=0}^n\frac{a_i}{i+1}x^i
\end{aligned}</script><p>所以我们知道</p>
<script type="math/tex; mode=display">
[x^i]g^\*(x)=\frac{[x^i]g(x)}{i+1}</script><p>这是经过一次变换之后的结果，如果我们进行$m$次变换，那么可以得到</p>
<script type="math/tex; mode=display">
[x^i]g^\*(x)=\frac{[x^i]g(x)}{(i+1)^m}</script><p>现在关键就在于将最开始的$f$变换成$g$，最后再将$g^*$变换成$f^*$</p>
<p>我们来讨论一下从$f$变成$g$</p>
<script type="math/tex; mode=display">
\begin{aligned} 
g(x) &=f(x+1) \\
\sum_{i=0}^n[x^i]g(x)x^i&=\sum_{i=0}^n[x^i]f(x)(x+1)^i\\
\sum_{i=0}^n[x^i]g(x)x^i&=\sum_{i=0}^n[x^i]f(x)\sum_{k=0}^i\begin{pmatrix}i\\ k\end{pmatrix}x^k\\
[x^i]g(x)&=\sum_{k=0}^i\begin{pmatrix}i\\ k\end{pmatrix}[x^k]f(x)\\
i![x^i]g(x)&=\sum_{k=0}^n\frac{k![x^k]f(x)}{(k-i)!}
\end{aligned}</script><p>从$g$变成$f$差不多</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">250010</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> r[N * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, t, w = <span class="number">1</span>;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w = (LL)w * Wn % mod)</span><br><span class="line">                t = (LL)w * a[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!type) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, inv = Pow(len, mod - <span class="number">2</span>);i &lt; len;i++)</span><br><span class="line">        a[i] = (LL)a[i] * inv % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N], A[N * <span class="number">4</span>], B[N * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"random.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"random.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n; LL m; <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>, &amp;n, &amp;m), frac[<span class="number">0</span>] = <span class="number">1</span>, m %= mod - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    inv[n] = Pow(frac[n], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) inv[i] = (LL)inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]), A[i] = (LL)A[i] * frac[i] % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) B[n - i] = inv[i];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n * <span class="number">2</span>) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    NTT(A, len, <span class="number">1</span>), NTT(B, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) A[i] = (LL)A[i] * B[i] % mod;</span><br><span class="line">    NTT(A, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) A[i] = A[i + n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>;i &lt; len;i++) A[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) A[i] = (LL)A[i] % mod * Pow(Pow(i + <span class="number">1</span>, m), mod - <span class="number">2</span>) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>;i &lt; len;i++) B[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) B[n - i] = i &amp; <span class="number">1</span> ? mod - inv[i] : inv[i];</span><br><span class="line">    NTT(A, len, <span class="number">1</span>), NTT(B, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) A[i] = (LL)A[i] * B[i] % mod;</span><br><span class="line">    NTT(A, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, (LL)A[i + n] * inv[i] % mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/28/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/28/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">线性规划</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-28 20:40:20" itemprop="dateCreated datePublished" datetime="2019-04-28T20:40:20+08:00">2019-04-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-25 17:06:56" itemprop="dateModified" datetime="2020-06-25T17:06:56+08:00">2020-06-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么是线性规划"><a href="#什么是线性规划" class="headerlink" title="什么是线性规划"></a>什么是线性规划</h1><blockquote>
<p>实际生活中有很多问题都是这样的形式：它们需要最大化或者最小化一个目标；它们通常面临资源、时间等多方面的限制。假如把这些问题的目标简化成一个线性的函数，把限制表示成一些线性的等式或者不等式，那么这些问题就可以被描述成线性规划问题。</p>
<p>——2016国家集训队论文集</p>
</blockquote>
<p>在线性规划中，我们有$n$个变量$x_1,x_2,\cdots, x_n$</p>
<p>我们希望一个估价函数$f(x_1, x_2,x_3,\cdots,x_n)$尽量大/小</p>
<p>同时我们希望这些变量能满足一些线性等式或者不等式$g(x_1,x_2,x_3,\cdots,x_n)$</p>
<p>那么这个过程就叫线性规划</p>
<h1 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h1><ul>
<li><strong>线性函数</strong></li>
</ul>
<p>我们定义函数$f(x_1,x_2,x_3,\cdots,x_n)$为线性函数当且仅当有</p>
<script type="math/tex; mode=display">
f(x_1,x_2,\cdots,x_n)=\sum_{i=1}^na_ix_i</script><p>其中$a_i$为实数常量，$x_i$为变量</p>
<ul>
<li><strong>线性等式</strong></li>
</ul>
<p>定义线性等式为$f(x_1,x_2,\cdots,x_n)=b$，其中$f$是线性函数，$b$是实数常量</p>
<ul>
<li><strong>线性不等式</strong></li>
</ul>
<p>定义线性不等式为$f(x_1,x_2,\cdots,x_n)\leq b$或者$f(x_1,x_2,\cdots,x_n)\geq b$，其中$f$是线性函数，$b$是实数常量</p>
<h1 id="标准型线性规划"><a href="#标准型线性规划" class="headerlink" title="标准型线性规划"></a>标准型线性规划</h1><p>标准型线性规划要求满足如下形式</p>
<p>最<strong>大</strong>化</p>
<script type="math/tex; mode=display">
\sum_{i=1}^nc_ix_i</script><p>满足约束</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{j=1}^na_{ij}x_j&\leq b_i\quad\quad i=1,2,\cdots,m\\\
x_i&\geq 0 \quad\quad \ i=1,2,\cdots, n
\end{aligned}</script><ul>
<li>那么问题来了，如果某个限制不是$\sum a_ix_i\leq b$，而是$\sum a_ix_i\geq b$，怎么办？</li>
</ul>
<p>等式两边同时乘以一个负号，就可以变成小于等于</p>
<ul>
<li>那如果是要求估价函数最小呢？</li>
</ul>
<p>将所有的$c_i$取反，最后再将答案取反</p>
<ul>
<li>如果有一个限制是$\sum a_ix_i=b$怎么办？</li>
</ul>
<p>将其拆成两个限制，$\sum a_ix_i\geq b$以及$\sum a_ix_i\leq b$</p>
<ul>
<li>如果有一个变量$x$没有要求其$\geq 0$呢</li>
</ul>
<p>将其拆成两个变量$a,b$，令$x=a-b$，再令$a\geq 0,b\geq 0$即可</p>
<p>标准型还可以用矩阵表示</p>
<p>如果我们用$c$表示$c_i$构成的行向量，$A$为$a$构成的矩阵，那么它等价于</p>
<p>最大化</p>
<script type="math/tex; mode=display">
c^Tx</script><p>满足约束</p>
<script type="math/tex; mode=display">
\begin{gathered}
Ax\leq b\\
x\geq 0
\end{gathered}</script><p>其中$c^T$表示矩阵转置</p>
<p>注意这里的$\leq,\geq$代表每一维都小于等于/大于等于</p>
<h1 id="松弛型线性规划"><a href="#松弛型线性规划" class="headerlink" title="松弛型线性规划"></a>松弛型线性规划</h1><p>如果直接求解标准型线性规划，涉及到乘法不等式变号的问题，而且满足的是不等式也不太好做</p>
<p>我们把它转化一下</p>
<p>我们新引入$m$个变量（$m$是约束个数，$n$是未知数个数）</p>
<p>对于限制</p>
<script type="math/tex; mode=display">
\sum_{i=1}^na_ix_i\leq b,x_i\geq 0</script><p>我们利用一个新的变量$x_{i+n}$，可以将它变成</p>
<script type="math/tex; mode=display">
\begin{gathered}
b-\sum_{i=1}^na_ix_i=x_{i+n}\\ x_{i+n}\geq 0,x_i\geq 0
\end{gathered}</script><p>这样就可以将不等式转化为等式了</p>
<p>所以我们这样表示松弛型线性规划：</p>
<p>最大化</p>
<script type="math/tex; mode=display">
\sum_{i=1}^nc_ix_i</script><p>满足约束</p>
<script type="math/tex; mode=display">
\begin{aligned}
x_{i+n}&=b_i-\sum_{j=1}^na_{ij}x_j\quad\quad i=1,2,\cdots,m\\
x_j&\geq 0,x_{i+n}\geq 0\quad\quad\ \ \ i=1,2,\cdots,m
\end{aligned}</script><p>我们将$x_i(i\leq n)$叫做<strong>非基变量</strong>，$x_{i+n}$叫做<strong>基变量</strong></p>
<p>可以看出，标准型线性规划可以很方便地转移成松弛型线性规划</p>
<h1 id="单纯形"><a href="#单纯形" class="headerlink" title="单纯形"></a>单纯形</h1><p>显然最终解所构成的区域一定是一个凸集，局部最优解只有一个</p>
<p>所以我们可以使用类似爬山算法的方法，每次往估价函数更优的那个方向爬，直到爬不动为止</p>
<p>我们首先来尝试构造一组基本解，即先满足所有约束，不管估价函数</p>
<p>如果所有的$b$都大于等于$0$，那么显然有一组解为所有的非基变量都为$0$，否则接下来会讲</p>
<p>我们将这个解进行“转轴”操作，使其往估价函数更优的那一方移动</p>
<h2 id="转轴操作"><a href="#转轴操作" class="headerlink" title="转轴操作"></a>转轴操作</h2><p>我们默认，任意时刻，非基变量的值都为$0$</p>
<p>一次转轴操作，等价于将一个基变量与一个非基变量<strong>交换位置</strong>，即基变量变成非基变量，非基变量变成基变量</p>
<p>我们假设选择了一个基变量$x_B$与一个非基变量$x_N$，现在要交换它们</p>
<p>原来的约束是这样的</p>
<script type="math/tex; mode=display">
x_B=b-\sum_{i=1}^na_ix_i</script><p>我们将$x_N$提出来，然后移项</p>
<script type="math/tex; mode=display">
\begin{gathered}
x_B=b-\sum_{i\not =N}a_ix_i-a_Nx_N\\
x_N=\frac{b-\sum_{i\not= N}a_ix_i-x_B}{a_N}
\end{gathered}</script><p>注意！此时的$x_B$变成了$0$，因为它从一个基变量变成了一个非基变量，而$x_N$的值变成了$\frac{b}{a_N}$</p>
<p>由于我们之前是<strong>交换</strong>基变量与非基变量，所以在等式中，$x_N$这一项的系数变成了$-\frac{1}{a_N}$，而其它项的系数分别除以了$a_N$</p>
<p>我们用这条新的等式代替原来的等式，然后再用这条等式去替换其它的约束以及估价函数</p>
<p>就像高斯消元一样，将其它式子带有$x_N$的项改为这个式子</p>
<p>所以转一次的时间复杂度为$O(nm)$</p>
<p>那么如何选择要进行操作的两个变量呢</p>
<p>显然我们必须满足条件：</p>
<ol>
<li>转完之后估价函数必须更优秀</li>
<li>转完之后等式右边的$b$不能小于$0$</li>
</ol>
<p>我们先考虑第一个条件</p>
<p>在转轴的过程中，$x_N$从原来的$0$变成了一个实数，它在一直变大，所以为了让答案更大，必须有$c_N&gt; 0$</p>
<p>否则当前已经是最优解，退出</p>
<p>接着考虑第二个条件</p>
<p>对于一个等式</p>
<script type="math/tex; mode=display">
x_{i+n}=b-\sum_{i=1}^na_ix_i</script><p>它限制了$x_N$的上界或者下界</p>
<p>如果$a_N\leq0$，那么它无法限制$x_N$的上界，答案为无穷大</p>
<p>否则$x_N$的上界为$\frac{b}{a_N}$</p>
<p>为了让转轴之后，其它的等式的常数都大于等于$0$</p>
<p>我们每次选择$\frac{b}{a_N}$最小的那一个进行转轴操作即可</p>
<hr>
<p>代码如下</p>
<p>注意<code>s[...][n + 1]</code>存的是$b$，也就是那个约束的基变量，其它位置存的是每一项的系数，第一维表示第几个约束</p>
<p>这里的系数算上了前面那个负号</p>
<p><code>c</code>是估价函数，<code>c[n + 1]</code>是这个估价函数当前的值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pivot</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="comment">// 转轴操作, x为未知数, y为第几个方程</span></span><br><span class="line">    <span class="keyword">double</span> tmp = s[y][x]; s[y][x] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n + <span class="number">1</span>;i++) s[y][i] /= -tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="keyword">if</span> (i != y) &#123;</span><br><span class="line">        tmp = s[i][x], s[i][x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (tmp &lt;= eps &amp;&amp; tmp &gt;= -eps) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n + <span class="number">1</span>;j++) s[i][j] += tmp * s[y][j]; </span><br><span class="line">    &#125;</span><br><span class="line">    tmp = c[x], c[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n + <span class="number">1</span>;i++) c[i] += tmp * s[y][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">LP</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="comment">// n为未知数的个数, m为方程数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pos, cur;;pivot(pos, cur, n, m)) &#123;</span><br><span class="line">        <span class="keyword">double</span> tmp = <span class="number">1e100</span>; pos = cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span> (c[i] &gt; eps) pos = i;</span><br><span class="line">        <span class="keyword">if</span> (!pos) <span class="keyword">return</span> c[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="keyword">if</span> (s[i][pos] &lt; -eps) &#123;</span><br><span class="line">            <span class="keyword">double</span> now = s[i][n + <span class="number">1</span>] / -s[i][pos];</span><br><span class="line">            <span class="keyword">if</span> (now &lt; tmp) tmp = now, cur = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!cur) <span class="keyword">return</span> <span class="number">1e100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<strong>线性规划的时间复杂度最坏情况下是指数级别的</strong></p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>我们来讨论一下当存在$b_i&lt;0$的时候该怎么做</p>
<p>显然这个时候我们之前选择的非基向量等于$0$的解就不满足条件了</p>
<p>我们随便找到一个$b&lt;0$的约束，比如是这个</p>
<script type="math/tex; mode=display">
x_{t+n}=b_t-\sum_{j=1}^na_{tj}x_j</script><p>我们从这个约束中，随便找到一个系数（注意算上前面那个负号）大于$0$的变量，假设是$x_B$</p>
<p>进行一次转轴操作，将$x_B$换成基变量，将$x_{t+n}$换成非基变量</p>
<script type="math/tex; mode=display">
x_B=\frac{b_t-\sum_{j\not =B}a_{tj}x_j-x_{t+n}}{a_{tB}}</script><p>由于之前我们要求了$x_B$的系数必须为正，也就是说$a_{tB}$为负</p>
<p>而$b_t$为负，那么转轴之后这个约束的$b$就变成正的了</p>
<p>如果我们找不到这样一个系数为正的非基变量，那么原线性规划一定无解</p>
<p>因为所有的变量都必须不小于$0$，因此这个约束的右边一定小于$0$，无解</p>
<p>注意这样转一次轴之后，虽然这个约束的$b$变成正的了，但是其它约束的$b$可能就变成负数了</p>
<p>但是没关系，我们有信仰，<code>while (1)</code>转轴就可以了，直到所有约束的$b$都变成正数</p>
<p>即使这样时间复杂度是玄学的</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">233</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;++i) <span class="keyword">if</span>(a[i][n + <span class="number">1</span>] &lt; <span class="number">0</span> &amp;&amp;(!r || rand() &amp; <span class="number">1</span>)) r = i;</span><br><span class="line">        <span class="keyword">if</span> (!r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) <span class="keyword">if</span>(a[r][i] &gt; <span class="number">0</span> &amp;&amp; (!c || rand() &amp; <span class="number">1</span>)) c = i;</span><br><span class="line">        <span class="keyword">if</span> (!c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pivot(r, c);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>true</code>代表初始化成功，否则代表初始化失败，线性规划无解</p>
<h2 id="最终解"><a href="#最终解" class="headerlink" title="最终解"></a>最终解</h2><p>如果要求求出每个变量的值，那么我们可以开个数组存一下每个变量被转到哪里去了</p>
<p>如果这个变量变成了一个基变量，那么它的值等于约束右边的$b$</p>
<p>否则这个变量就是$0$</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>最坏情况下的时间复杂度是指数级别的</p>
<p>但是我们有信仰，随机情况下还是很优秀的</p>
<p>大部分时可以过$n,m=100-500$的数据</p>
<h1 id="将问题表示为线性规划"><a href="#将问题表示为线性规划" class="headerlink" title="将问题表示为线性规划"></a>将问题表示为线性规划</h1><h2 id="某个题"><a href="#某个题" class="headerlink" title="某个题"></a>某个题</h2><p>$A,B$两个人在洞中发现了$n$个石头，第$i$个石头对于$A$来说价值为$A_i$，对于$B$来说价值为$B_i$，石头是可以切割的，并且价值与其体积成正比。现在$A,B$要分配这些石头，要求它们两个人最终得到的价值相同，问这个价值最大可以是多少</p>
<p>$n\leq 50, 0\leq A_i,B_i\leq 100$</p>
<p>对于每块石头我们开一个变量$x_i$，表示这块石头有多少分给了$A$，显然有$0\leq x_i\leq 1$</p>
<p>那么两个人得到的价值之和分别为</p>
<script type="math/tex; mode=display">
\begin{gathered}
V_A=\sum_{i=1}^nx_iA_i\\
V_B=\sum_{i=1}^n(1-x_i)B_i
\end{gathered}</script><p>约束为$V_A=V_B$，要求最大化$V_A$</p>
<p>这里我们可以使用一个小技巧，即将约束改为$V_A\leq V_B$，最大化$V_A$，可以发现这是与原来的约束完全等价的</p>
<p>因为假如有一个解满足$V_A\ne V_B$，那么我们一定可以通过将某个变量$x$调大的方式使得$V_A$变得更大，那么这个解一定不是最优解</p>
<p>因此约束为</p>
<script type="math/tex; mode=display">
\begin{gathered}
V_A\leq V_B\Rightarrow \sum_{i=1}^nx_iA_i\leq \sum_{i=1}^n(1-x_i)B_i\\
\sum_{i=1}^nx_i(A_i+B_i)\leq\sum_{i=1}^nB_i
\end{gathered}</script><p>注意到$\sum B_i\geq 0$，因此不需要运行初始化，直接求解即可</p>
<h2 id="最大流问题"><a href="#最大流问题" class="headerlink" title="最大流问题"></a>最大流问题</h2><p>在原来的最大流问题中，除了源点、汇点外的每个点必须满足流入流量等于流出流量</p>
<p>我们新建一条从汇点连向源点，并且权值为$\infty$的边。</p>
<p>那么最终这条边的流量也就是源点到汇点的流量</p>
<p>用$f(u,v)$表示一条边的实际流量，$c(u,v)$表示一条边的流量，那么可以得到如下的线性规划</p>
<p>最大化</p>
<script type="math/tex; mode=display">
f(t,s)</script><p>满足约束</p>
<script type="math/tex; mode=display">
\begin{gathered}
f(u,v)\leq c(u,v) \quad\quad (u,v)\in E\\
\sum_vf(u,v)=\sum_vf(v,u)\quad \quad u\in V\\
f(u,v)\geq 0\quad\quad (u,v)\in E\cup|(t,s)|
\end{gathered}</script><h2 id="最小费用流问题"><a href="#最小费用流问题" class="headerlink" title="最小费用流问题"></a>最小费用流问题</h2><p>此时就不需要在汇点和源点之间新建边了</p>
<p>我们用$w(u,v)$代表一条边的费用，那么可以得出如下线性规划</p>
<p>最小化</p>
<script type="math/tex; mode=display">
\sum f(u,v)w(u,v)\quad\quad (u,v)\in E</script><p>满足约束</p>
<script type="math/tex; mode=display">
\begin{gathered}
\sum_vf(u,v)=\sum_{v}f(v,u)\quad \quad(u,v)\in E,v\not= s,t\\
f(u,v)\leq c(u,v)\quad\quad (u,v)\in E\\
f(u,v)\geq 0\quad\quad(u,v)\in E
\end{gathered}</script><h1 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h1><p>我们考虑这样一个线性规划</p>
<p>最<strong>小</strong>化</p>
<script type="math/tex; mode=display">
7x_1+x_2+5x_3</script><p>满足约束</p>
<script type="math/tex; mode=display">
\begin{gathered}
x_1-x_2+3x_3\geq 10\\
5x_1+2x_2-x_3\geq 6\\
x_{1,2,3}\geq 0
\end{gathered}</script><p>普通线性规划要求最大化，而这里要求最小化</p>
<p>普通线性规划的约束是小于等于，而这里是大于等于</p>
<p>我们当然可以选择将约束左右两边同时乘以$-1$，但是这样就需要初始化</p>
<p>这里有另一种方法——转对偶问题</p>
<p>由于$x_{1,2,3}\geq 0$，我们知道$7x_1+x_2+5x_3\geq x_1-x_2+3x_3\geq 10$</p>
<p>那么我们就知道了最终答案的一个下界，能不能找到一个更紧的下界呢？</p>
<p>能，比如</p>
<script type="math/tex; mode=display">
7x_1+x_2+5x_3\geq(x_1-x_2+3x_3)+(5x_1+2x_2-x_3)=10+6</script><p>于是我们有了一个奇妙的想法</p>
<p>对于每一个约束我们单独开一个变量，对于第$i$个约束的变量为$y_i$</p>
<p>我们用$y$来表示在最终的下界中，每个约束所乘的系数</p>
<p>比如上面的那个就可以表示为</p>
<script type="math/tex; mode=display">
y_1(x_1-x_2+3x_3)+y_2(5x_1+2x_2-x_3)</script><p>我们需要保证，对于每个变量$x_i$，通过这种方式表示出来的系数不超过估价函数中$x_i$的系数，否则我们就无法保证求出的是下界</p>
<p>同时我们需要最大化下界</p>
<p>那么我们可以得出如下的线性规划</p>
<p>最大化</p>
<script type="math/tex; mode=display">
10y_1+6y_2</script><p>满足约束</p>
<script type="math/tex; mode=display">
\begin{gathered}
y_1+5y_2\leq 7\\
-y_1+2y_2\leq 1\\
3y_1-y_2\leq 5\\
y_{1,2}\geq 0
\end{gathered}</script><p>求解这个线性规划，我们就能得到原估价函数的下界</p>
<p>我们将新得到的线性规划为对偶问题，如果对这个对偶问题再次进行对偶操作，那么我们会得到原问题</p>
<p>一个最大化问题可以对偶成最小化问题，同样一个最小化问题可以对偶成最大化问题</p>
<hr>
<p>下面给出对偶线性规划的定义</p>
<p>对于原式线性规划</p>
<p>最小化</p>
<script type="math/tex; mode=display">
\sum_{i=1}^nc_ix_i</script><p>满足约束</p>
<script type="math/tex; mode=display">
\begin{gathered}
\sum_{j=1}^na_{i,j}x_j\geq b_j\quad\quad i=1,2,\cdots, m\\
x_i\geq 0\quad\quad i=1,2,\cdots,m
\end{gathered}</script><p>它的对偶问题为</p>
<p>最大化</p>
<script type="math/tex; mode=display">
\sum_{i=1}^mb_iy_i</script><p>满足约束</p>
<script type="math/tex; mode=display">
\begin{gathered}
\sum_{j=1}^ma_{ij}y_j\leq c_i\quad\quad i=1,2,\cdots,n\\
y_i\geq 0\quad\quad i=1,2,\cdots n
\end{gathered}</script><p>用矩阵可以表示为</p>
<script type="math/tex; mode=display">
\begin{cases}
最大化\ c^Tx\\
满足约束\ Ax\geq b,x\geq 0
\end{cases}
\longleftrightarrow
\begin{cases}
最大化\ b^Ty\\
满足约束\ A^Ty\leq c,y\geq 0
\end{cases}</script><p>同样，$A^T$表示矩形转置</p>
<h1 id="几个重要定理"><a href="#几个重要定理" class="headerlink" title="几个重要定理"></a>几个重要定理</h1><h2 id="定理1-线性规划弱对偶性"><a href="#定理1-线性规划弱对偶性" class="headerlink" title="定理1. 线性规划弱对偶性"></a>定理1. 线性规划弱对偶性</h2><blockquote>
<p>若$X=(x_1,x_2,\cdots,x_n)$是原问题的一个可行解，$Y=(y_1,y_2,\cdots,y_m)$是对偶问题的一个可行解，那么</p>
<script type="math/tex; mode=display">
\sum_{i=1}^mb_iy_i\leq\sum_{j=1}^nc_jx_j</script></blockquote>
<p><del>其实我觉得挺显然的</del></p>
<p>证明：</p>
<p>由于$Y$是对偶问题的一个可行解，所以</p>
<script type="math/tex; mode=display">
c_j\geq\sum_{i=1}^ma_{ij}y_i</script><p>由于有$x_i\geq 0$，所以</p>
<script type="math/tex; mode=display">
\sum_{j=1}^nc_jx_j\geq\sum_{j=1}^n(\sum_{i=1}^ma_{ij}y_i)x_j</script><p>由于$X$是原问题的一个可行解，所以</p>
<script type="math/tex; mode=display">
b_j\leq\sum_{i=1}^na_{ji}x_i</script><p>由于有$y_i\geq 0$，所以</p>
<script type="math/tex; mode=display">
\sum_{i=1}^m(\sum_{j=1}^na_{ij}x_j)y_i\geq \sum_{i=1}^mb_iy_i</script><p>我们知道</p>
<script type="math/tex; mode=display">
\sum_{j=1}^n(\sum_{i=1}^ma_{ij}y_i)x_j=\sum_{i=1}^m(\sum_{j=1}^na_{ij}x_j)y_i</script><p>所以结论成立</p>
<h2 id="定理2-线性规划对偶性"><a href="#定理2-线性规划对偶性" class="headerlink" title="定理2. 线性规划对偶性"></a>定理2. 线性规划对偶性</h2><blockquote>
<p>若$X^{\times }=(x_1,x_2,\cdots,x_n)$是原问题的最优解，$Y^{\times }=(y_1,y_2,\cdots,y_m)$是对偶问题的最优解，那么</p>
<script type="math/tex; mode=display">
\sum_{i=1}^mb_iy_i=\sum_{j=1}^nc_jx_j</script></blockquote>
<p><strong>引理</strong>： 设$I$是一个下标集合，对于每一个$j\in I$，设$\alpha_j,\beta_j$是实数，并令$x_j$是一个实数变量，设$\gamma$是任意的实数。假设对于变量$x_j$的任意设置，我们有</p>
<script type="math/tex; mode=display">
\sum_{j\in I}\alpha_jx_j=\gamma+\sum_{j\in I}\beta_jx_j</script><p>那么对于任意的$j\in I,\alpha_j=\beta_j$，且$\gamma=0$</p>
<p><strong>证明</strong>：因为上式对于任意的$x_j$都成立，那么我们可以通过代入一些特殊值的方式求出$\gamma,\alpha,\beta$。比如令所有的$x$都为$0$，那么我们可以得到$\gamma=0$，对于$j$，我们令$x_j=1,x_k=0(k\ne j)$，那么我们可以得出$\alpha_j=\beta_j$</p>
<p>注意这里使用的特殊值仍然满足$x_j\geq 0$</p>
<hr>
<p>为了证明这个定理，我们先尝试构造一组对偶问题的解</p>
<p>定义$N$表示非基变量，$B$表示基变量</p>
<p>我们假设原问题在经过松弛过后得到的结果为</p>
<p>最大化</p>
<script type="math/tex; mode=display">
v'+\sum_{j\in N}c'_jx_j</script><p>满足约束</p>
<script type="math/tex; mode=display">
x_i=b'_i-\sum_{j\in N}a'_{ij}x_j\quad\quad i\in B</script><p>我们令</p>
<script type="math/tex; mode=display">
\bar y_i=\begin{cases}
-c'_{n+i}&若(n+i)\in N\\
0 &其它
\end{cases}</script><p>其实就是在原问题求解完毕后，在估价函数中所有非基变量的系数取反</p>
<p>现在我们开始证明</p>
<p>定义$\bar x=(\bar x_1,\bar x_2,\cdots,\bar x_n)$为原问题的最优解，$\bar y$为按照上面的方式取得的对偶问题的解</p>
<p>在最终形态的线性规划中，原问题的估价函数为</p>
<script type="math/tex; mode=display">
z=v'+\sum_{j\in N}c'_j\bar x_j</script><p>对于$j\in B$，我们定义$c’_j=0$</p>
<p>所以</p>
<script type="math/tex; mode=display">
\begin{aligned}
z&=v'+\sum_{j\in N}c'_j\bar x_j+\sum_{j\in B}c'_j\bar x_j\\
&=v'+\sum_{i=1}^{n+m}c'_j\bar x_j
\end{aligned}</script><p>对于$j\in N$，我们知道$\bar x_j=0$，如果我们将此时的解代入原问题求估价函数，那么会得到同样的结果。所以</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{j=1}^nc_j\bar x_j&=v'+\sum_{j=1}^{n+m}c'_j\bar x_j\\
&=v'+\sum_{j\in N}c'_j\bar x_j+\sum_{j\in B}c'_j\bar x_j\\
&=v'+\sum_{j\in N}(c'_j\times 0)+\sum_{j\in B}(0\times \bar x_j)\\
&=v'
\end{aligned}</script><p>现在我们要说明之前构造出来的$\bar y$对于对偶线性规划是可行的，并且其估价函数的值$\sum\limits_{i=1}^mb_iy_i$等于$\sum\limits_{j=1}^n c_j\bar x_j$。我们刚刚证明了原问题（第一个松弛型）与最终问题（最后一个松弛型）代入$\bar x$求值是相等的。更一般地，所有松弛型都是等价的意味着对于任意变量集合$x=(x_1,x_2,\cdots,x_n)$，我们有</p>
<script type="math/tex; mode=display">
\sum_{j=1}^nc_jx_j=v'+\sum_{j=1}^{n+m}c'_jx_j</script><p>因此，对于任意的特定值集合$\bar x=(\bar x_1,\bar x_2,\cdots, \bar x_n)$，有</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{j=1}^nc_j\bar x_j&=v'+\sum_{j=1}^{n+m}c'_j\bar x_j=v'+\sum_{j=1}^nc'_j\bar x_j+\sum_{j=1}^mc'_{j+n}\bar x_{j+n}\\
&=v'+\sum_{j=1}^nc'_j\bar x_j+\sum_{i=1}^m(-\bar y_i)\bar x_{n+i}\\
&=v'+\sum_{j=1}^nc'_j\bar x_j+\sum_{i=1}^m(-\bar y_i)(b_i-\sum_{j=1}^na_{ij}\bar x_j)
\end{aligned}</script><p>注意，原问题的对偶问题和原问题经过变换后的对偶问题是等价的</p>
<p>对于原问题的一次变换，其实就是转轴操作，我们可以认为在对偶问题中，我们同步进行了一次转轴操作，最终得到的仍然是对偶问题</p>
<p>所以这里的$b,a$我们改成$b’,a’$仍然是可以的</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{j=1}^nc_j\bar x_j&=v'+\sum_{j=1}^nc'_j\bar x_j-\sum_{i=1}^mb_i\bar y_i+\sum_{i=1}^m\bar y_i\sum_{j=1}^na_{ij}\bar x_j\\
&=v'+\sum_{j=1}^nc'_j\bar x_j-\sum_{i=1}^mb_i\bar y_i+\sum_{j=1}^n\bar x_j\sum_{i=1}^ma_{ij}\bar y_i\\
&=(v'-\sum_{i=1}^mb_i\bar y_i)+\sum_{j=1}^n(c'_j+\sum_{i=1}^ma_{ij}\bar y_i)\bar x_j
\end{aligned}</script><p>根据引理，我们可以得到</p>
<script type="math/tex; mode=display">
\begin{gathered}
v'-\sum_{i=1}^mb_i\bar y_i=0\\
c'_j+\sum_{i=1}^ma_{ij}\bar y_i=c_j
\end{gathered}</script><p>因此，对偶问题的估价函数值与原问题相等，下面我们来说明$\bar y$为对偶问题的可行解</p>
<p>对于基变量，我们知道$c’=0$</p>
<p>对于非基变量，我们知道$c’\leq 0$，否则我们可以继续进行松弛操作，使得估价函数的值更加优秀</p>
<p>因此$c’_j\leq 0,\sum\limits_{i=1}^ma_{ij}\bar y_i\leq c_j$</p>
<p>满足对偶问题的约束</p>
<p>因此我们证明了定理2，同时给出了构造对偶问题最优解的一种方法</p>
<h2 id="定理3-互松弛定理"><a href="#定理3-互松弛定理" class="headerlink" title="定理3. 互松弛定理"></a>定理3. 互松弛定理</h2><blockquote>
<p>若$X=(x_1,x_2,\cdots,x_n),Y=(y_1,y_2,\cdots,y_n)$分别是原问题及对偶问题的一组可行解，那么$X,Y$都是最优解当且仅当</p>
<script type="math/tex; mode=display">
\begin{gathered}
对于所有的1\leq j\leq n,满足x_j=0或\sum_{i=1}^ma_{ij}y_i=c_j\\
对于所有的1\leq i\leq m,满足y_i=0或\sum_{j=1}^na_{ij}x_j=b_i
\end{gathered}</script></blockquote>
<p>证明：根据定理2证明中的最后一步</p>
<script type="math/tex; mode=display">
c'_j+\sum_{i=1}^ma_{ij}\bar y_i=c_j</script><p>我们分类讨论：</p>
<ol>
<li>$c’_j=0$</li>
</ol>
<p>此时也就是$x_j$的系数为$0$，那么$x_j$随意即可，对最终的结果不会造成影响</p>
<ol>
<li>$c’_j&lt; 0$</li>
</ol>
<p>此时为了要求最终结果最大，必然有$x_j=0$，否则我们可以通过减少$x_j$的值使得结果变大</p>
<p>对于$y$的证明同理</p>
<h1 id="对偶的应用"><a href="#对偶的应用" class="headerlink" title="对偶的应用"></a>对偶的应用</h1><h2 id="偷懒"><a href="#偷懒" class="headerlink" title="偷懒"></a>偷懒</h2><p>给一张$n$个点的带权无向图，边$u,v$的权值为$w_{u,v}$，可以随意增加或者减少一条边的边权，代价为边权的变化量。要求进行操作之后任意两点间直接相连的边的长度不超过两点之间的最短路，求最小代价</p>
<p>$n\leq 10,w\leq 20$</p>
<p>对于每一条边我们开两个变量$t_{u,v},t’_{u,v}$，表示这条边增加了多少/减少了多少</p>
<p>那么对于一条边$u,v$，经过操作之后它的边权为$w_{u,v}+t_{u,v}-t’_{u,v}$，令$d_{u,v}$表示操作之后$u,v$两点间的最短路长度</p>
<p>我们可以得到如下线性规划</p>
<p>最小化</p>
<script type="math/tex; mode=display">
\sum_{(u,v)\in E}t_{u,v}+t'_{u,v}</script><p>满足约束</p>
<script type="math/tex; mode=display">
\begin{gathered}
d_{u,v}\geq w_{u,v}+t_{u,v}-t'_{u,v}\quad\quad (u,v)\in E\\
-d_{u,v}\geq -w_{u,v}-t_{u,v}+t'_{u,v}\quad\quad (u,v)\in E\\
w_{u,i}+t_{u,i}-t'_{u,i}\geq d_{u,v}-d_{u,i}\quad\quad u\ne v,(u,i)\in E\\
\end{gathered}
d,t,t'\geq 0</script><p>注意到之间求解需要初始化，而目标函数中的系数都是正的</p>
<p>所以我们可以将这个线性规划进行对偶，将所有的$b$都变成正数，这样就不需要初始化了</p>
<h2 id="将线性规划转化为半平面交"><a href="#将线性规划转化为半平面交" class="headerlink" title="将线性规划转化为半平面交"></a>将线性规划转化为半平面交</h2><p>给出三个长度为$n$的数组$a_i,b_i,c_i$，每次询问给出两个数$s,t$，求一组非负实数$x_i$，满足</p>
<script type="math/tex; mode=display">
\sum_{i=1}^na_ix_i=s,\sum_{i=1}^nb_ix_i=t</script><p>同时最大化$\sum\limits_{i=1}^nc_ix_i$，对于每组询问输出最大值或无解</p>
<p>$n\leq 10^5,a,b,c,s,t,m\leq 10^4$</p>
<p>注意到每次变化的是限制，而对于目标函数是不变的，这意味着转对偶之后限制是不变的</p>
<p>那么对初始线性规划我们转一个对偶，然后未知数就变成了两个，限制变成了$n$个，并且是固定的</p>
<p>此时目标函数变成了$sy_1+ty_2$</p>
<p>由于初始线性规划的约束是等于，所以转对偶之后对于$y_1,y_2$是否大于$0$没有限制</p>
<p>这里简单说明一下</p>
<p>我们考虑一个这样的线性规划</p>
<p>约束为</p>
<script type="math/tex; mode=display">
\sum_{j=1}^na_{ij}x_i=b_i</script><p>我们可以把它拆成两个</p>
<script type="math/tex; mode=display">
\begin{gathered}
\sum_{j=1}^na_{ij}x_i\geq b_i\\
-\sum_{j=1}^na_{ij}x_i\geq -b_i
\end{gathered}</script><p>现在考虑对偶，我们设第一个限制的未知数为$y_1$，第二个为$y_2$</p>
<p>那么对偶的限制一定是对$y_1-y_2$的限制</p>
<p>现在我们将$y_1,y_2$合成一个变量，虽然有$y_1\geq 0,y_2\geq 0$，但是这个新合成的变量$y_1-y_2$却可以小于$0$</p>
<p>所以此时对偶之后的变量才没有$\geq 0$的限制</p>
<p>将$y_1$看作$x$，将$y_2$看作$y$，我们可以把约束转化为半平面交的形式</p>
<p>所以询问的时候直接在凸壳上二分即可</p>
<h2 id="将线性规划转化为网络流"><a href="#将线性规划转化为网络流" class="headerlink" title="将线性规划转化为网络流"></a>将线性规划转化为网络流</h2><p>给出一个带权的连通无向图，有$n$个点$m$条边，对于每条边，增加$1$的权值需要花费$a_i$，减少$1$的权值需要花费$b_i$，给定一棵生成树，需要通过修改边权使得它成为最小生成树，求最小花费</p>
<p>考虑一条边为非树边的含义是什么</p>
<p>如果一条原图上的边$u,v$不在最小生成树上，那么在生成树上它覆盖的所有边的权值都不能小于它</p>
<p>并且树边一定不会加，非树边一定不会减</p>
<p>写成线性规划的形式就是</p>
<p>最小化</p>
<script type="math/tex; mode=display">
\sum_{i\in T}b_ix_i+\sum_{i\in E-T}a_ix_i</script><p>满足约束</p>
<script type="math/tex; mode=display">
\begin{gathered}
x_i+x_j\geq w_i-w_j\quad\quad i被j覆盖\\
x_i\geq 0
\end{gathered}</script><p>首先来转一个对偶</p>
<p>最大化</p>
<script type="math/tex; mode=display">
\sum_{i\in T,j\in E-T,j覆盖i}(w_i-w_j)y_{ij}</script><p>满足约束</p>
<script type="math/tex; mode=display">
\sum_{j\in E-T,j覆盖i}y_{ij}\leq b_i\quad\quad i\in T\\
\sum_{i\in T,j覆盖i} y_{ij}\leq a_i\quad\quad j\in E-T</script><p>我们将$T$中的边放在左边，$E-T$中的边放在右边，可以看出这是一个最大费用流模型，其中$y_{ij}$就是流量</p>
<p>需要满足对于$T$中的点，每个点的流量不超过$b_i$，对于$E-T$中的点，每个点的流量不超过$a_i$</p>
<p>如果$j$覆盖$i$，那么我们从$i$向$j$连一条容量无限，费用为$w_i-w_j$的边</p>
<p>然后在这张图上跑一遍费用流就可以了</p>
<p>注意这里的费用流不是优先满足最大流，而是优先满足费用最大</p>
<p><code>dinic</code>的时候如果当前费用小于上次更新时的费用就<code>break</code></p>
<hr>
<p>完结撒花</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/25/4-24%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/25/4-24%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/" class="post-title-link" itemprop="url">4.24省选模拟</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-25 14:31:53" itemprop="dateCreated datePublished" datetime="2019-04-25T14:31:53+08:00">2019-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:27:15" itemprop="dateModified" datetime="2020-04-23T09:27:15+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="T1-密文"><a href="#T1-密文" class="headerlink" title="T1 密文"></a>T1 密文</h1><p><img src="https://i.loli.net/2019/04/25/5cc157597b96f.png" alt="1556174666712"></p>
<p><img src="https://i.loli.net/2019/04/25/5cc15778b7aa2.png" alt="1556174705013"></p>
<p>知道密文的每一位，等于知道密文的每一个前缀和，或者任意两个前缀的异或和</p>
<p>而每次操作得到的其实就是两个前缀和的异或和</p>
<p>假设这次我们询问了$a,b$这两个前缀，下次询问了$b,c$这两个前缀，那么我们就知道了$a,c$的异或和是多少</p>
<p>将前缀看作点，如果我们询问了$a,b$这两个前缀，那么我们就用一条权值为询问代价的边将这两个点连接起来</p>
<p>最优的方案一定是连成了一棵生成树，因为所有非树边都是不必要的，任意两个前缀的异或和等于它们在树上路径所经过边的权值的异或和</p>
<p>所以这个题就是最小异或和生成树，共$n+1$个节点，即$n+1$个前缀和</p>
<p>关于最小异或和生成树，可以在<code>trie</code>上分治，每次按照最高位将当前点集分为最高位为0以及最高位为1的两个部分，将这两个部分各自连通，然后用一条权值最小的边连通这两个集合</p>
<p>我们每次枚举小的那个集合中的所有数，然后放到大的那个集合里面暴力查异或最小值即可</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="keyword">int</span> trie[N * <span class="number">31</span>][<span class="number">2</span>], sz[N * <span class="number">31</span>], ncnt = <span class="number">1</span>, dep[N * <span class="number">31</span>]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num[N * <span class="number">31</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> now = <span class="number">1</span>, i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> nxt = v &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!trie[now][nxt]) trie[now][nxt] = ++ncnt, dep[ncnt] = dep[now] - <span class="number">1</span>;</span><br><span class="line">        now = trie[now][nxt], sz[now]++, num[now].push_back(v);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; <span class="number">0</span> || !u) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">int</span> t = x &gt;&gt; dep[u] &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (trie[u][t]) <span class="keyword">return</span> query(trie[u][t], x);</span><br><span class="line">    <span class="keyword">return</span> query(trie[u][t ^ <span class="number">1</span>], x) + (<span class="number">1</span> &lt;&lt; dep[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u || dep[u] &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    divide(trie[u][<span class="number">0</span>]), divide(trie[u][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> v = sz[trie[u][<span class="number">0</span>]] &lt; sz[trie[u][<span class="number">1</span>]] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> t = ~<span class="number">0U</span> &gt;&gt; <span class="number">1</span>, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; sz[trie[u][v]];i++) </span><br><span class="line">        t = min(t, query(trie[u][v ^ <span class="number">1</span>], num[trie[u][v]][i]) + (<span class="number">1</span> &lt;&lt; dep[u])), flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag) ans += t;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"secret.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"secret.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), dep[<span class="number">1</span>] = <span class="number">30</span>, insert(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ls = <span class="number">0</span>, i = <span class="number">1</span>, a;i &lt;= n;i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), ls ^= a, insert(ls);</span><br><span class="line">    divide(<span class="number">1</span>), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-最短路"><a href="#T2-最短路" class="headerlink" title="T2 最短路"></a>T2 最短路</h1><p><img src="https://i.loli.net/2019/04/25/5cc1595fac06a.png" alt="1556175190678"></p>
<p><img src="https://i.loli.net/2019/04/25/5cc1597a52891.png" alt="1556175217309"></p>
<p>数据太水，本来只能拿30分的算法拿了71分</p>
<p>对于这$30\%$的数据做法比较简单，建出最短路<code>DAG</code>，然后<code>DAG</code>上的边边权为<code>inf</code>，将每个点拆成两个点，中间连一条权值为1的边，然后跑一遍起点到终点的最大流就可以得出最少需要让多少个点+1才能使得最短路变长</p>
<p>对于所有数据，我们考虑这样建图</p>
<p>首先二分答案<code>mid</code>，然后建<code>mid + 1</code>层点，第$i$层的点表示路径长度为$i-1$</p>
<p>每一层都有$n$个点$s$以及它们的虚点$t$，将每一层的点向那一层中对应的虚点连边，如果是$1,n$号点就连<code>inf</code>，否则连1</p>
<p>对于第$i$层到第$i+1$层，我们将原图中所有的边连上。比如原图中有一条$u\rightarrow v$的边，那么我们就从这一层的$t_u$向下一层的$s_v$连边，权值为<code>inf</code></p>
<p>为了保证每个点最多只会被加一次，对于每一层的点$s_i$，我们从它向下一层的$t_i$连一条边，权值为<code>inf</code></p>
<p>然后需要加的点数就是第一层中$s_1$到最后一层中$t_n$的最大流，这样才能表示答案<strong>大于</strong><code>mid</code></p>
<p>这样建图的原因是，每在这张图上经过一条原图的边，就会从第$i$层到达第$i+1$层，含义就是路径长度$+1$</p>
<p>如果我们割掉了某个点$s$到$t$的边，那么所有到达$s$的路径都只能经过$s$到下一层的$t$的这条边，那么相对应地，长度就$+1$</p>
<p>而这样建图的话，在不同层中多次割掉同一个点$s\rightarrow t$的边是不优秀的，在最大流中选择割掉的那一条边一定是第一次到达这个点的时刻所对应的那条边</p>
<p>因为无论是否让$u$这个点的权值$+1$，在第$t$时刻到达$u$的路径一定可以在比$t$更晚的时刻到达$u$，所以割掉后面的边是没有好处的，不会出现在最大流中</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;</span><br><span class="line">&#125; e[N * <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt = <span class="number">1</span>, dep[N], cur[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from], w&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to], <span class="number">0</span>&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dep)), dep[s] = <span class="number">0</span>; <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; q.push(s);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">            <span class="keyword">if</span> (e[i].w &amp;&amp; dep[e[i].to] == <span class="number">-1</span>) &#123;</span><br><span class="line">                dep[e[i].to] = dep[u] + <span class="number">1</span>, q.push(e[i].to);</span><br><span class="line">                <span class="keyword">if</span> (e[i].to == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == t || !f) <span class="keyword">return</span> f; <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u], tmp; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].w &amp;&amp; dep[e[i].to] == dep[u] + <span class="number">1</span> &amp;&amp; (tmp = DFS(e[i].to, min(f, e[i].w), t))) &#123;</span><br><span class="line">            res += tmp, f -= tmp, e[i].w -= tmp, e[i ^ <span class="number">1</span>].w += tmp;</span><br><span class="line">            <span class="keyword">if</span> (!f) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (BFS(s, t)) <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span>(head)), res += DFS(s, <span class="number">1e9</span>, t);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N]; <span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ID</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> type, <span class="keyword">int</span> layer)</span> </span>&#123;<span class="keyword">return</span> n * <span class="number">2</span> * layer + n * type + u;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head)), ecnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= mid; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++) &#123;</span><br><span class="line">            adde(ID(j, <span class="number">0</span>, i), ID(j, <span class="number">1</span>, i), j == <span class="number">1</span> ? <span class="number">1e9</span> : <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; mid) adde(ID(j, <span class="number">0</span>, i), ID(j, <span class="number">1</span>, i + <span class="number">1</span>), <span class="number">1e9</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; mid) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[j]) adde(ID(j, <span class="number">1</span>, i), ID(v, <span class="number">0</span>, i + <span class="number">1</span>), <span class="number">1e9</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; mid) adde(ID(n, <span class="number">0</span>, i), ID(n, <span class="number">0</span>, i + <span class="number">1</span>), <span class="number">1e9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Dinic(ID(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), ID(n, <span class="number">0</span>, mid));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"min.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"min.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> m, k; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), a++, b++, G[a].push_back(b), G[b].push_back(a);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">2</span> * n, mid, ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Solve(mid = (l + r) &gt;&gt; <span class="number">1</span>) &lt;= k) ans = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-特技飞行"><a href="#T3-特技飞行" class="headerlink" title="T3 特技飞行"></a>T3 特技飞行</h1><p>题目太长，这里只给出简单的描述</p>
<p>有$n$架飞机，它们的航线对应着起点在$x=x_0$，终点在$x=x_1$的一条线段，它们的水平速度相同</p>
<p>当两架飞机相遇的时候，它们可以选择互换航线，获得$b$的分数；或者不交换，获得$a$的分数，但是要保证到达$x=x_1$的时候这些飞机从上到下的顺序仍然是起飞时的顺序</p>
<p>有$k$个观众，第$i$个观众的位置是$(p_i,q_i)$，观察距离是$r_i$，会查看$|x-p_i|+|y-q_i|\leq r_i$的所有相遇事件</p>
<p>当一个相遇事件被至少一名观众观察到，那么就可以获得$c$的分数</p>
<p>输出最终得分的最小值以及最大值</p>
<p><img src="https://i.loli.net/2019/04/25/5cc15d961a45e.png" alt="1556176268396"></p>
<p>首先可以看出，$c$是强行拼上去的，跟是否选择互换航线没有任何关系</p>
<p>那么我们可以算出$c$对答案的最终贡献是什么</p>
<p>显然对于两条有交点的线段$i,j$，必须满足$y_{i,0}<y_{j,0},y_{i,1}>y_{j,1}$</p>
<p>扫描线一下，同时使用一个<code>set</code>维护就可以求出所有交点</p>
<p>题目中给出的那个限制实际上是曼哈顿距离$\leq r$</p>
<p>那么我们有一个套路就是将坐标$x,y$变换成$x+y,x-y$</p>
<p>那么限制就变成了$p’-r\leq x’\leq p’+r,q’-r\leq y’\leq q’+r$，对应一个矩形范围</p>
<p>将所有转换后的坐标离散化，然后从上到下扫描线，用一个树状数组维护每个点的覆盖次数就可以了</p>
<p>我们再来考虑最终结果的最大/最小值</p>
<p>首先一定有一种方案是每次相遇都交换，这样最终的相对顺序一定是不变的，产生的要么是最大值，要么是最小值</p>
<p>另一种方案就是让交换的次数尽量少</p>
<p>我们考虑如果每次都不交换会发生什么</p>
<p>最终对应的从上到下的顺序是原顺序的一个置换，我们要让最终顺序等于原顺序</p>
<p>我们可以进行的操作是，每次选择两个位置，然后交换它们的排名</p>
<p>这种操作是一定可以成功的，因为我们只需要在这两架飞机相交的时候选择交换位置即可达到交换最终顺序的结果</p>
<p>所以操作等价于：给出一个置换，每次可以交换其中的任意两个数，问最少步数使得置换变成原排列</p>
<p>显然对于每一长度为$l$的环，我们只需要交换$l-1$次，那么最少的交换次数就是$n-$环的个数</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Vector Point</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point (<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    Point <span class="keyword">operator</span> + (<span class="keyword">const</span> Vector &amp;b) &#123;<span class="keyword">return</span> Point(x + b.x, y + b.y);&#125;</span><br><span class="line">    Vector <span class="keyword">operator</span> - (<span class="keyword">const</span> Point &amp;b) &#123;<span class="keyword">return</span> Vector(x - b.x, y - b.y);&#125;</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span> ^ (<span class="keyword">const</span> Vector &amp;b) &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125;</span><br><span class="line">    Vector <span class="keyword">operator</span> * (<span class="keyword">double</span> b) &#123;<span class="keyword">return</span> Vector(x * b, y * b);&#125;</span><br><span class="line">&#125; x[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span>Point a, b;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">Inter</span><span class="params">(Line a, Line b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> t = ((b.b - b.a) ^ (a.a - b.a)) / ((a.b - a.a) ^ (b.b - b.a));</span><br><span class="line">    <span class="keyword">return</span> a.a + (a.b - a.a) * t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> id[N], mark[N], t1[N], t2[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;<span class="keyword">if</span> (!mark[u]) mark[u] = <span class="number">1</span>, dfs(id[u]);&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;int, int&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIT set<span class="meta-string">&lt;P &gt;::iterator</span></span></span><br><span class="line"><span class="built_in">set</span>&lt;P &gt; s;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> t2[i] &lt; t2[j];&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> y; <span class="keyword">int</span> x1, x2, op;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Query &amp;b) <span class="keyword">const</span> &#123;<span class="keyword">return</span> y &lt; b.y;&#125;</span><br><span class="line">&#125; q[N];</span><br><span class="line"><span class="keyword">int</span> tree[N * <span class="number">2</span>], top;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;x;x -= x &amp; -x) tree[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;x &lt;= top;x += x &amp; -x) res += tree[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> zjk[N * <span class="number">5</span>]; <span class="keyword">int</span> cnt, watchx[N], watchy[N], r[N], qcnt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(Point i, Point j)</span> </span>&#123;<span class="keyword">return</span> i.x - i.y &lt; j.x - j.y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"aerobatics.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"aerobatics.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n, a, b, c, X1, X2, tot = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d"</span>, &amp;n, &amp;a, &amp;b, &amp;c, &amp;X1, &amp;X2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t1[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t2[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        SIT it = s.lower_bound(P(t2[i], i));</span><br><span class="line">        <span class="keyword">if</span> (it != s.end()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (SIT it2 = it;it2 != s.end();it2++) &#123;</span><br><span class="line">                Line a = (Line)&#123;Point(X1, t1[it2-&gt;second]), Point(X2, t2[it2-&gt;second])&#125;, </span><br><span class="line">                    b = (Line)&#123;Point(X1, t1[i]), Point(X2, t2[i])&#125;;</span><br><span class="line">                x[++tot] = Inter(a, b);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        s.insert(P(t2[i], i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) id[i] = i;</span><br><span class="line">    sort(id + <span class="number">1</span>, id + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span> (!mark[i]) dfs(i), cnt++;</span><br><span class="line">    <span class="keyword">int</span> s1 = tot * a, s2 = (tot - n + cnt) * b + (n - cnt) * a;</span><br><span class="line">    <span class="keyword">if</span> (s1 &gt; s2) swap(s1, s2);</span><br><span class="line">    <span class="keyword">int</span> k; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tot;i++) zjk[++cnt] = x[i].x + x[i].y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;watchx[i], &amp;watchy[i], &amp;r[i]), zjk[++cnt] = watchx[i] + watchy[i] - r[i], zjk[++cnt] = watchx[i] + watchy[i] + r[i];</span><br><span class="line">    sort(zjk + <span class="number">1</span>, zjk + cnt + <span class="number">1</span>), cnt = unique(zjk + <span class="number">1</span>, zjk + cnt + <span class="number">1</span>) - zjk - <span class="number">1</span>, top = cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = lower_bound(zjk + <span class="number">1</span>, zjk + cnt + <span class="number">1</span>, watchx[i] + watchy[i] - r[i]) - zjk, </span><br><span class="line">            b = lower_bound(zjk + <span class="number">1</span>, zjk + cnt + <span class="number">1</span>, watchx[i] + watchy[i] + r[i]) - zjk;</span><br><span class="line">        q[++qcnt] = (Query)&#123;watchx[i] - watchy[i] - r[i], a, b, <span class="number">0</span>&#125;, q[++qcnt] = (Query)&#123;watchx[i] - watchy[i] + r[i] + <span class="number">1e-5</span>, a, b, <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(x + <span class="number">1</span>, x + tot + <span class="number">1</span>, cmp2), sort(q + <span class="number">1</span>, q + qcnt + <span class="number">1</span>); <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, cur = <span class="number">1</span>;i &lt;= qcnt;i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt;= tot &amp;&amp; x[cur].x - x[cur].y &lt; q[i].y) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = lower_bound(zjk + <span class="number">1</span>, zjk + cnt + <span class="number">1</span>, x[cur].x + x[cur].y) - zjk;</span><br><span class="line">            <span class="keyword">if</span> (query(a) &gt;= <span class="number">1</span>) res++;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q[i].op) update(q[i].x2, <span class="number">-1</span>), update(q[i].x1 - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> update(q[i].x2, <span class="number">1</span>), update(q[i].x1 - <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, s1 + c * res, s2 + c * res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T4-吃"><a href="#T4-吃" class="headerlink" title="T4 吃"></a>T4 吃</h1><p><img src="https://i.loli.net/2019/04/25/5cc160fe35890.png" alt="1556177141042"></p>
<p><img src="https://i.loli.net/2019/04/25/5cc1611bcf07f.png" alt="1556177171716"></p>
<p>我们考虑这样统计答案：记$E(u,v)$表示当$u$被删除的时候，$v$仍与$u$连通的概率</p>
<p>那么答案就是</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\sum_{j=1}^nE(i,j)</script><p>很显然，给出的图是一棵基环树</p>
<p>我们考虑这两种点对：</p>
<ul>
<li>点$u,v$都在同一棵树上</li>
</ul>
<p>很显然此时的$E(u,v)=\frac{1}{dis(u,v)}$，因为需要保证$u$是$u,v$这条路径上第一被删除的点</p>
<p>可以使用点分治+<code>FFT</code>统计每种$dis$的方案数，最后再计算这一类点对的答案</p>
<ul>
<li>点$u,v$在不同的树上</li>
</ul>
<p>我们假设从$u$到$v$，必须经过的路径长度为$c$</p>
<p>在环上，$u$的根节点到$v$的根节点显然有两条路径，我们记它们的长度分别为$x,y$</p>
<p>那么显然，如果在$u$被删除的时候$u,v$仍然连通，那么要么是$c+x$这条路径没有被删除，概率为$\frac{1}{c+x}$，要么是$c+y$这条路径没有被删除，概率为$\frac{1}{c+y}$</p>
<p>注意此时我们重复统计了这两条路径都没有被删除的概率，为$\frac{1}{c+x+y}$</p>
<p>所以此时有</p>
<script type="math/tex; mode=display">
E(u,v)=\frac{1}{c+x}+\frac{1}{c+y}-\frac{1}{c+x+y}</script><p>我们考虑如何计算</p>
<p>首先随便断开环上的一条边，将环变成一条链，然后在链上分治</p>
<p>设$x$是经过链的路径，$y$是经过被破坏边的路径</p>
<p>我们选择当前区间的中点，显然从中点或者中点左边到中点右边的$x$路径一定会经过这个中点</p>
<p>那么我们可以利用这个性质将$x$分成两半，假设两个根节点分别为$u,v$</p>
<p>分成的这两半即为$u$到中点的路径，减去$v$到中点的路径</p>
<p>与之前相似，我们同样可以计算每一种$c+x$的方案数，即中点及左边多项式的和，乘上中点右边多项式的和，再加上两边分治的结果</p>
<p>$c+y$与之类似，注意$c+x+y$是不用分治的，因为$x+y$就是环长</p>
<p>代码就咕了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/23/TopTree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/23/TopTree/" class="post-title-link" itemprop="url">TopTree</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-23 08:21:54" itemprop="dateCreated datePublished" datetime="2019-04-23T08:21:54+08:00">2019-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:11:35" itemprop="dateModified" datetime="2020-04-23T09:11:35+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><code>TopTree</code>可以说是<code>LCT</code>的扩展，<code>LCT</code>支持链上的修改与查询，而<code>TopTree</code>可以支持链与子树的修改与查询</p>
<p><code>TopTree</code>的思想与<code>LCT</code>及其相似，都是将树进行轻重链剖分。但是与<code>LCT</code>不同的是，<code>TopTree</code>会单独维护某个节点的每个虚子树，而非简单地维护虚子树对当前点的贡献</p>
<p><code>TopTree</code>的时间复杂度为每次操作$O(\log n)$，但是常数巨大无比，为$97$</p>
<p>做好码<code>7168+b</code>的准备</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>让我们先从一道<del>神仙</del>题开始</p>
<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3153" target="_blank" rel="noopener">BZOJ3153</a></p>
<p>题意：有一棵树，每个点有一个权值，需要支持12个操作</p>
<ul>
<li>换根</li>
<li>路径加/路径覆盖</li>
<li>子树加/子树覆盖</li>
<li>查询路径的和/最大值/最小值</li>
<li>查询子树的和/最大值/最小值</li>
<li>换父亲</li>
</ul>
<h1 id="虚点Splay"><a href="#虚点Splay" class="headerlink" title="虚点Splay"></a>虚点<code>Splay</code></h1><p>对于一个点$u$，在<code>LCT</code>上的<code>splay</code>中我们维护了它的两个儿子</p>
<p>左儿子代表重链上比它高的节点，右儿子代表重链上比它低的节点</p>
<p>在<code>TopTree</code>中，每个点我们还要额外维护一个<code>splay</code>，这个<code>splay</code>上挂的点是以虚边的形式与$u$相连的点</p>
<p>举个例子</p>
<p><img src="https://i.loli.net/2019/04/23/5cbe6488ac1fd.png" alt="1555981442131"></p>
<p>图中的实线代表重边，虚线代表轻边</p>
<p>注意$\{1,4,7\}$单独是一棵<code>splay</code>,即$1$的虚儿子构成的<code>splay</code></p>
<p>我们称在原树中出现的点为<strong>实点</strong>，在原树中未出现的点为<strong>虚点</strong></p>
<p>那么在由某个点虚儿子构成的<code>splay</code>中，每一个实点都是<strong>叶子节点</strong>，除根节点外，每个非叶子节点都是<strong>虚点</strong></p>
<p>另一个例子</p>
<p><img src="https://i.loli.net/2019/04/23/5cbe66f56612a.png" alt="1555982055658"></p>
<p>注意到根节点有$4$个虚子树，所以必须新建两个虚点来维护这些虚子树，图中的橙色节点就是虚点，图中的虚边即为虚子树<code>splay</code></p>
<p>那么每个点我们维护$4$个儿子<code>ch[0 - 3][u]</code>，前两个儿子表示正常<code>LCT</code>中的儿子，即重链<code>splay</code>的左右儿子；后两个儿子表示虚子树中的两个儿子</p>
<p>显然虚点是没有前两个儿子的</p>
<h1 id="新的Rotate-Splay"><a href="#新的Rotate-Splay" class="headerlink" title="新的Rotate, Splay"></a>新的<code>Rotate, Splay</code></h1><p>如果一个虚点的<code>splay</code>转到实点里面去了，显然是不行的</p>
<p>所以对于虚点、实点我们需要单独<code>rotate, splay</code></p>
<p>注意<code>splay</code>时无论当前点是否为根节点，我们都要<code>pushup</code>一次</p>
<p>所以<code>rotate</code>的时候改一改，再在<code>splay</code>的最后加上一次<code>pushup</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> son)</span> </span>&#123;<span class="keyword">if</span> (u) fa[u] = f; ch[son][f] = u;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = fa[u], tmp = (ch[type + <span class="number">1</span>][f] == u) + type, ff = fa[f];</span><br><span class="line">    <span class="keyword">if</span> (ff) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) <span class="keyword">if</span> (ch[i][ff] == f) ch[i][ff] = u;</span><br><span class="line">    fa[u] = ff, Connect(ch[tmp ^ <span class="number">1</span>][u], f, tmp), Connect(f, u, tmp ^ <span class="number">1</span>), Pushup(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>type = 0</code>代表是原树，<code>type = 2</code>代表是虚树</p>
<p>其实跟原来的<code>rotate</code>差不多</p>
<p><code>splay</code>同理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Splay</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = u, top = <span class="number">0</span>; st[++top] = now;</span><br><span class="line">    <span class="keyword">while</span> (!Isroot(now, type)) st[++top] = now = fa[now];</span><br><span class="line">    <span class="keyword">while</span> (top) Pushdown(st[top--]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> f;!Isroot(u, type);Rotate(u, type)) </span><br><span class="line">        <span class="keyword">if</span> (!Isroot(f = fa[u], type))</span><br><span class="line">            Rotate((ch[type][f] == u) ^ (ch[type][fa[f]] == f) ? u : f, type); </span><br><span class="line">    Pushup(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="新的Pushdown"><a href="#新的Pushdown" class="headerlink" title="新的Pushdown"></a>新的<code>Pushdown</code></h1><p>在树上，我们需要维护两个标记</p>
<p>第一个是给重链打上的标记</p>
<p>第二个是给重链<code>splay</code>中它的后代的所有虚子树打上的标记（不包括重链节点）</p>
<p>显然虚点只有第二种标记</p>
<p>我们分以下几种情况讨论：</p>
<ul>
<li>当前点是实点，下放到重链上的左右儿子</li>
</ul>
<p>首先标记应该下传，同时给这两个儿子的点权打上第一个标记</p>
<p>注意第二个标记不会对这两个点权产生影响，因为它是给虚子树打的</p>
<ul>
<li>当前点是实点，下放到虚点</li>
</ul>
<p>第一个标记没有必要下方，只需要下方第二种标记</p>
<ul>
<li>当前点是实点，下放到一个非重链实点</li>
</ul>
<p>此时除了修改点权，还应将这个儿子的点权打上这两种标记</p>
<p>因为此时这个儿子是当前点的一个虚儿子</p>
<ul>
<li>当前点是虚点，下放到一个实点</li>
</ul>
<p>同上</p>
<ul>
<li>当前点是虚点，下放到虚点</li>
</ul>
<p>直接下传标记即可</p>
<p>注意翻转标记不应该传入虚子树的<code>splay</code>中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushdown</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (rev[u]) Rev(ch[<span class="number">0</span>][u]), Rev(ch[<span class="number">1</span>][u]), rev[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!in[u] &amp;&amp; tag[u].marked()) </span><br><span class="line">        Tag_Line(ch[<span class="number">0</span>][u], tag[u]), Tag_Line(ch[<span class="number">1</span>][u], tag[u]), tag[u] = Tag();</span><br><span class="line">    <span class="keyword">if</span> (T_tag[u].marked()) &#123;</span><br><span class="line">        Tag_Tree(ch[<span class="number">0</span>][u], T_tag[u], <span class="number">0</span>), Tag_Tree(ch[<span class="number">1</span>][u], T_tag[u], <span class="number">0</span>);</span><br><span class="line">        Tag_Tree(ch[<span class="number">2</span>][u], T_tag[u], <span class="number">1</span>), Tag_Tree(ch[<span class="number">3</span>][u], T_tag[u], <span class="number">1</span>), T_tag[u] = Tag();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>marked</code>代表是否有下传的必要</p>
<p><code>tag</code>是给重链打的标记</p>
<p><code>T_...</code>代表虚子树的信息或者标记</p>
<p><code>Tag_line</code>与<code>Tag_Tree</code>，分别是给链/树打标记</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Tag_Line</span><span class="params">(<span class="keyword">int</span> u, Tag t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>;</span><br><span class="line">    sum[u] += t, A_sum[u] = sum[u] + T_sum[u], val[u] = Get(val[u], t), tag[u] += t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Tag_Tree</span><span class="params">(<span class="keyword">int</span> u, Tag t, <span class="keyword">int</span> type)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>;</span><br><span class="line">    T_sum[u] += t, T_tag[u] += t;</span><br><span class="line">    <span class="keyword">if</span> (!in[u] &amp;&amp; type) Tag_Line(u, t); <span class="keyword">else</span> A_sum[u] = sum[u] + T_sum[u];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>A_sum</code>代表全部信息</p>
<p><code>Get(x, t)</code>代表$x$在标记$t$的作用下的值</p>
<p><code>in</code>代表是否为虚点</p>
<h1 id="新的Pushup"><a href="#新的Pushup" class="headerlink" title="新的Pushup"></a>新的<code>Pushup</code></h1><p>同样，我们分虚子树信息/重链信息以及全部信息来统计答案</p>
<p>分情况讨论</p>
<ul>
<li>当前点是虚点，子树也是虚点</li>
</ul>
<p>当前点虚子树信息为子树虚子树信息的和，此时虚子树信息就是全部信息</p>
<ul>
<li>当前点是虚点，子树是实点</li>
</ul>
<p>当前点虚子树信息为子树全部信息</p>
<ul>
<li>当前点是实点，子树是虚点</li>
</ul>
<p>只更新子树信息与子树全部信息</p>
<ul>
<li>当前点是实点，子树是重链上的点</li>
</ul>
<p>只更新重链信息与子树全部信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushup</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    T_sum[u] = Data();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>;i++) <span class="keyword">if</span> (ch[i][u]) T_sum[u] += T_sum[ch[i][u]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">3</span>;i++) <span class="keyword">if</span> (ch[i][u]) T_sum[u] += A_sum[ch[i][u]];</span><br><span class="line">    <span class="keyword">if</span> (in[u]) sum[u] = Data(), A_sum[u] = T_sum[u];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        sum[u] = Data(val[u]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>;i++) <span class="keyword">if</span> (ch[i][u]) sum[u] += sum[ch[i][u]];</span><br><span class="line">        A_sum[u] = sum[u] + T_sum[u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="新的操作Add"><a href="#新的操作Add" class="headerlink" title="新的操作Add"></a>新的操作<code>Add</code></h1><p>$Add(x,y)$表示从$x$向$y$连一条虚边</p>
<p>方式其实很暴躁，就是一直跳左儿子，最后再新建一个虚点$v$，将当前点挂在$v$上面</p>
<p><img src="https://i.loli.net/2019/04/23/5cbef3dd1b777.png" alt="1556018128092"></p>
<p>图中黄色节点代表$v$</p>
<p>注意在跳左儿子的时候要顺便<code>pushdown</code></p>
<p>最后别忘了将新添加的点旋转到<code>splay</code>的根</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (!y) <span class="keyword">return</span>; Pushdown(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">3</span>;i++) <span class="keyword">if</span> (!ch[i][x]) <span class="keyword">return</span> <span class="keyword">void</span>(Connect(y, x, i));</span><br><span class="line">    <span class="keyword">while</span> (ch[<span class="number">2</span>][x] &amp;&amp; in[ch[<span class="number">2</span>][x]]) x = ch[<span class="number">2</span>][x], Pushdown(x);</span><br><span class="line">    <span class="keyword">int</span> u = Create();</span><br><span class="line">    Connect(ch[<span class="number">2</span>][x], u, <span class="number">2</span>), Connect(y, u, <span class="number">3</span>), Connect(u, x, <span class="number">2</span>), Splay(u, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="新的操作Del"><a href="#新的操作Del" class="headerlink" title="新的操作Del"></a>新的操作<code>Del</code></h1><p>$Del(u)$表示删除$u$与其父亲相连的虚边</p>
<p>注意到每次$Add$操作都会新建一个点，那么$Del$操作我们也只需要删除一个点就可以保证空间为$O(n)$</p>
<p>如果$u$与其父亲直接相连，那么断开这条虚边就好了</p>
<p>否则我们找到$u$的虚点父亲$f$，先将$f$及它的祖先像<code>splay</code>一样<code>pushdown</code>，然后尝试删除$f$</p>
<p>注意此时也要<code>splay</code>来保证复杂度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Child</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) <span class="keyword">if</span> (ch[i][fa[u]] == u) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Del</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>; Splay(u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fa[u]) <span class="keyword">return</span>; <span class="keyword">int</span> f = fa[u];</span><br><span class="line">    <span class="keyword">if</span> (in[f]) &#123;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>, now = f, ff = fa[f]; st[++top] = now;</span><br><span class="line">        <span class="keyword">while</span> (!Isroot(now, <span class="number">2</span>)) st[++top] = now = fa[now];</span><br><span class="line">        <span class="keyword">while</span> (top) Pushdown(st[top--]);</span><br><span class="line">        <span class="keyword">if</span> (ff) &#123;<span class="keyword">int</span> other = ch[Child(u) ^ <span class="number">1</span>][f]; Pushdown(other), Connect(other, ff, Child(f)), Splay(ff, <span class="number">2</span>);&#125;</span><br><span class="line">        rub[++rcnt] = f;</span><br><span class="line">    &#125; <span class="keyword">else</span> ch[Child(u)][f] = <span class="number">0</span>, Splay(f, <span class="number">0</span>);</span><br><span class="line">    fa[u] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="新的操作Father"><a href="#新的操作Father" class="headerlink" title="新的操作Father"></a>新的操作<code>Father</code></h1><p>$Father(u)$表示找到$u$的以虚边相连的父亲</p>
<p>实现很简单，如果$u$的父亲节点就是原树中的父亲，那么直接返回，否则将这个虚点<code>splay</code>到根，再返回它的父亲</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Father</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Splay(u, <span class="number">0</span>); <span class="keyword">if</span> (!fa[u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!in[fa[u]]) <span class="keyword">return</span> fa[u];</span><br><span class="line">    <span class="keyword">int</span> f = fa[u]; Splay(f, <span class="number">2</span>); <span class="keyword">return</span> fa[f];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="新的Access以及LCA"><a href="#新的Access以及LCA" class="headerlink" title="新的Access以及LCA"></a>新的<code>Access</code>以及<code>LCA</code></h1><p>其实跟<code>LCT</code>的差不多，就是将连边/断边改成<code>Del, Add</code>，将跳父亲改成<code>Father</code></p>
<p>这里提一下如何求两个点的<code>LCA</code>，假设为$u,v$</p>
<p>首先将$u$ $Access$一下，此时$u$到根节点的链已经被打通，那么$v$到根节点的路径一定分为若干段实链与虚边，最后一段实链的最深的那个点就是<code>LCA</code></p>
<p><img src="https://i.loli.net/2019/04/23/5cbef7a2519bf.png" alt="1556019086677"></p>
<p>那么在$Access$的时候，直接返回结束时的<code>ls</code>就好了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ls = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;u;u = Father(ls = u)) </span><br><span class="line">        Splay(u, <span class="number">0</span>), Del(ls), Add(u, ch[<span class="number">1</span>][u]), Connect(ls, u, <span class="number">1</span>), Pushup(u);</span><br><span class="line">    <span class="keyword">return</span> ls;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;Access(x); <span class="keyword">return</span> Access(y);&#125;</span><br></pre></td></tr></table></figure>
<h1 id="一些例行操作"><a href="#一些例行操作" class="headerlink" title="一些例行操作"></a>一些例行操作</h1><p>由于这一部分的代码和<code>LCT</code>几乎是一样的，所以直接贴上来</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Findroot</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    Access(u), Splay(u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (ch[<span class="number">0</span>][u]) u = ch[<span class="number">0</span>][u];</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Makeroot</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;Access(u), Splay(u, <span class="number">0</span>), Rev(u);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;Makeroot(x), Add(y, x), Access(x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Cut</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;Access(u), Splay(u, <span class="number">0</span>), ch[<span class="number">0</span>][u] = fa[ch[<span class="number">0</span>][u]] = <span class="number">0</span>, Pushup(u);&#125; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;Makeroot(x), Access(y), Splay(y, <span class="number">0</span>);&#125;</span><br></pre></td></tr></table></figure>
<h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tag</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> k, b;</span><br><span class="line">    Tag(<span class="keyword">int</span> k = <span class="number">1</span>, <span class="keyword">int</span> b = <span class="number">0</span>) : k(k), b(b) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">marked</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> k != <span class="number">1</span> || b;&#125; </span><br><span class="line">    <span class="keyword">inline</span> Tag <span class="keyword">operator</span> + (<span class="keyword">const</span> Tag &amp;x) &#123;<span class="keyword">return</span> Tag(k * x.k, b * x.k + x.b);&#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> += (<span class="keyword">const</span> Tag &amp;x) &#123;*<span class="keyword">this</span> = *<span class="keyword">this</span> + x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">2147483647</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> x, Tag y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y.k + y.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> sum, mn, mx, sz;</span><br><span class="line">    Data() &#123;sum = sz = <span class="number">0</span>, mn = INF, mx = -INF;&#125;</span><br><span class="line">    Data(<span class="keyword">int</span> x) &#123;sum = mn = mx = x, sz = <span class="number">1</span>;&#125;</span><br><span class="line">    Data(<span class="keyword">int</span> sum, <span class="keyword">int</span> mn, <span class="keyword">int</span> mx, <span class="keyword">int</span> sz) : sum(sum), mn(mn), mx(mx), sz(sz) &#123;&#125;</span><br><span class="line">    <span class="keyword">inline</span> Data <span class="keyword">operator</span> + (<span class="keyword">const</span> Data &amp;x) &#123;<span class="keyword">return</span> Data(sum + x.sum, min(mn, x.mn), max(mx, x.mx), sz + x.sz);&#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> += (<span class="keyword">const</span> Data &amp;x) &#123;*<span class="keyword">this</span> = *<span class="keyword">this</span> + x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> Data <span class="keyword">operator</span> + (<span class="keyword">const</span> Data &amp;a, <span class="keyword">const</span> Tag &amp;b) &#123;<span class="keyword">return</span> a.sz ? Data(a.sum * b.k + a.sz * b.b, Get(a.mn, b), Get(a.mx, b), a.sz) : a;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> += (Data &amp;a, <span class="keyword">const</span> Tag &amp;b) &#123;a = a + b;&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="keyword">int</span> fa[N], ch[<span class="number">4</span>][N], ncnt, rt, rev[N], in[N], val[N], rub[N], rcnt;</span><br><span class="line">Data sum[N], T_sum[N], A_sum[N]; Tag tag[N], T_tag[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Isroot</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> type)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (type) <span class="keyword">return</span> !fa[u] || !in[fa[u]] || !in[u] || !u;</span><br><span class="line">    <span class="keyword">return</span> (ch[<span class="number">0</span>][fa[u]] != u &amp;&amp; ch[<span class="number">1</span>][fa[u]] != u) || !fa[u] || in[fa[u]] || in[u] || !u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rev</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>;</span><br><span class="line">    swap(ch[<span class="number">0</span>][u], ch[<span class="number">1</span>][u]), rev[u] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Tag_Line</span><span class="params">(<span class="keyword">int</span> u, Tag t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>;</span><br><span class="line">    sum[u] += t, A_sum[u] = sum[u] + T_sum[u], val[u] = Get(val[u], t), tag[u] += t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Tag_Tree</span><span class="params">(<span class="keyword">int</span> u, Tag t, <span class="keyword">int</span> type)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>;</span><br><span class="line">    T_sum[u] += t, T_tag[u] += t;</span><br><span class="line">    <span class="keyword">if</span> (!in[u] &amp;&amp; type) Tag_Line(u, t); <span class="keyword">else</span> A_sum[u] = sum[u] + T_sum[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushdown</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (rev[u]) Rev(ch[<span class="number">0</span>][u]), Rev(ch[<span class="number">1</span>][u]), rev[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!in[u] &amp;&amp; tag[u].marked()) </span><br><span class="line">        Tag_Line(ch[<span class="number">0</span>][u], tag[u]), Tag_Line(ch[<span class="number">1</span>][u], tag[u]), tag[u] = Tag();</span><br><span class="line">    <span class="keyword">if</span> (T_tag[u].marked()) &#123;</span><br><span class="line">        Tag_Tree(ch[<span class="number">0</span>][u], T_tag[u], <span class="number">0</span>), Tag_Tree(ch[<span class="number">1</span>][u], T_tag[u], <span class="number">0</span>);</span><br><span class="line">        Tag_Tree(ch[<span class="number">2</span>][u], T_tag[u], <span class="number">1</span>), Tag_Tree(ch[<span class="number">3</span>][u], T_tag[u], <span class="number">1</span>), T_tag[u] = Tag();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushup</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    T_sum[u] = Data();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>;i++) <span class="keyword">if</span> (ch[i][u]) T_sum[u] += T_sum[ch[i][u]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">3</span>;i++) <span class="keyword">if</span> (ch[i][u]) T_sum[u] += A_sum[ch[i][u]];</span><br><span class="line">    <span class="keyword">if</span> (in[u]) sum[u] = Data(), A_sum[u] = T_sum[u];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        sum[u] = Data(val[u]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>;i++) <span class="keyword">if</span> (ch[i][u]) sum[u] += sum[ch[i][u]];</span><br><span class="line">        A_sum[u] = sum[u] + T_sum[u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> son)</span> </span>&#123;<span class="keyword">if</span> (u) fa[u] = f; ch[son][f] = u;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = fa[u], tmp = (ch[type + <span class="number">1</span>][f] == u) + type, ff = fa[f];</span><br><span class="line">    <span class="keyword">if</span> (ff) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) <span class="keyword">if</span> (ch[i][ff] == f) ch[i][ff] = u;</span><br><span class="line">    fa[u] = ff, Connect(ch[tmp ^ <span class="number">1</span>][u], f, tmp), Connect(f, u, tmp ^ <span class="number">1</span>), Pushup(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Splay</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = u, top = <span class="number">0</span>; st[++top] = now;</span><br><span class="line">    <span class="keyword">while</span> (!Isroot(now, type)) st[++top] = now = fa[now];</span><br><span class="line">    <span class="keyword">while</span> (top) Pushdown(st[top--]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> f;!Isroot(u, type);Rotate(u, type)) </span><br><span class="line">        <span class="keyword">if</span> (!Isroot(f = fa[u], type))</span><br><span class="line">            Rotate((ch[type][f] == u) ^ (ch[type][fa[f]] == f) ? u : f, type); </span><br><span class="line">    Pushup(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = rcnt ? rub[rcnt--] : ++ncnt;</span><br><span class="line">    ch[<span class="number">2</span>][u] = ch[<span class="number">3</span>][u] = <span class="number">0</span>, in[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Child</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) <span class="keyword">if</span> (ch[i][fa[u]] == u) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (!y) <span class="keyword">return</span>; Pushdown(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">3</span>;i++) <span class="keyword">if</span> (!ch[i][x]) <span class="keyword">return</span> <span class="keyword">void</span>(Connect(y, x, i));</span><br><span class="line">    <span class="keyword">while</span> (ch[<span class="number">2</span>][x] &amp;&amp; in[ch[<span class="number">2</span>][x]]) x = ch[<span class="number">2</span>][x], Pushdown(x);</span><br><span class="line">    <span class="keyword">int</span> u = Create();</span><br><span class="line">    Connect(ch[<span class="number">2</span>][x], u, <span class="number">2</span>), Connect(y, u, <span class="number">3</span>), Connect(u, x, <span class="number">2</span>), Splay(u, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Del</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>; Splay(u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fa[u]) <span class="keyword">return</span>; <span class="keyword">int</span> f = fa[u];</span><br><span class="line">    <span class="keyword">if</span> (in[f]) &#123;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>, now = f, ff = fa[f]; st[++top] = now;</span><br><span class="line">        <span class="keyword">while</span> (!Isroot(now, <span class="number">2</span>)) st[++top] = now = fa[now];</span><br><span class="line">        <span class="keyword">while</span> (top) Pushdown(st[top--]);</span><br><span class="line">        <span class="keyword">if</span> (ff) &#123;<span class="keyword">int</span> other = ch[Child(u) ^ <span class="number">1</span>][f]; Pushdown(other), Connect(other, ff, Child(f)), Splay(ff, <span class="number">2</span>);&#125;</span><br><span class="line">        rub[++rcnt] = f;</span><br><span class="line">    &#125; <span class="keyword">else</span> ch[Child(u)][f] = <span class="number">0</span>, Splay(f, <span class="number">0</span>);</span><br><span class="line">    fa[u] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Father</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Splay(u, <span class="number">0</span>); <span class="keyword">if</span> (!fa[u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!in[fa[u]]) <span class="keyword">return</span> fa[u];</span><br><span class="line">    <span class="keyword">int</span> f = fa[u]; Splay(f, <span class="number">2</span>); <span class="keyword">return</span> fa[f];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ls = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;u;u = Father(ls = u)) </span><br><span class="line">        Splay(u, <span class="number">0</span>), Del(ls), Add(u, ch[<span class="number">1</span>][u]), Connect(ls, u, <span class="number">1</span>), Pushup(u);</span><br><span class="line">    <span class="keyword">return</span> ls;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;Access(x); <span class="keyword">return</span> Access(y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Findroot</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    Access(u), Splay(u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (ch[<span class="number">0</span>][u]) u = ch[<span class="number">0</span>][u];</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Makeroot</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;Access(u), Splay(u, <span class="number">0</span>), Rev(u);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;Makeroot(x), Add(y, x), Access(x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Cut</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;Access(u), Splay(u, <span class="number">0</span>), ch[<span class="number">0</span>][u] = fa[ch[<span class="number">0</span>][u]] = <span class="number">0</span>, Pushup(u);&#125; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;Makeroot(x), Access(y), Splay(y, <span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mark_Line</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, Tag t)</span> </span>&#123;Split(x, y), Tag_Line(y, t);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Data <span class="title">Ask_Line</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;Split(x, y); <span class="keyword">return</span> sum[y];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mark_Tree</span><span class="params">(<span class="keyword">int</span> u, Tag t)</span> </span>&#123;</span><br><span class="line">    Access(u), Splay(u, <span class="number">0</span>), val[u] = Get(val[u], t);</span><br><span class="line">    Tag_Tree(ch[<span class="number">2</span>][u], t, <span class="number">1</span>), Tag_Tree(ch[<span class="number">3</span>][u], t, <span class="number">1</span>), Pushup(u), Splay(u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Data <span class="title">Ask_Tree</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    Access(u), Splay(u, <span class="number">0</span>); <span class="function">Data <span class="title">res</span><span class="params">(val[u])</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">3</span>;i++) <span class="keyword">if</span> (ch[i][u]) res += A_sum[ch[i][u]];</span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ed[<span class="number">2</span>][N];</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar(); </span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, q, rt; read(n), read(q), ncnt = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) read(ed[<span class="number">0</span>][i]), read(ed[<span class="number">1</span>][i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) read(val[i]), Pushup(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) Link(ed[<span class="number">0</span>][i], ed[<span class="number">1</span>][i]);</span><br><span class="line">    read(rt), Makeroot(rt);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, x, y, z; read(op);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) read(rt), Makeroot(rt);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">9</span>) &#123;</span><br><span class="line">            read(x), read(y);</span><br><span class="line">            <span class="keyword">if</span> (LCA(x, y) != x) Cut(x), Link(y, x), Makeroot(rt);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">0</span>) read(x), read(y), Mark_Tree(x, Tag(<span class="number">0</span>, y));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">5</span>) read(x), read(y), Mark_Tree(x, Tag(<span class="number">1</span>, y));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) read(x), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ask_Tree(x).mn);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">4</span>) read(x), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ask_Tree(x).mx);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">11</span>) read(x), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ask_Tree(x).sum);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) read(x), read(y), read(z), Mark_Line(x, y, Tag(<span class="number">0</span>, z)), Makeroot(rt);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">6</span>) read(x), read(y), read(z), Mark_Line(x, y, Tag(<span class="number">1</span>, z)), Makeroot(rt);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">7</span>) read(x), read(y), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ask_Line(x, y).mn), Makeroot(rt);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">8</span>) read(x), read(y), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ask_Line(x, y).mx), Makeroot(rt);</span><br><span class="line">        <span class="keyword">else</span> read(x), read(y), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ask_Line(x, y).sum), Makeroot(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个疑问</p>
<p>第159行，将<code>Link(y, x)</code>改为<code>Link(x, y)</code>会错，暂时还不知道为什么</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/18/4-17%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/18/4-17%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/" class="post-title-link" itemprop="url">4.17省选模拟</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-18 19:01:27" itemprop="dateCreated datePublished" datetime="2019-04-18T19:01:27+08:00">2019-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:27:36" itemprop="dateModified" datetime="2020-04-23T09:27:36+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="T1-圈草地"><a href="#T1-圈草地" class="headerlink" title="T1 圈草地"></a>T1 圈草地</h1><p><img src="https://i.loli.net/2019/04/18/5cb8598ea8a77.png" alt="1555585345165"></p>
<p><img src="https://i.loli.net/2019/04/18/5cb859b53dd70.png" alt="1555585452299"></p>
<p>我们只考虑有用的左上角和右下角</p>
<p>考虑两个点$a,b$，如果$a$在$b$的第二象限，那么选择$a$作为左上角一定比选择$b$作为左上角优秀</p>
<p>那么我们将所有有用的点分两层排在一起，第一层是可以作为左上角的点，第二层是可以作为右下角的点</p>
<p><img src="https://i.loli.net/2019/04/18/5cb860d2e1fd7.png" alt="1555587272118"></p>
<p>我们考虑当右下角的点移动的时候左上角的最优决策点会如何变化</p>
<p>假如原来的最优决策点是$a$，另一个在$a$右上角的点是$b$，那么我们可以发现，右下角的点移动之后，$b$与之构成的矩形的面积与$a$与之构成的矩形的面积之差变大了</p>
<p>也就是说，移动之后，$b$会变得更加优秀</p>
<p>所以最优决策点是单调向右上角移动的</p>
<p>我们可以采用分治</p>
<p><code>solve(l, r, L, R)</code>表示右下角的点对应的区间是$[L,R]$，对应的最优决策点的区间是$[l,r]$</p>
<p>我们找到$l,r$的中点$mid$，二分出右下角那些点的最优决策点在$[l,mid]$中</p>
<p>然后继续分治下去</p>
<p>对于找一个矩形内部有多少个点，可以使用主席树</p>
<p>时间复杂度$O(n\log^3n)$</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, lson, rson, sum;</span><br><span class="line">&#125; T[N * <span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> RT[N], ncnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rt = ++ncnt; T[rt].l = l, T[rt].r = r, T[rt].lson = T[rt].rson = T[rt].sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> rt;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; T[rt].lson = build(l, mid), T[rt].rson = build(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> at)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nw = ++ncnt, l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>; T[nw] = T[rt], T[nw].sum++;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> nw;</span><br><span class="line">    <span class="keyword">if</span> (at &lt;= mid) T[nw].lson = update(T[nw].lson, at);</span><br><span class="line">    <span class="keyword">else</span> T[nw].rson = update(T[nw].rson, at);</span><br><span class="line">    <span class="keyword">return</span> nw;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt1, <span class="keyword">int</span> rt2, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt2].l, r = T[rt2].r, mid = (l + r) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> T[rt2].sum - T[rt1].sum;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) res += query(T[rt1].lson, T[rt2].lson, start, end);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; end) res += query(T[rt1].rson, T[rt2].rson, start, end);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125; st1[N], st2[N];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>, top1, top2;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x1 = st1[a].x, y1 = st1[a].y, x2 = st2[b].x, y2 = st2[b].y;</span><br><span class="line">    <span class="keyword">return</span> query(RT[x1 - <span class="number">1</span>], RT[x2], y2, y1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = l, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l;i &lt;= r;i++) <span class="keyword">if</span> (st1[i].x &lt;= st2[x].x &amp;&amp; st2[x].y &lt;= st1[i].y) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = query(i, x);</span><br><span class="line">        <span class="keyword">if</span> (res &lt;= tmp) res = tmp, pos = i;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; mid) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L;i &lt;= R;i++) </span><br><span class="line">            <span class="keyword">if</span> (st1[l].x &lt;= st2[i].x &amp;&amp; st2[i].y &lt;= st1[l].y)</span><br><span class="line">                ans = max(ans, query(l, i));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, l1 = L, r1 = R, m, pos = l1;</span><br><span class="line">    <span class="keyword">while</span> (l1 &lt;= r1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check(l, r, m = ((l1 + r1) &gt;&gt; <span class="number">1</span>), mid)) pos = m, l1 = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r1 = m - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    solve(l, mid, L, pos), solve(mid + <span class="number">1</span>, r, pos + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l;i &lt;= r;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = L;j &lt;= R;j++)</span><br><span class="line">            <span class="keyword">if</span> (st1[i].x &lt;= st2[j].x &amp;&amp; st2[j].y &lt;= st1[i].y)</span><br><span class="line">                ans = max(ans, query(i, j));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), RT[<span class="number">0</span>] = build(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), RT[i] = update(RT[i - <span class="number">1</span>], a);</span><br><span class="line">        <span class="keyword">if</span> (a &gt; st1[top1].y) st1[++top1] = (point)&#123;i, a&#125;;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (top2 &amp;&amp; st2[top2].y &gt; a) top2--;</span><br><span class="line">            st2[++top2] = (point)&#123;i, a&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (top1 &lt;= <span class="number">500</span> &amp;&amp; top2 &lt;= <span class="number">500</span>) solve2(<span class="number">1</span>, top1, <span class="number">1</span>, top2);</span><br><span class="line">    <span class="keyword">else</span> solve(<span class="number">1</span>, top1, <span class="number">1</span>, top2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-道路修建"><a href="#T2-道路修建" class="headerlink" title="T2 道路修建"></a>T2 道路修建</h1><p><img src="https://i.loli.net/2019/04/18/5cb8627245de8.png" alt="1555587688425"></p>
<p><img src="https://i.loli.net/2019/04/18/5cb86290b9bd9.png" alt="1555587721754"></p>
<p>容易发现一个结论：对于一个点$u$，假设它与$v$相连，那么它距离一号城市的最短路距离$d_u$一定满足$d_v-1\leq d_u\leq d_v+1$</p>
<p>那么我们可以通过这个建图跑网络流</p>
<p>将每个点拆成$n$个点，第$x$个点表示当前点的最短路是否大于等于$x-1$</p>
<p>将第一个拆出来的点与源点连一条$\infty$的边，将最后一个拆出来的点与汇点连一条$\infty$的边</p>
<p>将第$i$个拆出来的点向第$i+1$个点连一条权值为题中给出公式的边</p>
<p>最小割中，与$S$集合连接代表为<code>true</code>，否则为<code>false</code></p>
<p>为了满足$d_v-1\leq d_u\leq d_v+1$这个限制，我们可以模仿切糕这道题的做法</p>
<p>对于任意两个有边相连的点$u,v$，$u$拆出来的第$i$个点向$v$拆出来的第$i-1$个点连一条无法割掉的$\infty$ 的边</p>
<p>注意$(u,v)和(v,u)$是不一样的</p>
<h1 id="T3-美术作业"><a href="#T3-美术作业" class="headerlink" title="T3 美术作业"></a>T3 美术作业</h1><p><img src="https://i.loli.net/2019/04/18/5cb86451553e8.png" alt="1555588168670"></p>
<p><img src="https://i.loli.net/2019/04/18/5cb86482a8c37.png" alt="1555588211145"></p>
<p>可以看出，这是一个基环外向树</p>
<p>我们先考虑一棵树的情况：如何求它的染色方案</p>
<p>由于边是有向的，所以置换对答案的影响只有可能是对于$u$这个点，它有一些子树是完全同构的</p>
<p>比如这样</p>
<p><img src="https://i.loli.net/2019/04/18/5cb8658170f30.png" alt="1555588473582"></p>
<p>注意到如果$2,3,4$这几个点互换编号，那么结构是不变的</p>
<p>比如“2染颜色1，3染颜色1，4染颜色2”这种方案与“2染颜色2，3染颜色1，4染颜色1”是完全等价的</p>
<p>而不同构的子树之间是没有关系的</p>
<p>那么对于这种同构的情况怎么办呢</p>
<p>由于$2,3,4$都是同构的，所以它们的染色方案一定都一样，我们假设有$f$种方案，有$t$棵子树</p>
<p>我们将这$f$种染色方案分别编号为$1,2\cdots,f$，对于这些同构的子树按照根节点的编号排序</p>
<p>然后在这$f$种方案中选出$t$种，可以重复，然后按照从小到大的顺序依次给这些同构的子树染色，这样统计出来的结构一定不会重复</p>
<p>等价于将$t$个球放入$f$个盒子，每个盒子可以空</p>
<p>所以方案数为</p>
<script type="math/tex; mode=display">
f{f+t-1\choose f-1}=f{f+t-1\choose t}</script><p>现在我们求出了环上每棵树的染色方案</p>
<p>我们来考虑环的置换</p>
<p>对于一种置换后的不动点，它们对应树的结构必须相同，染的颜色也必须相同</p>
<p>所以对于每棵树最后得到的<code>hash</code>值我们跑一个<code>KMP</code>，求出它的最小循环节，这样每次转的次数一定是循环节长度的倍数</p>
<p>每个循环节我们将它看作一个点，染色方案为它包含的树的染色方案的乘积</p>
<p>然后就是普通<code>polya</code>了，枚举转多少次，然后不动点个数就是每个循环节的方案的$gcd(总长度，转的次数)$次方</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uLL unsigned long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = inv[r];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= r;i++)</span><br><span class="line">        res = (LL)res * (n - i + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt, dp[N], tmp[N], m;</span><br><span class="line">uLL P = <span class="number">233</span>, h[N], s[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> nxt[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ls = nxt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (ls &amp;&amp; s[ls + <span class="number">1</span>] != s[i]) ls = nxt[ls];</span><br><span class="line">        nxt[i] = ls + (s[ls + <span class="number">1</span>] == s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n % (n - nxt[n]) ? <span class="number">-1</span> : n - nxt[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next) </span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) tmp[++top] = e[i].to;</span><br><span class="line">    sort(tmp + <span class="number">1</span>, tmp + top + <span class="number">1</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> h[a] &lt; h[b];&#125;), h[u] = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= top;i++) </span><br><span class="line">        h[u] = ((h[u] * P + h[tmp[i]]) ^ h[tmp[i]]) + h[tmp[i]];</span><br><span class="line">    dp[u] = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, last;i &lt;= top;i = last) &#123;</span><br><span class="line">        <span class="keyword">for</span> (last = i;last &lt;= top &amp;&amp; h[tmp[last]] == h[tmp[i]];last++);</span><br><span class="line">        dp[u] = (LL)dp[u] * C(dp[tmp[i]] + last - i - <span class="number">1</span>, last - i) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> b ? gcd(b, a % b) : a;&#125;</span><br><span class="line"><span class="keyword">int</span> to[N], vis[N], cir[N], mark[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, tot = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;to[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = i;!vis[j];j = to[j]) vis[j] = i;</span><br><span class="line">        <span class="keyword">if</span> (vis[j] != i) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (;!mark[j];j = to[j]) mark[j] = <span class="number">1</span>, cir[++tot] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span> (!mark[i]) adde(to[i], i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tot;i++) dfs(cir[i], <span class="number">0</span>), s[i] = h[cir[i]];</span><br><span class="line">    <span class="keyword">int</span> zjk = KMP(tot), ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (~zjk) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= zjk;i++) f = (LL)f * dp[cir[i]] % mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tot / zjk;i++)</span><br><span class="line">            ans = (ans + Pow(f, gcd(i, tot / zjk))) % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL)ans * Pow(tot / zjk, mod - <span class="number">2</span>) % mod);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tot;i++) ans = (LL)ans * dp[cir[i]] % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/14/SCOI2019-%E6%B8%B8%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/14/SCOI2019-%E6%B8%B8%E8%AE%B0/" class="post-title-link" itemprop="url">SCOI2019 游记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-14 19:14:35" itemprop="dateCreated datePublished" datetime="2019-04-14T19:14:35+08:00">2019-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:12:04" itemprop="dateModified" datetime="2020-04-23T09:12:04+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B8%B8%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">游记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在之前的话"><a href="#写在之前的话" class="headerlink" title="写在之前的话"></a>写在之前的话</h1><p>感觉<code>NOIP</code>之后就有点没救了，之后冬令营全机房都去了</p>
<p>425分有点凉凉</p>
<p>不过可以试试冲E类</p>
<p>赶紧复习一下<code>exBSGS, exCRT, Cipolla</code></p>
<p>朱刘算法懒得看了</p>
<h1 id="Day0"><a href="#Day0" class="headerlink" title="Day0"></a>Day0</h1><p>比赛之前发了一个笔试考察范围，结果是去年<code>NOI</code>的笔试题库</p>
<p>本来以为要考什么神仙内容，结果笔试及其简单</p>
<p>重点是<strong>连题目顺序都和题库一样</strong></p>
<p>笔试时间是一个小时，结果30分钟可以走人的时候我在的这个考室已经没人了</p>
<p>感觉只要看了题库就应该是100分吧（雾</p>
<p>话说电子科大的教学楼上“电子科技大学”这几个字看起来好像电子神技大学</p>
<p>晚上看卢爷颓风暴英雄</p>
<p><del>Celeste真好玩</del></p>
<h1 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h1><p>路上单向模<code>ZJK</code></p>
<blockquote>
<p>我自闭了</p>
<p>我爆零了</p>
<p>来机房看神仙</p>
<p><code>rank</code> $10^9+7$</p>
</blockquote>
<p>结果每次考完之后都<code>rank</code> 1</p>
<p>这是某些选手的真实写照</p>
<hr>
<p>拿到试题之后解压，嗯？密码是一串数字</p>
<p>先看<code>T1</code>，那个图片有点劣质啊。。。</p>
<p>貌似是用<code>mspaint</code>画的</p>
<p>不过还将就</p>
<p>手玩了一下样例，好像找到了一点规律的样子</p>
<p>开考5分钟找工作人员要了几张纸</p>
<p>上个厕所冷静一下，顺便思考一下<code>T1</code></p>
<p>嗯？这不是SB题吗，只要不是划水选手都会做吧。。。</p>
<p>对于最有步数，显然有</p>
<script type="math/tex; mode=display">
f_m=3f_{m-1}+n-1</script><p>然后随便分治一下就行了</p>
<p>一发过掉大样例</p>
<p>题目中说$Q_i$小于等于答案的上限，然而又没说上限是多少</p>
<p>感觉有阴谋</p>
<p>保证答案小于等于30，有什么用呢</p>
<p>意思是$Q_i\leq (n-1)*3^{30}$吗</p>
<p>然后发现显然是假的，$Q_i$可以达到$3^{1000}$</p>
<p>手写高精度！</p>
<p><code>T2</code>的名字叫“肯赛训练”</p>
<p>这里是否有肯德基强行打广告的成份</p>
<p>思考了一下，感觉那个边权是假的</p>
<p>所以是个区间求重心？不会啊</p>
<p>先写暴力吧，好像很莫队的样子</p>
<p>加一个点很好处理，新的重心一定在原来的重心与加的点的连线上</p>
<p>貌似<code>LCT</code>维护虚子树信息可以做到$\log$?</p>
<p>于是开始码<code>LCT</code>，做好了6kb的准备</p>
<p>码了2kb的时候</p>
<p>woc?加点可以直接$\log$，那删点怎么办？</p>
<p>冷静一下</p>
<p>这个东西好像不是很好维护的样子，干脆暴跳吧</p>
<p>好像加点之后重心的移动次数是$O(\log)$的</p>
<p>先码一个树状数组</p>
<p>代码还是挺简单的</p>
<p>我的程序跑得巨慢无比</p>
<p><code>30s</code>后过了大样例</p>
<p>来看<code>T3</code></p>
<p>好像很多项式的样子</p>
<p>卷积的运算符是乘？是不是可以原根什么的啊</p>
<p>然后发现显然不是</p>
<p>还好暴力分给得很足</p>
<p>直接一行代码有5分</p>
<p>剩下的直接暴力数论分块可以再拿25分</p>
<p>貌似有两个$q=1$的点</p>
<p>欸是不是可以爆搜然后乘一个排列数啊</p>
<p>写完之后发现T成SB了</p>
<p>这个时候离考试结束大概还有10分钟</p>
<p>再来检查一下<code>T1</code>吧</p>
<p>手输了一组极限数据</p>
<p>wtf?RE?</p>
<p>赶紧看一下</p>
<p>还好在最后一分钟的时候发现是高精板子错了</p>
<p>那个高精乘的时候我是边乘边取模233</p>
<p>所以最后估分$100+[30-50]+30$?</p>
<p>莫队的分数很玄学的</p>
<hr>
<p><code>ZJK</code>说他<code>T1</code>可能会被卡常，然后期望$50+50+50$</p>
<p><code>ZYW</code>貌似切了<code>T2</code>的60分</p>
<p>都好强啊</p>
<p>很不幸，我面试是第6轮，也就是最后一轮</p>
<p>本来以为要考什么小学奥数，结果是政治问题？（雾</p>
<p><code>Bh</code>是第一轮，他说他们那组的面试题目是评论中美贸易战</p>
<p><code>hxy</code>的题目是七中食堂事件</p>
<p>还有什么国民党为什么会失败</p>
<p>好有趣啊</p>
<p>4：10之前一直在楼梯上坐着</p>
<p>看陈爷玩炉石</p>
<p>经过漫长的等待，终于轮到我了</p>
<p>感觉我们这组只有我一个初中的</p>
<p>拿到题目：如何评价近年来自主招生政策遭到限制？</p>
<p>开始10分钟讨论</p>
<p>丝毫没有面试经验</p>
<p>10分钟之后</p>
<p>考官：之前我提出的要求是讨论并选出一位代表发言，但是10分钟已经过去了，你们却没有选出一位代表</p>
<p>我们：。。。</p>
<p>考官：从面试的角度来说，你们这次讨论是失败的</p>
<p>我们：。。。</p>
<p>考官：现在再给你们一次机会，选出一个代表发言</p>
<p>显然不是我了2333</p>
<p>感觉面试是不是有点凉啊</p>
<hr>
<p>晚上来看成绩</p>
<p>嗯？$60+45+30?$</p>
<p><code>T1</code>的高精度果然<code>T</code>了啊</p>
<p>如果把11位压到17位应该就不会超时了</p>
<p>还是太菜了</p>
<p>orz陈爷180</p>
<p><code>ZYW</code>165，看来她进E类稳了</p>
<p><code>ZJK</code>好像有点爆炸？只有100，但是如果算上<code>NOIP</code>的话还是在我前面</p>
<p>看了看此时的加权成绩，<code>rk</code>21，好像有点凉？</p>
<p>明天加油吧</p>
<h1 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h1><p>考前陈爷口胡动态<code>SA</code>，感觉他A类很稳</p>
<p>拿到试题，密码又全是数字</p>
<p>先看<code>T1</code></p>
<p>好像很模板的样子</p>
<p>感觉那个分成两半部分，再取一个部分的操作没啥用</p>
<p>如果根据询问把每个点变一下，那不是最大子段和吗？</p>
<p>50pts get</p>
<p>如果要动态的话，线段树维护凸包？？？</p>
<p>反正这种东西我是很难写出来的</p>
<p>那线段树维护矩阵？？？</p>
<p>好像不是</p>
<p>两个自变量有点不爽，可以去掉一个</p>
<p>等等，前缀和之后好像是个很裸的斜率优化</p>
<p>15分钟码完，代码只有2kb。。</p>
<p>对拍了上万组数据，感觉很稳</p>
<p>来看<code>T2</code></p>
<p>哇，这是论文题欸！</p>
<p>去年国家集训队论文，有一个“解决树上连通块问题的一些技巧和工具”</p>
<p>原题啊！！！！</p>
<p>具体方法是利用“边数 = 点数 - 1”这个等式来容斥</p>
<p>枚举某个点作为$x$的方案数，减去某条边两个端点都是$x$的方案数</p>
<p>然后就切了？？？</p>
<p>跑一下大样例</p>
<p>嗯？输出负数？改成<code>long long</code></p>
<p>嗯？还是负数，看看答案</p>
<p>woc？答案怎么这么小</p>
<p>举手向监考老师求助</p>
<p>我：第二道题有模数吗</p>
<p>老师：题目中写了吗</p>
<p>我：没有啊，但是大样例无论如何都不可能这么小</p>
<p>老师：这个。。。你自己认真读题吧</p>
<p>我：<code>&amp;#fsdl&amp;DFfd*#$jkrhf29873Q@!Rds</code></p>
<p>不久之后更正通知下来了，模数是$10^9+7$</p>
<p>改一下程序，过了！很好</p>
<p>开始看<code>T3</code></p>
<p>这看上去很线性基</p>
<p>事实上线性基的确可以获得20分的好成绩</p>
<p>思考了一下感觉没有发现什么好的性质，果断写暴力</p>
<p>前20分直接暴力，后面20分线性基，然后还有20分貌似是找规律？</p>
<p>好像是$2^{不同数的个数}$的样子？</p>
<p>写！</p>
<p>11：00的时候我就码完了</p>
<p><code>T1</code>仍然没有拍出错</p>
<p>前面好像有个七中大佬在玩纸牌？</p>
<p>我默默地点开了扫雷</p>
<p>2min后</p>
<p>太不友好了！</p>
<p>还是试试虚拟机吧</p>
<p>结果打开虚拟机让我的电脑卡了一会儿</p>
<p>无聊打了一个程序模<code>ZJK</code></p>
<p>之后看了看各个<code>IDE</code>的作者信息</p>
<p>坐了2h后考试结束了</p>
<p>所以我今天估分$100+100+60?$感觉翻盘有望？</p>
<p><code>ZJK</code>和<code>ZYW</code>都估分$100+40+40$</p>
<p><code>ZYW</code>说她<code>T1</code>是在线，是在凸包上二分</p>
<p>蒟蒻只会离线</p>
<p>下午拿到成绩，前两道题确实是100，但是第三题只有40，总分240</p>
<p>看来是规律假了</p>
<p>不过，我竟然是rk 1？</p>
<p><code>ZYW</code>和<code>ZJK</code>确实是180，E类稳了</p>
<p><code>BH</code>有点神仙啊，切了<code>T2</code>，但是<code>T1</code>爆零了，本来是很有希望的</p>
<p>坐看卢爷翻盘240，orz</p>
<p>事实证明考前无聊的时候看看论文总是有用的</p>
<p>预祝陈爷<code>NOI</code>取得好成绩！</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>如果不是第二天的成功翻盘，我有可能进不了E类</p>
<p>感觉这次我们学校进步好大啊，去年只有一个省队</p>
<p>强者都上了400分orz</p>
<p>想起去年我失败的<code>SCOI</code>，想要了解详情可以知乎搜索<code>SCOI2018</code></p>
<p>希望我能够坚持到最后</p>
<p><code>NOI2019</code>见</p>
<h1 id="补充：关于题意"><a href="#补充：关于题意" class="headerlink" title="补充：关于题意"></a>补充：关于题意</h1><h2 id="D1T1-小红球的跳跃"><a href="#D1T1-小红球的跳跃" class="headerlink" title="D1T1 小红球的跳跃"></a>D1T1 小红球的跳跃</h2><p>有$m$个小红球，$n$个空岛。其中第一个、最后一个空岛以及中间的第$k$个空岛是固定的$(1&lt;k&lt;n)$是固定的，其余空岛是悬浮的。一开始所有小红球都在第一个空岛，你的目标是把他们都移动到最后一个空岛，并且使用的步数尽量小。</p>
<p>每回合你可以移动一个小红球到它左边或者右边的那个平台，但是有一些限制：</p>
<ul>
<li>移动的小红球必须是移动前/移动后它所在的平台上编号最小的。</li>
<li>如果一个小红球移动到了一个浮动平台上，那下一回合必须将这个小红球移走，否则它就会掉下去。</li>
</ul>
<p>有$q$个询问，每次给出一个时刻，你需要回答在最优方案中，这个时刻正在跳跃的是哪个小红球。</p>
<p>保证答案小于$30$，$n\leq 10^8,m\leq1000,q\leq5000$，时限$1$s</p>
<p>保证询问给出的时刻小于等于最优方案数</p>
<p>部分分：</p>
<ul>
<li>对于$20\%$的数据，保证$m,n,q\leq10$</li>
<li>对于$50\%$的数据，保证$n\leq 10^8,m\leq 10,q\leq 5000$</li>
</ul>
<h2 id="D1T2-肯赛训练"><a href="#D1T2-肯赛训练" class="headerlink" title="D1T2 肯赛训练"></a>D1T2 肯赛训练</h2><p>给出一棵树，$n$个节点，每条边有边权$c_i$。</p>
<p>给出一个点的序列，这个序列有$m$个数，第$i$个数$a_i$代表编号为$a_i$的点</p>
<p>有$q$个询问，每次询问给出一段区间$[l,r]$，你要在树上选出一个点，使得这个点离$a_l,a_{l+1},\cdots,a_{r}$的距离之和尽量小，输出这个点的编号</p>
<p>注意，选出的点不一定是$a_{l},a_{l+1},\cdots,a_r$其中的某一个</p>
<p>保证$n\leq 3*10^5,c_i\leq 1000,m\leq5*10^5,q\leq10^6$，区间的长度是奇数，时限$3$s</p>
<p>部分分：</p>
<ul>
<li>对于前$20\%$的数据，保证$n,m,q\leq2*10^3$</li>
<li>对于前$35\%$的数据，保证$m,q\leq2*10^3$</li>
<li><p>对于前$60\%$的数据，保证$n,m,q\leq10^5$</p>
</li>
<li><p>对于另$15\%$的数据，保证每个点的度数不超过$2$</p>
</li>
</ul>
<h2 id="D1T3-超矩形"><a href="#D1T3-超矩形" class="headerlink" title="D1T3 超矩形"></a>D1T3 超矩形</h2><p>给出一个数$n$，你需要找到$k$个数$a_1,a_2,\cdots,a_k$使得$\prod_{i=1}^ka_i\leq n$</p>
<p>给出一个变换$b_1,b_2,\cdots,b_k$，保证$b_i&lt;10$</p>
<p>你需要求出</p>
<script type="math/tex; mode=display">
\sum_{所有合法的方案}\prod_{i=1}^ka_i^{b_i}\pmod {998244353}</script><p>多组数据（$t$组）</p>
<p>保证$n\leq10^6,\sum k\leq10^6,t\leq100$，时限$4$s</p>
<p>给出$b$的方式是$q$个$s_i,r_i$，表示有连续$r_i$个$b_i$是$s_i$</p>
<p>保证$s_i$互不相同，$q&lt;5$</p>
<p>部分分：</p>
<ul>
<li>对于前$10\%$的数据，保证$k=1,q=1,s=0$</li>
<li>对于前$20\%$的数据，保证$k=1,q=1,s\leq1$</li>
<li><p>对于前$30\%$的数据，保证$k\leq2,q\leq2$</p>
</li>
<li><p>对于另$20\%$的数据，保证$q=1$</p>
</li>
</ul>
<h2 id="D2T1-湖之精灵的游戏"><a href="#D2T1-湖之精灵的游戏" class="headerlink" title="D2T1 湖之精灵的游戏"></a>D2T1 湖之精灵的游戏</h2><p>一个二维平面上有$n$个点，第$i$个点的坐标是$(x_i,y_i)$，你要和一位神仙玩游戏。</p>
<p>每次神仙会告诉你一个坐标$(x,y)$，连一条经过$(0,0),(x,y)$的直线，这会把平面分成两个部分$A,B$</p>
<p>你要选择一个区间$[l,r]$，那么计算的时候只会考虑编号在$[l,r]$之内的点</p>
<p>一个半平面的价值是这个半平面中，编号在$[l,r]$范围内的点与$(0,0),(x,y)$组成三角形的面积之和</p>
<p>你要选择一个半平面，神仙会选择另一个半平面，你想要使得你得到的价值减去神仙得到的价值的结果尽量大</p>
<p>有$m$轮游戏，对于每轮游戏输出这个最大值乘以$2$的结果</p>
<p>保证$n,m\leq 10^6$，$1\leq x,y\leq1000$，时限$2$s</p>
<p>部分分：</p>
<ul>
<li>对于$20\%$的数据，$n,m\leq200$</li>
<li>对于$50\%$的数据，$n,m\leq 10^4$</li>
</ul>
<h2 id="D2T2-RGB"><a href="#D2T2-RGB" class="headerlink" title="D2T2 RGB"></a>D2T2 <font color=red>R</font><font color=green>G</font><font color=blue>B</font></h2><p>有一棵树，$n$个节点，每条边有边权$c_i$，每个点的颜色为<font color=red>R</font>,<font color=green>G</font>,<font color=blue>B</font>三种颜色之一</p>
<p>你要统计有序对$(U,V)$的数量，其中$U,V$是两个点集</p>
<p>它还需要满足以下条件：</p>
<ul>
<li>$U$和$V$都必须是连通的</li>
<li>$U$的颜色只能是红色或者绿色，$V$的颜色只能是绿色或者蓝色</li>
<li>存在一个$U,V$均包含的点$x$，使得对于所有在$U,V$集合中的点$y$，有$dis(x,y)\leq w$</li>
</ul>
<p>保证$n\leq 2000,w\leq10^7,c_i\leq10^6$，时限$1$s，对$10^9+7$取模</p>
<p>部分分：</p>
<ul>
<li>对于$30\%$的数据，$n\leq 15$</li>
<li>对于另$10\%$的数据，只有一个<font color=green>G</font></li>
<li>对于另$20\%$的数据，树是一条链</li>
</ul>
<h2 id="D2T3-函数"><a href="#D2T3-函数" class="headerlink" title="D2T3 函数"></a>D2T3 函数</h2><p>有$n$个数$v_1,v_2,\cdots,v_n$，现在有一类函数$f_T(x)$，其中$T$是$V$的一个子集，它的定义是</p>
<script type="math/tex; mode=display">
f_T(x)=\bigoplus_{v_i\in T}(x+v_i)\\\
f_\emptyset(x)=0</script><p>我们称两个函数$f_s,f_t$是$W-$本质不同的，当且仅当存在一个$0\leq x\leq W$，使得$f_s(x)\not=f_t(x)$</p>
<p>问在这$2^n$个函数中，有多少函数是$W-$本质不同的</p>
<p>保证$n,w,v_i&lt; 2^{17}$，时限$1$s</p>
<p>部分分：</p>
<ul>
<li>对于$20\%$的数据，$n\leq15,w\leq10$</li>
<li>对于另$20\%$的数据，$w=0$</li>
<li>对于前$70\%$的数据，$n,w,v_i\leq2^{10}$</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/09/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/09/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/" class="post-title-link" itemprop="url">二次剩余</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-09 10:20:40" itemprop="dateCreated datePublished" datetime="2019-04-09T10:20:40+08:00">2019-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:34:44" itemprop="dateModified" datetime="2020-04-23T09:34:44+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>若方程$x^2\equiv a\pmod p$有解，那么称$a$为$p$的二次剩余，否则$a$为$p$的非二次剩余</p>
<h1 id="勒让德符号及欧拉判别法"><a href="#勒让德符号及欧拉判别法" class="headerlink" title="勒让德符号及欧拉判别法"></a>勒让德符号及欧拉判别法</h1><p>定义勒让德符号为</p>
<script type="math/tex; mode=display">
\left(\frac{a}{p}\right)=\begin{cases}1&a为p的二次剩余\\\ -1&a为p的非二次剩余\\\ 0 &a能被p整除\end{cases}</script><p>欧拉判别法就是：如果$a$不能被$p$整除，那么有</p>
<script type="math/tex; mode=display">
\left(\frac{a}{p}\right)=a^{\frac{p-1}{2}}</script><h2 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h2><blockquote>
<p>对于方程$x^2\equiv a\pmod p$ ，共有$\frac{p-1}{2}$个不同的$a$使得该方程有解</p>
</blockquote>
<p>我们忽略$x=0$，如果枚举$x$再求出$a$，那么$x$一共有$p-1$个不同的值，也就产生了$p-1$个$a$</p>
<p>我们知道一个二次剩余恰好会产生两个解，那么这$p-1$个$a$就被分配到了$\frac{p-1}{2}$个不同的桶里面</p>
<p>所以共有$\frac{p-1}{2}$个$a$</p>
<h2 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h2><blockquote>
<p>$(x+y)^p\equiv x^p+y^p\pmod p$</p>
</blockquote>
<p>我们将其二项式展开</p>
<script type="math/tex; mode=display">
(x+y)^p=\sum_{i=0}^p{p\choose i}x^iy^{p-i}</script><p>当$i\not=0$且$i\not=p$时，$p\choose i$一定包含因数$p$，所以可以忽略</p>
<p>只剩下第一项和最后一项</p>
<h1 id="Cipolla算法"><a href="#Cipolla算法" class="headerlink" title="Cipolla算法"></a>Cipolla算法</h1><p>现在要求出方程$x^2\equiv n\pmod p$的一个解</p>
<p>我们找出一个$a​$，使得$(a^2-n)^{\frac{p-1}{2}}\equiv-1\pmod p​$</p>
<p>设$\omega=\sqrt{a^2-n}$</p>
<blockquote>
<p>结论：$x=(a+\omega)^{\frac{p+1}{2}}$</p>
</blockquote>
<p>证明如下：</p>
<p>我们知道</p>
<script type="math/tex; mode=display">
(a^2-n)^{\frac{p-1}{2}}\equiv-1\pmod p\Rightarrow (\omega^2)^{\frac{p-1}{2}}\equiv -1\pmod p\\\
\omega^{p-1}\equiv -1\pmod p</script><p>那么有</p>
<script type="math/tex; mode=display">
\begin{aligned}
x&\equiv (a+\omega)^{\frac{p+1}{2}}\\\
x^2&\equiv (a+\omega)^{p+1}\equiv(a+\omega)^p(a+\omega)\\\
&\equiv(a^p+\omega^p)(a+\omega)\\\
&\equiv(a-\omega)(a+\omega)\\\
&\equiv a^2-\omega^2\equiv a^2-a^2+n\equiv n
\end{aligned}</script><p>我们可以通过实现一个类似复数的结构体来进行运算</p>
<p>由于$p$的二次剩余一共有$\frac{p-1}{2}$个，而$a$在$[0,p)$中随机选取</p>
<p>那么成功的概率就是$\frac{1}{2}$</p>
<p>此时答案中$\omega$部分的系数必然为0</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/09/BSGS%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/09/BSGS%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95/" class="post-title-link" itemprop="url">BSGS及其拓展</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-09 09:25:08" itemprop="dateCreated datePublished" datetime="2019-04-09T09:25:08+08:00">2019-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:21:34" itemprop="dateModified" datetime="2020-04-23T09:21:34+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a>BSGS</h1><p>解高次同余方程</p>
<script type="math/tex; mode=display">
A^x\equiv B\mod C且A\bot B</script><p>根据费马小定理，我们直到$A^{C-1}\equiv B\mod C$</p>
<p>那么如果这个方程有解，那么解的周期一定不会大于$C$，所以必然存在一个不大于$C$的解</p>
<p>如果$C$比较小，那么我们可以直接枚举$x$然后暴力判断</p>
<p>考虑$C$比较大的情况，这时就需要使用<code>BSGS</code>了</p>
<p>我们设$x=i*m-j$，其中$j&lt;m$，这个$m$是一个常量，我们设为$\sqrt{C}$</p>
<p>那么有</p>
<script type="math/tex; mode=display">
A^{i\*m-j}\equiv B\mod C\\\
A^{i\*m}\equiv B\*A^j\mod C</script><p>我们开一个<code>map</code>，枚举$j$，将$B*A^j$放到这个<code>map</code>里面</p>
<p>然后我们枚举$i*m$，在<code>map</code>中查找是否存在$A^{i*m}​$即可</p>
<p>注意这样枚举是取不到$x=0$的，这种情况我们需要特判</p>
<p>如果$i*m$此时已经大于$C$了，那么就无解</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">BSGS</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (B % C == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; s.clear();</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(C)), ls = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++, ls = (LL)ls * A % C)</span><br><span class="line">        s[(LL)B * ls % C] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, t = ls;i &lt;= C;i += m, t = (LL)t * ls % C) </span><br><span class="line">        <span class="keyword">if</span> (s.count(t)) <span class="keyword">return</span> i - s[t];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="exBSGS"><a href="#exBSGS" class="headerlink" title="exBSGS"></a>exBSGS</h1><p>同样是解上面那个方程</p>
<p>但是如果$A,C$不互质呢</p>
<p>原方程等价于</p>
<script type="math/tex; mode=display">
A^x+Cy=B</script><p>我们不停地消去$A,C$的非1因子，可以使得方程变为</p>
<script type="math/tex; mode=display">
aA^z+C'y=B'</script><p>每消去一次，我们就从$A^x$里面拿一个$A$出来，消完之后乘到系数$a$里面去</p>
<p>注意在消去过程中时，如果存在某个时刻使得$a=B’$，那么直接返回此时的消去次数就可以了</p>
<p>如果在消去过程中，$B’$没有当前要消去的那个因子，那么直接返回$-1$</p>
<p>我们设消去次数为$k$</p>
<p>那么此时方程就变成了</p>
<script type="math/tex; mode=display">
aA^z\equiv B'\mod C'(A\bot C')</script><p>使用普通的<code>BSGS</code>可以解出$z$，注意此时前面还有一个系数$a$</p>
<p>最后我们将解出的$z$加上$k$即可，因为最开始拿出了$k$个$A$来消去因数</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> b ? gcd(b, a % b) : a;&#125;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">BSGS</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C, <span class="keyword">int</span> basic)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (B % C == basic) <span class="keyword">return</span> <span class="number">0</span>; s.clear();</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(C)), ls = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++, ls = (LL)ls * A % C)</span><br><span class="line">        s[(LL)B * ls % C] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, t = (LL)ls * basic % C;i &lt;= C;i += m, t = (LL)t * ls % C) </span><br><span class="line">        <span class="keyword">if</span> (s.count(t)) <span class="keyword">return</span> i - s[t];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">exBSGS</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, cnt = <span class="number">0</span>, d; A %= C, B %= C;</span><br><span class="line">    <span class="keyword">while</span> ((d = gcd(A, C)) != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (B % d) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        a = (LL)a * (A / d) % C, C /= d, B /= d, cnt++;</span><br><span class="line">        <span class="keyword">if</span> (a == B) <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = BSGS(A, B, C, a);</span><br><span class="line">    <span class="keyword">return</span> ~res ? res + cnt : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/08/12%E7%9C%81%E8%81%94%E8%80%832019-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/08/12%E7%9C%81%E8%81%94%E8%80%832019-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">12省联考2019 字符串问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-08 21:26:15" itemprop="dateCreated datePublished" datetime="2019-04-08T21:26:15+08:00">2019-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:23:48" itemprop="dateModified" datetime="2020-04-23T09:23:48+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A2%98%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">题解</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给出一个字符串$S$， 现在要选取它的$n_a$个子串作为$A$类串，选取$n_b$个子串作为$B$类串</p>
<p>其中第$i$个$A$类串为$S(la_i,ra_i)$，第$i$个$B$类串为$S(lb_i,rb_i)$，$la_i,ra_i,lb_i,rb_i,n_a,n_b$均已给出</p>
<p>现额外给定$m$组支配关系，每组关系$(x,y)$表示第$x$个$A$类串支配第$y$个$B$类串</p>
<p>求出一个长度最大的字符串$T$，满足$T$是由$A$类串拼接而成的。我们假设$T$被划分成了$t_1,t_2,\cdots,t_k$（都是$A$类串），要求满足对于任意的$i&lt;k$，$t_i$所支配的串中至少有一个是$t_{i+1}$的前缀</p>
<p><img src="https://i.loli.net/2019/04/08/5cab4fcbe56e2.png" alt="1554730942968"></p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>对于这种要求所求值最大的问题，不是动态规划就是最长路</p>
<p>那么对于这道题显然就只能是最长路了</p>
<p>如果最后构建出来的图有环，那么$T$就可以无限长</p>
<p>否则我们拓扑排序，然后跑一个<code>dp</code>就可以了</p>
<p>首先我们将$S$串翻转，将所有的$A$串与$B$串都翻转</p>
<p>这样限制条件就可以变为我们熟悉的后缀</p>
<p>我们先考虑一种暴力连边方式</p>
<p>每个$A$串建一个点，每个$B$串建一个点</p>
<p>对于$A_i$，将所有是其后缀的$B$连向$A_i$，权值为$|A_i|$</p>
<p>对于一组支配$(A_i,B_i)$，$A_i$往$B_i$连一条权值为0的边</p>
<p>但是这样最坏会连$n_a*n_b$条边，需要优化</p>
<p>我们考虑这样一种优化方案</p>
<p>对于任意的$A_i,B_i$，如果$B_i$是$A_i$的后缀，那么$B_i$的后缀也是$A_i$的后缀</p>
<p>我们对于$B$单独建一个子图，这个子图需要满足如果$B_i$是$B_j$的后缀，那么所有能走到$B_i$的路径都可以走到$B_j$</p>
<p>这样的话$A_i$只需要从它包含的那个最长的$B$串后缀连边就可以了</p>
<p>那么什么图满足这个性质呢？</p>
<p>很明显是<code>parent</code>树</p>
<p>我们建出<code>parent</code>树，然后从父亲往儿子节点连边</p>
<p>因为父亲对应的点一定是儿子的后缀</p>
<p>对于每个串$A_i,B_i$，找到它在树上的位置，这个可以通过倍增实现</p>
<p>实际上我们不需要对于每个串$A$，都找到那个最长的且是它后缀的$B$</p>
<p>直接从<code>parent</code>树上$A_i$的对应节点往$A_i$连边就可以了</p>
<p>因为这样同样可以保证最长的且是它后缀的$B$可以走到$A_i$</p>
<p>兴奋地写完，发现第三个样例过不去($-1$)</p>
<p>事实上是我们少考虑了一种情况</p>
<p><code>parent</code>树上的某个节点可以表示长度在一段区间的串</p>
<p>如果一条路径是从父亲走向儿子，那么当然没有问题，因为此时它代表的串是这个节点所能代表的最短的串</p>
<p>如果有一个串$A_i$以及另一个串$B_j$，它们对应着树上的同一个点</p>
<p>在之前的建图方式中，$B_j$一定能到达$A_i$</p>
<p>但是如果$|B_j|&gt;|A_i|$呢，显然这种转移是不合法的</p>
<p>解决方法是对于树上的一个点$u$，假如有$a_u$个$A$串挂在上面</p>
<p>那么我们将这些$A$串按照长度从小到大排序，将$u$拆成$a_u+1$个点，第$i$个点往$i+1$个点连边，父亲的最右边那个点往儿子的最左边那个点连边</p>
<p>对于一个串$B$，它就对应着它在树上的那个点所拆成的点中，第一个长度不小于它的点</p>
<p>这样就没有问题了</p>
<p>注意开<code>long long</code></p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> P = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="keyword">int</span> LEN;</span><br><span class="line"><span class="keyword">namespace</span> SAM &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; next; </span><br><span class="line">        <span class="keyword">int</span> link, len;</span><br><span class="line">    &#125; st[N * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ncnt, last;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;st[<span class="number">0</span>].link = <span class="number">-1</span>, st[<span class="number">0</span>].len = ncnt = last = <span class="number">0</span>, st[<span class="number">0</span>].next.clear();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">extend</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = ++ncnt, p; st[cur].len = st[last].len + <span class="number">1</span>, st[cur].link = <span class="number">0</span>, st[cur].next.clear();</span><br><span class="line">        <span class="keyword">for</span> (p = last;p != <span class="number">-1</span> &amp;&amp; !st[p].next.count(c);p = st[p].link)</span><br><span class="line">            st[p].next[c] = cur;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> q = st[p].next[c];</span><br><span class="line">            <span class="keyword">if</span> (st[q].len == st[p].len + <span class="number">1</span>) st[cur].link = q;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> clone = ++ncnt; st[clone].len = st[p].len + <span class="number">1</span>, st[clone].next = st[q].next, st[clone].link = st[q].link;</span><br><span class="line">                <span class="keyword">for</span> (;p != <span class="number">-1</span> &amp;&amp; st[p].next[c] == q;p = st[p].link)</span><br><span class="line">                    st[p].next[c] = clone;</span><br><span class="line">                st[q].link = st[cur].link = clone;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= ncnt;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : st[i].next)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"sam: "</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; v.second &lt;&lt; <span class="string">' '</span> &lt;&lt; v.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> SUF_Tree &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to, next;&#125; e[N * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> head[N * <span class="number">2</span>], ecnt, len[N * <span class="number">2</span>], fa[<span class="number">18</span>][N * <span class="number">2</span>]; </span><br><span class="line">    <span class="built_in">vector</span>&lt;P&gt; nodes[N * <span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">        fa[<span class="number">0</span>][u] = f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">17</span>;i++) fa[i][u] = fa[i - <span class="number">1</span>][fa[i - <span class="number">1</span>][u]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">            <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">2</span> * LEN;i++) head[i] = <span class="number">0</span>, nodes[i].clear(), nodes[i].push_back(P(<span class="number">1e9</span>, <span class="number">-1</span>));</span><br><span class="line">        ecnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>;i &gt;= <span class="number">0</span>;i--) <span class="keyword">if</span> (fa[i][u])</span><br><span class="line">            <span class="keyword">if</span> (l &lt;= len[fa[i][now]])</span><br><span class="line">                now = fa[i][now];</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> id[N], tot, onT[N], sz[N], onT2[N], na;</span><br><span class="line"><span class="keyword">namespace</span> GRAPH &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to, next, w;&#125; e[N * <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">int</span> head[N * <span class="number">4</span>], ecnt, ind[N * <span class="number">4</span>], st[N * <span class="number">4</span>], top, ncnt; LL dp[N * <span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        e[++ecnt] = (edge)&#123;to, head[from], w&#125;, ind[to]++, head[from] = ecnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Topsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        top = <span class="number">0</span>; <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= ncnt;i++) <span class="keyword">if</span> (!ind[i]) q.push(i), st[++top] = i;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next) </span><br><span class="line">                <span class="keyword">if</span> (!(--ind[e[i].to])) q.push(e[i].to), st[++top] = e[i].to;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> top == ncnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= ncnt;i++) head[i] = ind[i] = dp[i] = <span class="number">0</span>;</span><br><span class="line">        ecnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">DP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = top;i &gt;= <span class="number">1</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = st[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = head[u];j;j = e[j].next)</span><br><span class="line">                dp[u] = max(dp[u], dp[e[j].to] + e[j].w);</span><br><span class="line">            <span class="keyword">if</span> (u &lt;= na) res = max(res, dp[u] + sz[u]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p[N * <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    p[u].clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : SUF_Tree::nodes[u]) &#123;</span><br><span class="line">        p[u].push_back(++tot);</span><br><span class="line">        <span class="keyword">if</span> (v.second &gt; <span class="number">0</span>) onT[v.second] = tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i + <span class="number">1</span> &lt; p[u].size();i++)</span><br><span class="line">        GRAPH::adde(p[u][i], p[u][i + <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = SUF_Tree::head[u];i;i = SUF_Tree::e[i].next) &#123;</span><br><span class="line">        dfs(SUF_Tree::e[i].to);</span><br><span class="line">        GRAPH::adde(*p[u].rbegin(), *p[SUF_Tree::e[i].to].begin(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; read(T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>), LEN = <span class="built_in">strlen</span>(s + <span class="number">1</span>), reverse(s + <span class="number">1</span>, s + LEN + <span class="number">1</span>), SAM::init(), SUF_Tree::init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= LEN;i++) id[i] = SAM::extend(s[i]);</span><br><span class="line"><span class="comment">//        cout &lt;&lt; SAM::ncnt &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= SAM::ncnt;i++) SUF_Tree::adde(SAM::st[i].link, i), SUF_Tree::len[i] = SAM::st[i].len;</span><br><span class="line">        SUF_Tree::dfs(<span class="number">0</span>, <span class="number">0</span>); read(na), tot = na;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; "ok" &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l, r;i &lt;= na;i++) &#123;</span><br><span class="line">            read(l), read(r), l = LEN - l + <span class="number">1</span>, r = LEN - r + <span class="number">1</span>, swap(l, r), sz[i] = r - l + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> t = SUF_Tree::find(id[r], r - l + <span class="number">1</span>); </span><br><span class="line">            SUF_Tree::nodes[t].push_back(P(r - l + <span class="number">1</span>, i));</span><br><span class="line">        &#125;</span><br><span class="line">        GRAPH::ncnt = na * <span class="number">2</span> + SAM::ncnt + <span class="number">1</span>, GRAPH::init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= SAM::ncnt;i++) sort(SUF_Tree::nodes[i].begin(), SUF_Tree::nodes[i].end());</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= na;i++) GRAPH::adde(onT[i], i, sz[i]);</span><br><span class="line">        <span class="keyword">int</span> nb; read(nb);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l, r;i &lt;= nb;i++) &#123;</span><br><span class="line">            read(l), read(r), l = LEN - l + <span class="number">1</span>, r = LEN - r + <span class="number">1</span>, swap(l, r);</span><br><span class="line">            <span class="keyword">int</span> t = SUF_Tree::find(id[r], r - l + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> pos = lower_bound(SUF_Tree::nodes[t].begin(), SUF_Tree::nodes[t].end(), P(r - l + <span class="number">1</span>, <span class="number">-2</span>)) - SUF_Tree::nodes[t].begin();</span><br><span class="line">            onT2[i] = p[t][pos];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> matches; read(matches);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= matches;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b; read(a), read(b), GRAPH::adde(a, onT2[b], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        GRAPH::ncnt = tot;</span><br><span class="line">        <span class="keyword">if</span> (!GRAPH::Topsort()) &#123;<span class="built_in">puts</span>(<span class="string">"-1"</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, GRAPH::DP());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/07/BJOI2018-%E5%8F%8C%E4%BA%BA%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/07/BJOI2018-%E5%8F%8C%E4%BA%BA%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/" class="post-title-link" itemprop="url">BJOI2018 双人猜数游戏</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-07 11:53:41" itemprop="dateCreated datePublished" datetime="2019-04-07T11:53:41+08:00">2019-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:21:47" itemprop="dateModified" datetime="2020-04-23T09:21:47+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A2%98%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">题解</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://www.luogu.org/problemnew/show/P4459" target="_blank" rel="noopener">题目链接</a></p>
<p>神仙题啊</p>
<p>首先来模拟一下样例</p>
<p><code>Alice</code>知道乘积是60，<code>Bob</code>知道和是16，且两个数均不小于5</p>
<p><code>Bob</code>：此时两个数有可能为</p>
<p>$(5, 11), (6, 10), (7, 9), (8, 8)$</p>
<p>而<code>Bob</code>在第一轮没有猜出来，也就是说，这两个数的和不是10或11</p>
<p><code>Alice</code>：此时两个数有可能为</p>
<p>$(5, 12), (6, 10)$</p>
<p>由于Alice也没有猜出来，所以对于Bob来说，以下情况就被排除了</p>
<p>$(5, 11), (7, 9), (8, 8)$</p>
<p>对于$(5, 11)$而言，55只有这一种分解方式，而<code>Alice</code>在第一轮中没有猜出来，所以不是</p>
<p>对于$(7, 9)$而言，63还可以被分解成$(3, 21)$，但是不满足两个数都大于等于5，而<code>Alice</code>没有猜出来，所以也不是</p>
<p>$(8, 8)​$同理</p>
<p>所以对于<code>Bob</code>来说，这两个数只有可能是$(6, 10)$，他也就确定了答案</p>
<p><code>Alice</code>知道，<code>Bob</code>已经猜出来了，所以$(5, 12)$就被排除了，因为在这种情况下，$Bob​$不可能这么早就猜出答案</p>
<p>所以<code>Alice</code>也知道答案是$(6, 10)​$了</p>
<p>我们用<code>dp</code>来描述这个过程，<code>dp[i][n][m]</code>表示，当前是第i轮，且两个答案分别是$n,m$，在$1-i​$轮中，是否能决定答案</p>
<p>如果这一轮是<code>Bob</code>猜，那么我们就枚举$n+m$的划分方式。如果每一种合法的划分方式都能在$1-(i-1)$轮被猜出来，那么<code>Bob</code>一定能确定这两个数分别为$n, m$</p>
<p>否则，我们则枚举$n*m$的约数， 判断方式与<code>Bob</code>的相同</p>
<p>但是这样可能会出现一种特殊情况，就是已经到了$t$轮，第一个人猜出来了，而第二个人没有猜出来</p>
<p>那么我们就多进行一轮转移，这次转移与之前的转移相反，如果每一种合法的划分方式在$1-t$轮都不能被猜出来，那么才能确定答案</p>
<p>$n,m$的最大值不会超过500，直接枚举</p>
<p>直接交程序，数组只开500的话是秒跑</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500</span></span><br><span class="line"><span class="keyword">int</span> dp[N + <span class="number">10</span>][N + <span class="number">10</span>][<span class="number">16</span>], m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, tmpa, tmpb;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, j;i &lt;= a + b - i &amp;&amp; cnt &lt; <span class="number">2</span>;i++) </span><br><span class="line">        <span class="keyword">if</span> (!dp[i][j = a + b - i][c - <span class="number">1</span>] || c == <span class="number">1</span>) </span><br><span class="line">            cnt++, tmpa = i, tmpb = j;</span><br><span class="line">    <span class="keyword">return</span> cnt == <span class="number">1</span> &amp;&amp; a == tmpa &amp;&amp; b == tmpb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, tmpa, tmpb;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, j;i * i &lt;= a * b &amp;&amp; cnt &lt; <span class="number">2</span>;i++)</span><br><span class="line">        <span class="keyword">if</span> (a * b % i == <span class="number">0</span> &amp;&amp; (!dp[i][j = a * b / i][c - <span class="number">1</span>] || c == <span class="number">1</span>))</span><br><span class="line">            cnt++, tmpa = i, tmpb = j;</span><br><span class="line">    <span class="keyword">return</span> cnt == <span class="number">1</span> &amp;&amp; a == tmpa &amp;&amp; b == tmpb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, tmpa, tmpb;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, j;i &lt;= a + b - i &amp;&amp; cnt &lt; <span class="number">2</span>;i++) </span><br><span class="line">        <span class="keyword">if</span> (dp[i][j = a + b - i][c] &amp;&amp; !dp[i][j][c - <span class="number">2</span>]) </span><br><span class="line">            cnt++, tmpa = i, tmpb = j;</span><br><span class="line">    <span class="keyword">return</span> cnt == <span class="number">1</span> &amp;&amp; a == tmpa &amp;&amp; b == tmpb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check4</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, tmpa, tmpb;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, j;i * i &lt;= a * b &amp;&amp; cnt &lt; <span class="number">2</span>;i++)</span><br><span class="line">        <span class="keyword">if</span> (a * b % i == <span class="number">0</span> &amp;&amp; dp[i][j = a * b / i][c] &amp;&amp; !dp[i][j][c - <span class="number">2</span>])</span><br><span class="line">            cnt++, tmpa = i, tmpb = j;</span><br><span class="line">    <span class="keyword">return</span> cnt == <span class="number">1</span> &amp;&amp; a == tmpa &amp;&amp; b == tmpb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">8</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, flag; <span class="built_in">scanf</span>(<span class="string">"%d%s%d"</span>, &amp;m, name + <span class="number">1</span>, &amp;t), flag = name[<span class="number">1</span>] == <span class="string">'B'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= t + <span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = m;a &lt;= N / <span class="number">2</span>;a++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = a;b &lt;= N;b++)</span><br><span class="line">                dp[a][b][i] = dp[a][b][i - <span class="number">2</span>] | (((i &amp; <span class="number">1</span>) ^ flag ^ <span class="number">1</span>) ? check1(a, b, i) : check2(a, b, i));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = m * <span class="number">2</span>;s;s++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = m, b = s - a;a * <span class="number">2</span> &lt;= s;a++, b = s - a)</span><br><span class="line">            <span class="keyword">if</span> (dp[a][b][t + <span class="number">1</span>] &amp;&amp; !(dp[a][b][t - <span class="number">1</span>] | dp[a][b][t])) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = t &amp; <span class="number">1</span> ^ flag;</span><br><span class="line">                <span class="keyword">if</span> (!(tmp ? check4(a, b, t + <span class="number">1</span>) : check3(a, b, t + <span class="number">1</span>))) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">' '</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/16/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="PlanarG"
      src="/images/77041874_p0_master12001.jpg">
  <p class="site-author-name" itemprop="name">PlanarG</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">191</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">65</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://planarg.top/" title="https:&#x2F;&#x2F;planarg.top&#x2F;">Title</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">PlanarG</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1.5,"jsonPath":"/live2dw/assets/histoire.model.json"},"display":{"position":"left","width":150,"height":300,"hOffset":35,"vOffset":-25},"mobile":{"show":false},"log":false});</script></body>
</html>
