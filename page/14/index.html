<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="PlanarG&#39;s blog">
<meta property="og:url" content="http://yoursite.com/page/14/index.html">
<meta property="og:site_name" content="PlanarG&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="PlanarG">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/14/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>PlanarG's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">PlanarG's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-友链">

    <a href="/friends/" rel="section"><i class="fa fa-fw fa-user"></i>友链</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/25/4-24%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/25/4-24%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/" class="post-title-link" itemprop="url">4.24省选模拟</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-25 14:31:53" itemprop="dateCreated datePublished" datetime="2019-04-25T14:31:53+08:00">2019-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:27:15" itemprop="dateModified" datetime="2020-04-23T09:27:15+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="T1-密文"><a href="#T1-密文" class="headerlink" title="T1 密文"></a>T1 密文</h1><p><img src="https://i.loli.net/2019/04/25/5cc157597b96f.png" alt="1556174666712"></p>
<p><img src="https://i.loli.net/2019/04/25/5cc15778b7aa2.png" alt="1556174705013"></p>
<p>知道密文的每一位，等于知道密文的每一个前缀和，或者任意两个前缀的异或和</p>
<p>而每次操作得到的其实就是两个前缀和的异或和</p>
<p>假设这次我们询问了$a,b$这两个前缀，下次询问了$b,c$这两个前缀，那么我们就知道了$a,c$的异或和是多少</p>
<p>将前缀看作点，如果我们询问了$a,b$这两个前缀，那么我们就用一条权值为询问代价的边将这两个点连接起来</p>
<p>最优的方案一定是连成了一棵生成树，因为所有非树边都是不必要的，任意两个前缀的异或和等于它们在树上路径所经过边的权值的异或和</p>
<p>所以这个题就是最小异或和生成树，共$n+1$个节点，即$n+1$个前缀和</p>
<p>关于最小异或和生成树，可以在<code>trie</code>上分治，每次按照最高位将当前点集分为最高位为0以及最高位为1的两个部分，将这两个部分各自连通，然后用一条权值最小的边连通这两个集合</p>
<p>我们每次枚举小的那个集合中的所有数，然后放到大的那个集合里面暴力查异或最小值即可</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="keyword">int</span> trie[N * <span class="number">31</span>][<span class="number">2</span>], sz[N * <span class="number">31</span>], ncnt = <span class="number">1</span>, dep[N * <span class="number">31</span>]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num[N * <span class="number">31</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> now = <span class="number">1</span>, i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> nxt = v &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!trie[now][nxt]) trie[now][nxt] = ++ncnt, dep[ncnt] = dep[now] - <span class="number">1</span>;</span><br><span class="line">        now = trie[now][nxt], sz[now]++, num[now].push_back(v);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; <span class="number">0</span> || !u) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">int</span> t = x &gt;&gt; dep[u] &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (trie[u][t]) <span class="keyword">return</span> query(trie[u][t], x);</span><br><span class="line">    <span class="keyword">return</span> query(trie[u][t ^ <span class="number">1</span>], x) + (<span class="number">1</span> &lt;&lt; dep[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u || dep[u] &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    divide(trie[u][<span class="number">0</span>]), divide(trie[u][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> v = sz[trie[u][<span class="number">0</span>]] &lt; sz[trie[u][<span class="number">1</span>]] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> t = ~<span class="number">0U</span> &gt;&gt; <span class="number">1</span>, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; sz[trie[u][v]];i++) </span><br><span class="line">        t = min(t, query(trie[u][v ^ <span class="number">1</span>], num[trie[u][v]][i]) + (<span class="number">1</span> &lt;&lt; dep[u])), flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag) ans += t;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"secret.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"secret.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), dep[<span class="number">1</span>] = <span class="number">30</span>, insert(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ls = <span class="number">0</span>, i = <span class="number">1</span>, a;i &lt;= n;i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), ls ^= a, insert(ls);</span><br><span class="line">    divide(<span class="number">1</span>), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-最短路"><a href="#T2-最短路" class="headerlink" title="T2 最短路"></a>T2 最短路</h1><p><img src="https://i.loli.net/2019/04/25/5cc1595fac06a.png" alt="1556175190678"></p>
<p><img src="https://i.loli.net/2019/04/25/5cc1597a52891.png" alt="1556175217309"></p>
<p>数据太水，本来只能拿30分的算法拿了71分</p>
<p>对于这$30\%$的数据做法比较简单，建出最短路<code>DAG</code>，然后<code>DAG</code>上的边边权为<code>inf</code>，将每个点拆成两个点，中间连一条权值为1的边，然后跑一遍起点到终点的最大流就可以得出最少需要让多少个点+1才能使得最短路变长</p>
<p>对于所有数据，我们考虑这样建图</p>
<p>首先二分答案<code>mid</code>，然后建<code>mid + 1</code>层点，第$i$层的点表示路径长度为$i-1$</p>
<p>每一层都有$n$个点$s$以及它们的虚点$t$，将每一层的点向那一层中对应的虚点连边，如果是$1,n$号点就连<code>inf</code>，否则连1</p>
<p>对于第$i$层到第$i+1$层，我们将原图中所有的边连上。比如原图中有一条$u\rightarrow v$的边，那么我们就从这一层的$t_u$向下一层的$s_v$连边，权值为<code>inf</code></p>
<p>为了保证每个点最多只会被加一次，对于每一层的点$s_i$，我们从它向下一层的$t_i$连一条边，权值为<code>inf</code></p>
<p>然后需要加的点数就是第一层中$s_1$到最后一层中$t_n$的最大流，这样才能表示答案<strong>大于</strong><code>mid</code></p>
<p>这样建图的原因是，每在这张图上经过一条原图的边，就会从第$i$层到达第$i+1$层，含义就是路径长度$+1$</p>
<p>如果我们割掉了某个点$s$到$t$的边，那么所有到达$s$的路径都只能经过$s$到下一层的$t$的这条边，那么相对应地，长度就$+1$</p>
<p>而这样建图的话，在不同层中多次割掉同一个点$s\rightarrow t$的边是不优秀的，在最大流中选择割掉的那一条边一定是第一次到达这个点的时刻所对应的那条边</p>
<p>因为无论是否让$u$这个点的权值$+1$，在第$t$时刻到达$u$的路径一定可以在比$t$更晚的时刻到达$u$，所以割掉后面的边是没有好处的，不会出现在最大流中</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;</span><br><span class="line">&#125; e[N * <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt = <span class="number">1</span>, dep[N], cur[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from], w&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to], <span class="number">0</span>&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dep)), dep[s] = <span class="number">0</span>; <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; q.push(s);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">            <span class="keyword">if</span> (e[i].w &amp;&amp; dep[e[i].to] == <span class="number">-1</span>) &#123;</span><br><span class="line">                dep[e[i].to] = dep[u] + <span class="number">1</span>, q.push(e[i].to);</span><br><span class="line">                <span class="keyword">if</span> (e[i].to == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == t || !f) <span class="keyword">return</span> f; <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u], tmp; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].w &amp;&amp; dep[e[i].to] == dep[u] + <span class="number">1</span> &amp;&amp; (tmp = DFS(e[i].to, min(f, e[i].w), t))) &#123;</span><br><span class="line">            res += tmp, f -= tmp, e[i].w -= tmp, e[i ^ <span class="number">1</span>].w += tmp;</span><br><span class="line">            <span class="keyword">if</span> (!f) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (BFS(s, t)) <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span>(head)), res += DFS(s, <span class="number">1e9</span>, t);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N]; <span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ID</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> type, <span class="keyword">int</span> layer)</span> </span>&#123;<span class="keyword">return</span> n * <span class="number">2</span> * layer + n * type + u;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head)), ecnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= mid; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++) &#123;</span><br><span class="line">            adde(ID(j, <span class="number">0</span>, i), ID(j, <span class="number">1</span>, i), j == <span class="number">1</span> ? <span class="number">1e9</span> : <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; mid) adde(ID(j, <span class="number">0</span>, i), ID(j, <span class="number">1</span>, i + <span class="number">1</span>), <span class="number">1e9</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; mid) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[j]) adde(ID(j, <span class="number">1</span>, i), ID(v, <span class="number">0</span>, i + <span class="number">1</span>), <span class="number">1e9</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; mid) adde(ID(n, <span class="number">0</span>, i), ID(n, <span class="number">0</span>, i + <span class="number">1</span>), <span class="number">1e9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Dinic(ID(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), ID(n, <span class="number">0</span>, mid));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"min.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"min.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> m, k; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), a++, b++, G[a].push_back(b), G[b].push_back(a);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">2</span> * n, mid, ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Solve(mid = (l + r) &gt;&gt; <span class="number">1</span>) &lt;= k) ans = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-特技飞行"><a href="#T3-特技飞行" class="headerlink" title="T3 特技飞行"></a>T3 特技飞行</h1><p>题目太长，这里只给出简单的描述</p>
<p>有$n$架飞机，它们的航线对应着起点在$x=x_0$，终点在$x=x_1$的一条线段，它们的水平速度相同</p>
<p>当两架飞机相遇的时候，它们可以选择互换航线，获得$b$的分数；或者不交换，获得$a$的分数，但是要保证到达$x=x_1$的时候这些飞机从上到下的顺序仍然是起飞时的顺序</p>
<p>有$k$个观众，第$i$个观众的位置是$(p_i,q_i)$，观察距离是$r_i$，会查看$|x-p_i|+|y-q_i|\leq r_i$的所有相遇事件</p>
<p>当一个相遇事件被至少一名观众观察到，那么就可以获得$c$的分数</p>
<p>输出最终得分的最小值以及最大值</p>
<p><img src="https://i.loli.net/2019/04/25/5cc15d961a45e.png" alt="1556176268396"></p>
<p>首先可以看出，$c$是强行拼上去的，跟是否选择互换航线没有任何关系</p>
<p>那么我们可以算出$c$对答案的最终贡献是什么</p>
<p>显然对于两条有交点的线段$i,j$，必须满足$y_{i,0}<y_{j,0},y_{i,1}>y_{j,1}$</p>
<p>扫描线一下，同时使用一个<code>set</code>维护就可以求出所有交点</p>
<p>题目中给出的那个限制实际上是曼哈顿距离$\leq r$</p>
<p>那么我们有一个套路就是将坐标$x,y$变换成$x+y,x-y$</p>
<p>那么限制就变成了$p’-r\leq x’\leq p’+r,q’-r\leq y’\leq q’+r$，对应一个矩形范围</p>
<p>将所有转换后的坐标离散化，然后从上到下扫描线，用一个树状数组维护每个点的覆盖次数就可以了</p>
<p>我们再来考虑最终结果的最大/最小值</p>
<p>首先一定有一种方案是每次相遇都交换，这样最终的相对顺序一定是不变的，产生的要么是最大值，要么是最小值</p>
<p>另一种方案就是让交换的次数尽量少</p>
<p>我们考虑如果每次都不交换会发生什么</p>
<p>最终对应的从上到下的顺序是原顺序的一个置换，我们要让最终顺序等于原顺序</p>
<p>我们可以进行的操作是，每次选择两个位置，然后交换它们的排名</p>
<p>这种操作是一定可以成功的，因为我们只需要在这两架飞机相交的时候选择交换位置即可达到交换最终顺序的结果</p>
<p>所以操作等价于：给出一个置换，每次可以交换其中的任意两个数，问最少步数使得置换变成原排列</p>
<p>显然对于每一长度为$l$的环，我们只需要交换$l-1$次，那么最少的交换次数就是$n-$环的个数</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Vector Point</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point (<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    Point <span class="keyword">operator</span> + (<span class="keyword">const</span> Vector &amp;b) &#123;<span class="keyword">return</span> Point(x + b.x, y + b.y);&#125;</span><br><span class="line">    Vector <span class="keyword">operator</span> - (<span class="keyword">const</span> Point &amp;b) &#123;<span class="keyword">return</span> Vector(x - b.x, y - b.y);&#125;</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span> ^ (<span class="keyword">const</span> Vector &amp;b) &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125;</span><br><span class="line">    Vector <span class="keyword">operator</span> * (<span class="keyword">double</span> b) &#123;<span class="keyword">return</span> Vector(x * b, y * b);&#125;</span><br><span class="line">&#125; x[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span>Point a, b;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">Inter</span><span class="params">(Line a, Line b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> t = ((b.b - b.a) ^ (a.a - b.a)) / ((a.b - a.a) ^ (b.b - b.a));</span><br><span class="line">    <span class="keyword">return</span> a.a + (a.b - a.a) * t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> id[N], mark[N], t1[N], t2[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;<span class="keyword">if</span> (!mark[u]) mark[u] = <span class="number">1</span>, dfs(id[u]);&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;int, int&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIT set<span class="meta-string">&lt;P &gt;::iterator</span></span></span><br><span class="line"><span class="built_in">set</span>&lt;P &gt; s;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> t2[i] &lt; t2[j];&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> y; <span class="keyword">int</span> x1, x2, op;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Query &amp;b) <span class="keyword">const</span> &#123;<span class="keyword">return</span> y &lt; b.y;&#125;</span><br><span class="line">&#125; q[N];</span><br><span class="line"><span class="keyword">int</span> tree[N * <span class="number">2</span>], top;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;x;x -= x &amp; -x) tree[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;x &lt;= top;x += x &amp; -x) res += tree[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> zjk[N * <span class="number">5</span>]; <span class="keyword">int</span> cnt, watchx[N], watchy[N], r[N], qcnt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(Point i, Point j)</span> </span>&#123;<span class="keyword">return</span> i.x - i.y &lt; j.x - j.y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"aerobatics.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"aerobatics.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n, a, b, c, X1, X2, tot = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d"</span>, &amp;n, &amp;a, &amp;b, &amp;c, &amp;X1, &amp;X2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t1[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t2[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        SIT it = s.lower_bound(P(t2[i], i));</span><br><span class="line">        <span class="keyword">if</span> (it != s.end()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (SIT it2 = it;it2 != s.end();it2++) &#123;</span><br><span class="line">                Line a = (Line)&#123;Point(X1, t1[it2-&gt;second]), Point(X2, t2[it2-&gt;second])&#125;, </span><br><span class="line">                    b = (Line)&#123;Point(X1, t1[i]), Point(X2, t2[i])&#125;;</span><br><span class="line">                x[++tot] = Inter(a, b);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        s.insert(P(t2[i], i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) id[i] = i;</span><br><span class="line">    sort(id + <span class="number">1</span>, id + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span> (!mark[i]) dfs(i), cnt++;</span><br><span class="line">    <span class="keyword">int</span> s1 = tot * a, s2 = (tot - n + cnt) * b + (n - cnt) * a;</span><br><span class="line">    <span class="keyword">if</span> (s1 &gt; s2) swap(s1, s2);</span><br><span class="line">    <span class="keyword">int</span> k; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tot;i++) zjk[++cnt] = x[i].x + x[i].y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;watchx[i], &amp;watchy[i], &amp;r[i]), zjk[++cnt] = watchx[i] + watchy[i] - r[i], zjk[++cnt] = watchx[i] + watchy[i] + r[i];</span><br><span class="line">    sort(zjk + <span class="number">1</span>, zjk + cnt + <span class="number">1</span>), cnt = unique(zjk + <span class="number">1</span>, zjk + cnt + <span class="number">1</span>) - zjk - <span class="number">1</span>, top = cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = lower_bound(zjk + <span class="number">1</span>, zjk + cnt + <span class="number">1</span>, watchx[i] + watchy[i] - r[i]) - zjk, </span><br><span class="line">            b = lower_bound(zjk + <span class="number">1</span>, zjk + cnt + <span class="number">1</span>, watchx[i] + watchy[i] + r[i]) - zjk;</span><br><span class="line">        q[++qcnt] = (Query)&#123;watchx[i] - watchy[i] - r[i], a, b, <span class="number">0</span>&#125;, q[++qcnt] = (Query)&#123;watchx[i] - watchy[i] + r[i] + <span class="number">1e-5</span>, a, b, <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(x + <span class="number">1</span>, x + tot + <span class="number">1</span>, cmp2), sort(q + <span class="number">1</span>, q + qcnt + <span class="number">1</span>); <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, cur = <span class="number">1</span>;i &lt;= qcnt;i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt;= tot &amp;&amp; x[cur].x - x[cur].y &lt; q[i].y) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = lower_bound(zjk + <span class="number">1</span>, zjk + cnt + <span class="number">1</span>, x[cur].x + x[cur].y) - zjk;</span><br><span class="line">            <span class="keyword">if</span> (query(a) &gt;= <span class="number">1</span>) res++;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q[i].op) update(q[i].x2, <span class="number">-1</span>), update(q[i].x1 - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> update(q[i].x2, <span class="number">1</span>), update(q[i].x1 - <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, s1 + c * res, s2 + c * res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T4-吃"><a href="#T4-吃" class="headerlink" title="T4 吃"></a>T4 吃</h1><p><img src="https://i.loli.net/2019/04/25/5cc160fe35890.png" alt="1556177141042"></p>
<p><img src="https://i.loli.net/2019/04/25/5cc1611bcf07f.png" alt="1556177171716"></p>
<p>我们考虑这样统计答案：记$E(u,v)$表示当$u$被删除的时候，$v$仍与$u$连通的概率</p>
<p>那么答案就是</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\sum_{j=1}^nE(i,j)</script><p>很显然，给出的图是一棵基环树</p>
<p>我们考虑这两种点对：</p>
<ul>
<li>点$u,v$都在同一棵树上</li>
</ul>
<p>很显然此时的$E(u,v)=\frac{1}{dis(u,v)}$，因为需要保证$u$是$u,v$这条路径上第一被删除的点</p>
<p>可以使用点分治+<code>FFT</code>统计每种$dis$的方案数，最后再计算这一类点对的答案</p>
<ul>
<li>点$u,v$在不同的树上</li>
</ul>
<p>我们假设从$u$到$v$，必须经过的路径长度为$c$</p>
<p>在环上，$u$的根节点到$v$的根节点显然有两条路径，我们记它们的长度分别为$x,y$</p>
<p>那么显然，如果在$u$被删除的时候$u,v$仍然连通，那么要么是$c+x$这条路径没有被删除，概率为$\frac{1}{c+x}$，要么是$c+y$这条路径没有被删除，概率为$\frac{1}{c+y}$</p>
<p>注意此时我们重复统计了这两条路径都没有被删除的概率，为$\frac{1}{c+x+y}$</p>
<p>所以此时有</p>
<script type="math/tex; mode=display">
E(u,v)=\frac{1}{c+x}+\frac{1}{c+y}-\frac{1}{c+x+y}</script><p>我们考虑如何计算</p>
<p>首先随便断开环上的一条边，将环变成一条链，然后在链上分治</p>
<p>设$x$是经过链的路径，$y$是经过被破坏边的路径</p>
<p>我们选择当前区间的中点，显然从中点或者中点左边到中点右边的$x$路径一定会经过这个中点</p>
<p>那么我们可以利用这个性质将$x$分成两半，假设两个根节点分别为$u,v$</p>
<p>分成的这两半即为$u$到中点的路径，减去$v$到中点的路径</p>
<p>与之前相似，我们同样可以计算每一种$c+x$的方案数，即中点及左边多项式的和，乘上中点右边多项式的和，再加上两边分治的结果</p>
<p>$c+y$与之类似，注意$c+x+y$是不用分治的，因为$x+y$就是环长</p>
<p>代码就咕了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/23/TopTree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/23/TopTree/" class="post-title-link" itemprop="url">TopTree</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-23 08:21:54" itemprop="dateCreated datePublished" datetime="2019-04-23T08:21:54+08:00">2019-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:11:35" itemprop="dateModified" datetime="2020-04-23T09:11:35+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><code>TopTree</code>可以说是<code>LCT</code>的扩展，<code>LCT</code>支持链上的修改与查询，而<code>TopTree</code>可以支持链与子树的修改与查询</p>
<p><code>TopTree</code>的思想与<code>LCT</code>及其相似，都是将树进行轻重链剖分。但是与<code>LCT</code>不同的是，<code>TopTree</code>会单独维护某个节点的每个虚子树，而非简单地维护虚子树对当前点的贡献</p>
<p><code>TopTree</code>的时间复杂度为每次操作$O(\log n)$，但是常数巨大无比，为$97$</p>
<p>做好码<code>7168+b</code>的准备</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>让我们先从一道<del>神仙</del>题开始</p>
<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3153" target="_blank" rel="noopener">BZOJ3153</a></p>
<p>题意：有一棵树，每个点有一个权值，需要支持12个操作</p>
<ul>
<li>换根</li>
<li>路径加/路径覆盖</li>
<li>子树加/子树覆盖</li>
<li>查询路径的和/最大值/最小值</li>
<li>查询子树的和/最大值/最小值</li>
<li>换父亲</li>
</ul>
<h1 id="虚点Splay"><a href="#虚点Splay" class="headerlink" title="虚点Splay"></a>虚点<code>Splay</code></h1><p>对于一个点$u$，在<code>LCT</code>上的<code>splay</code>中我们维护了它的两个儿子</p>
<p>左儿子代表重链上比它高的节点，右儿子代表重链上比它低的节点</p>
<p>在<code>TopTree</code>中，每个点我们还要额外维护一个<code>splay</code>，这个<code>splay</code>上挂的点是以虚边的形式与$u$相连的点</p>
<p>举个例子</p>
<p><img src="https://i.loli.net/2019/04/23/5cbe6488ac1fd.png" alt="1555981442131"></p>
<p>图中的实线代表重边，虚线代表轻边</p>
<p>注意$\{1,4,7\}$单独是一棵<code>splay</code>,即$1$的虚儿子构成的<code>splay</code></p>
<p>我们称在原树中出现的点为<strong>实点</strong>，在原树中未出现的点为<strong>虚点</strong></p>
<p>那么在由某个点虚儿子构成的<code>splay</code>中，每一个实点都是<strong>叶子节点</strong>，除根节点外，每个非叶子节点都是<strong>虚点</strong></p>
<p>另一个例子</p>
<p><img src="https://i.loli.net/2019/04/23/5cbe66f56612a.png" alt="1555982055658"></p>
<p>注意到根节点有$4$个虚子树，所以必须新建两个虚点来维护这些虚子树，图中的橙色节点就是虚点，图中的虚边即为虚子树<code>splay</code></p>
<p>那么每个点我们维护$4$个儿子<code>ch[0 - 3][u]</code>，前两个儿子表示正常<code>LCT</code>中的儿子，即重链<code>splay</code>的左右儿子；后两个儿子表示虚子树中的两个儿子</p>
<p>显然虚点是没有前两个儿子的</p>
<h1 id="新的Rotate-Splay"><a href="#新的Rotate-Splay" class="headerlink" title="新的Rotate, Splay"></a>新的<code>Rotate, Splay</code></h1><p>如果一个虚点的<code>splay</code>转到实点里面去了，显然是不行的</p>
<p>所以对于虚点、实点我们需要单独<code>rotate, splay</code></p>
<p>注意<code>splay</code>时无论当前点是否为根节点，我们都要<code>pushup</code>一次</p>
<p>所以<code>rotate</code>的时候改一改，再在<code>splay</code>的最后加上一次<code>pushup</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> son)</span> </span>&#123;<span class="keyword">if</span> (u) fa[u] = f; ch[son][f] = u;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = fa[u], tmp = (ch[type + <span class="number">1</span>][f] == u) + type, ff = fa[f];</span><br><span class="line">    <span class="keyword">if</span> (ff) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) <span class="keyword">if</span> (ch[i][ff] == f) ch[i][ff] = u;</span><br><span class="line">    fa[u] = ff, Connect(ch[tmp ^ <span class="number">1</span>][u], f, tmp), Connect(f, u, tmp ^ <span class="number">1</span>), Pushup(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>type = 0</code>代表是原树，<code>type = 2</code>代表是虚树</p>
<p>其实跟原来的<code>rotate</code>差不多</p>
<p><code>splay</code>同理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Splay</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = u, top = <span class="number">0</span>; st[++top] = now;</span><br><span class="line">    <span class="keyword">while</span> (!Isroot(now, type)) st[++top] = now = fa[now];</span><br><span class="line">    <span class="keyword">while</span> (top) Pushdown(st[top--]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> f;!Isroot(u, type);Rotate(u, type)) </span><br><span class="line">        <span class="keyword">if</span> (!Isroot(f = fa[u], type))</span><br><span class="line">            Rotate((ch[type][f] == u) ^ (ch[type][fa[f]] == f) ? u : f, type); </span><br><span class="line">    Pushup(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="新的Pushdown"><a href="#新的Pushdown" class="headerlink" title="新的Pushdown"></a>新的<code>Pushdown</code></h1><p>在树上，我们需要维护两个标记</p>
<p>第一个是给重链打上的标记</p>
<p>第二个是给重链<code>splay</code>中它的后代的所有虚子树打上的标记（不包括重链节点）</p>
<p>显然虚点只有第二种标记</p>
<p>我们分以下几种情况讨论：</p>
<ul>
<li>当前点是实点，下放到重链上的左右儿子</li>
</ul>
<p>首先标记应该下传，同时给这两个儿子的点权打上第一个标记</p>
<p>注意第二个标记不会对这两个点权产生影响，因为它是给虚子树打的</p>
<ul>
<li>当前点是实点，下放到虚点</li>
</ul>
<p>第一个标记没有必要下方，只需要下方第二种标记</p>
<ul>
<li>当前点是实点，下放到一个非重链实点</li>
</ul>
<p>此时除了修改点权，还应将这个儿子的点权打上这两种标记</p>
<p>因为此时这个儿子是当前点的一个虚儿子</p>
<ul>
<li>当前点是虚点，下放到一个实点</li>
</ul>
<p>同上</p>
<ul>
<li>当前点是虚点，下放到虚点</li>
</ul>
<p>直接下传标记即可</p>
<p>注意翻转标记不应该传入虚子树的<code>splay</code>中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushdown</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (rev[u]) Rev(ch[<span class="number">0</span>][u]), Rev(ch[<span class="number">1</span>][u]), rev[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!in[u] &amp;&amp; tag[u].marked()) </span><br><span class="line">        Tag_Line(ch[<span class="number">0</span>][u], tag[u]), Tag_Line(ch[<span class="number">1</span>][u], tag[u]), tag[u] = Tag();</span><br><span class="line">    <span class="keyword">if</span> (T_tag[u].marked()) &#123;</span><br><span class="line">        Tag_Tree(ch[<span class="number">0</span>][u], T_tag[u], <span class="number">0</span>), Tag_Tree(ch[<span class="number">1</span>][u], T_tag[u], <span class="number">0</span>);</span><br><span class="line">        Tag_Tree(ch[<span class="number">2</span>][u], T_tag[u], <span class="number">1</span>), Tag_Tree(ch[<span class="number">3</span>][u], T_tag[u], <span class="number">1</span>), T_tag[u] = Tag();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>marked</code>代表是否有下传的必要</p>
<p><code>tag</code>是给重链打的标记</p>
<p><code>T_...</code>代表虚子树的信息或者标记</p>
<p><code>Tag_line</code>与<code>Tag_Tree</code>，分别是给链/树打标记</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Tag_Line</span><span class="params">(<span class="keyword">int</span> u, Tag t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>;</span><br><span class="line">    sum[u] += t, A_sum[u] = sum[u] + T_sum[u], val[u] = Get(val[u], t), tag[u] += t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Tag_Tree</span><span class="params">(<span class="keyword">int</span> u, Tag t, <span class="keyword">int</span> type)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>;</span><br><span class="line">    T_sum[u] += t, T_tag[u] += t;</span><br><span class="line">    <span class="keyword">if</span> (!in[u] &amp;&amp; type) Tag_Line(u, t); <span class="keyword">else</span> A_sum[u] = sum[u] + T_sum[u];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>A_sum</code>代表全部信息</p>
<p><code>Get(x, t)</code>代表$x$在标记$t$的作用下的值</p>
<p><code>in</code>代表是否为虚点</p>
<h1 id="新的Pushup"><a href="#新的Pushup" class="headerlink" title="新的Pushup"></a>新的<code>Pushup</code></h1><p>同样，我们分虚子树信息/重链信息以及全部信息来统计答案</p>
<p>分情况讨论</p>
<ul>
<li>当前点是虚点，子树也是虚点</li>
</ul>
<p>当前点虚子树信息为子树虚子树信息的和，此时虚子树信息就是全部信息</p>
<ul>
<li>当前点是虚点，子树是实点</li>
</ul>
<p>当前点虚子树信息为子树全部信息</p>
<ul>
<li>当前点是实点，子树是虚点</li>
</ul>
<p>只更新子树信息与子树全部信息</p>
<ul>
<li>当前点是实点，子树是重链上的点</li>
</ul>
<p>只更新重链信息与子树全部信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushup</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    T_sum[u] = Data();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>;i++) <span class="keyword">if</span> (ch[i][u]) T_sum[u] += T_sum[ch[i][u]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">3</span>;i++) <span class="keyword">if</span> (ch[i][u]) T_sum[u] += A_sum[ch[i][u]];</span><br><span class="line">    <span class="keyword">if</span> (in[u]) sum[u] = Data(), A_sum[u] = T_sum[u];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        sum[u] = Data(val[u]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>;i++) <span class="keyword">if</span> (ch[i][u]) sum[u] += sum[ch[i][u]];</span><br><span class="line">        A_sum[u] = sum[u] + T_sum[u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="新的操作Add"><a href="#新的操作Add" class="headerlink" title="新的操作Add"></a>新的操作<code>Add</code></h1><p>$Add(x,y)$表示从$x$向$y$连一条虚边</p>
<p>方式其实很暴躁，就是一直跳左儿子，最后再新建一个虚点$v$，将当前点挂在$v$上面</p>
<p><img src="https://i.loli.net/2019/04/23/5cbef3dd1b777.png" alt="1556018128092"></p>
<p>图中黄色节点代表$v$</p>
<p>注意在跳左儿子的时候要顺便<code>pushdown</code></p>
<p>最后别忘了将新添加的点旋转到<code>splay</code>的根</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (!y) <span class="keyword">return</span>; Pushdown(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">3</span>;i++) <span class="keyword">if</span> (!ch[i][x]) <span class="keyword">return</span> <span class="keyword">void</span>(Connect(y, x, i));</span><br><span class="line">    <span class="keyword">while</span> (ch[<span class="number">2</span>][x] &amp;&amp; in[ch[<span class="number">2</span>][x]]) x = ch[<span class="number">2</span>][x], Pushdown(x);</span><br><span class="line">    <span class="keyword">int</span> u = Create();</span><br><span class="line">    Connect(ch[<span class="number">2</span>][x], u, <span class="number">2</span>), Connect(y, u, <span class="number">3</span>), Connect(u, x, <span class="number">2</span>), Splay(u, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="新的操作Del"><a href="#新的操作Del" class="headerlink" title="新的操作Del"></a>新的操作<code>Del</code></h1><p>$Del(u)$表示删除$u$与其父亲相连的虚边</p>
<p>注意到每次$Add$操作都会新建一个点，那么$Del$操作我们也只需要删除一个点就可以保证空间为$O(n)$</p>
<p>如果$u$与其父亲直接相连，那么断开这条虚边就好了</p>
<p>否则我们找到$u$的虚点父亲$f$，先将$f$及它的祖先像<code>splay</code>一样<code>pushdown</code>，然后尝试删除$f$</p>
<p>注意此时也要<code>splay</code>来保证复杂度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Child</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) <span class="keyword">if</span> (ch[i][fa[u]] == u) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Del</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>; Splay(u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fa[u]) <span class="keyword">return</span>; <span class="keyword">int</span> f = fa[u];</span><br><span class="line">    <span class="keyword">if</span> (in[f]) &#123;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>, now = f, ff = fa[f]; st[++top] = now;</span><br><span class="line">        <span class="keyword">while</span> (!Isroot(now, <span class="number">2</span>)) st[++top] = now = fa[now];</span><br><span class="line">        <span class="keyword">while</span> (top) Pushdown(st[top--]);</span><br><span class="line">        <span class="keyword">if</span> (ff) &#123;<span class="keyword">int</span> other = ch[Child(u) ^ <span class="number">1</span>][f]; Pushdown(other), Connect(other, ff, Child(f)), Splay(ff, <span class="number">2</span>);&#125;</span><br><span class="line">        rub[++rcnt] = f;</span><br><span class="line">    &#125; <span class="keyword">else</span> ch[Child(u)][f] = <span class="number">0</span>, Splay(f, <span class="number">0</span>);</span><br><span class="line">    fa[u] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="新的操作Father"><a href="#新的操作Father" class="headerlink" title="新的操作Father"></a>新的操作<code>Father</code></h1><p>$Father(u)$表示找到$u$的以虚边相连的父亲</p>
<p>实现很简单，如果$u$的父亲节点就是原树中的父亲，那么直接返回，否则将这个虚点<code>splay</code>到根，再返回它的父亲</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Father</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Splay(u, <span class="number">0</span>); <span class="keyword">if</span> (!fa[u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!in[fa[u]]) <span class="keyword">return</span> fa[u];</span><br><span class="line">    <span class="keyword">int</span> f = fa[u]; Splay(f, <span class="number">2</span>); <span class="keyword">return</span> fa[f];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="新的Access以及LCA"><a href="#新的Access以及LCA" class="headerlink" title="新的Access以及LCA"></a>新的<code>Access</code>以及<code>LCA</code></h1><p>其实跟<code>LCT</code>的差不多，就是将连边/断边改成<code>Del, Add</code>，将跳父亲改成<code>Father</code></p>
<p>这里提一下如何求两个点的<code>LCA</code>，假设为$u,v$</p>
<p>首先将$u$ $Access$一下，此时$u$到根节点的链已经被打通，那么$v$到根节点的路径一定分为若干段实链与虚边，最后一段实链的最深的那个点就是<code>LCA</code></p>
<p><img src="https://i.loli.net/2019/04/23/5cbef7a2519bf.png" alt="1556019086677"></p>
<p>那么在$Access$的时候，直接返回结束时的<code>ls</code>就好了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ls = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;u;u = Father(ls = u)) </span><br><span class="line">        Splay(u, <span class="number">0</span>), Del(ls), Add(u, ch[<span class="number">1</span>][u]), Connect(ls, u, <span class="number">1</span>), Pushup(u);</span><br><span class="line">    <span class="keyword">return</span> ls;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;Access(x); <span class="keyword">return</span> Access(y);&#125;</span><br></pre></td></tr></table></figure>
<h1 id="一些例行操作"><a href="#一些例行操作" class="headerlink" title="一些例行操作"></a>一些例行操作</h1><p>由于这一部分的代码和<code>LCT</code>几乎是一样的，所以直接贴上来</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Findroot</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    Access(u), Splay(u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (ch[<span class="number">0</span>][u]) u = ch[<span class="number">0</span>][u];</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Makeroot</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;Access(u), Splay(u, <span class="number">0</span>), Rev(u);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;Makeroot(x), Add(y, x), Access(x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Cut</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;Access(u), Splay(u, <span class="number">0</span>), ch[<span class="number">0</span>][u] = fa[ch[<span class="number">0</span>][u]] = <span class="number">0</span>, Pushup(u);&#125; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;Makeroot(x), Access(y), Splay(y, <span class="number">0</span>);&#125;</span><br></pre></td></tr></table></figure>
<h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tag</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> k, b;</span><br><span class="line">    Tag(<span class="keyword">int</span> k = <span class="number">1</span>, <span class="keyword">int</span> b = <span class="number">0</span>) : k(k), b(b) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">marked</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> k != <span class="number">1</span> || b;&#125; </span><br><span class="line">    <span class="keyword">inline</span> Tag <span class="keyword">operator</span> + (<span class="keyword">const</span> Tag &amp;x) &#123;<span class="keyword">return</span> Tag(k * x.k, b * x.k + x.b);&#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> += (<span class="keyword">const</span> Tag &amp;x) &#123;*<span class="keyword">this</span> = *<span class="keyword">this</span> + x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">2147483647</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> x, Tag y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y.k + y.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> sum, mn, mx, sz;</span><br><span class="line">    Data() &#123;sum = sz = <span class="number">0</span>, mn = INF, mx = -INF;&#125;</span><br><span class="line">    Data(<span class="keyword">int</span> x) &#123;sum = mn = mx = x, sz = <span class="number">1</span>;&#125;</span><br><span class="line">    Data(<span class="keyword">int</span> sum, <span class="keyword">int</span> mn, <span class="keyword">int</span> mx, <span class="keyword">int</span> sz) : sum(sum), mn(mn), mx(mx), sz(sz) &#123;&#125;</span><br><span class="line">    <span class="keyword">inline</span> Data <span class="keyword">operator</span> + (<span class="keyword">const</span> Data &amp;x) &#123;<span class="keyword">return</span> Data(sum + x.sum, min(mn, x.mn), max(mx, x.mx), sz + x.sz);&#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> += (<span class="keyword">const</span> Data &amp;x) &#123;*<span class="keyword">this</span> = *<span class="keyword">this</span> + x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> Data <span class="keyword">operator</span> + (<span class="keyword">const</span> Data &amp;a, <span class="keyword">const</span> Tag &amp;b) &#123;<span class="keyword">return</span> a.sz ? Data(a.sum * b.k + a.sz * b.b, Get(a.mn, b), Get(a.mx, b), a.sz) : a;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> += (Data &amp;a, <span class="keyword">const</span> Tag &amp;b) &#123;a = a + b;&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="keyword">int</span> fa[N], ch[<span class="number">4</span>][N], ncnt, rt, rev[N], in[N], val[N], rub[N], rcnt;</span><br><span class="line">Data sum[N], T_sum[N], A_sum[N]; Tag tag[N], T_tag[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Isroot</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> type)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (type) <span class="keyword">return</span> !fa[u] || !in[fa[u]] || !in[u] || !u;</span><br><span class="line">    <span class="keyword">return</span> (ch[<span class="number">0</span>][fa[u]] != u &amp;&amp; ch[<span class="number">1</span>][fa[u]] != u) || !fa[u] || in[fa[u]] || in[u] || !u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rev</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>;</span><br><span class="line">    swap(ch[<span class="number">0</span>][u], ch[<span class="number">1</span>][u]), rev[u] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Tag_Line</span><span class="params">(<span class="keyword">int</span> u, Tag t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>;</span><br><span class="line">    sum[u] += t, A_sum[u] = sum[u] + T_sum[u], val[u] = Get(val[u], t), tag[u] += t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Tag_Tree</span><span class="params">(<span class="keyword">int</span> u, Tag t, <span class="keyword">int</span> type)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>;</span><br><span class="line">    T_sum[u] += t, T_tag[u] += t;</span><br><span class="line">    <span class="keyword">if</span> (!in[u] &amp;&amp; type) Tag_Line(u, t); <span class="keyword">else</span> A_sum[u] = sum[u] + T_sum[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushdown</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (rev[u]) Rev(ch[<span class="number">0</span>][u]), Rev(ch[<span class="number">1</span>][u]), rev[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!in[u] &amp;&amp; tag[u].marked()) </span><br><span class="line">        Tag_Line(ch[<span class="number">0</span>][u], tag[u]), Tag_Line(ch[<span class="number">1</span>][u], tag[u]), tag[u] = Tag();</span><br><span class="line">    <span class="keyword">if</span> (T_tag[u].marked()) &#123;</span><br><span class="line">        Tag_Tree(ch[<span class="number">0</span>][u], T_tag[u], <span class="number">0</span>), Tag_Tree(ch[<span class="number">1</span>][u], T_tag[u], <span class="number">0</span>);</span><br><span class="line">        Tag_Tree(ch[<span class="number">2</span>][u], T_tag[u], <span class="number">1</span>), Tag_Tree(ch[<span class="number">3</span>][u], T_tag[u], <span class="number">1</span>), T_tag[u] = Tag();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushup</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    T_sum[u] = Data();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>;i++) <span class="keyword">if</span> (ch[i][u]) T_sum[u] += T_sum[ch[i][u]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">3</span>;i++) <span class="keyword">if</span> (ch[i][u]) T_sum[u] += A_sum[ch[i][u]];</span><br><span class="line">    <span class="keyword">if</span> (in[u]) sum[u] = Data(), A_sum[u] = T_sum[u];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        sum[u] = Data(val[u]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>;i++) <span class="keyword">if</span> (ch[i][u]) sum[u] += sum[ch[i][u]];</span><br><span class="line">        A_sum[u] = sum[u] + T_sum[u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> son)</span> </span>&#123;<span class="keyword">if</span> (u) fa[u] = f; ch[son][f] = u;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = fa[u], tmp = (ch[type + <span class="number">1</span>][f] == u) + type, ff = fa[f];</span><br><span class="line">    <span class="keyword">if</span> (ff) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) <span class="keyword">if</span> (ch[i][ff] == f) ch[i][ff] = u;</span><br><span class="line">    fa[u] = ff, Connect(ch[tmp ^ <span class="number">1</span>][u], f, tmp), Connect(f, u, tmp ^ <span class="number">1</span>), Pushup(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Splay</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = u, top = <span class="number">0</span>; st[++top] = now;</span><br><span class="line">    <span class="keyword">while</span> (!Isroot(now, type)) st[++top] = now = fa[now];</span><br><span class="line">    <span class="keyword">while</span> (top) Pushdown(st[top--]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> f;!Isroot(u, type);Rotate(u, type)) </span><br><span class="line">        <span class="keyword">if</span> (!Isroot(f = fa[u], type))</span><br><span class="line">            Rotate((ch[type][f] == u) ^ (ch[type][fa[f]] == f) ? u : f, type); </span><br><span class="line">    Pushup(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = rcnt ? rub[rcnt--] : ++ncnt;</span><br><span class="line">    ch[<span class="number">2</span>][u] = ch[<span class="number">3</span>][u] = <span class="number">0</span>, in[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Child</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) <span class="keyword">if</span> (ch[i][fa[u]] == u) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (!y) <span class="keyword">return</span>; Pushdown(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">3</span>;i++) <span class="keyword">if</span> (!ch[i][x]) <span class="keyword">return</span> <span class="keyword">void</span>(Connect(y, x, i));</span><br><span class="line">    <span class="keyword">while</span> (ch[<span class="number">2</span>][x] &amp;&amp; in[ch[<span class="number">2</span>][x]]) x = ch[<span class="number">2</span>][x], Pushdown(x);</span><br><span class="line">    <span class="keyword">int</span> u = Create();</span><br><span class="line">    Connect(ch[<span class="number">2</span>][x], u, <span class="number">2</span>), Connect(y, u, <span class="number">3</span>), Connect(u, x, <span class="number">2</span>), Splay(u, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Del</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>; Splay(u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fa[u]) <span class="keyword">return</span>; <span class="keyword">int</span> f = fa[u];</span><br><span class="line">    <span class="keyword">if</span> (in[f]) &#123;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>, now = f, ff = fa[f]; st[++top] = now;</span><br><span class="line">        <span class="keyword">while</span> (!Isroot(now, <span class="number">2</span>)) st[++top] = now = fa[now];</span><br><span class="line">        <span class="keyword">while</span> (top) Pushdown(st[top--]);</span><br><span class="line">        <span class="keyword">if</span> (ff) &#123;<span class="keyword">int</span> other = ch[Child(u) ^ <span class="number">1</span>][f]; Pushdown(other), Connect(other, ff, Child(f)), Splay(ff, <span class="number">2</span>);&#125;</span><br><span class="line">        rub[++rcnt] = f;</span><br><span class="line">    &#125; <span class="keyword">else</span> ch[Child(u)][f] = <span class="number">0</span>, Splay(f, <span class="number">0</span>);</span><br><span class="line">    fa[u] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Father</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Splay(u, <span class="number">0</span>); <span class="keyword">if</span> (!fa[u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!in[fa[u]]) <span class="keyword">return</span> fa[u];</span><br><span class="line">    <span class="keyword">int</span> f = fa[u]; Splay(f, <span class="number">2</span>); <span class="keyword">return</span> fa[f];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ls = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;u;u = Father(ls = u)) </span><br><span class="line">        Splay(u, <span class="number">0</span>), Del(ls), Add(u, ch[<span class="number">1</span>][u]), Connect(ls, u, <span class="number">1</span>), Pushup(u);</span><br><span class="line">    <span class="keyword">return</span> ls;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;Access(x); <span class="keyword">return</span> Access(y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Findroot</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    Access(u), Splay(u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (ch[<span class="number">0</span>][u]) u = ch[<span class="number">0</span>][u];</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Makeroot</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;Access(u), Splay(u, <span class="number">0</span>), Rev(u);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;Makeroot(x), Add(y, x), Access(x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Cut</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;Access(u), Splay(u, <span class="number">0</span>), ch[<span class="number">0</span>][u] = fa[ch[<span class="number">0</span>][u]] = <span class="number">0</span>, Pushup(u);&#125; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;Makeroot(x), Access(y), Splay(y, <span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mark_Line</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, Tag t)</span> </span>&#123;Split(x, y), Tag_Line(y, t);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Data <span class="title">Ask_Line</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;Split(x, y); <span class="keyword">return</span> sum[y];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mark_Tree</span><span class="params">(<span class="keyword">int</span> u, Tag t)</span> </span>&#123;</span><br><span class="line">    Access(u), Splay(u, <span class="number">0</span>), val[u] = Get(val[u], t);</span><br><span class="line">    Tag_Tree(ch[<span class="number">2</span>][u], t, <span class="number">1</span>), Tag_Tree(ch[<span class="number">3</span>][u], t, <span class="number">1</span>), Pushup(u), Splay(u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Data <span class="title">Ask_Tree</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    Access(u), Splay(u, <span class="number">0</span>); <span class="function">Data <span class="title">res</span><span class="params">(val[u])</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">3</span>;i++) <span class="keyword">if</span> (ch[i][u]) res += A_sum[ch[i][u]];</span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ed[<span class="number">2</span>][N];</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar(); </span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, q, rt; read(n), read(q), ncnt = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) read(ed[<span class="number">0</span>][i]), read(ed[<span class="number">1</span>][i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) read(val[i]), Pushup(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) Link(ed[<span class="number">0</span>][i], ed[<span class="number">1</span>][i]);</span><br><span class="line">    read(rt), Makeroot(rt);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, x, y, z; read(op);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) read(rt), Makeroot(rt);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">9</span>) &#123;</span><br><span class="line">            read(x), read(y);</span><br><span class="line">            <span class="keyword">if</span> (LCA(x, y) != x) Cut(x), Link(y, x), Makeroot(rt);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">0</span>) read(x), read(y), Mark_Tree(x, Tag(<span class="number">0</span>, y));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">5</span>) read(x), read(y), Mark_Tree(x, Tag(<span class="number">1</span>, y));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) read(x), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ask_Tree(x).mn);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">4</span>) read(x), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ask_Tree(x).mx);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">11</span>) read(x), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ask_Tree(x).sum);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) read(x), read(y), read(z), Mark_Line(x, y, Tag(<span class="number">0</span>, z)), Makeroot(rt);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">6</span>) read(x), read(y), read(z), Mark_Line(x, y, Tag(<span class="number">1</span>, z)), Makeroot(rt);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">7</span>) read(x), read(y), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ask_Line(x, y).mn), Makeroot(rt);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">8</span>) read(x), read(y), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ask_Line(x, y).mx), Makeroot(rt);</span><br><span class="line">        <span class="keyword">else</span> read(x), read(y), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ask_Line(x, y).sum), Makeroot(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个疑问</p>
<p>第159行，将<code>Link(y, x)</code>改为<code>Link(x, y)</code>会错，暂时还不知道为什么</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/18/4-17%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/18/4-17%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/" class="post-title-link" itemprop="url">4.17省选模拟</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-18 19:01:27" itemprop="dateCreated datePublished" datetime="2019-04-18T19:01:27+08:00">2019-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:27:36" itemprop="dateModified" datetime="2020-04-23T09:27:36+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="T1-圈草地"><a href="#T1-圈草地" class="headerlink" title="T1 圈草地"></a>T1 圈草地</h1><p><img src="https://i.loli.net/2019/04/18/5cb8598ea8a77.png" alt="1555585345165"></p>
<p><img src="https://i.loli.net/2019/04/18/5cb859b53dd70.png" alt="1555585452299"></p>
<p>我们只考虑有用的左上角和右下角</p>
<p>考虑两个点$a,b$，如果$a$在$b$的第二象限，那么选择$a$作为左上角一定比选择$b$作为左上角优秀</p>
<p>那么我们将所有有用的点分两层排在一起，第一层是可以作为左上角的点，第二层是可以作为右下角的点</p>
<p><img src="https://i.loli.net/2019/04/18/5cb860d2e1fd7.png" alt="1555587272118"></p>
<p>我们考虑当右下角的点移动的时候左上角的最优决策点会如何变化</p>
<p>假如原来的最优决策点是$a$，另一个在$a$右上角的点是$b$，那么我们可以发现，右下角的点移动之后，$b$与之构成的矩形的面积与$a$与之构成的矩形的面积之差变大了</p>
<p>也就是说，移动之后，$b$会变得更加优秀</p>
<p>所以最优决策点是单调向右上角移动的</p>
<p>我们可以采用分治</p>
<p><code>solve(l, r, L, R)</code>表示右下角的点对应的区间是$[L,R]$，对应的最优决策点的区间是$[l,r]$</p>
<p>我们找到$l,r$的中点$mid$，二分出右下角那些点的最优决策点在$[l,mid]$中</p>
<p>然后继续分治下去</p>
<p>对于找一个矩形内部有多少个点，可以使用主席树</p>
<p>时间复杂度$O(n\log^3n)$</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, lson, rson, sum;</span><br><span class="line">&#125; T[N * <span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> RT[N], ncnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rt = ++ncnt; T[rt].l = l, T[rt].r = r, T[rt].lson = T[rt].rson = T[rt].sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> rt;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; T[rt].lson = build(l, mid), T[rt].rson = build(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> at)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nw = ++ncnt, l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>; T[nw] = T[rt], T[nw].sum++;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> nw;</span><br><span class="line">    <span class="keyword">if</span> (at &lt;= mid) T[nw].lson = update(T[nw].lson, at);</span><br><span class="line">    <span class="keyword">else</span> T[nw].rson = update(T[nw].rson, at);</span><br><span class="line">    <span class="keyword">return</span> nw;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt1, <span class="keyword">int</span> rt2, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt2].l, r = T[rt2].r, mid = (l + r) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> T[rt2].sum - T[rt1].sum;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) res += query(T[rt1].lson, T[rt2].lson, start, end);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; end) res += query(T[rt1].rson, T[rt2].rson, start, end);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125; st1[N], st2[N];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>, top1, top2;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x1 = st1[a].x, y1 = st1[a].y, x2 = st2[b].x, y2 = st2[b].y;</span><br><span class="line">    <span class="keyword">return</span> query(RT[x1 - <span class="number">1</span>], RT[x2], y2, y1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = l, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l;i &lt;= r;i++) <span class="keyword">if</span> (st1[i].x &lt;= st2[x].x &amp;&amp; st2[x].y &lt;= st1[i].y) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = query(i, x);</span><br><span class="line">        <span class="keyword">if</span> (res &lt;= tmp) res = tmp, pos = i;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; mid) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L;i &lt;= R;i++) </span><br><span class="line">            <span class="keyword">if</span> (st1[l].x &lt;= st2[i].x &amp;&amp; st2[i].y &lt;= st1[l].y)</span><br><span class="line">                ans = max(ans, query(l, i));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, l1 = L, r1 = R, m, pos = l1;</span><br><span class="line">    <span class="keyword">while</span> (l1 &lt;= r1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check(l, r, m = ((l1 + r1) &gt;&gt; <span class="number">1</span>), mid)) pos = m, l1 = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r1 = m - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    solve(l, mid, L, pos), solve(mid + <span class="number">1</span>, r, pos + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l;i &lt;= r;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = L;j &lt;= R;j++)</span><br><span class="line">            <span class="keyword">if</span> (st1[i].x &lt;= st2[j].x &amp;&amp; st2[j].y &lt;= st1[i].y)</span><br><span class="line">                ans = max(ans, query(i, j));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), RT[<span class="number">0</span>] = build(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), RT[i] = update(RT[i - <span class="number">1</span>], a);</span><br><span class="line">        <span class="keyword">if</span> (a &gt; st1[top1].y) st1[++top1] = (point)&#123;i, a&#125;;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (top2 &amp;&amp; st2[top2].y &gt; a) top2--;</span><br><span class="line">            st2[++top2] = (point)&#123;i, a&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (top1 &lt;= <span class="number">500</span> &amp;&amp; top2 &lt;= <span class="number">500</span>) solve2(<span class="number">1</span>, top1, <span class="number">1</span>, top2);</span><br><span class="line">    <span class="keyword">else</span> solve(<span class="number">1</span>, top1, <span class="number">1</span>, top2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-道路修建"><a href="#T2-道路修建" class="headerlink" title="T2 道路修建"></a>T2 道路修建</h1><p><img src="https://i.loli.net/2019/04/18/5cb8627245de8.png" alt="1555587688425"></p>
<p><img src="https://i.loli.net/2019/04/18/5cb86290b9bd9.png" alt="1555587721754"></p>
<p>容易发现一个结论：对于一个点$u$，假设它与$v$相连，那么它距离一号城市的最短路距离$d_u$一定满足$d_v-1\leq d_u\leq d_v+1$</p>
<p>那么我们可以通过这个建图跑网络流</p>
<p>将每个点拆成$n$个点，第$x$个点表示当前点的最短路是否大于等于$x-1$</p>
<p>将第一个拆出来的点与源点连一条$\infty$的边，将最后一个拆出来的点与汇点连一条$\infty$的边</p>
<p>将第$i$个拆出来的点向第$i+1$个点连一条权值为题中给出公式的边</p>
<p>最小割中，与$S$集合连接代表为<code>true</code>，否则为<code>false</code></p>
<p>为了满足$d_v-1\leq d_u\leq d_v+1$这个限制，我们可以模仿切糕这道题的做法</p>
<p>对于任意两个有边相连的点$u,v$，$u$拆出来的第$i$个点向$v$拆出来的第$i-1$个点连一条无法割掉的$\infty$ 的边</p>
<p>注意$(u,v)和(v,u)$是不一样的</p>
<h1 id="T3-美术作业"><a href="#T3-美术作业" class="headerlink" title="T3 美术作业"></a>T3 美术作业</h1><p><img src="https://i.loli.net/2019/04/18/5cb86451553e8.png" alt="1555588168670"></p>
<p><img src="https://i.loli.net/2019/04/18/5cb86482a8c37.png" alt="1555588211145"></p>
<p>可以看出，这是一个基环外向树</p>
<p>我们先考虑一棵树的情况：如何求它的染色方案</p>
<p>由于边是有向的，所以置换对答案的影响只有可能是对于$u$这个点，它有一些子树是完全同构的</p>
<p>比如这样</p>
<p><img src="https://i.loli.net/2019/04/18/5cb8658170f30.png" alt="1555588473582"></p>
<p>注意到如果$2,3,4$这几个点互换编号，那么结构是不变的</p>
<p>比如“2染颜色1，3染颜色1，4染颜色2”这种方案与“2染颜色2，3染颜色1，4染颜色1”是完全等价的</p>
<p>而不同构的子树之间是没有关系的</p>
<p>那么对于这种同构的情况怎么办呢</p>
<p>由于$2,3,4$都是同构的，所以它们的染色方案一定都一样，我们假设有$f$种方案，有$t$棵子树</p>
<p>我们将这$f$种染色方案分别编号为$1,2\cdots,f$，对于这些同构的子树按照根节点的编号排序</p>
<p>然后在这$f$种方案中选出$t$种，可以重复，然后按照从小到大的顺序依次给这些同构的子树染色，这样统计出来的结构一定不会重复</p>
<p>等价于将$t$个球放入$f$个盒子，每个盒子可以空</p>
<p>所以方案数为</p>
<script type="math/tex; mode=display">
f{f+t-1\choose f-1}=f{f+t-1\choose t}</script><p>现在我们求出了环上每棵树的染色方案</p>
<p>我们来考虑环的置换</p>
<p>对于一种置换后的不动点，它们对应树的结构必须相同，染的颜色也必须相同</p>
<p>所以对于每棵树最后得到的<code>hash</code>值我们跑一个<code>KMP</code>，求出它的最小循环节，这样每次转的次数一定是循环节长度的倍数</p>
<p>每个循环节我们将它看作一个点，染色方案为它包含的树的染色方案的乘积</p>
<p>然后就是普通<code>polya</code>了，枚举转多少次，然后不动点个数就是每个循环节的方案的$gcd(总长度，转的次数)$次方</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uLL unsigned long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = inv[r];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= r;i++)</span><br><span class="line">        res = (LL)res * (n - i + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt, dp[N], tmp[N], m;</span><br><span class="line">uLL P = <span class="number">233</span>, h[N], s[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> nxt[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ls = nxt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (ls &amp;&amp; s[ls + <span class="number">1</span>] != s[i]) ls = nxt[ls];</span><br><span class="line">        nxt[i] = ls + (s[ls + <span class="number">1</span>] == s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n % (n - nxt[n]) ? <span class="number">-1</span> : n - nxt[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next) </span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) tmp[++top] = e[i].to;</span><br><span class="line">    sort(tmp + <span class="number">1</span>, tmp + top + <span class="number">1</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> h[a] &lt; h[b];&#125;), h[u] = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= top;i++) </span><br><span class="line">        h[u] = ((h[u] * P + h[tmp[i]]) ^ h[tmp[i]]) + h[tmp[i]];</span><br><span class="line">    dp[u] = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, last;i &lt;= top;i = last) &#123;</span><br><span class="line">        <span class="keyword">for</span> (last = i;last &lt;= top &amp;&amp; h[tmp[last]] == h[tmp[i]];last++);</span><br><span class="line">        dp[u] = (LL)dp[u] * C(dp[tmp[i]] + last - i - <span class="number">1</span>, last - i) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> b ? gcd(b, a % b) : a;&#125;</span><br><span class="line"><span class="keyword">int</span> to[N], vis[N], cir[N], mark[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, tot = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;to[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = i;!vis[j];j = to[j]) vis[j] = i;</span><br><span class="line">        <span class="keyword">if</span> (vis[j] != i) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (;!mark[j];j = to[j]) mark[j] = <span class="number">1</span>, cir[++tot] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span> (!mark[i]) adde(to[i], i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tot;i++) dfs(cir[i], <span class="number">0</span>), s[i] = h[cir[i]];</span><br><span class="line">    <span class="keyword">int</span> zjk = KMP(tot), ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (~zjk) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= zjk;i++) f = (LL)f * dp[cir[i]] % mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tot / zjk;i++)</span><br><span class="line">            ans = (ans + Pow(f, gcd(i, tot / zjk))) % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL)ans * Pow(tot / zjk, mod - <span class="number">2</span>) % mod);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tot;i++) ans = (LL)ans * dp[cir[i]] % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/14/SCOI2019-%E6%B8%B8%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/14/SCOI2019-%E6%B8%B8%E8%AE%B0/" class="post-title-link" itemprop="url">SCOI2019 游记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-14 19:14:35" itemprop="dateCreated datePublished" datetime="2019-04-14T19:14:35+08:00">2019-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:12:04" itemprop="dateModified" datetime="2020-04-23T09:12:04+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B8%B8%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">游记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在之前的话"><a href="#写在之前的话" class="headerlink" title="写在之前的话"></a>写在之前的话</h1><p>感觉<code>NOIP</code>之后就有点没救了，之后冬令营全机房都去了</p>
<p>425分有点凉凉</p>
<p>不过可以试试冲E类</p>
<p>赶紧复习一下<code>exBSGS, exCRT, Cipolla</code></p>
<p>朱刘算法懒得看了</p>
<h1 id="Day0"><a href="#Day0" class="headerlink" title="Day0"></a>Day0</h1><p>比赛之前发了一个笔试考察范围，结果是去年<code>NOI</code>的笔试题库</p>
<p>本来以为要考什么神仙内容，结果笔试及其简单</p>
<p>重点是<strong>连题目顺序都和题库一样</strong></p>
<p>笔试时间是一个小时，结果30分钟可以走人的时候我在的这个考室已经没人了</p>
<p>感觉只要看了题库就应该是100分吧（雾</p>
<p>话说电子科大的教学楼上“电子科技大学”这几个字看起来好像电子神技大学</p>
<p>晚上看卢爷颓风暴英雄</p>
<p><del>Celeste真好玩</del></p>
<h1 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h1><p>路上单向模<code>ZJK</code></p>
<blockquote>
<p>我自闭了</p>
<p>我爆零了</p>
<p>来机房看神仙</p>
<p><code>rank</code> $10^9+7$</p>
</blockquote>
<p>结果每次考完之后都<code>rank</code> 1</p>
<p>这是某些选手的真实写照</p>
<hr>
<p>拿到试题之后解压，嗯？密码是一串数字</p>
<p>先看<code>T1</code>，那个图片有点劣质啊。。。</p>
<p>貌似是用<code>mspaint</code>画的</p>
<p>不过还将就</p>
<p>手玩了一下样例，好像找到了一点规律的样子</p>
<p>开考5分钟找工作人员要了几张纸</p>
<p>上个厕所冷静一下，顺便思考一下<code>T1</code></p>
<p>嗯？这不是SB题吗，只要不是划水选手都会做吧。。。</p>
<p>对于最有步数，显然有</p>
<script type="math/tex; mode=display">
f_m=3f_{m-1}+n-1</script><p>然后随便分治一下就行了</p>
<p>一发过掉大样例</p>
<p>题目中说$Q_i$小于等于答案的上限，然而又没说上限是多少</p>
<p>感觉有阴谋</p>
<p>保证答案小于等于30，有什么用呢</p>
<p>意思是$Q_i\leq (n-1)*3^{30}$吗</p>
<p>然后发现显然是假的，$Q_i$可以达到$3^{1000}$</p>
<p>手写高精度！</p>
<p><code>T2</code>的名字叫“肯赛训练”</p>
<p>这里是否有肯德基强行打广告的成份</p>
<p>思考了一下，感觉那个边权是假的</p>
<p>所以是个区间求重心？不会啊</p>
<p>先写暴力吧，好像很莫队的样子</p>
<p>加一个点很好处理，新的重心一定在原来的重心与加的点的连线上</p>
<p>貌似<code>LCT</code>维护虚子树信息可以做到$\log$?</p>
<p>于是开始码<code>LCT</code>，做好了6kb的准备</p>
<p>码了2kb的时候</p>
<p>woc?加点可以直接$\log$，那删点怎么办？</p>
<p>冷静一下</p>
<p>这个东西好像不是很好维护的样子，干脆暴跳吧</p>
<p>好像加点之后重心的移动次数是$O(\log)$的</p>
<p>先码一个树状数组</p>
<p>代码还是挺简单的</p>
<p>我的程序跑得巨慢无比</p>
<p><code>30s</code>后过了大样例</p>
<p>来看<code>T3</code></p>
<p>好像很多项式的样子</p>
<p>卷积的运算符是乘？是不是可以原根什么的啊</p>
<p>然后发现显然不是</p>
<p>还好暴力分给得很足</p>
<p>直接一行代码有5分</p>
<p>剩下的直接暴力数论分块可以再拿25分</p>
<p>貌似有两个$q=1$的点</p>
<p>欸是不是可以爆搜然后乘一个排列数啊</p>
<p>写完之后发现T成SB了</p>
<p>这个时候离考试结束大概还有10分钟</p>
<p>再来检查一下<code>T1</code>吧</p>
<p>手输了一组极限数据</p>
<p>wtf?RE?</p>
<p>赶紧看一下</p>
<p>还好在最后一分钟的时候发现是高精板子错了</p>
<p>那个高精乘的时候我是边乘边取模233</p>
<p>所以最后估分$100+[30-50]+30$?</p>
<p>莫队的分数很玄学的</p>
<hr>
<p><code>ZJK</code>说他<code>T1</code>可能会被卡常，然后期望$50+50+50$</p>
<p><code>ZYW</code>貌似切了<code>T2</code>的60分</p>
<p>都好强啊</p>
<p>很不幸，我面试是第6轮，也就是最后一轮</p>
<p>本来以为要考什么小学奥数，结果是政治问题？（雾</p>
<p><code>Bh</code>是第一轮，他说他们那组的面试题目是评论中美贸易战</p>
<p><code>hxy</code>的题目是七中食堂事件</p>
<p>还有什么国民党为什么会失败</p>
<p>好有趣啊</p>
<p>4：10之前一直在楼梯上坐着</p>
<p>看陈爷玩炉石</p>
<p>经过漫长的等待，终于轮到我了</p>
<p>感觉我们这组只有我一个初中的</p>
<p>拿到题目：如何评价近年来自主招生政策遭到限制？</p>
<p>开始10分钟讨论</p>
<p>丝毫没有面试经验</p>
<p>10分钟之后</p>
<p>考官：之前我提出的要求是讨论并选出一位代表发言，但是10分钟已经过去了，你们却没有选出一位代表</p>
<p>我们：。。。</p>
<p>考官：从面试的角度来说，你们这次讨论是失败的</p>
<p>我们：。。。</p>
<p>考官：现在再给你们一次机会，选出一个代表发言</p>
<p>显然不是我了2333</p>
<p>感觉面试是不是有点凉啊</p>
<hr>
<p>晚上来看成绩</p>
<p>嗯？$60+45+30?$</p>
<p><code>T1</code>的高精度果然<code>T</code>了啊</p>
<p>如果把11位压到17位应该就不会超时了</p>
<p>还是太菜了</p>
<p>orz陈爷180</p>
<p><code>ZYW</code>165，看来她进E类稳了</p>
<p><code>ZJK</code>好像有点爆炸？只有100，但是如果算上<code>NOIP</code>的话还是在我前面</p>
<p>看了看此时的加权成绩，<code>rk</code>21，好像有点凉？</p>
<p>明天加油吧</p>
<h1 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h1><p>考前陈爷口胡动态<code>SA</code>，感觉他A类很稳</p>
<p>拿到试题，密码又全是数字</p>
<p>先看<code>T1</code></p>
<p>好像很模板的样子</p>
<p>感觉那个分成两半部分，再取一个部分的操作没啥用</p>
<p>如果根据询问把每个点变一下，那不是最大子段和吗？</p>
<p>50pts get</p>
<p>如果要动态的话，线段树维护凸包？？？</p>
<p>反正这种东西我是很难写出来的</p>
<p>那线段树维护矩阵？？？</p>
<p>好像不是</p>
<p>两个自变量有点不爽，可以去掉一个</p>
<p>等等，前缀和之后好像是个很裸的斜率优化</p>
<p>15分钟码完，代码只有2kb。。</p>
<p>对拍了上万组数据，感觉很稳</p>
<p>来看<code>T2</code></p>
<p>哇，这是论文题欸！</p>
<p>去年国家集训队论文，有一个“解决树上连通块问题的一些技巧和工具”</p>
<p>原题啊！！！！</p>
<p>具体方法是利用“边数 = 点数 - 1”这个等式来容斥</p>
<p>枚举某个点作为$x$的方案数，减去某条边两个端点都是$x$的方案数</p>
<p>然后就切了？？？</p>
<p>跑一下大样例</p>
<p>嗯？输出负数？改成<code>long long</code></p>
<p>嗯？还是负数，看看答案</p>
<p>woc？答案怎么这么小</p>
<p>举手向监考老师求助</p>
<p>我：第二道题有模数吗</p>
<p>老师：题目中写了吗</p>
<p>我：没有啊，但是大样例无论如何都不可能这么小</p>
<p>老师：这个。。。你自己认真读题吧</p>
<p>我：<code>&amp;#fsdl&amp;DFfd*#$jkrhf29873Q@!Rds</code></p>
<p>不久之后更正通知下来了，模数是$10^9+7$</p>
<p>改一下程序，过了！很好</p>
<p>开始看<code>T3</code></p>
<p>这看上去很线性基</p>
<p>事实上线性基的确可以获得20分的好成绩</p>
<p>思考了一下感觉没有发现什么好的性质，果断写暴力</p>
<p>前20分直接暴力，后面20分线性基，然后还有20分貌似是找规律？</p>
<p>好像是$2^{不同数的个数}$的样子？</p>
<p>写！</p>
<p>11：00的时候我就码完了</p>
<p><code>T1</code>仍然没有拍出错</p>
<p>前面好像有个七中大佬在玩纸牌？</p>
<p>我默默地点开了扫雷</p>
<p>2min后</p>
<p>太不友好了！</p>
<p>还是试试虚拟机吧</p>
<p>结果打开虚拟机让我的电脑卡了一会儿</p>
<p>无聊打了一个程序模<code>ZJK</code></p>
<p>之后看了看各个<code>IDE</code>的作者信息</p>
<p>坐了2h后考试结束了</p>
<p>所以我今天估分$100+100+60?$感觉翻盘有望？</p>
<p><code>ZJK</code>和<code>ZYW</code>都估分$100+40+40$</p>
<p><code>ZYW</code>说她<code>T1</code>是在线，是在凸包上二分</p>
<p>蒟蒻只会离线</p>
<p>下午拿到成绩，前两道题确实是100，但是第三题只有40，总分240</p>
<p>看来是规律假了</p>
<p>不过，我竟然是rk 1？</p>
<p><code>ZYW</code>和<code>ZJK</code>确实是180，E类稳了</p>
<p><code>BH</code>有点神仙啊，切了<code>T2</code>，但是<code>T1</code>爆零了，本来是很有希望的</p>
<p>坐看卢爷翻盘240，orz</p>
<p>事实证明考前无聊的时候看看论文总是有用的</p>
<p>预祝陈爷<code>NOI</code>取得好成绩！</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>如果不是第二天的成功翻盘，我有可能进不了E类</p>
<p>感觉这次我们学校进步好大啊，去年只有一个省队</p>
<p>强者都上了400分orz</p>
<p>想起去年我失败的<code>SCOI</code>，想要了解详情可以知乎搜索<code>SCOI2018</code></p>
<p>希望我能够坚持到最后</p>
<p><code>NOI2019</code>见</p>
<h1 id="补充：关于题意"><a href="#补充：关于题意" class="headerlink" title="补充：关于题意"></a>补充：关于题意</h1><h2 id="D1T1-小红球的跳跃"><a href="#D1T1-小红球的跳跃" class="headerlink" title="D1T1 小红球的跳跃"></a>D1T1 小红球的跳跃</h2><p>有$m$个小红球，$n$个空岛。其中第一个、最后一个空岛以及中间的第$k$个空岛是固定的$(1&lt;k&lt;n)$是固定的，其余空岛是悬浮的。一开始所有小红球都在第一个空岛，你的目标是把他们都移动到最后一个空岛，并且使用的步数尽量小。</p>
<p>每回合你可以移动一个小红球到它左边或者右边的那个平台，但是有一些限制：</p>
<ul>
<li>移动的小红球必须是移动前/移动后它所在的平台上编号最小的。</li>
<li>如果一个小红球移动到了一个浮动平台上，那下一回合必须将这个小红球移走，否则它就会掉下去。</li>
</ul>
<p>有$q$个询问，每次给出一个时刻，你需要回答在最优方案中，这个时刻正在跳跃的是哪个小红球。</p>
<p>保证答案小于$30$，$n\leq 10^8,m\leq1000,q\leq5000$，时限$1$s</p>
<p>保证询问给出的时刻小于等于最优方案数</p>
<p>部分分：</p>
<ul>
<li>对于$20\%$的数据，保证$m,n,q\leq10$</li>
<li>对于$50\%$的数据，保证$n\leq 10^8,m\leq 10,q\leq 5000$</li>
</ul>
<h2 id="D1T2-肯赛训练"><a href="#D1T2-肯赛训练" class="headerlink" title="D1T2 肯赛训练"></a>D1T2 肯赛训练</h2><p>给出一棵树，$n$个节点，每条边有边权$c_i$。</p>
<p>给出一个点的序列，这个序列有$m$个数，第$i$个数$a_i$代表编号为$a_i$的点</p>
<p>有$q$个询问，每次询问给出一段区间$[l,r]$，你要在树上选出一个点，使得这个点离$a_l,a_{l+1},\cdots,a_{r}$的距离之和尽量小，输出这个点的编号</p>
<p>注意，选出的点不一定是$a_{l},a_{l+1},\cdots,a_r$其中的某一个</p>
<p>保证$n\leq 3*10^5,c_i\leq 1000,m\leq5*10^5,q\leq10^6$，区间的长度是奇数，时限$3$s</p>
<p>部分分：</p>
<ul>
<li>对于前$20\%$的数据，保证$n,m,q\leq2*10^3$</li>
<li>对于前$35\%$的数据，保证$m,q\leq2*10^3$</li>
<li><p>对于前$60\%$的数据，保证$n,m,q\leq10^5$</p>
</li>
<li><p>对于另$15\%$的数据，保证每个点的度数不超过$2$</p>
</li>
</ul>
<h2 id="D1T3-超矩形"><a href="#D1T3-超矩形" class="headerlink" title="D1T3 超矩形"></a>D1T3 超矩形</h2><p>给出一个数$n$，你需要找到$k$个数$a_1,a_2,\cdots,a_k$使得$\prod_{i=1}^ka_i\leq n$</p>
<p>给出一个变换$b_1,b_2,\cdots,b_k$，保证$b_i&lt;10$</p>
<p>你需要求出</p>
<script type="math/tex; mode=display">
\sum_{所有合法的方案}\prod_{i=1}^ka_i^{b_i}\pmod {998244353}</script><p>多组数据（$t$组）</p>
<p>保证$n\leq10^6,\sum k\leq10^6,t\leq100$，时限$4$s</p>
<p>给出$b$的方式是$q$个$s_i,r_i$，表示有连续$r_i$个$b_i$是$s_i$</p>
<p>保证$s_i$互不相同，$q&lt;5$</p>
<p>部分分：</p>
<ul>
<li>对于前$10\%$的数据，保证$k=1,q=1,s=0$</li>
<li>对于前$20\%$的数据，保证$k=1,q=1,s\leq1$</li>
<li><p>对于前$30\%$的数据，保证$k\leq2,q\leq2$</p>
</li>
<li><p>对于另$20\%$的数据，保证$q=1$</p>
</li>
</ul>
<h2 id="D2T1-湖之精灵的游戏"><a href="#D2T1-湖之精灵的游戏" class="headerlink" title="D2T1 湖之精灵的游戏"></a>D2T1 湖之精灵的游戏</h2><p>一个二维平面上有$n$个点，第$i$个点的坐标是$(x_i,y_i)$，你要和一位神仙玩游戏。</p>
<p>每次神仙会告诉你一个坐标$(x,y)$，连一条经过$(0,0),(x,y)$的直线，这会把平面分成两个部分$A,B$</p>
<p>你要选择一个区间$[l,r]$，那么计算的时候只会考虑编号在$[l,r]$之内的点</p>
<p>一个半平面的价值是这个半平面中，编号在$[l,r]$范围内的点与$(0,0),(x,y)$组成三角形的面积之和</p>
<p>你要选择一个半平面，神仙会选择另一个半平面，你想要使得你得到的价值减去神仙得到的价值的结果尽量大</p>
<p>有$m$轮游戏，对于每轮游戏输出这个最大值乘以$2$的结果</p>
<p>保证$n,m\leq 10^6$，$1\leq x,y\leq1000$，时限$2$s</p>
<p>部分分：</p>
<ul>
<li>对于$20\%$的数据，$n,m\leq200$</li>
<li>对于$50\%$的数据，$n,m\leq 10^4$</li>
</ul>
<h2 id="D2T2-RGB"><a href="#D2T2-RGB" class="headerlink" title="D2T2 RGB"></a>D2T2 <font color=red>R</font><font color=green>G</font><font color=blue>B</font></h2><p>有一棵树，$n$个节点，每条边有边权$c_i$，每个点的颜色为<font color=red>R</font>,<font color=green>G</font>,<font color=blue>B</font>三种颜色之一</p>
<p>你要统计有序对$(U,V)$的数量，其中$U,V$是两个点集</p>
<p>它还需要满足以下条件：</p>
<ul>
<li>$U$和$V$都必须是连通的</li>
<li>$U$的颜色只能是红色或者绿色，$V$的颜色只能是绿色或者蓝色</li>
<li>存在一个$U,V$均包含的点$x$，使得对于所有在$U,V$集合中的点$y$，有$dis(x,y)\leq w$</li>
</ul>
<p>保证$n\leq 2000,w\leq10^7,c_i\leq10^6$，时限$1$s，对$10^9+7$取模</p>
<p>部分分：</p>
<ul>
<li>对于$30\%$的数据，$n\leq 15$</li>
<li>对于另$10\%$的数据，只有一个<font color=green>G</font></li>
<li>对于另$20\%$的数据，树是一条链</li>
</ul>
<h2 id="D2T3-函数"><a href="#D2T3-函数" class="headerlink" title="D2T3 函数"></a>D2T3 函数</h2><p>有$n$个数$v_1,v_2,\cdots,v_n$，现在有一类函数$f_T(x)$，其中$T$是$V$的一个子集，它的定义是</p>
<script type="math/tex; mode=display">
f_T(x)=\bigoplus_{v_i\in T}(x+v_i)\\\
f_\emptyset(x)=0</script><p>我们称两个函数$f_s,f_t$是$W-$本质不同的，当且仅当存在一个$0\leq x\leq W$，使得$f_s(x)\not=f_t(x)$</p>
<p>问在这$2^n$个函数中，有多少函数是$W-$本质不同的</p>
<p>保证$n,w,v_i&lt; 2^{17}$，时限$1$s</p>
<p>部分分：</p>
<ul>
<li>对于$20\%$的数据，$n\leq15,w\leq10$</li>
<li>对于另$20\%$的数据，$w=0$</li>
<li>对于前$70\%$的数据，$n,w,v_i\leq2^{10}$</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/09/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/09/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/" class="post-title-link" itemprop="url">二次剩余</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-09 10:20:40" itemprop="dateCreated datePublished" datetime="2019-04-09T10:20:40+08:00">2019-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:34:44" itemprop="dateModified" datetime="2020-04-23T09:34:44+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>若方程$x^2\equiv a\pmod p$有解，那么称$a$为$p$的二次剩余，否则$a$为$p$的非二次剩余</p>
<h1 id="勒让德符号及欧拉判别法"><a href="#勒让德符号及欧拉判别法" class="headerlink" title="勒让德符号及欧拉判别法"></a>勒让德符号及欧拉判别法</h1><p>定义勒让德符号为</p>
<script type="math/tex; mode=display">
\left(\frac{a}{p}\right)=\begin{cases}1&a为p的二次剩余\\\ -1&a为p的非二次剩余\\\ 0 &a能被p整除\end{cases}</script><p>欧拉判别法就是：如果$a$不能被$p$整除，那么有</p>
<script type="math/tex; mode=display">
\left(\frac{a}{p}\right)=a^{\frac{p-1}{2}}</script><h2 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h2><blockquote>
<p>对于方程$x^2\equiv a\pmod p$ ，共有$\frac{p-1}{2}$个不同的$a$使得该方程有解</p>
</blockquote>
<p>我们忽略$x=0$，如果枚举$x$再求出$a$，那么$x$一共有$p-1$个不同的值，也就产生了$p-1$个$a$</p>
<p>我们知道一个二次剩余恰好会产生两个解，那么这$p-1$个$a$就被分配到了$\frac{p-1}{2}$个不同的桶里面</p>
<p>所以共有$\frac{p-1}{2}$个$a$</p>
<h2 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h2><blockquote>
<p>$(x+y)^p\equiv x^p+y^p\pmod p$</p>
</blockquote>
<p>我们将其二项式展开</p>
<script type="math/tex; mode=display">
(x+y)^p=\sum_{i=0}^p{p\choose i}x^iy^{p-i}</script><p>当$i\not=0$且$i\not=p$时，$p\choose i$一定包含因数$p$，所以可以忽略</p>
<p>只剩下第一项和最后一项</p>
<h1 id="Cipolla算法"><a href="#Cipolla算法" class="headerlink" title="Cipolla算法"></a>Cipolla算法</h1><p>现在要求出方程$x^2\equiv n\pmod p$的一个解</p>
<p>我们找出一个$a​$，使得$(a^2-n)^{\frac{p-1}{2}}\equiv-1\pmod p​$</p>
<p>设$\omega=\sqrt{a^2-n}$</p>
<blockquote>
<p>结论：$x=(a+\omega)^{\frac{p+1}{2}}$</p>
</blockquote>
<p>证明如下：</p>
<p>我们知道</p>
<script type="math/tex; mode=display">
(a^2-n)^{\frac{p-1}{2}}\equiv-1\pmod p\Rightarrow (\omega^2)^{\frac{p-1}{2}}\equiv -1\pmod p\\\
\omega^{p-1}\equiv -1\pmod p</script><p>那么有</p>
<script type="math/tex; mode=display">
\begin{aligned}
x&\equiv (a+\omega)^{\frac{p+1}{2}}\\\
x^2&\equiv (a+\omega)^{p+1}\equiv(a+\omega)^p(a+\omega)\\\
&\equiv(a^p+\omega^p)(a+\omega)\\\
&\equiv(a-\omega)(a+\omega)\\\
&\equiv a^2-\omega^2\equiv a^2-a^2+n\equiv n
\end{aligned}</script><p>我们可以通过实现一个类似复数的结构体来进行运算</p>
<p>由于$p$的二次剩余一共有$\frac{p-1}{2}$个，而$a$在$[0,p)$中随机选取</p>
<p>那么成功的概率就是$\frac{1}{2}$</p>
<p>此时答案中$\omega$部分的系数必然为0</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/09/BSGS%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/09/BSGS%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95/" class="post-title-link" itemprop="url">BSGS及其拓展</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-09 09:25:08" itemprop="dateCreated datePublished" datetime="2019-04-09T09:25:08+08:00">2019-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:21:34" itemprop="dateModified" datetime="2020-04-23T09:21:34+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a>BSGS</h1><p>解高次同余方程</p>
<script type="math/tex; mode=display">
A^x\equiv B\mod C且A\bot B</script><p>根据费马小定理，我们直到$A^{C-1}\equiv B\mod C$</p>
<p>那么如果这个方程有解，那么解的周期一定不会大于$C$，所以必然存在一个不大于$C$的解</p>
<p>如果$C$比较小，那么我们可以直接枚举$x$然后暴力判断</p>
<p>考虑$C$比较大的情况，这时就需要使用<code>BSGS</code>了</p>
<p>我们设$x=i*m-j$，其中$j&lt;m$，这个$m$是一个常量，我们设为$\sqrt{C}$</p>
<p>那么有</p>
<script type="math/tex; mode=display">
A^{i\*m-j}\equiv B\mod C\\\
A^{i\*m}\equiv B\*A^j\mod C</script><p>我们开一个<code>map</code>，枚举$j$，将$B*A^j$放到这个<code>map</code>里面</p>
<p>然后我们枚举$i*m$，在<code>map</code>中查找是否存在$A^{i*m}​$即可</p>
<p>注意这样枚举是取不到$x=0$的，这种情况我们需要特判</p>
<p>如果$i*m$此时已经大于$C$了，那么就无解</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">BSGS</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (B % C == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; s.clear();</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(C)), ls = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++, ls = (LL)ls * A % C)</span><br><span class="line">        s[(LL)B * ls % C] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, t = ls;i &lt;= C;i += m, t = (LL)t * ls % C) </span><br><span class="line">        <span class="keyword">if</span> (s.count(t)) <span class="keyword">return</span> i - s[t];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="exBSGS"><a href="#exBSGS" class="headerlink" title="exBSGS"></a>exBSGS</h1><p>同样是解上面那个方程</p>
<p>但是如果$A,C$不互质呢</p>
<p>原方程等价于</p>
<script type="math/tex; mode=display">
A^x+Cy=B</script><p>我们不停地消去$A,C$的非1因子，可以使得方程变为</p>
<script type="math/tex; mode=display">
aA^z+C'y=B'</script><p>每消去一次，我们就从$A^x$里面拿一个$A$出来，消完之后乘到系数$a$里面去</p>
<p>注意在消去过程中时，如果存在某个时刻使得$a=B’$，那么直接返回此时的消去次数就可以了</p>
<p>如果在消去过程中，$B’$没有当前要消去的那个因子，那么直接返回$-1$</p>
<p>我们设消去次数为$k$</p>
<p>那么此时方程就变成了</p>
<script type="math/tex; mode=display">
aA^z\equiv B'\mod C'(A\bot C')</script><p>使用普通的<code>BSGS</code>可以解出$z$，注意此时前面还有一个系数$a$</p>
<p>最后我们将解出的$z$加上$k$即可，因为最开始拿出了$k$个$A$来消去因数</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> b ? gcd(b, a % b) : a;&#125;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">BSGS</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C, <span class="keyword">int</span> basic)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (B % C == basic) <span class="keyword">return</span> <span class="number">0</span>; s.clear();</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(C)), ls = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++, ls = (LL)ls * A % C)</span><br><span class="line">        s[(LL)B * ls % C] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, t = (LL)ls * basic % C;i &lt;= C;i += m, t = (LL)t * ls % C) </span><br><span class="line">        <span class="keyword">if</span> (s.count(t)) <span class="keyword">return</span> i - s[t];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">exBSGS</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, cnt = <span class="number">0</span>, d; A %= C, B %= C;</span><br><span class="line">    <span class="keyword">while</span> ((d = gcd(A, C)) != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (B % d) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        a = (LL)a * (A / d) % C, C /= d, B /= d, cnt++;</span><br><span class="line">        <span class="keyword">if</span> (a == B) <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = BSGS(A, B, C, a);</span><br><span class="line">    <span class="keyword">return</span> ~res ? res + cnt : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/08/12%E7%9C%81%E8%81%94%E8%80%832019-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/08/12%E7%9C%81%E8%81%94%E8%80%832019-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">12省联考2019 字符串问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-08 21:26:15" itemprop="dateCreated datePublished" datetime="2019-04-08T21:26:15+08:00">2019-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:23:48" itemprop="dateModified" datetime="2020-04-23T09:23:48+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A2%98%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">题解</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给出一个字符串$S$， 现在要选取它的$n_a$个子串作为$A$类串，选取$n_b$个子串作为$B$类串</p>
<p>其中第$i$个$A$类串为$S(la_i,ra_i)$，第$i$个$B$类串为$S(lb_i,rb_i)$，$la_i,ra_i,lb_i,rb_i,n_a,n_b$均已给出</p>
<p>现额外给定$m$组支配关系，每组关系$(x,y)$表示第$x$个$A$类串支配第$y$个$B$类串</p>
<p>求出一个长度最大的字符串$T$，满足$T$是由$A$类串拼接而成的。我们假设$T$被划分成了$t_1,t_2,\cdots,t_k$（都是$A$类串），要求满足对于任意的$i&lt;k$，$t_i$所支配的串中至少有一个是$t_{i+1}$的前缀</p>
<p><img src="https://i.loli.net/2019/04/08/5cab4fcbe56e2.png" alt="1554730942968"></p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>对于这种要求所求值最大的问题，不是动态规划就是最长路</p>
<p>那么对于这道题显然就只能是最长路了</p>
<p>如果最后构建出来的图有环，那么$T$就可以无限长</p>
<p>否则我们拓扑排序，然后跑一个<code>dp</code>就可以了</p>
<p>首先我们将$S$串翻转，将所有的$A$串与$B$串都翻转</p>
<p>这样限制条件就可以变为我们熟悉的后缀</p>
<p>我们先考虑一种暴力连边方式</p>
<p>每个$A$串建一个点，每个$B$串建一个点</p>
<p>对于$A_i$，将所有是其后缀的$B$连向$A_i$，权值为$|A_i|$</p>
<p>对于一组支配$(A_i,B_i)$，$A_i$往$B_i$连一条权值为0的边</p>
<p>但是这样最坏会连$n_a*n_b$条边，需要优化</p>
<p>我们考虑这样一种优化方案</p>
<p>对于任意的$A_i,B_i$，如果$B_i$是$A_i$的后缀，那么$B_i$的后缀也是$A_i$的后缀</p>
<p>我们对于$B$单独建一个子图，这个子图需要满足如果$B_i$是$B_j$的后缀，那么所有能走到$B_i$的路径都可以走到$B_j$</p>
<p>这样的话$A_i$只需要从它包含的那个最长的$B$串后缀连边就可以了</p>
<p>那么什么图满足这个性质呢？</p>
<p>很明显是<code>parent</code>树</p>
<p>我们建出<code>parent</code>树，然后从父亲往儿子节点连边</p>
<p>因为父亲对应的点一定是儿子的后缀</p>
<p>对于每个串$A_i,B_i$，找到它在树上的位置，这个可以通过倍增实现</p>
<p>实际上我们不需要对于每个串$A$，都找到那个最长的且是它后缀的$B$</p>
<p>直接从<code>parent</code>树上$A_i$的对应节点往$A_i$连边就可以了</p>
<p>因为这样同样可以保证最长的且是它后缀的$B$可以走到$A_i$</p>
<p>兴奋地写完，发现第三个样例过不去($-1$)</p>
<p>事实上是我们少考虑了一种情况</p>
<p><code>parent</code>树上的某个节点可以表示长度在一段区间的串</p>
<p>如果一条路径是从父亲走向儿子，那么当然没有问题，因为此时它代表的串是这个节点所能代表的最短的串</p>
<p>如果有一个串$A_i$以及另一个串$B_j$，它们对应着树上的同一个点</p>
<p>在之前的建图方式中，$B_j$一定能到达$A_i$</p>
<p>但是如果$|B_j|&gt;|A_i|$呢，显然这种转移是不合法的</p>
<p>解决方法是对于树上的一个点$u$，假如有$a_u$个$A$串挂在上面</p>
<p>那么我们将这些$A$串按照长度从小到大排序，将$u$拆成$a_u+1$个点，第$i$个点往$i+1$个点连边，父亲的最右边那个点往儿子的最左边那个点连边</p>
<p>对于一个串$B$，它就对应着它在树上的那个点所拆成的点中，第一个长度不小于它的点</p>
<p>这样就没有问题了</p>
<p>注意开<code>long long</code></p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> P = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="keyword">int</span> LEN;</span><br><span class="line"><span class="keyword">namespace</span> SAM &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; next; </span><br><span class="line">        <span class="keyword">int</span> link, len;</span><br><span class="line">    &#125; st[N * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ncnt, last;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;st[<span class="number">0</span>].link = <span class="number">-1</span>, st[<span class="number">0</span>].len = ncnt = last = <span class="number">0</span>, st[<span class="number">0</span>].next.clear();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">extend</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = ++ncnt, p; st[cur].len = st[last].len + <span class="number">1</span>, st[cur].link = <span class="number">0</span>, st[cur].next.clear();</span><br><span class="line">        <span class="keyword">for</span> (p = last;p != <span class="number">-1</span> &amp;&amp; !st[p].next.count(c);p = st[p].link)</span><br><span class="line">            st[p].next[c] = cur;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> q = st[p].next[c];</span><br><span class="line">            <span class="keyword">if</span> (st[q].len == st[p].len + <span class="number">1</span>) st[cur].link = q;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> clone = ++ncnt; st[clone].len = st[p].len + <span class="number">1</span>, st[clone].next = st[q].next, st[clone].link = st[q].link;</span><br><span class="line">                <span class="keyword">for</span> (;p != <span class="number">-1</span> &amp;&amp; st[p].next[c] == q;p = st[p].link)</span><br><span class="line">                    st[p].next[c] = clone;</span><br><span class="line">                st[q].link = st[cur].link = clone;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= ncnt;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : st[i].next)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"sam: "</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; v.second &lt;&lt; <span class="string">' '</span> &lt;&lt; v.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> SUF_Tree &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to, next;&#125; e[N * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> head[N * <span class="number">2</span>], ecnt, len[N * <span class="number">2</span>], fa[<span class="number">18</span>][N * <span class="number">2</span>]; </span><br><span class="line">    <span class="built_in">vector</span>&lt;P&gt; nodes[N * <span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">        fa[<span class="number">0</span>][u] = f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">17</span>;i++) fa[i][u] = fa[i - <span class="number">1</span>][fa[i - <span class="number">1</span>][u]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">            <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">2</span> * LEN;i++) head[i] = <span class="number">0</span>, nodes[i].clear(), nodes[i].push_back(P(<span class="number">1e9</span>, <span class="number">-1</span>));</span><br><span class="line">        ecnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>;i &gt;= <span class="number">0</span>;i--) <span class="keyword">if</span> (fa[i][u])</span><br><span class="line">            <span class="keyword">if</span> (l &lt;= len[fa[i][now]])</span><br><span class="line">                now = fa[i][now];</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> id[N], tot, onT[N], sz[N], onT2[N], na;</span><br><span class="line"><span class="keyword">namespace</span> GRAPH &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to, next, w;&#125; e[N * <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">int</span> head[N * <span class="number">4</span>], ecnt, ind[N * <span class="number">4</span>], st[N * <span class="number">4</span>], top, ncnt; LL dp[N * <span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        e[++ecnt] = (edge)&#123;to, head[from], w&#125;, ind[to]++, head[from] = ecnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Topsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        top = <span class="number">0</span>; <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= ncnt;i++) <span class="keyword">if</span> (!ind[i]) q.push(i), st[++top] = i;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next) </span><br><span class="line">                <span class="keyword">if</span> (!(--ind[e[i].to])) q.push(e[i].to), st[++top] = e[i].to;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> top == ncnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= ncnt;i++) head[i] = ind[i] = dp[i] = <span class="number">0</span>;</span><br><span class="line">        ecnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">DP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = top;i &gt;= <span class="number">1</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = st[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = head[u];j;j = e[j].next)</span><br><span class="line">                dp[u] = max(dp[u], dp[e[j].to] + e[j].w);</span><br><span class="line">            <span class="keyword">if</span> (u &lt;= na) res = max(res, dp[u] + sz[u]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p[N * <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    p[u].clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : SUF_Tree::nodes[u]) &#123;</span><br><span class="line">        p[u].push_back(++tot);</span><br><span class="line">        <span class="keyword">if</span> (v.second &gt; <span class="number">0</span>) onT[v.second] = tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i + <span class="number">1</span> &lt; p[u].size();i++)</span><br><span class="line">        GRAPH::adde(p[u][i], p[u][i + <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = SUF_Tree::head[u];i;i = SUF_Tree::e[i].next) &#123;</span><br><span class="line">        dfs(SUF_Tree::e[i].to);</span><br><span class="line">        GRAPH::adde(*p[u].rbegin(), *p[SUF_Tree::e[i].to].begin(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; read(T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>), LEN = <span class="built_in">strlen</span>(s + <span class="number">1</span>), reverse(s + <span class="number">1</span>, s + LEN + <span class="number">1</span>), SAM::init(), SUF_Tree::init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= LEN;i++) id[i] = SAM::extend(s[i]);</span><br><span class="line"><span class="comment">//        cout &lt;&lt; SAM::ncnt &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= SAM::ncnt;i++) SUF_Tree::adde(SAM::st[i].link, i), SUF_Tree::len[i] = SAM::st[i].len;</span><br><span class="line">        SUF_Tree::dfs(<span class="number">0</span>, <span class="number">0</span>); read(na), tot = na;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; "ok" &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l, r;i &lt;= na;i++) &#123;</span><br><span class="line">            read(l), read(r), l = LEN - l + <span class="number">1</span>, r = LEN - r + <span class="number">1</span>, swap(l, r), sz[i] = r - l + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> t = SUF_Tree::find(id[r], r - l + <span class="number">1</span>); </span><br><span class="line">            SUF_Tree::nodes[t].push_back(P(r - l + <span class="number">1</span>, i));</span><br><span class="line">        &#125;</span><br><span class="line">        GRAPH::ncnt = na * <span class="number">2</span> + SAM::ncnt + <span class="number">1</span>, GRAPH::init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= SAM::ncnt;i++) sort(SUF_Tree::nodes[i].begin(), SUF_Tree::nodes[i].end());</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= na;i++) GRAPH::adde(onT[i], i, sz[i]);</span><br><span class="line">        <span class="keyword">int</span> nb; read(nb);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l, r;i &lt;= nb;i++) &#123;</span><br><span class="line">            read(l), read(r), l = LEN - l + <span class="number">1</span>, r = LEN - r + <span class="number">1</span>, swap(l, r);</span><br><span class="line">            <span class="keyword">int</span> t = SUF_Tree::find(id[r], r - l + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> pos = lower_bound(SUF_Tree::nodes[t].begin(), SUF_Tree::nodes[t].end(), P(r - l + <span class="number">1</span>, <span class="number">-2</span>)) - SUF_Tree::nodes[t].begin();</span><br><span class="line">            onT2[i] = p[t][pos];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> matches; read(matches);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= matches;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b; read(a), read(b), GRAPH::adde(a, onT2[b], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        GRAPH::ncnt = tot;</span><br><span class="line">        <span class="keyword">if</span> (!GRAPH::Topsort()) &#123;<span class="built_in">puts</span>(<span class="string">"-1"</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, GRAPH::DP());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/07/BJOI2018-%E5%8F%8C%E4%BA%BA%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/07/BJOI2018-%E5%8F%8C%E4%BA%BA%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/" class="post-title-link" itemprop="url">BJOI2018 双人猜数游戏</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-07 11:53:41" itemprop="dateCreated datePublished" datetime="2019-04-07T11:53:41+08:00">2019-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:21:47" itemprop="dateModified" datetime="2020-04-23T09:21:47+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A2%98%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">题解</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://www.luogu.org/problemnew/show/P4459" target="_blank" rel="noopener">题目链接</a></p>
<p>神仙题啊</p>
<p>首先来模拟一下样例</p>
<p><code>Alice</code>知道乘积是60，<code>Bob</code>知道和是16，且两个数均不小于5</p>
<p><code>Bob</code>：此时两个数有可能为</p>
<p>$(5, 11), (6, 10), (7, 9), (8, 8)$</p>
<p>而<code>Bob</code>在第一轮没有猜出来，也就是说，这两个数的和不是10或11</p>
<p><code>Alice</code>：此时两个数有可能为</p>
<p>$(5, 12), (6, 10)$</p>
<p>由于Alice也没有猜出来，所以对于Bob来说，以下情况就被排除了</p>
<p>$(5, 11), (7, 9), (8, 8)$</p>
<p>对于$(5, 11)$而言，55只有这一种分解方式，而<code>Alice</code>在第一轮中没有猜出来，所以不是</p>
<p>对于$(7, 9)$而言，63还可以被分解成$(3, 21)$，但是不满足两个数都大于等于5，而<code>Alice</code>没有猜出来，所以也不是</p>
<p>$(8, 8)​$同理</p>
<p>所以对于<code>Bob</code>来说，这两个数只有可能是$(6, 10)$，他也就确定了答案</p>
<p><code>Alice</code>知道，<code>Bob</code>已经猜出来了，所以$(5, 12)$就被排除了，因为在这种情况下，$Bob​$不可能这么早就猜出答案</p>
<p>所以<code>Alice</code>也知道答案是$(6, 10)​$了</p>
<p>我们用<code>dp</code>来描述这个过程，<code>dp[i][n][m]</code>表示，当前是第i轮，且两个答案分别是$n,m$，在$1-i​$轮中，是否能决定答案</p>
<p>如果这一轮是<code>Bob</code>猜，那么我们就枚举$n+m$的划分方式。如果每一种合法的划分方式都能在$1-(i-1)$轮被猜出来，那么<code>Bob</code>一定能确定这两个数分别为$n, m$</p>
<p>否则，我们则枚举$n*m$的约数， 判断方式与<code>Bob</code>的相同</p>
<p>但是这样可能会出现一种特殊情况，就是已经到了$t$轮，第一个人猜出来了，而第二个人没有猜出来</p>
<p>那么我们就多进行一轮转移，这次转移与之前的转移相反，如果每一种合法的划分方式在$1-t$轮都不能被猜出来，那么才能确定答案</p>
<p>$n,m$的最大值不会超过500，直接枚举</p>
<p>直接交程序，数组只开500的话是秒跑</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500</span></span><br><span class="line"><span class="keyword">int</span> dp[N + <span class="number">10</span>][N + <span class="number">10</span>][<span class="number">16</span>], m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, tmpa, tmpb;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, j;i &lt;= a + b - i &amp;&amp; cnt &lt; <span class="number">2</span>;i++) </span><br><span class="line">        <span class="keyword">if</span> (!dp[i][j = a + b - i][c - <span class="number">1</span>] || c == <span class="number">1</span>) </span><br><span class="line">            cnt++, tmpa = i, tmpb = j;</span><br><span class="line">    <span class="keyword">return</span> cnt == <span class="number">1</span> &amp;&amp; a == tmpa &amp;&amp; b == tmpb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, tmpa, tmpb;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, j;i * i &lt;= a * b &amp;&amp; cnt &lt; <span class="number">2</span>;i++)</span><br><span class="line">        <span class="keyword">if</span> (a * b % i == <span class="number">0</span> &amp;&amp; (!dp[i][j = a * b / i][c - <span class="number">1</span>] || c == <span class="number">1</span>))</span><br><span class="line">            cnt++, tmpa = i, tmpb = j;</span><br><span class="line">    <span class="keyword">return</span> cnt == <span class="number">1</span> &amp;&amp; a == tmpa &amp;&amp; b == tmpb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, tmpa, tmpb;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, j;i &lt;= a + b - i &amp;&amp; cnt &lt; <span class="number">2</span>;i++) </span><br><span class="line">        <span class="keyword">if</span> (dp[i][j = a + b - i][c] &amp;&amp; !dp[i][j][c - <span class="number">2</span>]) </span><br><span class="line">            cnt++, tmpa = i, tmpb = j;</span><br><span class="line">    <span class="keyword">return</span> cnt == <span class="number">1</span> &amp;&amp; a == tmpa &amp;&amp; b == tmpb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check4</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, tmpa, tmpb;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, j;i * i &lt;= a * b &amp;&amp; cnt &lt; <span class="number">2</span>;i++)</span><br><span class="line">        <span class="keyword">if</span> (a * b % i == <span class="number">0</span> &amp;&amp; dp[i][j = a * b / i][c] &amp;&amp; !dp[i][j][c - <span class="number">2</span>])</span><br><span class="line">            cnt++, tmpa = i, tmpb = j;</span><br><span class="line">    <span class="keyword">return</span> cnt == <span class="number">1</span> &amp;&amp; a == tmpa &amp;&amp; b == tmpb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">8</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, flag; <span class="built_in">scanf</span>(<span class="string">"%d%s%d"</span>, &amp;m, name + <span class="number">1</span>, &amp;t), flag = name[<span class="number">1</span>] == <span class="string">'B'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= t + <span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = m;a &lt;= N / <span class="number">2</span>;a++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = a;b &lt;= N;b++)</span><br><span class="line">                dp[a][b][i] = dp[a][b][i - <span class="number">2</span>] | (((i &amp; <span class="number">1</span>) ^ flag ^ <span class="number">1</span>) ? check1(a, b, i) : check2(a, b, i));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = m * <span class="number">2</span>;s;s++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = m, b = s - a;a * <span class="number">2</span> &lt;= s;a++, b = s - a)</span><br><span class="line">            <span class="keyword">if</span> (dp[a][b][t + <span class="number">1</span>] &amp;&amp; !(dp[a][b][t - <span class="number">1</span>] | dp[a][b][t])) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = t &amp; <span class="number">1</span> ^ flag;</span><br><span class="line">                <span class="keyword">if</span> (!(tmp ? check4(a, b, t + <span class="number">1</span>) : check3(a, b, t + <span class="number">1</span>))) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">' '</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/07/BJOI2018-%E4%BA%8C%E8%BF%9B%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/07/BJOI2018-%E4%BA%8C%E8%BF%9B%E5%88%B6/" class="post-title-link" itemprop="url">BJOI2018 二进制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-07 11:50:09" itemprop="dateCreated datePublished" datetime="2019-04-07T11:50:09+08:00">2019-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:21:57" itemprop="dateModified" datetime="2020-04-23T09:21:57+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A2%98%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">题解</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://www.luogu.org/problemnew/show/P4428" target="_blank" rel="noopener">题目链接</a></p>
<p>先考虑哪些二进制在重新排列之后可以是3的倍数</p>
<p>我们分3种情况讨论：</p>
<ol>
<li>0 ：模3的余数是0</li>
<li>10 ：就是1出现在下标为偶数的地方，模3余2</li>
<li>01 ：1出现在下标为奇数的地方，模3余1</li>
</ol>
<p>那么，我们就可以用这三种余数来进行组合</p>
<p>考虑以下情况：</p>
<ol>
<li>有偶数个1 ：显然，通过情况2与3组合可以成为3的倍数</li>
<li>有奇数个1 ：注意到3个情况2或者情况3的叠加仍然可以成为3的倍数，而这样至少需要2个0和3个1（10101）</li>
</ol>
<p>那么综合上面两种情况，我们可以得出结论，一段区间为不合法的区间当且仅当：</p>
<ol>
<li>区间内只有1个1</li>
<li>区间中有奇数个1且没有0</li>
<li>区间中有奇数个1且有1个0</li>
</ol>
<p>这道题是带修改的，所以需要将<code>dp</code>放到线段树上统计</p>
<p>那么我们考虑一段区间应该维护什么</p>
<p>首先将第一种情况分开，先不管</p>
<p>那么对于一段区间，我们可以用<code>dp[i][j(0/1)][k(0/1)]</code>表示</p>
<p>即状态为$i$，1的个数是奇数还是偶数，出现了0个0还是1个0的区间总数</p>
<p>线段树<code>pushup</code>的时候子区间也是可以跨<code>mid</code>合并的</p>
<p>具体来说，就是一个左子树的以<code>mid</code>为右端点的区间和一个右子树的以<code>mid + 1</code>为左端点的区间合并</p>
<p>所以，对于状态i，我们这样设计</p>
<p><code>i = 0</code> 表示不取左端点和右端点</p>
<p><code>i = 1</code> 表示必须取左端点，不能取右端点</p>
<p><code>i = 2</code> 表示必须取右端点，不能取左端点</p>
<p><code>i = 3</code> 表示必须左右端点都取</p>
<p>合并的时候枚举一下有几个0以及1的奇偶性就可以了</p>
<p>我们另外开一个数组，单独统计情况1，也就是只有1个1的区间的数量</p>
<p>转移与上面的类似</p>
<p><code>g[i][j(0/1)]</code>表示状态为$i$，出没出现1的区间的总数</p>
<p>但是统计的时候不能直接将两个加起来</p>
<p>注意到这两个统计是有重复的，当我们进行第一次统计时也顺便统计了区间内有1个1，只有0/1个0的数量，需要去重</p>
<p>对于有1个1，0个0的区间数量，显然也就是区间内1的数量</p>
<p>对于有1个1，1个0的区间数量，我们用一个树状数组维护，在这个01区间的第一位维护即可</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    LL f[<span class="number">4</span>][<span class="number">2</span>][<span class="number">2</span>], g[<span class="number">4</span>][<span class="number">2</span>];</span><br><span class="line">    Data() &#123;<span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)), <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span>(g));&#125;</span><br><span class="line">&#125; T[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Data <span class="title">UN</span><span class="params">(Data a, Data b)</span> </span>&#123;</span><br><span class="line">    Data c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= <span class="number">1</span>;j++) &#123;</span><br><span class="line">            c.f[<span class="number">0</span>][i][j] += a.f[<span class="number">0</span>][i][j] + b.f[<span class="number">0</span>][i][j] + a.f[<span class="number">2</span>][i][j] + b.f[<span class="number">1</span>][i][j];</span><br><span class="line">            c.f[<span class="number">1</span>][i][j] += a.f[<span class="number">1</span>][i][j] + a.f[<span class="number">3</span>][i][j], c.f[<span class="number">2</span>][i][j] += b.f[<span class="number">2</span>][i][j] + b.f[<span class="number">3</span>][i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        c.g[<span class="number">0</span>][i] += a.g[<span class="number">0</span>][i] + b.g[<span class="number">0</span>][i] + a.g[<span class="number">2</span>][i] + b.g[<span class="number">1</span>][i];</span><br><span class="line">        c.g[<span class="number">1</span>][i] += a.g[<span class="number">1</span>][i] + a.g[<span class="number">3</span>][i], c.g[<span class="number">2</span>][i] += b.g[<span class="number">2</span>][i] + b.g[<span class="number">3</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= <span class="number">1</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + j &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                c.g[<span class="number">0</span>][i + j] += a.g[<span class="number">2</span>][i] * b.g[<span class="number">1</span>][j], c.g[<span class="number">1</span>][i + j] += a.g[<span class="number">3</span>][i] * b.g[<span class="number">1</span>][j];</span><br><span class="line">                c.g[<span class="number">2</span>][i + j] += a.g[<span class="number">2</span>][i] * b.g[<span class="number">3</span>][j], c.g[<span class="number">3</span>][i + j] += a.g[<span class="number">3</span>][i] * b.g[<span class="number">3</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= <span class="number">1</span>;k++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>;k + l &lt;= <span class="number">1</span>;l++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> ti = (i + j) &amp; <span class="number">1</span>, tj = k + l;</span><br><span class="line">                    c.f[<span class="number">0</span>][ti][tj] += a.f[<span class="number">2</span>][i][k] * b.f[<span class="number">1</span>][j][l], c.f[<span class="number">1</span>][ti][tj] += a.f[<span class="number">3</span>][i][k] * b.f[<span class="number">1</span>][j][l];</span><br><span class="line">                    c.f[<span class="number">2</span>][ti][tj] += a.f[<span class="number">2</span>][i][k] * b.f[<span class="number">3</span>][j][l], c.f[<span class="number">3</span>][ti][tj] += a.f[<span class="number">3</span>][i][k] * b.f[<span class="number">3</span>][j][l];</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> val[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="keyword">void</span>(T[rt].f[<span class="number">3</span>][val[l]][val[l] ^ <span class="number">1</span>] = T[rt].g[<span class="number">3</span>][val[l]] = <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; build(rt &lt;&lt; <span class="number">1</span>, l, mid), build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    T[rt] = UN(T[rt &lt;&lt; <span class="number">1</span>], T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> at)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        val[l] ^= <span class="number">1</span>, T[rt] = Data();</span><br><span class="line">        T[rt].f[<span class="number">3</span>][val[l]][val[l] ^ <span class="number">1</span>] = T[rt].g[<span class="number">3</span>][val[l]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (at &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, at); <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, at);</span><br><span class="line">    T[rt] = UN(T[rt &lt;&lt; <span class="number">1</span>], T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Data <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> T[rt];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (end &lt;= mid) <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span>, l, mid, start, end);</span><br><span class="line">    <span class="keyword">if</span> (start &gt; mid) <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, start, end);</span><br><span class="line">    <span class="keyword">return</span> UN(query(rt &lt;&lt; <span class="number">1</span>, l, mid, start, mid), query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, end));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tree[<span class="number">2</span>][N], n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> at, <span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">for</span> (;at &lt;= n;at += at &amp; -at) tree[id][at] += x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> at)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;at;at -= at &amp; -at) res += tree[id][at];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val[i]), update(<span class="number">0</span>, i, val[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) <span class="keyword">if</span> (val[i] != val[i + <span class="number">1</span>]) update(<span class="number">1</span>, i, <span class="number">1</span>);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n); <span class="keyword">int</span> q; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b != n) update(<span class="number">1</span>, b, <span class="number">-2</span> * (val[b] != val[b + <span class="number">1</span>]) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="number">1</span>) update(<span class="number">1</span>, b - <span class="number">1</span>, <span class="number">-2</span> * (val[b - <span class="number">1</span>] != val[b]) + <span class="number">1</span>);</span><br><span class="line">            update(<span class="number">0</span>, b, <span class="number">-2</span> * val[b] + <span class="number">1</span>), update(<span class="number">1</span>, <span class="number">1</span>, n, b);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c); Data tmp = query(<span class="number">1</span>, <span class="number">1</span>, n, b, c); LL res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">3</span>;i++) res += tmp.f[i][<span class="number">1</span>][<span class="number">0</span>] + tmp.f[i][<span class="number">1</span>][<span class="number">1</span>] + tmp.g[i][<span class="number">1</span>];</span><br><span class="line">            res -= query(<span class="number">0</span>, c) - query(<span class="number">0</span>, b - <span class="number">1</span>) + query(<span class="number">1</span>, c - <span class="number">1</span>) - query(<span class="number">1</span>, b - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (LL)(c - b + <span class="number">1</span>) * (c - b + <span class="number">2</span>) / <span class="number">2</span> - res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/07/FFT%E4%B8%8ENTT%E4%B8%93%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/07/FFT%E4%B8%8ENTT%E4%B8%93%E9%A2%98/" class="post-title-link" itemprop="url">FFT与NTT专题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-07 11:27:43" itemprop="dateCreated datePublished" datetime="2019-04-07T11:27:43+08:00">2019-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:16:53" itemprop="dateModified" datetime="2020-04-23T09:16:53+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A2%98%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">题解</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="A-–-礼物"><a href="#A-–-礼物" class="headerlink" title="A – 礼物"></a>A – 礼物</h1><p>先不管旋转操作，考虑化简这个差异值</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^n(x_i-y_i-c)^2
&=\sum_{i=1}^n(x_i-y_i)^2+nc^2-2c\sum_{i=1}^n(x_i-y_i)\\\
&=\sum_{i=1}^nx_i^2+\sum_{i=1}^ny_i^2+nc^2-2c\sum_{i=1}^n(x_i-y_i)-2\sum_{i=1}^nx_iy_i
\end{aligned}</script><p>注意到$\sum x^2+\sum y^2$是常数，先不管</p>
<p>可以发现，这是一个关于$c$的二次函数</p>
<p>那么我们知道，此时$c$的极值点就在$-\frac{b}{2a}$处</p>
<p>所以，我们可以得出$c$的最优值是</p>
<script type="math/tex; mode=display">
\frac{\sum_{i=1}^n x_i-\sum_{i=1}^n y_i}{n}</script><p>而分子的两个数均与旋转无关</p>
<p>但是$c$只能是整数</p>
<p>所以判一下$c, c-1, c+1$哪个与上面的式子更接近</p>
<p>注意到旋转唯一能改变的是$\sum xy$</p>
<p>而我们要让这个值尽量小</p>
<p>设</p>
<script type="math/tex; mode=display">
F(m)=\sum_{i=1}^nx_iy_{i+m}</script><p>我们可以看出，这是一个类似卷积的东西</p>
<p>但是一般的卷积是后两式下标的和不变</p>
<p>而这个是差不变</p>
<p>所以把这个式子变一下</p>
<p>设</p>
<script type="math/tex; mode=display">
x_{n-i+1}=x_i</script><p>就是将x倒序一下</p>
<p>可以得到 </p>
<script type="math/tex; mode=display">
F(m)=\sum_{i=1}^nx_{n-i+1}y_{i+m}</script><p>不妨设后面$xy$的卷积是$A$，也就是</p>
<script type="math/tex; mode=display">
A(n+m+1)=\sum_{i=1}^nx_{n-i+1}y_{i+m}</script><p>可以发现，这个$A$就是将$F$整体向右平移了$n+1$</p>
<p>所以</p>
<script type="math/tex; mode=display">
F(m)=A(n+m+1)</script><p>为了不丢精度，NTT即可（保证答案不会超过mod）</p>
<p>代码如下 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">int</span> r[N &lt;&lt; <span class="number">2</span>]; <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> type, <span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, w = <span class="number">1</span>, t;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w = (LL)w * Wn % mod)</span><br><span class="line">                t = (LL)w * a[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x[N], y[N], A[N &lt;&lt; <span class="number">2</span>], B[N &lt;&lt; <span class="number">2</span>], res[N];</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; <span class="keyword">inline</span> T <span class="title">Abs</span><span class="params">(<span class="keyword">const</span> T x)</span> </span>&#123;<span class="keyword">return</span> x &gt; <span class="number">0</span> ? x : -x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, sumx = <span class="number">0</span>, sumy = <span class="number">0</span>, sumx2 = <span class="number">0</span>, sumy2 = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x[i]), A[i] = x[i], sumx += x[i], sumx2 += x[i] * x[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;y[i]), B[<span class="number">2</span> * n - i] = B[n - i] = y[i], sumy += y[i], sumy2 += y[i] * y[i];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= <span class="number">3</span> * n) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    NTT(len, <span class="number">1</span>, A), NTT(len, <span class="number">1</span>, B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) A[i] = (LL)A[i] * B[i] % mod;</span><br><span class="line">    NTT(len, <span class="number">0</span>, A); <span class="keyword">int</span> Inv = Pow(len, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) res[i] = (LL)A[<span class="number">2</span> * n - i] * Inv % mod;</span><br><span class="line">    <span class="keyword">int</span> c = (sumx - sumy) / n; LL ans = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">if</span> (Abs((LL)c * n - sumx + sumy) &gt; Abs(((LL)c * n + n - sumx + sumy))) c++;</span><br><span class="line">    <span class="keyword">if</span> (Abs((LL)c * n - sumx + sumy) &gt; Abs(((LL)c * n - n - sumx + sumy))) c--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        LL tmp = (LL)sumx2 + sumy2 - <span class="number">2</span> * res[i] - (LL)<span class="number">2</span> * c * (sumx - sumy) + (LL)n * c * c;</span><br><span class="line">        <span class="keyword">if</span> (tmp &lt; ans) ans = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-–-求和"><a href="#B-–-求和" class="headerlink" title="B – 求和"></a>B – 求和</h1><p>我们知道</p>
<script type="math/tex; mode=display">
S(n,m)=\sum_{i=0}^m(-1)^i{m\choose i}(m-i)^n\frac{1}{m!}</script><p>原理很简单，容斥有几个盒子没有放球，有$m\choose i$种选法，再将$n$个球放入$m-i$个盒子。由于盒子是无序的，最后除以$m$的阶乘</p>
<p>那么我们用这个化简原式</p>
<p>注意到第二个$\sum$的上界是$i$，非常讨厌</p>
<p>由于斯特林数的性质，把这个$i$换成$n$也没有问题</p>
<p>因为当$m&gt;n$时，$S(n,m)=0$</p>
<p>所以有</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=0}^n\sum_{j=0}^nS(i,j)\*2^j\*j!
&=\sum_{j=0}^n2^j\*j!\sum_{i=0}^n\sum_{k=0}^j(-1)^k{j\choose k}(j-k)^i\frac{1}{j!}\\\
&=\sum_{j=0}^n2^j\*j!\sum_{k=0}^j\frac{(-1)^k}{k!}\*\frac{\sum_{i=0}^n(j-k)^i}{(j-k)!}
\end{aligned}</script><p>注意到后面那个是卷积的形式</p>
<p>第一个多项式很好求，第二个的分子是等比数列</p>
<p>我们设$B$是第二个多项式</p>
<p>显然有</p>
<script type="math/tex; mode=display">
B(0)=0, B(1)=n+1</script><p>对于其它情况，直接用等比数列求和公式算出来就行了</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">int</span> r[N &lt;&lt; <span class="number">2</span>]; <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> type, <span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, w = <span class="number">1</span>, t;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w = (LL)w * Wn % mod)</span><br><span class="line">                t = (LL)w * a[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> A[N &lt;&lt; <span class="number">2</span>], B[N &lt;&lt; <span class="number">2</span>], frac[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, len = <span class="number">1</span>, l = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    frac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= <span class="number">2</span> * n) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    A[<span class="number">0</span>] = B[<span class="number">0</span>] = <span class="number">1</span>, B[<span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) A[i] = (i &amp; <span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span>) * Pow(frac[i], mod - <span class="number">2</span>), A[i] = (A[i] + mod) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) B[i] = ((LL)(Pow(i, n + <span class="number">1</span>) - <span class="number">1</span>) * Pow(i - <span class="number">1</span>, mod - <span class="number">2</span>) % mod * Pow(frac[i], mod - <span class="number">2</span>) % mod + mod) % mod;</span><br><span class="line">    NTT(len, <span class="number">1</span>, A), NTT(len, <span class="number">1</span>, B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) A[i] = (LL)A[i] * B[i] % mod;</span><br><span class="line">    NTT(len, <span class="number">0</span>, A); <span class="keyword">int</span> Inv = Pow(len, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) res = (res + (LL)tmp * frac[i] % mod * A[i]) % mod, tmp = tmp * <span class="number">2</span> % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL)res * Inv % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-–-序列统计"><a href="#C-–-序列统计" class="headerlink" title="C – 序列统计"></a>C – 序列统计</h1><p>这题的难点在于转化成原根</p>
<p>注意到要求的是所有数的乘积而非和</p>
<p>如果是和的话直接NTT就好了</p>
<p>那么我们就将乘积转化成和的形式</p>
<p>如果两个数都是某个数的某次方，那么这两个数乘起来就是指数相加</p>
<p>而原根恰好可以表示模$m$剩余系下的每个数</p>
<p>所以把每个数转化成原根的某次方就好了</p>
<p>求原根代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">G</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, flg = <span class="number">1</span>;i;i++, flg = <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>;j * j &lt; x;j++) </span><br><span class="line">            <span class="keyword">if</span> ((x - <span class="number">1</span>) % j == <span class="number">0</span> &amp;&amp; Pow(i, (x - <span class="number">1</span>) / j, x) == <span class="number">1</span>) &#123;flg = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (flg) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-–-残缺的字符串"><a href="#D-–-残缺的字符串" class="headerlink" title="D – 残缺的字符串"></a>D – 残缺的字符串</h1><p>带通配符的字符串匹配问题</p>
<p>首先考虑不带通配符的怎么做</p>
<p>那么拓展KMP， 后缀数组都可以</p>
<p>但是我们有一个更高级的方法：FFT求字符串匹配</p>
<p>首先我们需要定义“匹配”</p>
<p>所以设差异函数$g(i)$表示从$B$串的$i$位置开始，与$A$串的差异程度</p>
<p>有</p>
<script type="math/tex; mode=display">
g(x)=\sum_{i=x}^{x+m-1}(B_i-A_{i-x+1})^2</script><p>显然，只有当$A$串从$x$位置开始与$B$串完全相同，$g$的值才为0</p>
<p>化简原式</p>
<script type="math/tex; mode=display">
\begin{aligned}
g(x)&=\sum_{i=x}^{x+m-1}A_{i-x+1}^2+\sum_{i=x}^{x+m-1}B_i^2-2\sum_{i=x}^{x+m-1}B_iA_{i-x+1}\\\
&=\sum_{i=1}^mA_i^2+\sum_{i=1}^mB_{i+x-1}^2-2\sum_{i=1}^mA_iB_{i+x-1}
\end{aligned}</script><p>前两项可以通过预处理前缀和得出，后面的是一个下标差相等的卷积</p>
<p>那么模仿之前的套路，我们将$A$序列倒序一下再求卷积就行了</p>
<p>解决了不带通配符的问题，再考虑带通配符</p>
<p>这个通配符是可以匹配任意字符的，所以把差异函数改一下</p>
<script type="math/tex; mode=display">
g(x)=\sum_{i=x}^{x+m-1}(B_i-A_{i-x+1})^2A_{i-x+1}B_i</script><p>当$i$处的字符是$*$时，我们设那个地方的值为0</p>
<p>化简得</p>
<script type="math/tex; mode=display">
=\sum_{i=1}^mA_i^3B_{i-x+1}+\sum_{i=1}^mA_iB_{i-x+1}^3-2\sum_{i=1}^xA_i^2B_{i-x+1}^2</script><p>做3次FFT即可</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300010</span></span><br><span class="line"><span class="keyword">int</span> r[N &lt;&lt; <span class="number">2</span>]; <span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> type, <span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; <span class="title">Wn</span><span class="params">(<span class="built_in">cos</span>(<span class="number">2</span> * PI / mid), type * <span class="built_in">sin</span>(<span class="number">2</span> * PI / mid))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid) &#123;</span><br><span class="line">            complex&lt;double&gt; w(1), t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w *= Wn) </span><br><span class="line">                t = w * a[j + (mid &gt;&gt; <span class="number">1</span>)], a[j + (mid &gt;&gt; <span class="number">1</span>)] = a[j] - t, a[j] += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> a[N], b[N]; <span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; A[N &lt;&lt; <span class="number">2</span>], B[N &lt;&lt; <span class="number">2</span>]; <span class="keyword">int</span> a1[N], b1[N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line">LL res[N]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Clear(x) for (int i = 0;i &lt; len;i++) x[i] = 0;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    FFT(len, <span class="number">1</span>, A), FFT(len, <span class="number">1</span>, B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) A[i] *= B[i];</span><br><span class="line">    FFT(len, <span class="number">-1</span>, A);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) res[i] += k * (LL)(A[i].real() / len + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d%s%s"</span>, &amp;m, &amp;n, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) a1[m - i] = a[i] == <span class="string">'*'</span> ? <span class="number">0</span> : a[i] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) b1[i] = b[i] == <span class="string">'*'</span> ? <span class="number">0</span> : b[i] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= m + n) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) A[i] = a1[i] * a1[i] * a1[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) B[i] = b1[i];</span><br><span class="line">    mul(len, n, <span class="number">1</span>); Clear(A) Clear(B)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) A[i] = a1[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) B[i] = b1[i] * b1[i] * b1[i];</span><br><span class="line">    mul(len, n, <span class="number">1</span>); Clear(A) Clear(B)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) A[i] = a1[i] * a1[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) B[i] = b1[i] * b1[i];</span><br><span class="line">    mul(len, n, <span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">if</span> (res[i] == <span class="number">0</span>) ans.push_back(i - m + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : ans) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-–-万径人踪灭"><a href="#E-–-万径人踪灭" class="headerlink" title="E – 万径人踪灭"></a>E – 万径人踪灭</h1><p>假设当前确定了一个对称中心$i$</p>
<p>那么当两个位置$j,k$关于i对称且这两个位置的字母相同时对答案有贡献</p>
<p>对称则意味着$j+k=i*2​$，可以FFT</p>
<p>枚举字符，然后FFT</p>
<p>假设这个中心有x对这样的位置</p>
<p>那么每一对都是独立的，可以选也可以不选，但是不能都不选</p>
<p>所以此时的答案为$2^x-1$</p>
<p>题目要求不能全部连续，那么最后再跑一边<code>manacher</code>，减去全部连续的答案即可</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">int</span> r[N &lt;&lt; <span class="number">2</span>]; <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> p = mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % p) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % p;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> type, <span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, t, w = <span class="number">1</span>;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w = (LL) w * Wn % mod)</span><br><span class="line">                t = (LL)w * a[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> A[N &lt;&lt; <span class="number">2</span>], B[N &lt;&lt; <span class="number">2</span>], pal[N &lt;&lt; <span class="number">2</span>], Pow2[N]; <span class="keyword">char</span> s[N], t[N * <span class="number">2</span>]; <span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">manacher</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    t[<span class="number">0</span>] = <span class="string">'#'</span>, t[n * <span class="number">2</span> + <span class="number">1</span>] = <span class="string">'$'</span>, t[n * <span class="number">2</span> + <span class="number">2</span>] = <span class="string">'@'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) t[i * <span class="number">2</span> - <span class="number">1</span>] = <span class="string">'$'</span>, t[i * <span class="number">2</span>] = s[i]; </span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">1</span>, mx = <span class="number">1</span>, res = <span class="number">0</span>; pal[<span class="number">1</span>] = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n * <span class="number">2</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= mx) pal[i] = min(mx - i + <span class="number">1</span>, pal[<span class="number">2</span> * pos - i]);</span><br><span class="line">        <span class="keyword">else</span> pal[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (t[i - pal[i]] == t[i + pal[i]]) pal[i]++;</span><br><span class="line">        <span class="keyword">if</span> (i + pal[i] - <span class="number">1</span> &gt; mx) mx = i + pal[i] - <span class="number">1</span>, pos = i;</span><br><span class="line">        res = (res + pal[i] / <span class="number">2</span>) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>); <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span> (s[i] == <span class="string">'a'</span>) A[i] = <span class="number">1</span>; <span class="keyword">else</span> B[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>, ans = <span class="number">0</span>; Pow2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Pow2[i] = Pow2[i - <span class="number">1</span>] * <span class="number">2</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n * <span class="number">2</span>) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    NTT(len, <span class="number">1</span>, A), NTT(len, <span class="number">1</span>, B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) A[i] = (LL)A[i] * A[i] % mod, B[i] = (LL)B[i] * B[i] % mod;</span><br><span class="line">    NTT(len, <span class="number">0</span>, A), NTT(len, <span class="number">0</span>, B); <span class="keyword">int</span> Inv = Pow(len, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, t;i &lt;= n * <span class="number">2</span>;i++) &#123;</span><br><span class="line">        t = (LL)(A[i] + B[i]) * Inv % mod + (i &amp; <span class="number">1</span> ^ <span class="number">1</span>);</span><br><span class="line">        ans = (ans + Pow2[t / <span class="number">2</span>] - <span class="number">1</span>) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (ans - manacher(n) + p) % p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F-–-性能优化"><a href="#F-–-性能优化" class="headerlink" title="F – 性能优化"></a>F – 性能优化</h1><p>这道题利用到了FFT的原理</p>
<p>如果模数是质数，那么非常好办</p>
<p>但是这题不仅模数不是质数，而且求的是循环卷积，直接FFT会爆炸</p>
<p>贴一篇我觉得很好的题解</p>
<p><img src="https://0x131cc05home.files.wordpress.com/2019/02/1.jpg?w=700" alt="img"></p>
<p>这个rev数组可以模拟FFT的过程，递归地求出来</p>
<p>单位根满足消去律，上面的$F(\omega_n^i)$指的是$i\leq \frac{n}{p}$的情况</p>
<p>对于剩余的情况，有$\omega_{\frac{n}{p}}^i=\omega_{\frac{n}{p}}^{i-\frac{n}{p}}$</p>
<p>也就是说，代入的$F^{[0]},F^{[1]},\cdots,F^{[p-1]}$都相同，但是系数不同</p>
<p>然后分治就可以了</p>
<p>同样地，最后需要除以<code>len</code>，也就是模数$-1$</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tot, prime[N], r[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetPos</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> dep, <span class="keyword">int</span> len, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep == tot + <span class="number">1</span>) <span class="keyword">return</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> tmp = len / prime[dep], s = x % prime[dep];</span><br><span class="line">    <span class="keyword">return</span> GetPos((x - s) / prime[dep], dep + <span class="number">1</span>, tmp, cnt + tmp * s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp[N], g;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> a[], <span class="keyword">int</span> mod, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) tmp[r[i]] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) a[i] = tmp[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tot, block = <span class="number">1</span>;i &gt;= <span class="number">1</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = block; block *= prime[i];</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(g, type ? (mod - <span class="number">1</span>) / block : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / block, mod);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; len;j++) tmp[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, Wk = <span class="number">1</span>;j &lt; len;j += block, Wk = <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; block;k++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = k % mid, w = <span class="number">1</span>;l &lt; block;l += mid, w = (LL)w * Wk % mod)</span><br><span class="line">                    tmp[j + k] = (tmp[j + k] + (LL)w * a[j + l]) % mod;</span><br><span class="line">                Wk = (LL)Wk * Wn % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; len;j++) a[j] = tmp[j];</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">GetG</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, flag = <span class="number">1</span>;i;i++, flag = <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>;j * j &lt; x;j++)</span><br><span class="line">            <span class="keyword">if</span> (Pow(i, (x - <span class="number">1</span>) / j, x) == <span class="number">1</span>) &#123;flag = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> A[N &lt;&lt; <span class="number">2</span>], B[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, C; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;C);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;B[i]);</span><br><span class="line">    <span class="keyword">int</span> tmp = n; g = GetG(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i * i &lt;= tmp;i++)</span><br><span class="line">        <span class="keyword">while</span> (tmp % i == <span class="number">0</span>) prime[++tot] = i, tmp /= i;</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="number">1</span>) prime[++tot] = tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) r[i] = GetPos(i, <span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line">    NTT(n, A, n + <span class="number">1</span>, <span class="number">1</span>), NTT(n, B, n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) A[i] = (LL)A[i] * Pow(B[i], C, n + <span class="number">1</span>) % (n + <span class="number">1</span>);</span><br><span class="line">    NTT(n, A, n + <span class="number">1</span>, <span class="number">0</span>); <span class="keyword">int</span> Inv = Pow(n, n - <span class="number">1</span>, n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL)A[i] * Inv % (n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="H-–-Frightful-Formula"><a href="#H-–-Frightful-Formula" class="headerlink" title="H – Frightful Formula"></a>H – Frightful Formula</h1><p>算是比较简单的一道题</p>
<p>公式等价于一个表格，往右走有$a$种方法，往下走有$b$种方法，还可以直接从这个格子开始走，有$c$种方法</p>
<p>先不考虑第一行和第一列格子</p>
<p>假设是从$i,j$这个格子开始走的</p>
<p>那么，这个格子需要向右走$n-j$步，向下走$n-i$步</p>
<p>对答案的贡献是</p>
<script type="math/tex; mode=display">
c\*a^{n-i}\*b^{n-j}\*{n-i+n-j\choose n-i}</script><p>含义是，从这个格子开始，有$c$种走法，向有走$n-j$次，向下走$n-i$次，在$n-j+n-i$步中，有$n-i​$步是往下走的</p>
<p>那么，把这些空白的格子加起来，我们可以得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
c\sum_{i=2}^n\sum_{j=2}^na^{n-i}b^{n-j}{n-i+n-j\choose n-i}
&=c\sum_{i=0}^{n-2}\sum_{j=0}^{n-2}a^ib^j{i+j\choose i}\\\
&=c\sum_{i=0}^{n-2}\frac{a^i}{i!}\sum_{j=0}^{n-2}(i+j)!\frac{b^j}{j!}
\end{aligned}</script><p>我们可以枚举$i$，后面的是一个下标差相等的卷积</p>
<p>将多项式逆序一下就可以了</p>
<p>这道题没有给模数，而答案又很大</p>
<p>为了防止丢精度，所以使用MTT</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e6</span> + <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> p = mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % p) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % p;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ZJK = (<span class="number">1</span> &lt;&lt; <span class="number">19</span>) + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> frac[N * <span class="number">2</span>], f[<span class="number">2</span>][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;<span class="keyword">return</span> (LL)frac[n] * Pow(frac[r], mod - <span class="number">2</span>) % mod * Pow(frac[n - r], mod - <span class="number">2</span>) % mod;&#125;</span><br><span class="line"><span class="comment">// #define double long double</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CP</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    CP(<span class="keyword">double</span> _x = <span class="number">0</span>, <span class="keyword">double</span> _y = <span class="number">0</span>) : x(_x), y(_y) &#123;&#125;</span><br><span class="line">    CP <span class="keyword">operator</span> * (<span class="keyword">const</span> CP &amp;b) &#123;<span class="keyword">return</span> CP(x * b.x - y * b.y, x * b.y + y * b.x);&#125;</span><br><span class="line">    CP <span class="keyword">operator</span> + (<span class="keyword">const</span> CP &amp;b) &#123;<span class="keyword">return</span> CP(x + b.x, y + b.y);&#125;</span><br><span class="line">    CP <span class="keyword">operator</span> - (<span class="keyword">const</span> CP &amp;b) &#123;<span class="keyword">return</span> CP(x - b.x, y - b.y);&#125;</span><br><span class="line">    CP <span class="keyword">operator</span> / (<span class="keyword">const</span> <span class="keyword">double</span> b) &#123;<span class="keyword">return</span> CP(x / b, y / b);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> r[ZJK]; <span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> type, CP a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">CP <span class="title">Wn</span><span class="params">(<span class="built_in">cos</span>(<span class="number">2</span> * PI / mid), type * <span class="built_in">sin</span>(<span class="number">2</span> * PI / mid))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid) &#123;</span><br><span class="line">            CP w(1), t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w = w * Wn) </span><br><span class="line">                t = w * a[j + (mid &gt;&gt; <span class="number">1</span>)], a[j + (mid &gt;&gt; <span class="number">1</span>)] = a[j] - t, a[j] = a[j] + t; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">-1</span>) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) a[i] = a[i] / len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line">CP a[ZJK], b[ZJK], c[ZJK], d[ZJK];</span><br><span class="line"><span class="keyword">int</span> A[ZJK], B[ZJK];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MTT</span><span class="params">(<span class="keyword">int</span> len, LL m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) a[i] = A[i] / m, b[i] = A[i] % m, c[i] = B[i] / m, d[i] = B[i] % m;</span><br><span class="line">    FFT(len, <span class="number">1</span>, a), FFT(len, <span class="number">1</span>, b), FFT(len, <span class="number">1</span>, c), FFT(len, <span class="number">1</span>, d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) &#123;</span><br><span class="line">        CP a1 = a[i], b1 = b[i], c1 = c[i], d1 = d[i];</span><br><span class="line">        a[i] = a1 * c1, b[i] = a1 * d1, c[i] = b1 * c1, d[i] = b1 * d1;</span><br><span class="line">    &#125;</span><br><span class="line">    FFT(len, <span class="number">-1</span>, a), FFT(len, <span class="number">-1</span>, b), FFT(len, <span class="number">-1</span>, c), FFT(len, <span class="number">-1</span>, d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) </span><br><span class="line">        A[i] = ((LL)(a[i].x + <span class="number">0.5</span>) * m % mod * m % mod + (LL)(b[i].x + <span class="number">0.5</span>) * m % mod + (LL)(c[i].x + <span class="number">0.5</span>) * m % mod</span><br><span class="line">            + (LL)(d[i].x + <span class="number">0.5</span>)) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c, n; <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;a, &amp;b, &amp;c), frac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;f[<span class="number">1</span>][i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;f[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n * <span class="number">2</span>;i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, tmp1 = Pow(b, n - <span class="number">1</span>), tmp2 = Pow(a, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) ans = (ans + (LL)f[<span class="number">0</span>][i] * C(<span class="number">2</span> * n - <span class="number">2</span> - i, n - i) % mod * tmp1 % mod * Pow(a, n - i)) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) ans = (ans + (LL)f[<span class="number">1</span>][i] * C(<span class="number">2</span> * n - <span class="number">2</span> - i, n - i) % mod * tmp2 % mod * Pow(b, n - i)) % mod;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= <span class="number">2</span> * n) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t;i &lt;= n - <span class="number">2</span>;i++) t = Pow(frac[i], mod - <span class="number">2</span>), A[i] = (LL)Pow(a, i) * t % mod, B[i] = (LL)Pow(b, i) * t % mod;</span><br><span class="line">    MTT(len, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">2</span> * n - <span class="number">4</span>;i++) ans = (ans + (LL)c * A[i] % mod * frac[i]) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="PlanarG"
      src="/images/77041874_p0_master12001.jpg">
  <p class="site-author-name" itemprop="name">PlanarG</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">179</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">64</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">PlanarG</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1.5,"jsonPath":"/live2dw/assets/histoire.model.json"},"display":{"position":"left","width":150,"height":300,"hOffset":35,"vOffset":-25},"mobile":{"show":false},"log":false});</script></body>
</html>
