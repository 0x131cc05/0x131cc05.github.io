<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"planarg.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="PlanarG&#39;s blog">
<meta property="og:url" content="https://planarg.top/page/16/index.html">
<meta property="og:site_name" content="PlanarG&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="PlanarG">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://planarg.top/page/16/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>PlanarG's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">PlanarG's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section">首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section">标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section">分类</a>

  </li>
        <li class="menu-item menu-item-友链">

    <a href="/friends/" rel="section">友链</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section">归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger">搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/18/4-17%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/18/4-17%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/" class="post-title-link" itemprop="url">4.17省选模拟</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-18 19:01:27" itemprop="dateCreated datePublished" datetime="2019-04-18T19:01:27+08:00">2019-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:27:36" itemprop="dateModified" datetime="2020-04-23T09:27:36+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="T1-圈草地"><a href="#T1-圈草地" class="headerlink" title="T1 圈草地"></a>T1 圈草地</h1><p><img src="https://i.loli.net/2019/04/18/5cb8598ea8a77.png" alt="1555585345165"></p>
<p><img src="https://i.loli.net/2019/04/18/5cb859b53dd70.png" alt="1555585452299"></p>
<p>我们只考虑有用的左上角和右下角</p>
<p>考虑两个点$a,b$，如果$a$在$b$的第二象限，那么选择$a$作为左上角一定比选择$b$作为左上角优秀</p>
<p>那么我们将所有有用的点分两层排在一起，第一层是可以作为左上角的点，第二层是可以作为右下角的点</p>
<p><img src="https://i.loli.net/2019/04/18/5cb860d2e1fd7.png" alt="1555587272118"></p>
<p>我们考虑当右下角的点移动的时候左上角的最优决策点会如何变化</p>
<p>假如原来的最优决策点是$a$，另一个在$a$右上角的点是$b$，那么我们可以发现，右下角的点移动之后，$b$与之构成的矩形的面积与$a$与之构成的矩形的面积之差变大了</p>
<p>也就是说，移动之后，$b$会变得更加优秀</p>
<p>所以最优决策点是单调向右上角移动的</p>
<p>我们可以采用分治</p>
<p><code>solve(l, r, L, R)</code>表示右下角的点对应的区间是$[L,R]$，对应的最优决策点的区间是$[l,r]$</p>
<p>我们找到$l,r$的中点$mid$，二分出右下角那些点的最优决策点在$[l,mid]$中</p>
<p>然后继续分治下去</p>
<p>对于找一个矩形内部有多少个点，可以使用主席树</p>
<p>时间复杂度$O(n\log^3n)$</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, lson, rson, sum;</span><br><span class="line">&#125; T[N * <span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> RT[N], ncnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rt = ++ncnt; T[rt].l = l, T[rt].r = r, T[rt].lson = T[rt].rson = T[rt].sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> rt;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; T[rt].lson = build(l, mid), T[rt].rson = build(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> at)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nw = ++ncnt, l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>; T[nw] = T[rt], T[nw].sum++;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> nw;</span><br><span class="line">    <span class="keyword">if</span> (at &lt;= mid) T[nw].lson = update(T[nw].lson, at);</span><br><span class="line">    <span class="keyword">else</span> T[nw].rson = update(T[nw].rson, at);</span><br><span class="line">    <span class="keyword">return</span> nw;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt1, <span class="keyword">int</span> rt2, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt2].l, r = T[rt2].r, mid = (l + r) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> T[rt2].sum - T[rt1].sum;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) res += query(T[rt1].lson, T[rt2].lson, start, end);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; end) res += query(T[rt1].rson, T[rt2].rson, start, end);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125; st1[N], st2[N];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>, top1, top2;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x1 = st1[a].x, y1 = st1[a].y, x2 = st2[b].x, y2 = st2[b].y;</span><br><span class="line">    <span class="keyword">return</span> query(RT[x1 - <span class="number">1</span>], RT[x2], y2, y1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = l, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l;i &lt;= r;i++) <span class="keyword">if</span> (st1[i].x &lt;= st2[x].x &amp;&amp; st2[x].y &lt;= st1[i].y) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = query(i, x);</span><br><span class="line">        <span class="keyword">if</span> (res &lt;= tmp) res = tmp, pos = i;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; mid) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L;i &lt;= R;i++) </span><br><span class="line">            <span class="keyword">if</span> (st1[l].x &lt;= st2[i].x &amp;&amp; st2[i].y &lt;= st1[l].y)</span><br><span class="line">                ans = max(ans, query(l, i));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, l1 = L, r1 = R, m, pos = l1;</span><br><span class="line">    <span class="keyword">while</span> (l1 &lt;= r1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check(l, r, m = ((l1 + r1) &gt;&gt; <span class="number">1</span>), mid)) pos = m, l1 = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r1 = m - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    solve(l, mid, L, pos), solve(mid + <span class="number">1</span>, r, pos + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l;i &lt;= r;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = L;j &lt;= R;j++)</span><br><span class="line">            <span class="keyword">if</span> (st1[i].x &lt;= st2[j].x &amp;&amp; st2[j].y &lt;= st1[i].y)</span><br><span class="line">                ans = max(ans, query(i, j));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), RT[<span class="number">0</span>] = build(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), RT[i] = update(RT[i - <span class="number">1</span>], a);</span><br><span class="line">        <span class="keyword">if</span> (a &gt; st1[top1].y) st1[++top1] = (point)&#123;i, a&#125;;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (top2 &amp;&amp; st2[top2].y &gt; a) top2--;</span><br><span class="line">            st2[++top2] = (point)&#123;i, a&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (top1 &lt;= <span class="number">500</span> &amp;&amp; top2 &lt;= <span class="number">500</span>) solve2(<span class="number">1</span>, top1, <span class="number">1</span>, top2);</span><br><span class="line">    <span class="keyword">else</span> solve(<span class="number">1</span>, top1, <span class="number">1</span>, top2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-道路修建"><a href="#T2-道路修建" class="headerlink" title="T2 道路修建"></a>T2 道路修建</h1><p><img src="https://i.loli.net/2019/04/18/5cb8627245de8.png" alt="1555587688425"></p>
<p><img src="https://i.loli.net/2019/04/18/5cb86290b9bd9.png" alt="1555587721754"></p>
<p>容易发现一个结论：对于一个点$u$，假设它与$v$相连，那么它距离一号城市的最短路距离$d_u$一定满足$d_v-1\leq d_u\leq d_v+1$</p>
<p>那么我们可以通过这个建图跑网络流</p>
<p>将每个点拆成$n$个点，第$x$个点表示当前点的最短路是否大于等于$x-1$</p>
<p>将第一个拆出来的点与源点连一条$\infty$的边，将最后一个拆出来的点与汇点连一条$\infty$的边</p>
<p>将第$i$个拆出来的点向第$i+1$个点连一条权值为题中给出公式的边</p>
<p>最小割中，与$S$集合连接代表为<code>true</code>，否则为<code>false</code></p>
<p>为了满足$d_v-1\leq d_u\leq d_v+1$这个限制，我们可以模仿切糕这道题的做法</p>
<p>对于任意两个有边相连的点$u,v$，$u$拆出来的第$i$个点向$v$拆出来的第$i-1$个点连一条无法割掉的$\infty$ 的边</p>
<p>注意$(u,v)和(v,u)$是不一样的</p>
<h1 id="T3-美术作业"><a href="#T3-美术作业" class="headerlink" title="T3 美术作业"></a>T3 美术作业</h1><p><img src="https://i.loli.net/2019/04/18/5cb86451553e8.png" alt="1555588168670"></p>
<p><img src="https://i.loli.net/2019/04/18/5cb86482a8c37.png" alt="1555588211145"></p>
<p>可以看出，这是一个基环外向树</p>
<p>我们先考虑一棵树的情况：如何求它的染色方案</p>
<p>由于边是有向的，所以置换对答案的影响只有可能是对于$u$这个点，它有一些子树是完全同构的</p>
<p>比如这样</p>
<p><img src="https://i.loli.net/2019/04/18/5cb8658170f30.png" alt="1555588473582"></p>
<p>注意到如果$2,3,4$这几个点互换编号，那么结构是不变的</p>
<p>比如“2染颜色1，3染颜色1，4染颜色2”这种方案与“2染颜色2，3染颜色1，4染颜色1”是完全等价的</p>
<p>而不同构的子树之间是没有关系的</p>
<p>那么对于这种同构的情况怎么办呢</p>
<p>由于$2,3,4$都是同构的，所以它们的染色方案一定都一样，我们假设有$f$种方案，有$t$棵子树</p>
<p>我们将这$f$种染色方案分别编号为$1,2\cdots,f$，对于这些同构的子树按照根节点的编号排序</p>
<p>然后在这$f$种方案中选出$t$种，可以重复，然后按照从小到大的顺序依次给这些同构的子树染色，这样统计出来的结构一定不会重复</p>
<p>等价于将$t$个球放入$f$个盒子，每个盒子可以空</p>
<p>所以方案数为</p>
<script type="math/tex; mode=display">
f{f+t-1\choose f-1}=f{f+t-1\choose t}</script><p>现在我们求出了环上每棵树的染色方案</p>
<p>我们来考虑环的置换</p>
<p>对于一种置换后的不动点，它们对应树的结构必须相同，染的颜色也必须相同</p>
<p>所以对于每棵树最后得到的<code>hash</code>值我们跑一个<code>KMP</code>，求出它的最小循环节，这样每次转的次数一定是循环节长度的倍数</p>
<p>每个循环节我们将它看作一个点，染色方案为它包含的树的染色方案的乘积</p>
<p>然后就是普通<code>polya</code>了，枚举转多少次，然后不动点个数就是每个循环节的方案的$gcd(总长度，转的次数)$次方</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uLL unsigned long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = inv[r];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= r;i++)</span><br><span class="line">        res = (LL)res * (n - i + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt, dp[N], tmp[N], m;</span><br><span class="line">uLL P = <span class="number">233</span>, h[N], s[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> nxt[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ls = nxt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (ls &amp;&amp; s[ls + <span class="number">1</span>] != s[i]) ls = nxt[ls];</span><br><span class="line">        nxt[i] = ls + (s[ls + <span class="number">1</span>] == s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n % (n - nxt[n]) ? <span class="number">-1</span> : n - nxt[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next) </span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) tmp[++top] = e[i].to;</span><br><span class="line">    sort(tmp + <span class="number">1</span>, tmp + top + <span class="number">1</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> h[a] &lt; h[b];&#125;), h[u] = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= top;i++) </span><br><span class="line">        h[u] = ((h[u] * P + h[tmp[i]]) ^ h[tmp[i]]) + h[tmp[i]];</span><br><span class="line">    dp[u] = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, last;i &lt;= top;i = last) &#123;</span><br><span class="line">        <span class="keyword">for</span> (last = i;last &lt;= top &amp;&amp; h[tmp[last]] == h[tmp[i]];last++);</span><br><span class="line">        dp[u] = (LL)dp[u] * C(dp[tmp[i]] + last - i - <span class="number">1</span>, last - i) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> b ? gcd(b, a % b) : a;&#125;</span><br><span class="line"><span class="keyword">int</span> to[N], vis[N], cir[N], mark[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, tot = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;to[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = i;!vis[j];j = to[j]) vis[j] = i;</span><br><span class="line">        <span class="keyword">if</span> (vis[j] != i) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (;!mark[j];j = to[j]) mark[j] = <span class="number">1</span>, cir[++tot] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span> (!mark[i]) adde(to[i], i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tot;i++) dfs(cir[i], <span class="number">0</span>), s[i] = h[cir[i]];</span><br><span class="line">    <span class="keyword">int</span> zjk = KMP(tot), ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (~zjk) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= zjk;i++) f = (LL)f * dp[cir[i]] % mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tot / zjk;i++)</span><br><span class="line">            ans = (ans + Pow(f, gcd(i, tot / zjk))) % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL)ans * Pow(tot / zjk, mod - <span class="number">2</span>) % mod);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tot;i++) ans = (LL)ans * dp[cir[i]] % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/14/SCOI2019-%E6%B8%B8%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/14/SCOI2019-%E6%B8%B8%E8%AE%B0/" class="post-title-link" itemprop="url">SCOI2019 游记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-14 19:14:35" itemprop="dateCreated datePublished" datetime="2019-04-14T19:14:35+08:00">2019-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:12:04" itemprop="dateModified" datetime="2020-04-23T09:12:04+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B8%B8%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">游记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="写在之前的话"><a href="#写在之前的话" class="headerlink" title="写在之前的话"></a>写在之前的话</h1><p>感觉<code>NOIP</code>之后就有点没救了，之后冬令营全机房都去了</p>
<p>425分有点凉凉</p>
<p>不过可以试试冲E类</p>
<p>赶紧复习一下<code>exBSGS, exCRT, Cipolla</code></p>
<p>朱刘算法懒得看了</p>
<h1 id="Day0"><a href="#Day0" class="headerlink" title="Day0"></a>Day0</h1><p>比赛之前发了一个笔试考察范围，结果是去年<code>NOI</code>的笔试题库</p>
<p>本来以为要考什么神仙内容，结果笔试及其简单</p>
<p>重点是<strong>连题目顺序都和题库一样</strong></p>
<p>笔试时间是一个小时，结果30分钟可以走人的时候我在的这个考室已经没人了</p>
<p>感觉只要看了题库就应该是100分吧（雾</p>
<p>话说电子科大的教学楼上“电子科技大学”这几个字看起来好像电子神技大学</p>
<p>晚上看卢爷颓风暴英雄</p>
<p><del>Celeste真好玩</del></p>
<h1 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h1><p>路上单向模<code>ZJK</code></p>
<blockquote>
<p>我自闭了</p>
<p>我爆零了</p>
<p>来机房看神仙</p>
<p><code>rank</code> $10^9+7$</p>
</blockquote>
<p>结果每次考完之后都<code>rank</code> 1</p>
<p>这是某些选手的真实写照</p>
<hr>
<p>拿到试题之后解压，嗯？密码是一串数字</p>
<p>先看<code>T1</code>，那个图片有点劣质啊。。。</p>
<p>貌似是用<code>mspaint</code>画的</p>
<p>不过还将就</p>
<p>手玩了一下样例，好像找到了一点规律的样子</p>
<p>开考5分钟找工作人员要了几张纸</p>
<p>上个厕所冷静一下，顺便思考一下<code>T1</code></p>
<p>嗯？这不是SB题吗，只要不是划水选手都会做吧。。。</p>
<p>对于最有步数，显然有</p>
<script type="math/tex; mode=display">
f_m=3f_{m-1}+n-1</script><p>然后随便分治一下就行了</p>
<p>一发过掉大样例</p>
<p>题目中说$Q_i$小于等于答案的上限，然而又没说上限是多少</p>
<p>感觉有阴谋</p>
<p>保证答案小于等于30，有什么用呢</p>
<p>意思是$Q_i\leq (n-1)*3^{30}$吗</p>
<p>然后发现显然是假的，$Q_i$可以达到$3^{1000}$</p>
<p>手写高精度！</p>
<p><code>T2</code>的名字叫“肯赛训练”</p>
<p>这里是否有肯德基强行打广告的成份</p>
<p>思考了一下，感觉那个边权是假的</p>
<p>所以是个区间求重心？不会啊</p>
<p>先写暴力吧，好像很莫队的样子</p>
<p>加一个点很好处理，新的重心一定在原来的重心与加的点的连线上</p>
<p>貌似<code>LCT</code>维护虚子树信息可以做到$\log$?</p>
<p>于是开始码<code>LCT</code>，做好了6kb的准备</p>
<p>码了2kb的时候</p>
<p>woc?加点可以直接$\log$，那删点怎么办？</p>
<p>冷静一下</p>
<p>这个东西好像不是很好维护的样子，干脆暴跳吧</p>
<p>好像加点之后重心的移动次数是$O(\log)$的</p>
<p>先码一个树状数组</p>
<p>代码还是挺简单的</p>
<p>我的程序跑得巨慢无比</p>
<p><code>30s</code>后过了大样例</p>
<p>来看<code>T3</code></p>
<p>好像很多项式的样子</p>
<p>卷积的运算符是乘？是不是可以原根什么的啊</p>
<p>然后发现显然不是</p>
<p>还好暴力分给得很足</p>
<p>直接一行代码有5分</p>
<p>剩下的直接暴力数论分块可以再拿25分</p>
<p>貌似有两个$q=1$的点</p>
<p>欸是不是可以爆搜然后乘一个排列数啊</p>
<p>写完之后发现T成SB了</p>
<p>这个时候离考试结束大概还有10分钟</p>
<p>再来检查一下<code>T1</code>吧</p>
<p>手输了一组极限数据</p>
<p>wtf?RE?</p>
<p>赶紧看一下</p>
<p>还好在最后一分钟的时候发现是高精板子错了</p>
<p>那个高精乘的时候我是边乘边取模233</p>
<p>所以最后估分$100+[30-50]+30$?</p>
<p>莫队的分数很玄学的</p>
<hr>
<p><code>ZJK</code>说他<code>T1</code>可能会被卡常，然后期望$50+50+50$</p>
<p><code>ZYW</code>貌似切了<code>T2</code>的60分</p>
<p>都好强啊</p>
<p>很不幸，我面试是第6轮，也就是最后一轮</p>
<p>本来以为要考什么小学奥数，结果是政治问题？（雾</p>
<p><code>Bh</code>是第一轮，他说他们那组的面试题目是评论中美贸易战</p>
<p><code>hxy</code>的题目是七中食堂事件</p>
<p>还有什么国民党为什么会失败</p>
<p>好有趣啊</p>
<p>4：10之前一直在楼梯上坐着</p>
<p>看陈爷玩炉石</p>
<p>经过漫长的等待，终于轮到我了</p>
<p>感觉我们这组只有我一个初中的</p>
<p>拿到题目：如何评价近年来自主招生政策遭到限制？</p>
<p>开始10分钟讨论</p>
<p>丝毫没有面试经验</p>
<p>10分钟之后</p>
<p>考官：之前我提出的要求是讨论并选出一位代表发言，但是10分钟已经过去了，你们却没有选出一位代表</p>
<p>我们：。。。</p>
<p>考官：从面试的角度来说，你们这次讨论是失败的</p>
<p>我们：。。。</p>
<p>考官：现在再给你们一次机会，选出一个代表发言</p>
<p>显然不是我了2333</p>
<p>感觉面试是不是有点凉啊</p>
<hr>
<p>晚上来看成绩</p>
<p>嗯？$60+45+30?$</p>
<p><code>T1</code>的高精度果然<code>T</code>了啊</p>
<p>如果把11位压到17位应该就不会超时了</p>
<p>还是太菜了</p>
<p>orz陈爷180</p>
<p><code>ZYW</code>165，看来她进E类稳了</p>
<p><code>ZJK</code>好像有点爆炸？只有100，但是如果算上<code>NOIP</code>的话还是在我前面</p>
<p>看了看此时的加权成绩，<code>rk</code>21，好像有点凉？</p>
<p>明天加油吧</p>
<h1 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h1><p>考前陈爷口胡动态<code>SA</code>，感觉他A类很稳</p>
<p>拿到试题，密码又全是数字</p>
<p>先看<code>T1</code></p>
<p>好像很模板的样子</p>
<p>感觉那个分成两半部分，再取一个部分的操作没啥用</p>
<p>如果根据询问把每个点变一下，那不是最大子段和吗？</p>
<p>50pts get</p>
<p>如果要动态的话，线段树维护凸包？？？</p>
<p>反正这种东西我是很难写出来的</p>
<p>那线段树维护矩阵？？？</p>
<p>好像不是</p>
<p>两个自变量有点不爽，可以去掉一个</p>
<p>等等，前缀和之后好像是个很裸的斜率优化</p>
<p>15分钟码完，代码只有2kb。。</p>
<p>对拍了上万组数据，感觉很稳</p>
<p>来看<code>T2</code></p>
<p>哇，这是论文题欸！</p>
<p>去年国家集训队论文，有一个“解决树上连通块问题的一些技巧和工具”</p>
<p>原题啊！！！！</p>
<p>具体方法是利用“边数 = 点数 - 1”这个等式来容斥</p>
<p>枚举某个点作为$x$的方案数，减去某条边两个端点都是$x$的方案数</p>
<p>然后就切了？？？</p>
<p>跑一下大样例</p>
<p>嗯？输出负数？改成<code>long long</code></p>
<p>嗯？还是负数，看看答案</p>
<p>woc？答案怎么这么小</p>
<p>举手向监考老师求助</p>
<p>我：第二道题有模数吗</p>
<p>老师：题目中写了吗</p>
<p>我：没有啊，但是大样例无论如何都不可能这么小</p>
<p>老师：这个。。。你自己认真读题吧</p>
<p>我：<code>&amp;#fsdl&amp;DFfd*#$jkrhf29873Q@!Rds</code></p>
<p>不久之后更正通知下来了，模数是$10^9+7$</p>
<p>改一下程序，过了！很好</p>
<p>开始看<code>T3</code></p>
<p>这看上去很线性基</p>
<p>事实上线性基的确可以获得20分的好成绩</p>
<p>思考了一下感觉没有发现什么好的性质，果断写暴力</p>
<p>前20分直接暴力，后面20分线性基，然后还有20分貌似是找规律？</p>
<p>好像是$2^{不同数的个数}$的样子？</p>
<p>写！</p>
<p>11：00的时候我就码完了</p>
<p><code>T1</code>仍然没有拍出错</p>
<p>前面好像有个七中大佬在玩纸牌？</p>
<p>我默默地点开了扫雷</p>
<p>2min后</p>
<p>太不友好了！</p>
<p>还是试试虚拟机吧</p>
<p>结果打开虚拟机让我的电脑卡了一会儿</p>
<p>无聊打了一个程序模<code>ZJK</code></p>
<p>之后看了看各个<code>IDE</code>的作者信息</p>
<p>坐了2h后考试结束了</p>
<p>所以我今天估分$100+100+60?$感觉翻盘有望？</p>
<p><code>ZJK</code>和<code>ZYW</code>都估分$100+40+40$</p>
<p><code>ZYW</code>说她<code>T1</code>是在线，是在凸包上二分</p>
<p>蒟蒻只会离线</p>
<p>下午拿到成绩，前两道题确实是100，但是第三题只有40，总分240</p>
<p>看来是规律假了</p>
<p>不过，我竟然是rk 1？</p>
<p><code>ZYW</code>和<code>ZJK</code>确实是180，E类稳了</p>
<p><code>BH</code>有点神仙啊，切了<code>T2</code>，但是<code>T1</code>爆零了，本来是很有希望的</p>
<p>坐看卢爷翻盘240，orz</p>
<p>事实证明考前无聊的时候看看论文总是有用的</p>
<p>预祝陈爷<code>NOI</code>取得好成绩！</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>如果不是第二天的成功翻盘，我有可能进不了E类</p>
<p>感觉这次我们学校进步好大啊，去年只有一个省队</p>
<p>强者都上了400分orz</p>
<p>想起去年我失败的<code>SCOI</code>，想要了解详情可以知乎搜索<code>SCOI2018</code></p>
<p>希望我能够坚持到最后</p>
<p><code>NOI2019</code>见</p>
<h1 id="补充：关于题意"><a href="#补充：关于题意" class="headerlink" title="补充：关于题意"></a>补充：关于题意</h1><h2 id="D1T1-小红球的跳跃"><a href="#D1T1-小红球的跳跃" class="headerlink" title="D1T1 小红球的跳跃"></a>D1T1 小红球的跳跃</h2><p>有$m$个小红球，$n$个空岛。其中第一个、最后一个空岛以及中间的第$k$个空岛是固定的$(1&lt;k&lt;n)$是固定的，其余空岛是悬浮的。一开始所有小红球都在第一个空岛，你的目标是把他们都移动到最后一个空岛，并且使用的步数尽量小。</p>
<p>每回合你可以移动一个小红球到它左边或者右边的那个平台，但是有一些限制：</p>
<ul>
<li>移动的小红球必须是移动前/移动后它所在的平台上编号最小的。</li>
<li>如果一个小红球移动到了一个浮动平台上，那下一回合必须将这个小红球移走，否则它就会掉下去。</li>
</ul>
<p>有$q$个询问，每次给出一个时刻，你需要回答在最优方案中，这个时刻正在跳跃的是哪个小红球。</p>
<p>保证答案小于$30$，$n\leq 10^8,m\leq1000,q\leq5000$，时限$1$s</p>
<p>保证询问给出的时刻小于等于最优方案数</p>
<p>部分分：</p>
<ul>
<li>对于$20\%$的数据，保证$m,n,q\leq10$</li>
<li>对于$50\%$的数据，保证$n\leq 10^8,m\leq 10,q\leq 5000$</li>
</ul>
<h2 id="D1T2-肯赛训练"><a href="#D1T2-肯赛训练" class="headerlink" title="D1T2 肯赛训练"></a>D1T2 肯赛训练</h2><p>给出一棵树，$n$个节点，每条边有边权$c_i$。</p>
<p>给出一个点的序列，这个序列有$m$个数，第$i$个数$a_i$代表编号为$a_i$的点</p>
<p>有$q$个询问，每次询问给出一段区间$[l,r]$，你要在树上选出一个点，使得这个点离$a_l,a_{l+1},\cdots,a_{r}$的距离之和尽量小，输出这个点的编号</p>
<p>注意，选出的点不一定是$a_{l},a_{l+1},\cdots,a_r$其中的某一个</p>
<p>保证$n\leq 3*10^5,c_i\leq 1000,m\leq5*10^5,q\leq10^6$，区间的长度是奇数，时限$3$s</p>
<p>部分分：</p>
<ul>
<li>对于前$20\%$的数据，保证$n,m,q\leq2*10^3$</li>
<li>对于前$35\%$的数据，保证$m,q\leq2*10^3$</li>
<li><p>对于前$60\%$的数据，保证$n,m,q\leq10^5$</p>
</li>
<li><p>对于另$15\%$的数据，保证每个点的度数不超过$2$</p>
</li>
</ul>
<h2 id="D1T3-超矩形"><a href="#D1T3-超矩形" class="headerlink" title="D1T3 超矩形"></a>D1T3 超矩形</h2><p>给出一个数$n$，你需要找到$k$个数$a_1,a_2,\cdots,a_k$使得$\prod_{i=1}^ka_i\leq n$</p>
<p>给出一个变换$b_1,b_2,\cdots,b_k$，保证$b_i&lt;10$</p>
<p>你需要求出</p>
<script type="math/tex; mode=display">
\sum_{所有合法的方案}\prod_{i=1}^ka_i^{b_i}\pmod {998244353}</script><p>多组数据（$t$组）</p>
<p>保证$n\leq10^6,\sum k\leq10^6,t\leq100$，时限$4$s</p>
<p>给出$b$的方式是$q$个$s_i,r_i$，表示有连续$r_i$个$b_i$是$s_i$</p>
<p>保证$s_i$互不相同，$q&lt;5$</p>
<p>部分分：</p>
<ul>
<li>对于前$10\%$的数据，保证$k=1,q=1,s=0$</li>
<li>对于前$20\%$的数据，保证$k=1,q=1,s\leq1$</li>
<li><p>对于前$30\%$的数据，保证$k\leq2,q\leq2$</p>
</li>
<li><p>对于另$20\%$的数据，保证$q=1$</p>
</li>
</ul>
<h2 id="D2T1-湖之精灵的游戏"><a href="#D2T1-湖之精灵的游戏" class="headerlink" title="D2T1 湖之精灵的游戏"></a>D2T1 湖之精灵的游戏</h2><p>一个二维平面上有$n$个点，第$i$个点的坐标是$(x_i,y_i)$，你要和一位神仙玩游戏。</p>
<p>每次神仙会告诉你一个坐标$(x,y)$，连一条经过$(0,0),(x,y)$的直线，这会把平面分成两个部分$A,B$</p>
<p>你要选择一个区间$[l,r]$，那么计算的时候只会考虑编号在$[l,r]$之内的点</p>
<p>一个半平面的价值是这个半平面中，编号在$[l,r]$范围内的点与$(0,0),(x,y)$组成三角形的面积之和</p>
<p>你要选择一个半平面，神仙会选择另一个半平面，你想要使得你得到的价值减去神仙得到的价值的结果尽量大</p>
<p>有$m$轮游戏，对于每轮游戏输出这个最大值乘以$2$的结果</p>
<p>保证$n,m\leq 10^6$，$1\leq x,y\leq1000$，时限$2$s</p>
<p>部分分：</p>
<ul>
<li>对于$20\%$的数据，$n,m\leq200$</li>
<li>对于$50\%$的数据，$n,m\leq 10^4$</li>
</ul>
<h2 id="D2T2-RGB"><a href="#D2T2-RGB" class="headerlink" title="D2T2 RGB"></a>D2T2 <font color=red>R</font><font color=green>G</font><font color=blue>B</font></h2><p>有一棵树，$n$个节点，每条边有边权$c_i$，每个点的颜色为<font color=red>R</font>,<font color=green>G</font>,<font color=blue>B</font>三种颜色之一</p>
<p>你要统计有序对$(U,V)$的数量，其中$U,V$是两个点集</p>
<p>它还需要满足以下条件：</p>
<ul>
<li>$U$和$V$都必须是连通的</li>
<li>$U$的颜色只能是红色或者绿色，$V$的颜色只能是绿色或者蓝色</li>
<li>存在一个$U,V$均包含的点$x$，使得对于所有在$U,V$集合中的点$y$，有$dis(x,y)\leq w$</li>
</ul>
<p>保证$n\leq 2000,w\leq10^7,c_i\leq10^6$，时限$1$s，对$10^9+7$取模</p>
<p>部分分：</p>
<ul>
<li>对于$30\%$的数据，$n\leq 15$</li>
<li>对于另$10\%$的数据，只有一个<font color=green>G</font></li>
<li>对于另$20\%$的数据，树是一条链</li>
</ul>
<h2 id="D2T3-函数"><a href="#D2T3-函数" class="headerlink" title="D2T3 函数"></a>D2T3 函数</h2><p>有$n$个数$v_1,v_2,\cdots,v_n$，现在有一类函数$f_T(x)$，其中$T$是$V$的一个子集，它的定义是</p>
<script type="math/tex; mode=display">
f_T(x)=\bigoplus_{v_i\in T}(x+v_i)\\\
f_\emptyset(x)=0</script><p>我们称两个函数$f_s,f_t$是$W-$本质不同的，当且仅当存在一个$0\leq x\leq W$，使得$f_s(x)\not=f_t(x)$</p>
<p>问在这$2^n$个函数中，有多少函数是$W-$本质不同的</p>
<p>保证$n,w,v_i&lt; 2^{17}$，时限$1$s</p>
<p>部分分：</p>
<ul>
<li>对于$20\%$的数据，$n\leq15,w\leq10$</li>
<li>对于另$20\%$的数据，$w=0$</li>
<li>对于前$70\%$的数据，$n,w,v_i\leq2^{10}$</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/09/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/09/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/" class="post-title-link" itemprop="url">二次剩余</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-09 10:20:40" itemprop="dateCreated datePublished" datetime="2019-04-09T10:20:40+08:00">2019-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:34:44" itemprop="dateModified" datetime="2020-04-23T09:34:44+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>若方程$x^2\equiv a\pmod p$有解，那么称$a$为$p$的二次剩余，否则$a$为$p$的非二次剩余</p>
<h1 id="勒让德符号及欧拉判别法"><a href="#勒让德符号及欧拉判别法" class="headerlink" title="勒让德符号及欧拉判别法"></a>勒让德符号及欧拉判别法</h1><p>定义勒让德符号为</p>
<script type="math/tex; mode=display">
\left(\frac{a}{p}\right)=\begin{cases}1&a为p的二次剩余\\\ -1&a为p的非二次剩余\\\ 0 &a能被p整除\end{cases}</script><p>欧拉判别法就是：如果$a$不能被$p$整除，那么有</p>
<script type="math/tex; mode=display">
\left(\frac{a}{p}\right)=a^{\frac{p-1}{2}}</script><h2 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h2><blockquote>
<p>对于方程$x^2\equiv a\pmod p$ ，共有$\frac{p-1}{2}$个不同的$a$使得该方程有解</p>
</blockquote>
<p>我们忽略$x=0$，如果枚举$x$再求出$a$，那么$x$一共有$p-1$个不同的值，也就产生了$p-1$个$a$</p>
<p>我们知道一个二次剩余恰好会产生两个解，那么这$p-1$个$a$就被分配到了$\frac{p-1}{2}$个不同的桶里面</p>
<p>所以共有$\frac{p-1}{2}$个$a$</p>
<h2 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h2><blockquote>
<p>$(x+y)^p\equiv x^p+y^p\pmod p$</p>
</blockquote>
<p>我们将其二项式展开</p>
<script type="math/tex; mode=display">
(x+y)^p=\sum_{i=0}^p{p\choose i}x^iy^{p-i}</script><p>当$i\not=0$且$i\not=p$时，$p\choose i$一定包含因数$p$，所以可以忽略</p>
<p>只剩下第一项和最后一项</p>
<h1 id="Cipolla算法"><a href="#Cipolla算法" class="headerlink" title="Cipolla算法"></a>Cipolla算法</h1><p>现在要求出方程$x^2\equiv n\pmod p$的一个解</p>
<p>我们找出一个$a​$，使得$(a^2-n)^{\frac{p-1}{2}}\equiv-1\pmod p​$</p>
<p>设$\omega=\sqrt{a^2-n}$</p>
<blockquote>
<p>结论：$x=(a+\omega)^{\frac{p+1}{2}}$</p>
</blockquote>
<p>证明如下：</p>
<p>我们知道</p>
<script type="math/tex; mode=display">
(a^2-n)^{\frac{p-1}{2}}\equiv-1\pmod p\Rightarrow (\omega^2)^{\frac{p-1}{2}}\equiv -1\pmod p\\\
\omega^{p-1}\equiv -1\pmod p</script><p>那么有</p>
<script type="math/tex; mode=display">
\begin{aligned}
x&\equiv (a+\omega)^{\frac{p+1}{2}}\\\
x^2&\equiv (a+\omega)^{p+1}\equiv(a+\omega)^p(a+\omega)\\\
&\equiv(a^p+\omega^p)(a+\omega)\\\
&\equiv(a-\omega)(a+\omega)\\\
&\equiv a^2-\omega^2\equiv a^2-a^2+n\equiv n
\end{aligned}</script><p>我们可以通过实现一个类似复数的结构体来进行运算</p>
<p>由于$p$的二次剩余一共有$\frac{p-1}{2}$个，而$a$在$[0,p)$中随机选取</p>
<p>那么成功的概率就是$\frac{1}{2}$</p>
<p>此时答案中$\omega$部分的系数必然为0</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/09/BSGS%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/09/BSGS%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95/" class="post-title-link" itemprop="url">BSGS及其拓展</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-09 09:25:08" itemprop="dateCreated datePublished" datetime="2019-04-09T09:25:08+08:00">2019-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:21:34" itemprop="dateModified" datetime="2020-04-23T09:21:34+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a>BSGS</h1><p>解高次同余方程</p>
<script type="math/tex; mode=display">
A^x\equiv B\mod C且A\bot B</script><p>根据费马小定理，我们直到$A^{C-1}\equiv B\mod C$</p>
<p>那么如果这个方程有解，那么解的周期一定不会大于$C$，所以必然存在一个不大于$C$的解</p>
<p>如果$C$比较小，那么我们可以直接枚举$x$然后暴力判断</p>
<p>考虑$C$比较大的情况，这时就需要使用<code>BSGS</code>了</p>
<p>我们设$x=i*m-j$，其中$j&lt;m$，这个$m$是一个常量，我们设为$\sqrt{C}$</p>
<p>那么有</p>
<script type="math/tex; mode=display">
A^{i\*m-j}\equiv B\mod C\\\
A^{i\*m}\equiv B\*A^j\mod C</script><p>我们开一个<code>map</code>，枚举$j$，将$B*A^j$放到这个<code>map</code>里面</p>
<p>然后我们枚举$i*m$，在<code>map</code>中查找是否存在$A^{i*m}​$即可</p>
<p>注意这样枚举是取不到$x=0$的，这种情况我们需要特判</p>
<p>如果$i*m$此时已经大于$C$了，那么就无解</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">BSGS</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (B % C == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; s.clear();</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(C)), ls = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++, ls = (LL)ls * A % C)</span><br><span class="line">        s[(LL)B * ls % C] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, t = ls;i &lt;= C;i += m, t = (LL)t * ls % C) </span><br><span class="line">        <span class="keyword">if</span> (s.count(t)) <span class="keyword">return</span> i - s[t];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="exBSGS"><a href="#exBSGS" class="headerlink" title="exBSGS"></a>exBSGS</h1><p>同样是解上面那个方程</p>
<p>但是如果$A,C$不互质呢</p>
<p>原方程等价于</p>
<script type="math/tex; mode=display">
A^x+Cy=B</script><p>我们不停地消去$A,C$的非1因子，可以使得方程变为</p>
<script type="math/tex; mode=display">
aA^z+C'y=B'</script><p>每消去一次，我们就从$A^x$里面拿一个$A$出来，消完之后乘到系数$a$里面去</p>
<p>注意在消去过程中时，如果存在某个时刻使得$a=B’$，那么直接返回此时的消去次数就可以了</p>
<p>如果在消去过程中，$B’$没有当前要消去的那个因子，那么直接返回$-1$</p>
<p>我们设消去次数为$k$</p>
<p>那么此时方程就变成了</p>
<script type="math/tex; mode=display">
aA^z\equiv B'\mod C'(A\bot C')</script><p>使用普通的<code>BSGS</code>可以解出$z$，注意此时前面还有一个系数$a$</p>
<p>最后我们将解出的$z$加上$k$即可，因为最开始拿出了$k$个$A$来消去因数</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> b ? gcd(b, a % b) : a;&#125;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">BSGS</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C, <span class="keyword">int</span> basic)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (B % C == basic) <span class="keyword">return</span> <span class="number">0</span>; s.clear();</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(C)), ls = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++, ls = (LL)ls * A % C)</span><br><span class="line">        s[(LL)B * ls % C] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, t = (LL)ls * basic % C;i &lt;= C;i += m, t = (LL)t * ls % C) </span><br><span class="line">        <span class="keyword">if</span> (s.count(t)) <span class="keyword">return</span> i - s[t];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">exBSGS</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, cnt = <span class="number">0</span>, d; A %= C, B %= C;</span><br><span class="line">    <span class="keyword">while</span> ((d = gcd(A, C)) != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (B % d) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        a = (LL)a * (A / d) % C, C /= d, B /= d, cnt++;</span><br><span class="line">        <span class="keyword">if</span> (a == B) <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = BSGS(A, B, C, a);</span><br><span class="line">    <span class="keyword">return</span> ~res ? res + cnt : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/08/12%E7%9C%81%E8%81%94%E8%80%832019-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/08/12%E7%9C%81%E8%81%94%E8%80%832019-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">12省联考2019 字符串问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-08 21:26:15" itemprop="dateCreated datePublished" datetime="2019-04-08T21:26:15+08:00">2019-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:23:48" itemprop="dateModified" datetime="2020-04-23T09:23:48+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A2%98%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">题解</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给出一个字符串$S$， 现在要选取它的$n_a$个子串作为$A$类串，选取$n_b$个子串作为$B$类串</p>
<p>其中第$i$个$A$类串为$S(la_i,ra_i)$，第$i$个$B$类串为$S(lb_i,rb_i)$，$la_i,ra_i,lb_i,rb_i,n_a,n_b$均已给出</p>
<p>现额外给定$m$组支配关系，每组关系$(x,y)$表示第$x$个$A$类串支配第$y$个$B$类串</p>
<p>求出一个长度最大的字符串$T$，满足$T$是由$A$类串拼接而成的。我们假设$T$被划分成了$t_1,t_2,\cdots,t_k$（都是$A$类串），要求满足对于任意的$i&lt;k$，$t_i$所支配的串中至少有一个是$t_{i+1}$的前缀</p>
<p><img src="https://i.loli.net/2019/04/08/5cab4fcbe56e2.png" alt="1554730942968"></p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>对于这种要求所求值最大的问题，不是动态规划就是最长路</p>
<p>那么对于这道题显然就只能是最长路了</p>
<p>如果最后构建出来的图有环，那么$T$就可以无限长</p>
<p>否则我们拓扑排序，然后跑一个<code>dp</code>就可以了</p>
<p>首先我们将$S$串翻转，将所有的$A$串与$B$串都翻转</p>
<p>这样限制条件就可以变为我们熟悉的后缀</p>
<p>我们先考虑一种暴力连边方式</p>
<p>每个$A$串建一个点，每个$B$串建一个点</p>
<p>对于$A_i$，将所有是其后缀的$B$连向$A_i$，权值为$|A_i|$</p>
<p>对于一组支配$(A_i,B_i)$，$A_i$往$B_i$连一条权值为0的边</p>
<p>但是这样最坏会连$n_a*n_b$条边，需要优化</p>
<p>我们考虑这样一种优化方案</p>
<p>对于任意的$A_i,B_i$，如果$B_i$是$A_i$的后缀，那么$B_i$的后缀也是$A_i$的后缀</p>
<p>我们对于$B$单独建一个子图，这个子图需要满足如果$B_i$是$B_j$的后缀，那么所有能走到$B_i$的路径都可以走到$B_j$</p>
<p>这样的话$A_i$只需要从它包含的那个最长的$B$串后缀连边就可以了</p>
<p>那么什么图满足这个性质呢？</p>
<p>很明显是<code>parent</code>树</p>
<p>我们建出<code>parent</code>树，然后从父亲往儿子节点连边</p>
<p>因为父亲对应的点一定是儿子的后缀</p>
<p>对于每个串$A_i,B_i$，找到它在树上的位置，这个可以通过倍增实现</p>
<p>实际上我们不需要对于每个串$A$，都找到那个最长的且是它后缀的$B$</p>
<p>直接从<code>parent</code>树上$A_i$的对应节点往$A_i$连边就可以了</p>
<p>因为这样同样可以保证最长的且是它后缀的$B$可以走到$A_i$</p>
<p>兴奋地写完，发现第三个样例过不去($-1$)</p>
<p>事实上是我们少考虑了一种情况</p>
<p><code>parent</code>树上的某个节点可以表示长度在一段区间的串</p>
<p>如果一条路径是从父亲走向儿子，那么当然没有问题，因为此时它代表的串是这个节点所能代表的最短的串</p>
<p>如果有一个串$A_i$以及另一个串$B_j$，它们对应着树上的同一个点</p>
<p>在之前的建图方式中，$B_j$一定能到达$A_i$</p>
<p>但是如果$|B_j|&gt;|A_i|$呢，显然这种转移是不合法的</p>
<p>解决方法是对于树上的一个点$u$，假如有$a_u$个$A$串挂在上面</p>
<p>那么我们将这些$A$串按照长度从小到大排序，将$u$拆成$a_u+1$个点，第$i$个点往$i+1$个点连边，父亲的最右边那个点往儿子的最左边那个点连边</p>
<p>对于一个串$B$，它就对应着它在树上的那个点所拆成的点中，第一个长度不小于它的点</p>
<p>这样就没有问题了</p>
<p>注意开<code>long long</code></p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> P = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="keyword">int</span> LEN;</span><br><span class="line"><span class="keyword">namespace</span> SAM &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; next; </span><br><span class="line">        <span class="keyword">int</span> link, len;</span><br><span class="line">    &#125; st[N * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ncnt, last;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;st[<span class="number">0</span>].link = <span class="number">-1</span>, st[<span class="number">0</span>].len = ncnt = last = <span class="number">0</span>, st[<span class="number">0</span>].next.clear();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">extend</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = ++ncnt, p; st[cur].len = st[last].len + <span class="number">1</span>, st[cur].link = <span class="number">0</span>, st[cur].next.clear();</span><br><span class="line">        <span class="keyword">for</span> (p = last;p != <span class="number">-1</span> &amp;&amp; !st[p].next.count(c);p = st[p].link)</span><br><span class="line">            st[p].next[c] = cur;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> q = st[p].next[c];</span><br><span class="line">            <span class="keyword">if</span> (st[q].len == st[p].len + <span class="number">1</span>) st[cur].link = q;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> clone = ++ncnt; st[clone].len = st[p].len + <span class="number">1</span>, st[clone].next = st[q].next, st[clone].link = st[q].link;</span><br><span class="line">                <span class="keyword">for</span> (;p != <span class="number">-1</span> &amp;&amp; st[p].next[c] == q;p = st[p].link)</span><br><span class="line">                    st[p].next[c] = clone;</span><br><span class="line">                st[q].link = st[cur].link = clone;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= ncnt;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : st[i].next)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"sam: "</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; v.second &lt;&lt; <span class="string">' '</span> &lt;&lt; v.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> SUF_Tree &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to, next;&#125; e[N * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> head[N * <span class="number">2</span>], ecnt, len[N * <span class="number">2</span>], fa[<span class="number">18</span>][N * <span class="number">2</span>]; </span><br><span class="line">    <span class="built_in">vector</span>&lt;P&gt; nodes[N * <span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">        fa[<span class="number">0</span>][u] = f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">17</span>;i++) fa[i][u] = fa[i - <span class="number">1</span>][fa[i - <span class="number">1</span>][u]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">            <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">2</span> * LEN;i++) head[i] = <span class="number">0</span>, nodes[i].clear(), nodes[i].push_back(P(<span class="number">1e9</span>, <span class="number">-1</span>));</span><br><span class="line">        ecnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>;i &gt;= <span class="number">0</span>;i--) <span class="keyword">if</span> (fa[i][u])</span><br><span class="line">            <span class="keyword">if</span> (l &lt;= len[fa[i][now]])</span><br><span class="line">                now = fa[i][now];</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> id[N], tot, onT[N], sz[N], onT2[N], na;</span><br><span class="line"><span class="keyword">namespace</span> GRAPH &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to, next, w;&#125; e[N * <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">int</span> head[N * <span class="number">4</span>], ecnt, ind[N * <span class="number">4</span>], st[N * <span class="number">4</span>], top, ncnt; LL dp[N * <span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        e[++ecnt] = (edge)&#123;to, head[from], w&#125;, ind[to]++, head[from] = ecnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Topsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        top = <span class="number">0</span>; <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= ncnt;i++) <span class="keyword">if</span> (!ind[i]) q.push(i), st[++top] = i;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next) </span><br><span class="line">                <span class="keyword">if</span> (!(--ind[e[i].to])) q.push(e[i].to), st[++top] = e[i].to;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> top == ncnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= ncnt;i++) head[i] = ind[i] = dp[i] = <span class="number">0</span>;</span><br><span class="line">        ecnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">DP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = top;i &gt;= <span class="number">1</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = st[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = head[u];j;j = e[j].next)</span><br><span class="line">                dp[u] = max(dp[u], dp[e[j].to] + e[j].w);</span><br><span class="line">            <span class="keyword">if</span> (u &lt;= na) res = max(res, dp[u] + sz[u]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p[N * <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    p[u].clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : SUF_Tree::nodes[u]) &#123;</span><br><span class="line">        p[u].push_back(++tot);</span><br><span class="line">        <span class="keyword">if</span> (v.second &gt; <span class="number">0</span>) onT[v.second] = tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i + <span class="number">1</span> &lt; p[u].size();i++)</span><br><span class="line">        GRAPH::adde(p[u][i], p[u][i + <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = SUF_Tree::head[u];i;i = SUF_Tree::e[i].next) &#123;</span><br><span class="line">        dfs(SUF_Tree::e[i].to);</span><br><span class="line">        GRAPH::adde(*p[u].rbegin(), *p[SUF_Tree::e[i].to].begin(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; read(T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>), LEN = <span class="built_in">strlen</span>(s + <span class="number">1</span>), reverse(s + <span class="number">1</span>, s + LEN + <span class="number">1</span>), SAM::init(), SUF_Tree::init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= LEN;i++) id[i] = SAM::extend(s[i]);</span><br><span class="line"><span class="comment">//        cout &lt;&lt; SAM::ncnt &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= SAM::ncnt;i++) SUF_Tree::adde(SAM::st[i].link, i), SUF_Tree::len[i] = SAM::st[i].len;</span><br><span class="line">        SUF_Tree::dfs(<span class="number">0</span>, <span class="number">0</span>); read(na), tot = na;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; "ok" &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l, r;i &lt;= na;i++) &#123;</span><br><span class="line">            read(l), read(r), l = LEN - l + <span class="number">1</span>, r = LEN - r + <span class="number">1</span>, swap(l, r), sz[i] = r - l + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> t = SUF_Tree::find(id[r], r - l + <span class="number">1</span>); </span><br><span class="line">            SUF_Tree::nodes[t].push_back(P(r - l + <span class="number">1</span>, i));</span><br><span class="line">        &#125;</span><br><span class="line">        GRAPH::ncnt = na * <span class="number">2</span> + SAM::ncnt + <span class="number">1</span>, GRAPH::init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= SAM::ncnt;i++) sort(SUF_Tree::nodes[i].begin(), SUF_Tree::nodes[i].end());</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= na;i++) GRAPH::adde(onT[i], i, sz[i]);</span><br><span class="line">        <span class="keyword">int</span> nb; read(nb);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l, r;i &lt;= nb;i++) &#123;</span><br><span class="line">            read(l), read(r), l = LEN - l + <span class="number">1</span>, r = LEN - r + <span class="number">1</span>, swap(l, r);</span><br><span class="line">            <span class="keyword">int</span> t = SUF_Tree::find(id[r], r - l + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> pos = lower_bound(SUF_Tree::nodes[t].begin(), SUF_Tree::nodes[t].end(), P(r - l + <span class="number">1</span>, <span class="number">-2</span>)) - SUF_Tree::nodes[t].begin();</span><br><span class="line">            onT2[i] = p[t][pos];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> matches; read(matches);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= matches;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b; read(a), read(b), GRAPH::adde(a, onT2[b], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        GRAPH::ncnt = tot;</span><br><span class="line">        <span class="keyword">if</span> (!GRAPH::Topsort()) &#123;<span class="built_in">puts</span>(<span class="string">"-1"</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, GRAPH::DP());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/07/BJOI2018-%E5%8F%8C%E4%BA%BA%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/07/BJOI2018-%E5%8F%8C%E4%BA%BA%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/" class="post-title-link" itemprop="url">BJOI2018 双人猜数游戏</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-07 11:53:41" itemprop="dateCreated datePublished" datetime="2019-04-07T11:53:41+08:00">2019-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:21:47" itemprop="dateModified" datetime="2020-04-23T09:21:47+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A2%98%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">题解</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://www.luogu.org/problemnew/show/P4459" target="_blank" rel="noopener">题目链接</a></p>
<p>神仙题啊</p>
<p>首先来模拟一下样例</p>
<p><code>Alice</code>知道乘积是60，<code>Bob</code>知道和是16，且两个数均不小于5</p>
<p><code>Bob</code>：此时两个数有可能为</p>
<p>$(5, 11), (6, 10), (7, 9), (8, 8)$</p>
<p>而<code>Bob</code>在第一轮没有猜出来，也就是说，这两个数的和不是10或11</p>
<p><code>Alice</code>：此时两个数有可能为</p>
<p>$(5, 12), (6, 10)$</p>
<p>由于Alice也没有猜出来，所以对于Bob来说，以下情况就被排除了</p>
<p>$(5, 11), (7, 9), (8, 8)$</p>
<p>对于$(5, 11)$而言，55只有这一种分解方式，而<code>Alice</code>在第一轮中没有猜出来，所以不是</p>
<p>对于$(7, 9)$而言，63还可以被分解成$(3, 21)$，但是不满足两个数都大于等于5，而<code>Alice</code>没有猜出来，所以也不是</p>
<p>$(8, 8)​$同理</p>
<p>所以对于<code>Bob</code>来说，这两个数只有可能是$(6, 10)$，他也就确定了答案</p>
<p><code>Alice</code>知道，<code>Bob</code>已经猜出来了，所以$(5, 12)$就被排除了，因为在这种情况下，$Bob​$不可能这么早就猜出答案</p>
<p>所以<code>Alice</code>也知道答案是$(6, 10)​$了</p>
<p>我们用<code>dp</code>来描述这个过程，<code>dp[i][n][m]</code>表示，当前是第i轮，且两个答案分别是$n,m$，在$1-i​$轮中，是否能决定答案</p>
<p>如果这一轮是<code>Bob</code>猜，那么我们就枚举$n+m$的划分方式。如果每一种合法的划分方式都能在$1-(i-1)$轮被猜出来，那么<code>Bob</code>一定能确定这两个数分别为$n, m$</p>
<p>否则，我们则枚举$n*m$的约数， 判断方式与<code>Bob</code>的相同</p>
<p>但是这样可能会出现一种特殊情况，就是已经到了$t$轮，第一个人猜出来了，而第二个人没有猜出来</p>
<p>那么我们就多进行一轮转移，这次转移与之前的转移相反，如果每一种合法的划分方式在$1-t$轮都不能被猜出来，那么才能确定答案</p>
<p>$n,m$的最大值不会超过500，直接枚举</p>
<p>直接交程序，数组只开500的话是秒跑</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500</span></span><br><span class="line"><span class="keyword">int</span> dp[N + <span class="number">10</span>][N + <span class="number">10</span>][<span class="number">16</span>], m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, tmpa, tmpb;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, j;i &lt;= a + b - i &amp;&amp; cnt &lt; <span class="number">2</span>;i++) </span><br><span class="line">        <span class="keyword">if</span> (!dp[i][j = a + b - i][c - <span class="number">1</span>] || c == <span class="number">1</span>) </span><br><span class="line">            cnt++, tmpa = i, tmpb = j;</span><br><span class="line">    <span class="keyword">return</span> cnt == <span class="number">1</span> &amp;&amp; a == tmpa &amp;&amp; b == tmpb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, tmpa, tmpb;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, j;i * i &lt;= a * b &amp;&amp; cnt &lt; <span class="number">2</span>;i++)</span><br><span class="line">        <span class="keyword">if</span> (a * b % i == <span class="number">0</span> &amp;&amp; (!dp[i][j = a * b / i][c - <span class="number">1</span>] || c == <span class="number">1</span>))</span><br><span class="line">            cnt++, tmpa = i, tmpb = j;</span><br><span class="line">    <span class="keyword">return</span> cnt == <span class="number">1</span> &amp;&amp; a == tmpa &amp;&amp; b == tmpb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, tmpa, tmpb;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, j;i &lt;= a + b - i &amp;&amp; cnt &lt; <span class="number">2</span>;i++) </span><br><span class="line">        <span class="keyword">if</span> (dp[i][j = a + b - i][c] &amp;&amp; !dp[i][j][c - <span class="number">2</span>]) </span><br><span class="line">            cnt++, tmpa = i, tmpb = j;</span><br><span class="line">    <span class="keyword">return</span> cnt == <span class="number">1</span> &amp;&amp; a == tmpa &amp;&amp; b == tmpb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check4</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, tmpa, tmpb;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, j;i * i &lt;= a * b &amp;&amp; cnt &lt; <span class="number">2</span>;i++)</span><br><span class="line">        <span class="keyword">if</span> (a * b % i == <span class="number">0</span> &amp;&amp; dp[i][j = a * b / i][c] &amp;&amp; !dp[i][j][c - <span class="number">2</span>])</span><br><span class="line">            cnt++, tmpa = i, tmpb = j;</span><br><span class="line">    <span class="keyword">return</span> cnt == <span class="number">1</span> &amp;&amp; a == tmpa &amp;&amp; b == tmpb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">8</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, flag; <span class="built_in">scanf</span>(<span class="string">"%d%s%d"</span>, &amp;m, name + <span class="number">1</span>, &amp;t), flag = name[<span class="number">1</span>] == <span class="string">'B'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= t + <span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = m;a &lt;= N / <span class="number">2</span>;a++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = a;b &lt;= N;b++)</span><br><span class="line">                dp[a][b][i] = dp[a][b][i - <span class="number">2</span>] | (((i &amp; <span class="number">1</span>) ^ flag ^ <span class="number">1</span>) ? check1(a, b, i) : check2(a, b, i));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = m * <span class="number">2</span>;s;s++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = m, b = s - a;a * <span class="number">2</span> &lt;= s;a++, b = s - a)</span><br><span class="line">            <span class="keyword">if</span> (dp[a][b][t + <span class="number">1</span>] &amp;&amp; !(dp[a][b][t - <span class="number">1</span>] | dp[a][b][t])) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = t &amp; <span class="number">1</span> ^ flag;</span><br><span class="line">                <span class="keyword">if</span> (!(tmp ? check4(a, b, t + <span class="number">1</span>) : check3(a, b, t + <span class="number">1</span>))) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">' '</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/07/BJOI2018-%E4%BA%8C%E8%BF%9B%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/07/BJOI2018-%E4%BA%8C%E8%BF%9B%E5%88%B6/" class="post-title-link" itemprop="url">BJOI2018 二进制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-07 11:50:09" itemprop="dateCreated datePublished" datetime="2019-04-07T11:50:09+08:00">2019-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:21:57" itemprop="dateModified" datetime="2020-04-23T09:21:57+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A2%98%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">题解</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://www.luogu.org/problemnew/show/P4428" target="_blank" rel="noopener">题目链接</a></p>
<p>先考虑哪些二进制在重新排列之后可以是3的倍数</p>
<p>我们分3种情况讨论：</p>
<ol>
<li>0 ：模3的余数是0</li>
<li>10 ：就是1出现在下标为偶数的地方，模3余2</li>
<li>01 ：1出现在下标为奇数的地方，模3余1</li>
</ol>
<p>那么，我们就可以用这三种余数来进行组合</p>
<p>考虑以下情况：</p>
<ol>
<li>有偶数个1 ：显然，通过情况2与3组合可以成为3的倍数</li>
<li>有奇数个1 ：注意到3个情况2或者情况3的叠加仍然可以成为3的倍数，而这样至少需要2个0和3个1（10101）</li>
</ol>
<p>那么综合上面两种情况，我们可以得出结论，一段区间为不合法的区间当且仅当：</p>
<ol>
<li>区间内只有1个1</li>
<li>区间中有奇数个1且没有0</li>
<li>区间中有奇数个1且有1个0</li>
</ol>
<p>这道题是带修改的，所以需要将<code>dp</code>放到线段树上统计</p>
<p>那么我们考虑一段区间应该维护什么</p>
<p>首先将第一种情况分开，先不管</p>
<p>那么对于一段区间，我们可以用<code>dp[i][j(0/1)][k(0/1)]</code>表示</p>
<p>即状态为$i$，1的个数是奇数还是偶数，出现了0个0还是1个0的区间总数</p>
<p>线段树<code>pushup</code>的时候子区间也是可以跨<code>mid</code>合并的</p>
<p>具体来说，就是一个左子树的以<code>mid</code>为右端点的区间和一个右子树的以<code>mid + 1</code>为左端点的区间合并</p>
<p>所以，对于状态i，我们这样设计</p>
<p><code>i = 0</code> 表示不取左端点和右端点</p>
<p><code>i = 1</code> 表示必须取左端点，不能取右端点</p>
<p><code>i = 2</code> 表示必须取右端点，不能取左端点</p>
<p><code>i = 3</code> 表示必须左右端点都取</p>
<p>合并的时候枚举一下有几个0以及1的奇偶性就可以了</p>
<p>我们另外开一个数组，单独统计情况1，也就是只有1个1的区间的数量</p>
<p>转移与上面的类似</p>
<p><code>g[i][j(0/1)]</code>表示状态为$i$，出没出现1的区间的总数</p>
<p>但是统计的时候不能直接将两个加起来</p>
<p>注意到这两个统计是有重复的，当我们进行第一次统计时也顺便统计了区间内有1个1，只有0/1个0的数量，需要去重</p>
<p>对于有1个1，0个0的区间数量，显然也就是区间内1的数量</p>
<p>对于有1个1，1个0的区间数量，我们用一个树状数组维护，在这个01区间的第一位维护即可</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    LL f[<span class="number">4</span>][<span class="number">2</span>][<span class="number">2</span>], g[<span class="number">4</span>][<span class="number">2</span>];</span><br><span class="line">    Data() &#123;<span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)), <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span>(g));&#125;</span><br><span class="line">&#125; T[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Data <span class="title">UN</span><span class="params">(Data a, Data b)</span> </span>&#123;</span><br><span class="line">    Data c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= <span class="number">1</span>;j++) &#123;</span><br><span class="line">            c.f[<span class="number">0</span>][i][j] += a.f[<span class="number">0</span>][i][j] + b.f[<span class="number">0</span>][i][j] + a.f[<span class="number">2</span>][i][j] + b.f[<span class="number">1</span>][i][j];</span><br><span class="line">            c.f[<span class="number">1</span>][i][j] += a.f[<span class="number">1</span>][i][j] + a.f[<span class="number">3</span>][i][j], c.f[<span class="number">2</span>][i][j] += b.f[<span class="number">2</span>][i][j] + b.f[<span class="number">3</span>][i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        c.g[<span class="number">0</span>][i] += a.g[<span class="number">0</span>][i] + b.g[<span class="number">0</span>][i] + a.g[<span class="number">2</span>][i] + b.g[<span class="number">1</span>][i];</span><br><span class="line">        c.g[<span class="number">1</span>][i] += a.g[<span class="number">1</span>][i] + a.g[<span class="number">3</span>][i], c.g[<span class="number">2</span>][i] += b.g[<span class="number">2</span>][i] + b.g[<span class="number">3</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= <span class="number">1</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + j &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                c.g[<span class="number">0</span>][i + j] += a.g[<span class="number">2</span>][i] * b.g[<span class="number">1</span>][j], c.g[<span class="number">1</span>][i + j] += a.g[<span class="number">3</span>][i] * b.g[<span class="number">1</span>][j];</span><br><span class="line">                c.g[<span class="number">2</span>][i + j] += a.g[<span class="number">2</span>][i] * b.g[<span class="number">3</span>][j], c.g[<span class="number">3</span>][i + j] += a.g[<span class="number">3</span>][i] * b.g[<span class="number">3</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= <span class="number">1</span>;k++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>;k + l &lt;= <span class="number">1</span>;l++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> ti = (i + j) &amp; <span class="number">1</span>, tj = k + l;</span><br><span class="line">                    c.f[<span class="number">0</span>][ti][tj] += a.f[<span class="number">2</span>][i][k] * b.f[<span class="number">1</span>][j][l], c.f[<span class="number">1</span>][ti][tj] += a.f[<span class="number">3</span>][i][k] * b.f[<span class="number">1</span>][j][l];</span><br><span class="line">                    c.f[<span class="number">2</span>][ti][tj] += a.f[<span class="number">2</span>][i][k] * b.f[<span class="number">3</span>][j][l], c.f[<span class="number">3</span>][ti][tj] += a.f[<span class="number">3</span>][i][k] * b.f[<span class="number">3</span>][j][l];</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> val[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="keyword">void</span>(T[rt].f[<span class="number">3</span>][val[l]][val[l] ^ <span class="number">1</span>] = T[rt].g[<span class="number">3</span>][val[l]] = <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; build(rt &lt;&lt; <span class="number">1</span>, l, mid), build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    T[rt] = UN(T[rt &lt;&lt; <span class="number">1</span>], T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> at)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        val[l] ^= <span class="number">1</span>, T[rt] = Data();</span><br><span class="line">        T[rt].f[<span class="number">3</span>][val[l]][val[l] ^ <span class="number">1</span>] = T[rt].g[<span class="number">3</span>][val[l]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (at &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, at); <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, at);</span><br><span class="line">    T[rt] = UN(T[rt &lt;&lt; <span class="number">1</span>], T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Data <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> T[rt];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (end &lt;= mid) <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span>, l, mid, start, end);</span><br><span class="line">    <span class="keyword">if</span> (start &gt; mid) <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, start, end);</span><br><span class="line">    <span class="keyword">return</span> UN(query(rt &lt;&lt; <span class="number">1</span>, l, mid, start, mid), query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, end));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tree[<span class="number">2</span>][N], n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> at, <span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">for</span> (;at &lt;= n;at += at &amp; -at) tree[id][at] += x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> at)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;at;at -= at &amp; -at) res += tree[id][at];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val[i]), update(<span class="number">0</span>, i, val[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) <span class="keyword">if</span> (val[i] != val[i + <span class="number">1</span>]) update(<span class="number">1</span>, i, <span class="number">1</span>);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n); <span class="keyword">int</span> q; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b != n) update(<span class="number">1</span>, b, <span class="number">-2</span> * (val[b] != val[b + <span class="number">1</span>]) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="number">1</span>) update(<span class="number">1</span>, b - <span class="number">1</span>, <span class="number">-2</span> * (val[b - <span class="number">1</span>] != val[b]) + <span class="number">1</span>);</span><br><span class="line">            update(<span class="number">0</span>, b, <span class="number">-2</span> * val[b] + <span class="number">1</span>), update(<span class="number">1</span>, <span class="number">1</span>, n, b);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c); Data tmp = query(<span class="number">1</span>, <span class="number">1</span>, n, b, c); LL res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">3</span>;i++) res += tmp.f[i][<span class="number">1</span>][<span class="number">0</span>] + tmp.f[i][<span class="number">1</span>][<span class="number">1</span>] + tmp.g[i][<span class="number">1</span>];</span><br><span class="line">            res -= query(<span class="number">0</span>, c) - query(<span class="number">0</span>, b - <span class="number">1</span>) + query(<span class="number">1</span>, c - <span class="number">1</span>) - query(<span class="number">1</span>, b - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (LL)(c - b + <span class="number">1</span>) * (c - b + <span class="number">2</span>) / <span class="number">2</span> - res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/07/FFT%E4%B8%8ENTT%E4%B8%93%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/07/FFT%E4%B8%8ENTT%E4%B8%93%E9%A2%98/" class="post-title-link" itemprop="url">FFT与NTT专题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-07 11:27:43" itemprop="dateCreated datePublished" datetime="2019-04-07T11:27:43+08:00">2019-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:16:53" itemprop="dateModified" datetime="2020-04-23T09:16:53+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A2%98%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">题解</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="A-–-礼物"><a href="#A-–-礼物" class="headerlink" title="A – 礼物"></a>A – 礼物</h1><p>先不管旋转操作，考虑化简这个差异值</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^n(x_i-y_i-c)^2
&=\sum_{i=1}^n(x_i-y_i)^2+nc^2-2c\sum_{i=1}^n(x_i-y_i)\\\
&=\sum_{i=1}^nx_i^2+\sum_{i=1}^ny_i^2+nc^2-2c\sum_{i=1}^n(x_i-y_i)-2\sum_{i=1}^nx_iy_i
\end{aligned}</script><p>注意到$\sum x^2+\sum y^2$是常数，先不管</p>
<p>可以发现，这是一个关于$c$的二次函数</p>
<p>那么我们知道，此时$c$的极值点就在$-\frac{b}{2a}$处</p>
<p>所以，我们可以得出$c$的最优值是</p>
<script type="math/tex; mode=display">
\frac{\sum_{i=1}^n x_i-\sum_{i=1}^n y_i}{n}</script><p>而分子的两个数均与旋转无关</p>
<p>但是$c$只能是整数</p>
<p>所以判一下$c, c-1, c+1$哪个与上面的式子更接近</p>
<p>注意到旋转唯一能改变的是$\sum xy$</p>
<p>而我们要让这个值尽量小</p>
<p>设</p>
<script type="math/tex; mode=display">
F(m)=\sum_{i=1}^nx_iy_{i+m}</script><p>我们可以看出，这是一个类似卷积的东西</p>
<p>但是一般的卷积是后两式下标的和不变</p>
<p>而这个是差不变</p>
<p>所以把这个式子变一下</p>
<p>设</p>
<script type="math/tex; mode=display">
x_{n-i+1}=x_i</script><p>就是将x倒序一下</p>
<p>可以得到 </p>
<script type="math/tex; mode=display">
F(m)=\sum_{i=1}^nx_{n-i+1}y_{i+m}</script><p>不妨设后面$xy$的卷积是$A$，也就是</p>
<script type="math/tex; mode=display">
A(n+m+1)=\sum_{i=1}^nx_{n-i+1}y_{i+m}</script><p>可以发现，这个$A$就是将$F$整体向右平移了$n+1$</p>
<p>所以</p>
<script type="math/tex; mode=display">
F(m)=A(n+m+1)</script><p>为了不丢精度，NTT即可（保证答案不会超过mod）</p>
<p>代码如下 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">int</span> r[N &lt;&lt; <span class="number">2</span>]; <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> type, <span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, w = <span class="number">1</span>, t;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w = (LL)w * Wn % mod)</span><br><span class="line">                t = (LL)w * a[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x[N], y[N], A[N &lt;&lt; <span class="number">2</span>], B[N &lt;&lt; <span class="number">2</span>], res[N];</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; <span class="keyword">inline</span> T <span class="title">Abs</span><span class="params">(<span class="keyword">const</span> T x)</span> </span>&#123;<span class="keyword">return</span> x &gt; <span class="number">0</span> ? x : -x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, sumx = <span class="number">0</span>, sumy = <span class="number">0</span>, sumx2 = <span class="number">0</span>, sumy2 = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x[i]), A[i] = x[i], sumx += x[i], sumx2 += x[i] * x[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;y[i]), B[<span class="number">2</span> * n - i] = B[n - i] = y[i], sumy += y[i], sumy2 += y[i] * y[i];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= <span class="number">3</span> * n) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    NTT(len, <span class="number">1</span>, A), NTT(len, <span class="number">1</span>, B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) A[i] = (LL)A[i] * B[i] % mod;</span><br><span class="line">    NTT(len, <span class="number">0</span>, A); <span class="keyword">int</span> Inv = Pow(len, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) res[i] = (LL)A[<span class="number">2</span> * n - i] * Inv % mod;</span><br><span class="line">    <span class="keyword">int</span> c = (sumx - sumy) / n; LL ans = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">if</span> (Abs((LL)c * n - sumx + sumy) &gt; Abs(((LL)c * n + n - sumx + sumy))) c++;</span><br><span class="line">    <span class="keyword">if</span> (Abs((LL)c * n - sumx + sumy) &gt; Abs(((LL)c * n - n - sumx + sumy))) c--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        LL tmp = (LL)sumx2 + sumy2 - <span class="number">2</span> * res[i] - (LL)<span class="number">2</span> * c * (sumx - sumy) + (LL)n * c * c;</span><br><span class="line">        <span class="keyword">if</span> (tmp &lt; ans) ans = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B-–-求和"><a href="#B-–-求和" class="headerlink" title="B – 求和"></a>B – 求和</h1><p>我们知道</p>
<script type="math/tex; mode=display">
S(n,m)=\sum_{i=0}^m(-1)^i{m\choose i}(m-i)^n\frac{1}{m!}</script><p>原理很简单，容斥有几个盒子没有放球，有$m\choose i$种选法，再将$n$个球放入$m-i$个盒子。由于盒子是无序的，最后除以$m$的阶乘</p>
<p>那么我们用这个化简原式</p>
<p>注意到第二个$\sum$的上界是$i$，非常讨厌</p>
<p>由于斯特林数的性质，把这个$i$换成$n$也没有问题</p>
<p>因为当$m&gt;n$时，$S(n,m)=0$</p>
<p>所以有</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=0}^n\sum_{j=0}^nS(i,j)\*2^j\*j!
&=\sum_{j=0}^n2^j\*j!\sum_{i=0}^n\sum_{k=0}^j(-1)^k{j\choose k}(j-k)^i\frac{1}{j!}\\\
&=\sum_{j=0}^n2^j\*j!\sum_{k=0}^j\frac{(-1)^k}{k!}\*\frac{\sum_{i=0}^n(j-k)^i}{(j-k)!}
\end{aligned}</script><p>注意到后面那个是卷积的形式</p>
<p>第一个多项式很好求，第二个的分子是等比数列</p>
<p>我们设$B$是第二个多项式</p>
<p>显然有</p>
<script type="math/tex; mode=display">
B(0)=0, B(1)=n+1</script><p>对于其它情况，直接用等比数列求和公式算出来就行了</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">int</span> r[N &lt;&lt; <span class="number">2</span>]; <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> type, <span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, w = <span class="number">1</span>, t;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w = (LL)w * Wn % mod)</span><br><span class="line">                t = (LL)w * a[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> A[N &lt;&lt; <span class="number">2</span>], B[N &lt;&lt; <span class="number">2</span>], frac[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, len = <span class="number">1</span>, l = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    frac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= <span class="number">2</span> * n) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    A[<span class="number">0</span>] = B[<span class="number">0</span>] = <span class="number">1</span>, B[<span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) A[i] = (i &amp; <span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span>) * Pow(frac[i], mod - <span class="number">2</span>), A[i] = (A[i] + mod) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) B[i] = ((LL)(Pow(i, n + <span class="number">1</span>) - <span class="number">1</span>) * Pow(i - <span class="number">1</span>, mod - <span class="number">2</span>) % mod * Pow(frac[i], mod - <span class="number">2</span>) % mod + mod) % mod;</span><br><span class="line">    NTT(len, <span class="number">1</span>, A), NTT(len, <span class="number">1</span>, B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) A[i] = (LL)A[i] * B[i] % mod;</span><br><span class="line">    NTT(len, <span class="number">0</span>, A); <span class="keyword">int</span> Inv = Pow(len, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) res = (res + (LL)tmp * frac[i] % mod * A[i]) % mod, tmp = tmp * <span class="number">2</span> % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL)res * Inv % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-–-序列统计"><a href="#C-–-序列统计" class="headerlink" title="C – 序列统计"></a>C – 序列统计</h1><p>这题的难点在于转化成原根</p>
<p>注意到要求的是所有数的乘积而非和</p>
<p>如果是和的话直接NTT就好了</p>
<p>那么我们就将乘积转化成和的形式</p>
<p>如果两个数都是某个数的某次方，那么这两个数乘起来就是指数相加</p>
<p>而原根恰好可以表示模$m$剩余系下的每个数</p>
<p>所以把每个数转化成原根的某次方就好了</p>
<p>求原根代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">G</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, flg = <span class="number">1</span>;i;i++, flg = <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>;j * j &lt; x;j++) </span><br><span class="line">            <span class="keyword">if</span> ((x - <span class="number">1</span>) % j == <span class="number">0</span> &amp;&amp; Pow(i, (x - <span class="number">1</span>) / j, x) == <span class="number">1</span>) &#123;flg = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (flg) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D-–-残缺的字符串"><a href="#D-–-残缺的字符串" class="headerlink" title="D – 残缺的字符串"></a>D – 残缺的字符串</h1><p>带通配符的字符串匹配问题</p>
<p>首先考虑不带通配符的怎么做</p>
<p>那么拓展KMP， 后缀数组都可以</p>
<p>但是我们有一个更高级的方法：FFT求字符串匹配</p>
<p>首先我们需要定义“匹配”</p>
<p>所以设差异函数$g(i)$表示从$B$串的$i$位置开始，与$A$串的差异程度</p>
<p>有</p>
<script type="math/tex; mode=display">
g(x)=\sum_{i=x}^{x+m-1}(B_i-A_{i-x+1})^2</script><p>显然，只有当$A$串从$x$位置开始与$B$串完全相同，$g$的值才为0</p>
<p>化简原式</p>
<script type="math/tex; mode=display">
\begin{aligned}
g(x)&=\sum_{i=x}^{x+m-1}A_{i-x+1}^2+\sum_{i=x}^{x+m-1}B_i^2-2\sum_{i=x}^{x+m-1}B_iA_{i-x+1}\\\
&=\sum_{i=1}^mA_i^2+\sum_{i=1}^mB_{i+x-1}^2-2\sum_{i=1}^mA_iB_{i+x-1}
\end{aligned}</script><p>前两项可以通过预处理前缀和得出，后面的是一个下标差相等的卷积</p>
<p>那么模仿之前的套路，我们将$A$序列倒序一下再求卷积就行了</p>
<p>解决了不带通配符的问题，再考虑带通配符</p>
<p>这个通配符是可以匹配任意字符的，所以把差异函数改一下</p>
<script type="math/tex; mode=display">
g(x)=\sum_{i=x}^{x+m-1}(B_i-A_{i-x+1})^2A_{i-x+1}B_i</script><p>当$i$处的字符是$*$时，我们设那个地方的值为0</p>
<p>化简得</p>
<script type="math/tex; mode=display">
=\sum_{i=1}^mA_i^3B_{i-x+1}+\sum_{i=1}^mA_iB_{i-x+1}^3-2\sum_{i=1}^xA_i^2B_{i-x+1}^2</script><p>做3次FFT即可</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300010</span></span><br><span class="line"><span class="keyword">int</span> r[N &lt;&lt; <span class="number">2</span>]; <span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> type, <span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; <span class="title">Wn</span><span class="params">(<span class="built_in">cos</span>(<span class="number">2</span> * PI / mid), type * <span class="built_in">sin</span>(<span class="number">2</span> * PI / mid))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid) &#123;</span><br><span class="line">            complex&lt;double&gt; w(1), t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w *= Wn) </span><br><span class="line">                t = w * a[j + (mid &gt;&gt; <span class="number">1</span>)], a[j + (mid &gt;&gt; <span class="number">1</span>)] = a[j] - t, a[j] += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> a[N], b[N]; <span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; A[N &lt;&lt; <span class="number">2</span>], B[N &lt;&lt; <span class="number">2</span>]; <span class="keyword">int</span> a1[N], b1[N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line">LL res[N]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Clear(x) for (int i = 0;i &lt; len;i++) x[i] = 0;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    FFT(len, <span class="number">1</span>, A), FFT(len, <span class="number">1</span>, B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) A[i] *= B[i];</span><br><span class="line">    FFT(len, <span class="number">-1</span>, A);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) res[i] += k * (LL)(A[i].real() / len + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d%s%s"</span>, &amp;m, &amp;n, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) a1[m - i] = a[i] == <span class="string">'*'</span> ? <span class="number">0</span> : a[i] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) b1[i] = b[i] == <span class="string">'*'</span> ? <span class="number">0</span> : b[i] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= m + n) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) A[i] = a1[i] * a1[i] * a1[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) B[i] = b1[i];</span><br><span class="line">    mul(len, n, <span class="number">1</span>); Clear(A) Clear(B)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) A[i] = a1[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) B[i] = b1[i] * b1[i] * b1[i];</span><br><span class="line">    mul(len, n, <span class="number">1</span>); Clear(A) Clear(B)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) A[i] = a1[i] * a1[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) B[i] = b1[i] * b1[i];</span><br><span class="line">    mul(len, n, <span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">if</span> (res[i] == <span class="number">0</span>) ans.push_back(i - m + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : ans) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E-–-万径人踪灭"><a href="#E-–-万径人踪灭" class="headerlink" title="E – 万径人踪灭"></a>E – 万径人踪灭</h1><p>假设当前确定了一个对称中心$i$</p>
<p>那么当两个位置$j,k$关于i对称且这两个位置的字母相同时对答案有贡献</p>
<p>对称则意味着$j+k=i*2​$，可以FFT</p>
<p>枚举字符，然后FFT</p>
<p>假设这个中心有x对这样的位置</p>
<p>那么每一对都是独立的，可以选也可以不选，但是不能都不选</p>
<p>所以此时的答案为$2^x-1$</p>
<p>题目要求不能全部连续，那么最后再跑一边<code>manacher</code>，减去全部连续的答案即可</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">int</span> r[N &lt;&lt; <span class="number">2</span>]; <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> p = mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % p) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % p;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> type, <span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, t, w = <span class="number">1</span>;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w = (LL) w * Wn % mod)</span><br><span class="line">                t = (LL)w * a[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> A[N &lt;&lt; <span class="number">2</span>], B[N &lt;&lt; <span class="number">2</span>], pal[N &lt;&lt; <span class="number">2</span>], Pow2[N]; <span class="keyword">char</span> s[N], t[N * <span class="number">2</span>]; <span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">manacher</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    t[<span class="number">0</span>] = <span class="string">'#'</span>, t[n * <span class="number">2</span> + <span class="number">1</span>] = <span class="string">'$'</span>, t[n * <span class="number">2</span> + <span class="number">2</span>] = <span class="string">'@'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) t[i * <span class="number">2</span> - <span class="number">1</span>] = <span class="string">'$'</span>, t[i * <span class="number">2</span>] = s[i]; </span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">1</span>, mx = <span class="number">1</span>, res = <span class="number">0</span>; pal[<span class="number">1</span>] = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n * <span class="number">2</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= mx) pal[i] = min(mx - i + <span class="number">1</span>, pal[<span class="number">2</span> * pos - i]);</span><br><span class="line">        <span class="keyword">else</span> pal[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (t[i - pal[i]] == t[i + pal[i]]) pal[i]++;</span><br><span class="line">        <span class="keyword">if</span> (i + pal[i] - <span class="number">1</span> &gt; mx) mx = i + pal[i] - <span class="number">1</span>, pos = i;</span><br><span class="line">        res = (res + pal[i] / <span class="number">2</span>) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>); <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span> (s[i] == <span class="string">'a'</span>) A[i] = <span class="number">1</span>; <span class="keyword">else</span> B[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>, ans = <span class="number">0</span>; Pow2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Pow2[i] = Pow2[i - <span class="number">1</span>] * <span class="number">2</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n * <span class="number">2</span>) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    NTT(len, <span class="number">1</span>, A), NTT(len, <span class="number">1</span>, B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) A[i] = (LL)A[i] * A[i] % mod, B[i] = (LL)B[i] * B[i] % mod;</span><br><span class="line">    NTT(len, <span class="number">0</span>, A), NTT(len, <span class="number">0</span>, B); <span class="keyword">int</span> Inv = Pow(len, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, t;i &lt;= n * <span class="number">2</span>;i++) &#123;</span><br><span class="line">        t = (LL)(A[i] + B[i]) * Inv % mod + (i &amp; <span class="number">1</span> ^ <span class="number">1</span>);</span><br><span class="line">        ans = (ans + Pow2[t / <span class="number">2</span>] - <span class="number">1</span>) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (ans - manacher(n) + p) % p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F-–-性能优化"><a href="#F-–-性能优化" class="headerlink" title="F – 性能优化"></a>F – 性能优化</h1><p>这道题利用到了FFT的原理</p>
<p>如果模数是质数，那么非常好办</p>
<p>但是这题不仅模数不是质数，而且求的是循环卷积，直接FFT会爆炸</p>
<p>贴一篇我觉得很好的题解</p>
<p><img src="https://0x131cc05home.files.wordpress.com/2019/02/1.jpg?w=700" alt="img"></p>
<p>这个rev数组可以模拟FFT的过程，递归地求出来</p>
<p>单位根满足消去律，上面的$F(\omega_n^i)$指的是$i\leq \frac{n}{p}$的情况</p>
<p>对于剩余的情况，有$\omega_{\frac{n}{p}}^i=\omega_{\frac{n}{p}}^{i-\frac{n}{p}}$</p>
<p>也就是说，代入的$F^{[0]},F^{[1]},\cdots,F^{[p-1]}$都相同，但是系数不同</p>
<p>然后分治就可以了</p>
<p>同样地，最后需要除以<code>len</code>，也就是模数$-1$</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tot, prime[N], r[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetPos</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> dep, <span class="keyword">int</span> len, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep == tot + <span class="number">1</span>) <span class="keyword">return</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> tmp = len / prime[dep], s = x % prime[dep];</span><br><span class="line">    <span class="keyword">return</span> GetPos((x - s) / prime[dep], dep + <span class="number">1</span>, tmp, cnt + tmp * s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp[N], g;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> a[], <span class="keyword">int</span> mod, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) tmp[r[i]] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) a[i] = tmp[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tot, block = <span class="number">1</span>;i &gt;= <span class="number">1</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = block; block *= prime[i];</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(g, type ? (mod - <span class="number">1</span>) / block : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / block, mod);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; len;j++) tmp[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, Wk = <span class="number">1</span>;j &lt; len;j += block, Wk = <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; block;k++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = k % mid, w = <span class="number">1</span>;l &lt; block;l += mid, w = (LL)w * Wk % mod)</span><br><span class="line">                    tmp[j + k] = (tmp[j + k] + (LL)w * a[j + l]) % mod;</span><br><span class="line">                Wk = (LL)Wk * Wn % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; len;j++) a[j] = tmp[j];</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">GetG</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, flag = <span class="number">1</span>;i;i++, flag = <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>;j * j &lt; x;j++)</span><br><span class="line">            <span class="keyword">if</span> (Pow(i, (x - <span class="number">1</span>) / j, x) == <span class="number">1</span>) &#123;flag = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> A[N &lt;&lt; <span class="number">2</span>], B[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, C; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;C);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;B[i]);</span><br><span class="line">    <span class="keyword">int</span> tmp = n; g = GetG(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i * i &lt;= tmp;i++)</span><br><span class="line">        <span class="keyword">while</span> (tmp % i == <span class="number">0</span>) prime[++tot] = i, tmp /= i;</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="number">1</span>) prime[++tot] = tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) r[i] = GetPos(i, <span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line">    NTT(n, A, n + <span class="number">1</span>, <span class="number">1</span>), NTT(n, B, n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) A[i] = (LL)A[i] * Pow(B[i], C, n + <span class="number">1</span>) % (n + <span class="number">1</span>);</span><br><span class="line">    NTT(n, A, n + <span class="number">1</span>, <span class="number">0</span>); <span class="keyword">int</span> Inv = Pow(n, n - <span class="number">1</span>, n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL)A[i] * Inv % (n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="H-–-Frightful-Formula"><a href="#H-–-Frightful-Formula" class="headerlink" title="H – Frightful Formula"></a>H – Frightful Formula</h1><p>算是比较简单的一道题</p>
<p>公式等价于一个表格，往右走有$a$种方法，往下走有$b$种方法，还可以直接从这个格子开始走，有$c$种方法</p>
<p>先不考虑第一行和第一列格子</p>
<p>假设是从$i,j$这个格子开始走的</p>
<p>那么，这个格子需要向右走$n-j$步，向下走$n-i$步</p>
<p>对答案的贡献是</p>
<script type="math/tex; mode=display">
c\*a^{n-i}\*b^{n-j}\*{n-i+n-j\choose n-i}</script><p>含义是，从这个格子开始，有$c$种走法，向有走$n-j$次，向下走$n-i$次，在$n-j+n-i$步中，有$n-i​$步是往下走的</p>
<p>那么，把这些空白的格子加起来，我们可以得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
c\sum_{i=2}^n\sum_{j=2}^na^{n-i}b^{n-j}{n-i+n-j\choose n-i}
&=c\sum_{i=0}^{n-2}\sum_{j=0}^{n-2}a^ib^j{i+j\choose i}\\\
&=c\sum_{i=0}^{n-2}\frac{a^i}{i!}\sum_{j=0}^{n-2}(i+j)!\frac{b^j}{j!}
\end{aligned}</script><p>我们可以枚举$i$，后面的是一个下标差相等的卷积</p>
<p>将多项式逆序一下就可以了</p>
<p>这道题没有给模数，而答案又很大</p>
<p>为了防止丢精度，所以使用MTT</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e6</span> + <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> p = mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % p) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % p;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ZJK = (<span class="number">1</span> &lt;&lt; <span class="number">19</span>) + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> frac[N * <span class="number">2</span>], f[<span class="number">2</span>][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;<span class="keyword">return</span> (LL)frac[n] * Pow(frac[r], mod - <span class="number">2</span>) % mod * Pow(frac[n - r], mod - <span class="number">2</span>) % mod;&#125;</span><br><span class="line"><span class="comment">// #define double long double</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CP</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    CP(<span class="keyword">double</span> _x = <span class="number">0</span>, <span class="keyword">double</span> _y = <span class="number">0</span>) : x(_x), y(_y) &#123;&#125;</span><br><span class="line">    CP <span class="keyword">operator</span> * (<span class="keyword">const</span> CP &amp;b) &#123;<span class="keyword">return</span> CP(x * b.x - y * b.y, x * b.y + y * b.x);&#125;</span><br><span class="line">    CP <span class="keyword">operator</span> + (<span class="keyword">const</span> CP &amp;b) &#123;<span class="keyword">return</span> CP(x + b.x, y + b.y);&#125;</span><br><span class="line">    CP <span class="keyword">operator</span> - (<span class="keyword">const</span> CP &amp;b) &#123;<span class="keyword">return</span> CP(x - b.x, y - b.y);&#125;</span><br><span class="line">    CP <span class="keyword">operator</span> / (<span class="keyword">const</span> <span class="keyword">double</span> b) &#123;<span class="keyword">return</span> CP(x / b, y / b);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> r[ZJK]; <span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> type, CP a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">CP <span class="title">Wn</span><span class="params">(<span class="built_in">cos</span>(<span class="number">2</span> * PI / mid), type * <span class="built_in">sin</span>(<span class="number">2</span> * PI / mid))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid) &#123;</span><br><span class="line">            CP w(1), t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w = w * Wn) </span><br><span class="line">                t = w * a[j + (mid &gt;&gt; <span class="number">1</span>)], a[j + (mid &gt;&gt; <span class="number">1</span>)] = a[j] - t, a[j] = a[j] + t; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">-1</span>) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) a[i] = a[i] / len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line">CP a[ZJK], b[ZJK], c[ZJK], d[ZJK];</span><br><span class="line"><span class="keyword">int</span> A[ZJK], B[ZJK];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MTT</span><span class="params">(<span class="keyword">int</span> len, LL m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) a[i] = A[i] / m, b[i] = A[i] % m, c[i] = B[i] / m, d[i] = B[i] % m;</span><br><span class="line">    FFT(len, <span class="number">1</span>, a), FFT(len, <span class="number">1</span>, b), FFT(len, <span class="number">1</span>, c), FFT(len, <span class="number">1</span>, d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) &#123;</span><br><span class="line">        CP a1 = a[i], b1 = b[i], c1 = c[i], d1 = d[i];</span><br><span class="line">        a[i] = a1 * c1, b[i] = a1 * d1, c[i] = b1 * c1, d[i] = b1 * d1;</span><br><span class="line">    &#125;</span><br><span class="line">    FFT(len, <span class="number">-1</span>, a), FFT(len, <span class="number">-1</span>, b), FFT(len, <span class="number">-1</span>, c), FFT(len, <span class="number">-1</span>, d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) </span><br><span class="line">        A[i] = ((LL)(a[i].x + <span class="number">0.5</span>) * m % mod * m % mod + (LL)(b[i].x + <span class="number">0.5</span>) * m % mod + (LL)(c[i].x + <span class="number">0.5</span>) * m % mod</span><br><span class="line">            + (LL)(d[i].x + <span class="number">0.5</span>)) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c, n; <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;a, &amp;b, &amp;c), frac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;f[<span class="number">1</span>][i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;f[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n * <span class="number">2</span>;i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, tmp1 = Pow(b, n - <span class="number">1</span>), tmp2 = Pow(a, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) ans = (ans + (LL)f[<span class="number">0</span>][i] * C(<span class="number">2</span> * n - <span class="number">2</span> - i, n - i) % mod * tmp1 % mod * Pow(a, n - i)) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) ans = (ans + (LL)f[<span class="number">1</span>][i] * C(<span class="number">2</span> * n - <span class="number">2</span> - i, n - i) % mod * tmp2 % mod * Pow(b, n - i)) % mod;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= <span class="number">2</span> * n) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t;i &lt;= n - <span class="number">2</span>;i++) t = Pow(frac[i], mod - <span class="number">2</span>), A[i] = (LL)Pow(a, i) * t % mod, B[i] = (LL)Pow(b, i) * t % mod;</span><br><span class="line">    MTT(len, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">2</span> * n - <span class="number">4</span>;i++) ans = (ans + (LL)c * A[i] % mod * frac[i]) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/06/4-3%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/06/4-3%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/" class="post-title-link" itemprop="url">4.3省选模拟</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-06 16:12:46" itemprop="dateCreated datePublished" datetime="2019-04-06T16:12:46+08:00">2019-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:27:50" itemprop="dateModified" datetime="2020-04-23T09:27:50+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="T1-Diyiti"><a href="#T1-Diyiti" class="headerlink" title="T1 Diyiti"></a>T1 Diyiti</h1><p><img src="https://i.loli.net/2019/04/06/5ca8652f32552.png" alt="1554539772376"></p>
<p><img src="https://i.loli.net/2019/04/06/5ca8654c9255c.png" alt="1554539844233"></p>
<p>我们先考虑这样一个问题：给出$x,y$，如何计算$f(x,y)$</p>
<p>分析一下第一个操作的本质，就是将$x$末尾连续的0都变成1，将第一处1变成0</p>
<p>考虑一种特殊情况：$y$是$x$的子集</p>
<p>也就是说，我们可以只通过操作2将$x$变成$y$</p>
<p>如果我们使用了操作1，可以将最后一个1变成0</p>
<p>但是这样有一个副作用，就是后面所有的数都变成了1</p>
<p>根据之前的限制：$y$是$x$的子集，而$x$在这一位之后都是0</p>
<p>也就是说，$y$在这一位之后也全部是0</p>
<p>在这次操作之后，后面的数都变成了1</p>
<p>如果这次操作在第$i$位，那么我们至少还需要$i-1$次操作2才能将后面的位变得与$y$相同</p>
<p>只有在$i=1$即操作第一位的时候，$-1$操作才与操作2等价</p>
<p>否则$-1$操作一定没有操作2优秀</p>
<p>也就是说，如果我们能用操作2，就尽量用操作2</p>
<p>那么什么情况不能用操作2呢</p>
<p>就是$x$在某一位上为0，而$y$在这一位上为1</p>
<p>这个时候我们只能用$-1$操作</p>
<p>如果第$i$位是这样的情况，就意味着，我们必须将这一位之后的第一个$1-0$对前面的所有位都变成0，然后在这个$1-0$对位置使用一次$-1$操作</p>
<p>比如$x=(10010)_2,y=(00101)_2$</p>
<p>注意“第$k$位”指的是从右边开始的第$k$位</p>
<p>对于第一位来说，我们至少需要将第一位变成0</p>
<p>对于第三位来说，我们至少需要将第四位到第一位变成0</p>
<p>为了让操作数尽量小，我们选择将第一位至第四位都变成0</p>
<p>之后就变成了第一种情况，即$y$是$x$的子集</p>
<hr>
<p>总结一下流程：</p>
<ul>
<li>我们找到最高的满足$x_i=0,y_i=1$的位置</li>
<li>找到第一个比这一位高的，满足$x_i=1,y_i=0$的位置$j$</li>
<li>通过操作2，将位置$1-(j-1)$全部变成0</li>
<li>在$j$位置使用一次$-1$操作</li>
<li>对于每一处$x_i=1,y_i=0$的位置使用操作2</li>
</ul>
<p>所以，我们可以得出</p>
<script type="math/tex; mode=display">
f(x,y)=\begin{cases}\sum_{k>j}[x_k\not=y_k]+1+\sum_{k<j}[x_k=1]+\sum_{k<j}[y_k=0]&y\not\in x\\\ \sum_k[x_k\not=y_k]&y\in x\end{cases}</script><p>那么我们现在将它扩展到$x&lt;N$</p>
<p>显然，我们可以使用数位<code>dp</code></p>
<p>根据我们之前的计算过程，我们从高位向低位<code>dp</code>，将$x$分为3个状态</p>
<ul>
<li>还没有遇到$x_i=0,y_i=1$，即此时$y\in x$，这个状态可以作为终止状态</li>
<li><p>钦定此时会有一个$-1$操作，这个状态的起点必须是$x_i=1,y_i=0$且在这个状态中不能再出现其它的$x_i=1,y_i=0$以及$x_i=0,y_i=1$，这个状态<strong>不能</strong>作为终止状态 </p>
</li>
<li><p>遇到了第一个$x_i=0,y_i=1$，然后就可以随便转移了，这个状态可以作为终止状态</p>
</li>
</ul>
<p>第二个状态之所以不能成为终止状态，是因为必须至少有一个$x_i=0,y_i-1$，否则就不应该进入2状态</p>
<p>那么我们可以设<code>f[2][2][3][N], g[2][2][3][N]</code>表示当前在第$i$位，此时$x$是否等于$N$，$y$是否等于$x$，当前在第几个状态时的答案以及转移到结尾的方案数</p>
<p>为了偷懒，我们也可以只用一个<code>dp</code></p>
<p><code>dp[2][2][3][N][N]</code>表示当前到了第$i$位，之前已经用了$j$次操作，此时$x$是否等于$N$，$y$是否等于$x$，当前在第几个状态时的答案</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 510</span></span><br><span class="line"><span class="keyword">int</span> num[N], dp[<span class="number">2</span>][<span class="number">2</span>][<span class="number">3</span>][N][N * <span class="number">2</span>], len; <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x += y, x -= x &gt;= mod ? mod : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">bool</span> flag1, <span class="keyword">bool</span> flag2, <span class="keyword">int</span> state, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == len + <span class="number">1</span>) <span class="keyword">return</span> state == <span class="number">1</span> ? <span class="number">0</span> : cnt;</span><br><span class="line">    <span class="keyword">int</span> &amp;sum = dp[flag1][flag2][state][cur][cnt];</span><br><span class="line">    <span class="keyword">if</span> (~sum) <span class="keyword">return</span> sum;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>;x &lt; <span class="number">4</span>;x++) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = x &amp; <span class="number">1</span>, j = x &gt;&gt; <span class="number">1</span> &amp; <span class="number">1</span>, tflag1 = flag1 &amp;&amp; (i == num[cur]), tflag2 = flag2 &amp;&amp; (j == i);</span><br><span class="line">        <span class="keyword">if</span> (flag1 &amp;&amp; i &gt; num[cur]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag2 &amp;&amp; j &gt; i) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (state == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) <span class="keyword">continue</span>;</span><br><span class="line">            Inc(sum, DP(cur + <span class="number">1</span>, tflag1, tflag2, <span class="number">0</span>, cnt + (i &gt; j)));</span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) Inc(sum, DP(cur + <span class="number">1</span>, tflag1, tflag2, <span class="number">1</span>, cnt + <span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == j) Inc(sum, DP(cur + <span class="number">1</span>, tflag1, tflag2, <span class="number">1</span>, cnt + (i == <span class="number">1</span>) + (j == <span class="number">0</span>)));</span><br><span class="line">            <span class="keyword">else</span> Inc(sum, DP(cur + <span class="number">1</span>, tflag1, tflag2, <span class="number">2</span>, cnt)); </span><br><span class="line">        &#125; <span class="keyword">else</span> Inc(sum, DP(cur + <span class="number">1</span>, tflag1, tflag2, <span class="number">2</span>, cnt + (i == <span class="number">1</span>) + (j == <span class="number">0</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> input[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"diyiti.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"diyiti.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, input + <span class="number">1</span>), len = <span class="built_in">strlen</span>(input + <span class="number">1</span>), <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++) num[i] = input[i] - <span class="string">'0'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, DP(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-Dierti"><a href="#T2-Dierti" class="headerlink" title="T2 Dierti"></a>T2 Dierti</h1><p><img src="https://i.loli.net/2019/04/06/5ca89802d6f00.png" alt="1554552801425"></p>
<p><img src="https://i.loli.net/2019/04/06/5ca8981514ccf.png" alt="1554552819955"></p>
<p>看起来是一道好题，可惜没有题解</p>
<p>这里讲一下部分分做法（只会部分分）</p>
<p>首先我们可以枚举最后选到的是哪个$n$以及哪个$m$，求这个东西的$k$阶中心矩，最后再求期望</p>
<p>这里的$x$就是实际选的袋子中球的数量</p>
<p>考虑</p>
<script type="math/tex; mode=display">
\begin{aligned}
E((x-E(x))^k)&=E(\sum_{i=0}^k{k\choose i}x^k(-1)^{k-i}E(x)^{k-i})\\\
&=\sum_{i=0}^k{k\choose i}(-1)^{k}E(x)^{k}E(x^{k-i})
\end{aligned}</script><p>显然$E(x)=\frac{m}{n}$，所以关键是要求出$E(x^k)$</p>
<p>这等价于有一个数，现在要对这个数进行$m$次操作，每次操作都有$\frac{1}{n}$的概率会加1，否则不变</p>
<p>很像一道题<a href="https://www.luogu.org/problemnew/show/P1654" target="_blank" rel="noopener">osu</a></p>
<p>我们分别维护$E(x),E(x^2),\cdots,E(x^k)$，转移的时候再次使用二项式展开</p>
<p>这样一次转移是$k^3$的，可以使用矩阵乘法优化</p>
<p>可以拿到60分</p>
<h1 id="T3-Disanti"><a href="#T3-Disanti" class="headerlink" title="T3 Disanti"></a>T3 Disanti</h1><p><img src="https://i.loli.net/2019/04/07/5ca9b44761e6a.png" alt="1554625591423"></p>
<p><img src="https://i.loli.net/2019/04/07/5ca9b465f25d6.png" alt="1554625629573"></p>
<p>我不会啊，而且没有题解</p>
<p>先咕在这里吧</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2019/04/06/4-2%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/06/4-2%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/" class="post-title-link" itemprop="url">4.2省选模拟</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-06 15:22:26" itemprop="dateCreated datePublished" datetime="2019-04-06T15:22:26+08:00">2019-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-23 09:28:04" itemprop="dateModified" datetime="2020-04-23T09:28:04+08:00">2020-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="T1-Painting"><a href="#T1-Painting" class="headerlink" title="T1 Painting"></a>T1 Painting</h1><p><img src="https://i.loli.net/2019/04/06/5ca853e21983b.png" alt="1554535371227"></p>
<p><img src="https://i.loli.net/2019/04/06/5ca853fe09737.png" alt="1554535413371"></p>
<p>我们考虑这样一种情况：<code>122133441</code></p>
<p>显然，<code>1</code>必须在最开始就刷上，如果先刷其它的数再刷<code>1</code>，那么颜色<code>2,3,4</code>不可能被<code>1</code>包含</p>
<p>颜色<code>3,4</code>刷的顺序无关紧要</p>
<p>我们考虑更一般的情况</p>
<p>如果存在颜色序列<code>a...b...b...a</code>，其中省略号的部分可能代表其它颜色，那么<code>a</code>一定在<code>b</code>之前被刷上</p>
<p>对于颜色序列<code>a..ab...b</code>，<code>a,b</code>被刷的顺序可以随意</p>
<p>我们可以通过这两个条件将拓扑关系建出来，可以发现，这是一棵树</p>
<p>树的祖先与后代刷的顺序是确定的，同一个父亲的儿子节点刷的顺序可以随意</p>
<p>于是我们考虑分治，假设当前分治到了区间<code>[l,r]</code>，这要求这个区间的左右两个端点的颜色相同</p>
<p>比如上面那个例子中，这个颜色就是<code>1</code></p>
<p>这个颜色将这个区间分成了若干段，对于每一段我们只关心当前颜色的儿子节点，将每一个颜色序列都缩成一个点</p>
<p>比如序列<code>12332144551</code>，<code>1</code>将序列分成了两个部分<code>2332,4455</code></p>
<p>对于颜色<code>2</code>，我们将它缩成一个长度为4的点，它在第一段</p>
<p>对于颜色<code>3</code>，我们不管它，因为它不是<code>1</code>的儿子，它在第二段</p>
<p>对于颜色<code>4,5</code>，我们将它们各缩成长度为2的点，它在第二段</p>
<p>对于每一段，我们分别进行<code>dp</code>，算出答案的最大值，因为段与段之间不能相互跨越，否则中间那个<code>1</code>就永远都刷不上了</p>
<p>我们用<code>dp[i][j]</code>表示已经刷好了<code>[i,j]</code>这些点，能获得的最大收益</p>
<p>如果我们假设第$i$个点缩成的长度是$b_i$，那么这个<code>dp</code>就满足</p>
<script type="math/tex; mode=display">
dp_{i,j}=\sum_{l=i}^jb_l+\max_{mid=i}^j\{dp_{i,mid-1}+dp_{mid+1,j}\}</script><p>含义是我们枚举第一次刷的颜色$mid$，这会将序列分成两段独立的区间，分别刷即可</p>
<p>这个<code>dp</code>是$m^3$的</p>
<p>如果我们打出这个<code>dp</code>取最优值的位置，可以发现它一定在左端点或者右端点转移</p>
<p>不会证明</p>
<p>此时<code>dp</code>就是$m^2$的了</p>
<p>题解的证明过程如下</p>
<div class="pdfobject-container" data-target="Color.pdf" data-height="500px"></div>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 5010</span></span><br><span class="line"><span class="keyword">int</span> num[N], nxt[N], lst[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp; <span class="keyword">int</span> dp[M][M], pre[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">DP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tmp.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) pre[i] = pre[i - <span class="number">1</span>] + tmp[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= n;j++) dp[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) dp[i][i] = tmp[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>;len &lt;= n;len++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">1</span>;start + len - <span class="number">1</span> &lt;= n;start++) &#123;</span><br><span class="line">            <span class="keyword">int</span> end = start + len - <span class="number">1</span>;</span><br><span class="line">            dp[start][end] = max(dp[start + <span class="number">1</span>][end], dp[start][end - <span class="number">1</span>]) + pre[end] - pre[start - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ls = l, cur = nxt[l];ls != r;cur = nxt[ls = cur]) &#123;</span><br><span class="line">        tmp.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> at = ls + <span class="number">1</span>;at != cur;at = lst[at] + <span class="number">1</span>) </span><br><span class="line">            tmp.push_back(lst[at] - at + <span class="number">1</span>);</span><br><span class="line">        res += DP();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ls = l, cur = nxt[l];ls != r;cur = nxt[ls = cur]) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> at = ls + <span class="number">1</span>;at != cur;at = lst[at] + <span class="number">1</span>) </span><br><span class="line">            solve(at, lst[at]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp1[N], beg[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"color.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"color.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">        <span class="keyword">if</span> (tmp1[num[i]]) nxt[tmp1[num[i]]] = i;</span><br><span class="line">        <span class="keyword">else</span> beg[num[i]] = i;</span><br><span class="line">        tmp1[num[i]] = i, lst[beg[num[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    nxt[<span class="number">0</span>] = n + <span class="number">1</span>, solve(<span class="number">0</span>, n + <span class="number">1</span>), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-Path"><a href="#T2-Path" class="headerlink" title="T2 Path"></a>T2 Path</h1><p><img src="https://i.loli.net/2019/04/06/5ca85b7f898f3.png" alt="1554537333909"></p>
<p><img src="https://i.loli.net/2019/04/06/5ca85b9a727e4.png" alt="1554537361628"></p>
<p>假设当前点是$u$</p>
<p>可以发现，最优策略一定是选择一个点集$v$，然后一直在$u$点等待，直到$u$和$v$连通，然后走这条出现的边</p>
<p>我们用<code>dp[u]</code>表示在最优策略下，$u$点到$n$需要的期望时间</p>
<p>我们将$u$点能到达的边按照<code>dp</code>值排序，可以发现选择的点集一定是一段前缀</p>
<p>我们枚举这个前缀，对于一个前缀$v_i$，如果选择这个前缀的点集，那么有转移</p>
<script type="math/tex; mode=display">
dp_u=\min_{i=1}^{|v|}\{\frac{1}{i}\sum_{t\in v_i}dp_t+\frac{m}{i}\}</script><p>含义是，如果选择了这个前缀，那么所选择的点中作为第一个出现的点的概率是相等的，为了走这一条边，我们期望要等$\frac{m}{i}$轮</p>
<p>由于有$\min$，所以无法高斯消元</p>
<p>一种方法是进行若干次迭代，每次迭代枚举每个点更新</p>
<p>另一种方法是使用一个类似<code>SPFA</code>的方法，将这次更新的点放进队列，继续拓展</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="keyword">double</span> dp[N]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dp[i] &lt; dp[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"path.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"path.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b;i &lt;= m;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), G[a].push_back(b), G[b].push_back(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) dp[i] = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>;t &lt;= <span class="number">2000000</span> / m;t++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">            sort(G[i].begin(), G[i].end(), cmp); <span class="keyword">double</span> tmp = <span class="number">0</span>, ans = <span class="number">0</span>, ls = <span class="number">1e9</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= G[i].size();j++) &#123;</span><br><span class="line">                tmp += dp[G[i][j - <span class="number">1</span>]], ans = tmp / j + (<span class="keyword">double</span>)m / j;</span><br><span class="line">                <span class="keyword">if</span> (ans &gt; ls) <span class="keyword">break</span>;</span><br><span class="line">                dp[i] = min(dp[i], ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.7lf\n"</span>, dp[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-Tree"><a href="#T3-Tree" class="headerlink" title="T3 Tree"></a>T3 Tree</h1><p><img src="https://i.loli.net/2019/04/06/5ca85d84910e7.png" alt="1554537850931"></p>
<p><img src="https://i.loli.net/2019/04/06/5ca85da120c4b.png" alt="1554537880643"></p>
<p>如果最远点的距离是$x$，那么所选择的点数必须不小于$\frac{n}{x}$</p>
<p>这个式子看上去就很像分块</p>
<p>我们暴力枚举答案$1-\sqrt{n}$，找到答案为当前值的关键点数的区间</p>
<p>对于现在还没有确定答案的那些关键点数，我们直接二分，然后暴力算答案</p>
<p>所谓暴力就是直接树上贪心</p>
<p>这样可以获得60分的好成绩</p>
<p>贴一下题解</p>
<p><img src="https://i.loli.net/2019/04/06/5ca85eea90a02.jpg" alt="sol_tree"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/15/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/17/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="PlanarG"
      src="/images/77041874_p0_master12001.jpg">
  <p class="site-author-name" itemprop="name">PlanarG</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">197</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">66</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://planarg.top/" title="https:&#x2F;&#x2F;planarg.top&#x2F;">Title</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">PlanarG</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1.5,"jsonPath":"/live2dw/assets/histoire.model.json"},"display":{"position":"left","width":150,"height":300,"hOffset":35,"vOffset":-25},"mobile":{"show":false},"log":false});</script></body>
</html>
