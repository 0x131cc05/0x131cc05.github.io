<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"planarg.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="PlanarG&#39;s blog">
<meta property="og:url" content="https://planarg.top/index.html">
<meta property="og:site_name" content="PlanarG&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="PlanarG">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://planarg.top/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>PlanarG's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">PlanarG's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section">首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section">标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section">分类</a>

  </li>
        <li class="menu-item menu-item-友链">

    <a href="/friends/" rel="section">友链</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section">归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger">搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2021/04/25/2.21%E7%BD%91%E7%BB%9C%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/2.21%E7%BD%91%E7%BB%9C%E6%B5%81/" class="post-title-link" itemprop="url">2.21网络流</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 19:00:58" itemprop="dateCreated datePublished" datetime="2021-04-25T19:00:58+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-21 20:47:49" itemprop="dateModified" datetime="2021-02-21T20:47:49+08:00">2021-02-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ARC107F"><a href="#ARC107F" class="headerlink" title="ARC107F"></a>ARC107F</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一张$n$个点，$m$条边的无向图，每个点有点权$A_i,B_i$。你可以选择若干个点删掉，代价为它们的$A_i$之和，然后对于剩下的每个连通块，获得的分数为其$B_i$之和的绝对值。</p>
<p>最大化收益减去代价。</p>
<script type="math/tex; mode=display">
n,m\leq 300</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>对于保留下来的每一条边，这条边连接的两个端点的$B_i$符号必然相同。注意到最后要最大化收益，因此可以去掉$B_i$的绝对值，相当于我们要给每个点分配$-1,0,1$，同时保证删去$0$点之和的每个连通块内所有点的标号相同。</p>
<p>对于原图中的每个点$i$，拆成两个点$i,i’$，连边$s\rightarrow i\rightarrow i’\rightarrow t$。割去这三条边分别表示$1,0,-1$。即一开始我们默认所有点的权值都是$B_i$，然后根据最小割的定义给这三条边分配容量。答案就是$\sum B_i$减去最小割。</p>
<p>考虑如何连边。由于每个点的状态只有三种，而当一个点被删去时，与它相连的所有边产生的限制都将消失。因此，我们只需要满足，一旦某个连通块内存在一个$-1$，就意味着这个连通块内必须全部是$-1$。不需要考虑$1$的限制。</p>
<p>因此，对于一条边$(u,v)$，连边$u’\rightarrow v,v’\rightarrow u$，边权$\infty$。即如果$u$或者$v$为$-1$，要么另一个点被删去，要么另一个点也必须为$-1$。</p>
<h1 id="Gym101471J"><a href="#Gym101471J" class="headerlink" title="Gym101471J"></a>Gym101471J</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给出一张$n$个点$m$条边的有向图，其中有两个源点$S_1,S_2$和汇点$T$。有两种液体，分别从$S_1,S_2$流入。第一种液体每单位会占用$1$的容量，第二种液体每单位会占用$v$的流量（单位可以是小数）。设这两种液体到达汇点的流量分别为$W,F$，那么最后的收益为$W^aF^{1-a}$。输出最大值。</p>
<script type="math/tex; mode=display">
n\leq 300,a\in[0.01,0.99]</script><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>观察一下可以发现$v$是没用的，我们可以将这两种液体都当成每单位只会占用$1$的流量，最后再将收益除以$v^{1-a}$。</p>
<p>分别从$S_1,S_2$开始跑一遍普通的网络流，记最大流量分别为$W_{max}$和$F_{max}$。接着建一个超级源点，向$S_1,S_2$连边，可以跑出$W+F$的上界$S$。</p>
<p>接下来我们证明，如果记$(W,F)$为最终一组可行的流量，那么它合法当且仅当：</p>
<ul>
<li>$W\leq W_{max}$</li>
<li>$F\leq F_{max}$</li>
<li>$W+F\leq S$</li>
</ul>
<p>这三个条件显然是必要的。接下来我们证明充分性。</p>
<p>考虑两种可行的流量：$(S-F_{max},F_{max})$以及$(W_{max},S-W_{max})$。我们可以给这两种方案分配$\alpha,\beta$的系数，只需要满足$\alpha+\beta\leq 1$。此时每条边最终的流量必然没有超过容量上界。运用向量的知识即可发现可以得到所有满足上述条件的$(F,W)$。</p>
<p>问题转化为了一个简单的不等式问题：如何分配$\alpha,\beta$使得$W^aF^{1-a}$最大。</p>
<p>运用简单的求导知识可得$[\alpha^a(1-\alpha)^{1-a}]’=0$时$\alpha$最优，化简得$\alpha=a$。即$\frac WF=\frac{a}{1-a}$时答案最优。</p>
<h1 id="CF1307G"><a href="#CF1307G" class="headerlink" title="CF1307G"></a>CF1307G</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>一张有向图，$q$次询问，每次给出$x_i$，可以给每条边的边权加上一个数，使得加的数之和不超过$x_i$，最大化$1$到$n$的最短路。</p>
<script type="math/tex; mode=display">
n\leq 50,q\leq 10^5</script><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>先考虑一次询问怎么做。</p>
<p>它看起来就非常的线性规划，首先将原问题转化为线性规划问题。</p>
<p>设原来的边权为$w_{u,v}$，加的数为$a_{u,v}$，我们想要判断答案能否超过$D$，那么有</p>
<p>最小化</p>
<script type="math/tex; mode=display">
\sum_{u,v\in E} a_{u,v}</script><p>满足约束</p>
<script type="math/tex; mode=display">
\begin{aligned}
d_v-d_u&\leq w_{u,v}+a_{u,v}\\
d_n-d_1&\geq D\\
d_i&\geq 0,a_{u,v}\geq 0
\end{aligned}</script><p>将第一个限制移项变为$d_u-d_v+a_{u,v}\geq -w_{u,v}$。于是我们得到了一个需要初始化的线性规划。</p>
<p>显然我们不可能每次都重新跑一遍这个线性规划，考虑将它转成对偶。</p>
<p>此时我们给原来每个方程分配一个新的变量$b_{u,v}$，给$d_n-d_1$这个方程分配变量$f$，可以得到对偶线性规划：</p>
<p>最大化</p>
<script type="math/tex; mode=display">
D\times f-\sum_{u,v\in E}w_{u,v}\times b_{u,v}</script><p>满足约束</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{v}b_{u,v}-\sum_{v}b_{v,u}&\leq 0\\
\sum_{v}b_{1,v}-\sum_{v}b_{v,1}-f&\leq 0\\
\sum_{v}b_{n,v}-\sum_{v}b_{v,n}+f&\leq 0\\
b_{u,v}&\leq 1
\end{aligned}</script><p>可以发现，它长得非常像费用流。</p>
<p>直接在原图上跑单路增广费用流，容易发现最终的最小费用是一个关于流量的分段一次函数，断点是每次增广之后的当前流量。</p>
<p>$D$与边权是无关的，于是我们可以在所有询问之前先求出流量为$i$时的最小费用，然后大概是一个斜率优化。</p>
<h1 id="CF1383F"><a href="#CF1383F" class="headerlink" title="CF1383F"></a>CF1383F</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>给出一张$n$个点$m$条边的有向图，其中有$k$条边是特殊边。$q$次询问，每次会给这$k$条边重新分配容量，问$1$到$n$的最大流。</p>
<script type="math/tex; mode=display">
n,m\leq 10^4,q\leq 2\times 10^5,k\leq 10,w\leq 25</script><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>最大流等于最小割，因此我们可以暴力枚举这$k$条边割的情况，因此一共只有$2^k$种本质不同的最大流。</p>
<p>复杂度为$O(flow\times 2^k+2^k\times q)$。</p>
<p>需要预处理保留这$k$条边的每个子集时的最大流，直接跑很难过，考虑优化</p>
<p>第一种优化是先将这$k$条边全部去掉，跑一遍最大流，然后仅保留残量网络。接下来每次在残量网络上增广。</p>
<p>第二种优化是采用优秀的转移方式，可以使用类似格雷码的方式，每次在原来网络的基础上加入一条边。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2021/04/25/2.18%E6%95%B0%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/2.18%E6%95%B0%E8%AE%BA/" class="post-title-link" itemprop="url">2.18数论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 19:00:58" itemprop="dateCreated datePublished" datetime="2021-04-25T19:00:58+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-18 22:58:59" itemprop="dateModified" datetime="2021-02-18T22:58:59+08:00">2021-02-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一个$n\times m$的表格，第$i$行$j$列的值为$\gcd(i, j)$。给出一个数列$a$，判断它是否在表格的某一行出现过。</p>
<script type="math/tex; mode=display">
n,m\leq 10^{12},|a|\leq 10^4</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>求出$a_i$的$\text{lcm}$。显然行必须是这个$\text{lcm}$的倍数。同时行取这个$\text{lcm}$的时候最优，因为如果取$\text{lcm}$的倍数的话会产生额外的质因子干扰$\gcd$，同时我们也应满足行的编号尽量小。</p>
<p>接下来考虑列。假设这个数列$a$对应第$i$行的第$j+1,j+2,\cdots, j+|a|$列，那么对于每个$k$我们有$a_k|j+k$，即$j\equiv a_k-k\bmod a_k$。用中国剩余定理合并之后可以得到$j\equiv x\bmod \text{lcm}(\{a\})$。求出最小的非负整数解$x$，由于$a_k|\text{lcm}(\{a\})$，根据$\gcd$的性质我们可以发现当$j$取这个$x$的时候最优。接下来扫一遍$a$，根据定义判断$a$是否在第$i$行$j$列合法即可。</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><script type="math/tex; mode=display">
\sum_{i=a}^b\text{lcm}(i, b)\bmod 10^9+7</script><p>$T\leq 5000$组数据，$a,b\leq 10^9$。</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><script type="math/tex; mode=display">
\sum_{i=a}^b\text{lcm}(i,b)=b\sum_{i=a}^b\frac{i}{\gcd(i,b)}</script><p>假设我们找到了一组系数$f(n)$使得$\sum_{d|n}f(d)=\frac{1}{n}$。那么</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=a}^b\frac{i}{\gcd(i,b)}&=\sum_{i=a}^bi\sum_{d|i,d|b}f(d)\\
&=\sum_{d|b}f(d)\sum_{i=a}^b[d|i]
\end{aligned}</script><p>第二个$\sum$里面的东西相当于求出一段区间内有多少个数是$d$的倍数，这非常好求。如果我们能算出$f$，那么只需要枚举$b$的所有因数就可以计算答案。</p>
<p>考虑如何算$f$。首先，由于$\frac{1}{x}$是个积性函数，因此$f$也必然是积性函数。</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(1)&=\frac{1}{1}=1\\
f(1)+f(p)&=\frac{1}{p}\Rightarrow f(p)=\frac{1}{p}-1\\
f(1)+f(p)+f(p^2)+\cdots+f(p^k)&=\frac{1}{p^k}\Rightarrow f(p^k)=\frac{1}{p^k}-\frac{1}{p^{k-1}}
\end{aligned}</script><p>因此，我们可以得到$f(n)=\frac{1}{n}\prod (1-p_i)$。这里$p_i$是$n$的所有质因子。</p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><script type="math/tex; mode=display">
\sum_{i=a}^b\frac{1}{i}\sum_{j=1}^i\text{lcm}(j,i)\bmod 10^9+7\\\
a,b\leq 10^{10}</script><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^n\frac{1}{i}\sum_{j=1}^i\text{lcm}(j,i)&=\sum_{i=1}^n\sum_{j=1}^i\frac{j}{\gcd(j, i)}\\
&=\sum_{i=1}^n\sum_{j=1}^ij\sum_{d=1}^n\frac{1}{d}[\gcd(j,i)=d]\\
&=\sum_{d=1}^n\sum_{i=1}^{\frac nd}\sum_{j=1}^ij[\gcd(j,i)=1]
\end{aligned}</script><p>此时最后一个$\sum$相当于$1\sim i$中与$i$互质的数之和，它等于$\frac{i\varphi(i)}{2}$。注意当$i=1$时要特判。</p>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><script type="math/tex; mode=display">
\sum_{i=1}^n\sum_{d|i}\gcd(d,\frac id),n\leq 10^{12}</script><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^n\sum_{d|i}\gcd(d,\frac id)&=\sum_{d=1}^n\sum_{i=1}^{\frac nd}\gcd(d,i)\\
&=\sum_{d=1}^n\sum_{i=1}^{\frac nd}\sum_{j|d,i}\varphi(j)\\
&=\sum_{j=1}^n\varphi(j)\sum_{d=1}^{\frac nj}\lfloor\frac{n}{dj^2}\rfloor
\end{aligned}</script><p>注意到$j$只用枚举到$\sqrt n$，最终复杂度为</p>
<script type="math/tex; mode=display">
\sum_{i=1}^\sqrt n\sqrt \frac{n}{i^2}=\sum_{i=1}^\sqrt n\frac{\sqrt n}{i}=\sqrt n\log(n)</script><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>定义$d(x)$是满足$y|x$且$y&gt;1$的最小正整数$y$。</p>
<p>定义</p>
<script type="math/tex; mode=display">
f(x)=\begin{cases}1&x=1\\\ d(x)f\left(\frac{x}{d(x)^2}\right)&x>1,d(x)^2\mid x\\\ f\left(\frac{x}{d(x)^2}\right)&\text{others}\end{cases}</script><p>求$\sum_{i=1}^nf(i)$</p>
<h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><p>有两种做法。</p>
<p>$d(x)$实际上就是$x$的最小质因子，观察$f$的式子可以发现，</p>
<script type="math/tex; mode=display">
f(x)=\prod p_i^{\lfloor\frac {k_i}2\rfloor}</script><p>它等价于</p>
<script type="math/tex; mode=display">
\max_{u^2\mid x}u</script><p>如果$u$满足$u\mid x$，那么$u$以及它的所有因数也满足这个条件，并且只有这些数满足条件</p>
<p>因此我们可以将这个东西变换一下</p>
<script type="math/tex; mode=display">
\max_{u^2\mid x}u=\sum_{u^2|x}\varphi(u)</script><p>因此我们实际上要求的就是</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^nf(i)&=\sum_{i=1}^n\sum_{u^2\mid i}\varphi(u)\\
&=\sum_{u=1}^{\sqrt n}\varphi(u)\lfloor\frac n{u^2}\rfloor
\end{aligned}</script><p>第二种做法是直接考虑<code>powerful number</code>筛。</p>
<p>定义<code>powerful number</code>为所有质因数的质数均$\geq 2$的数，可以证明$\leq n$的<code>powerful number</code>只有$O(\sqrt n)$个。</p>
<p>回到这道题，不难看出$f(x)$是积性函数。</p>
<p>考虑求出$h(x)$满足$f(n)=\sum_{d|n}h(d)$。我们有</p>
<script type="math/tex; mode=display">
\begin{aligned}
h(1)&=f(1)=1\\
h(1)+h(p)&=f(p)\Rightarrow h(p)=0\\
\end{aligned}</script><p>同时，$h(p^k)$是很好算的东西，这里就不推了。</p>
<p>注意到当$p$是质数时，$h(p)=0$，也就是说，$h$在所有非<code>powerful number</code>处取值都为$0$。</p>
<p>暴力搜出$n$以内的所有<code>powerful number</code>，然后用这个$h(n)$求值即可。</p>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>记$\text{sgcd}(i,j)$为$i,j$的公约数中第二大的，特别地若$\gcd(i,j)=1$，定义$\text{sgcd}(i,j)=0$。</p>
<p>求</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\sum_{j=1}^n\text{sgcd}(i,j)^k,n\leq 10^9,k\leq 50</script><h2 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h2><p>记$\text{minp}(x)$为$x$的最小质因子，特别地若$x=1$则$\text{minp}(x)=\infty$。</p>
<p>那么问题等价于</p>
<script type="math/tex; mode=display">
\begin{aligned}
\cdots&=\sum_{i=1}^n\sum_{j=1}^n\sum_{d=1}^n\left(\frac{d}{\text{minp}(d)}\right)^k[\gcd(i,j)=d]\\
&=\sum_{d=1}^n(\cdots)^k\sum_{i=1}^{\frac nd}\sum_{j=1}^{\frac nd}[\gcd(i,j)=1]\\
&=\sum_{d=1}^n(\cdots)^k(2\sum_{i=1}^{\frac nd}\varphi(i)-1)
\end{aligned}</script><p>第二个$\sum$可以使用一次杜教筛解决，问题转化为求$\left(\frac d{\text{minp}(d)}\right)^k$的前缀和。这个可以用类似<code>min25</code>筛的方式解决。</p>
<p>记$F(i,j)$表示考虑$[1,j]$中的数，最小质因子大于第$j$个质数的所有数的$k$次方之和。</p>
<p>记$G(i,j)$表示考虑$[1,j]$中的数，最小质因子大于第$j$个质数的数的个数。</p>
<p>记$H(i,j)$表示考虑$[1,j]$中的数，最小质因子不超过第$j$个质数的所有数的答案之和。</p>
<p>那么有</p>
<script type="math/tex; mode=display">
\begin{aligned}
F(i,j)&=F(i-1,j)-p_i^kF(i-1,\frac{j}{p_i})\\
G(i,j)&=G(i-1,j)-G(i-1,\frac{j}{p_i})\\
H(i,j)&=H(i-1,j)+F(i-1,\frac{j}{p_i})
\end{aligned}</script><p>当$p_j&gt;\sqrt n$时，最小质因子为$p_j$的数只有$p_j$，且它的答案为$1$。</p>
<p>用类似<code>min25</code>筛的方式$dp$一下即可。</p>
<h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><h2 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h2><p>给定$x,a,b$，求有多少对$(i,j)$满足$i\in[1,a],j\in[1,b]$且$\lfloor\frac xi\rfloor j=\lfloor\frac {xj}i\rfloor$。</p>
<script type="math/tex; mode=display">
x,a,b\leq 10^9</script><h2 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h2><p>问题等价于求出有多少对$i,j$满足$(x\bmod i)\times j&lt;i$。</p>
<p>将这个式子改写一下</p>
<script type="math/tex; mode=display">
\begin{aligned}
(x\bmod i)\times j<i&\Rightarrow j<\lceil\frac{i}{x\bmod i}\rceil\\
&\Rightarrow j<\lceil\frac{i}{x-\lfloor\frac xi\rfloor i}\rceil
\end{aligned}</script><p>枚举$\lfloor\frac xi\rfloor$，可行的$i$是一段区间。</p>
<p>将这个值相等的$i$划分为一段，由于这个东西随着$i$增加而递增，所以每次可以二分找出这一段的结尾。</p>
<p>然后打一下表会发现总段数不会很多。（我也不知道为什么）</p>
<h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><h2 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h2><p>求$(Fib_n\bmod Fib_k)\bmod 10^9+7$，$50000$组数据</p>
<script type="math/tex; mode=display">
n,k\leq 10^{18}</script><h2 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h2><p>我们知道</p>
<script type="math/tex; mode=display">
\begin{bmatrix}1&1\\\ 1& 0\end{bmatrix}^n=\begin{bmatrix}F_{n+1}&F_n\\\ F_n & F_{n-1}\end{bmatrix}</script><p>同时</p>
<script type="math/tex; mode=display">
\begin{aligned}
\begin{bmatrix}1&1\\\ 1& 0\end{bmatrix}^n&=\begin{bmatrix}1&1\\\ 1& 0\end{bmatrix}^{k-1}\times \begin{bmatrix}1&1\\\ 1& 0\end{bmatrix}^{n-k+1}\\
&=\begin{bmatrix}F_k&F_{k-1}\\\ F_{k-1}& F_{k-2}\end{bmatrix}\times \begin{bmatrix}F_{n-k+2}&F_{n-k+1}\\\ F_{n-k+1}& F_{n-k}\end{bmatrix}
\end{aligned}</script><p>观察左上角的元素，我们可以得到</p>
<script type="math/tex; mode=display">
F_{n+1}=F_kF_{n-k+2}+F_{k-1}F_{n-k+1}</script><p>即</p>
<script type="math/tex; mode=display">
F_n=F_kF_{n-k+1}+F_{k-1}F_{n-k}\tag{1}</script><p>另外，根据行列式的运算法则$\det(AB)=\det(A)\det(B)$，将第一个等式两边同时取行列式，可以得到</p>
<script type="math/tex; mode=display">
\begin{aligned}
(-1)^n&=F_{n+1}F_{n-1}-F_n^2\\
&=(F_n+F_{n-1})F_{n-1}-F_n^2\\
&=F_{n-1}^2+F_nF_{n-1}-F_n^2
\end{aligned}\tag{2}</script><p>接下来，我们将数列的下标拓展到负数，有$F_{-n}=(-1)^{n-1}F_n$。</p>
<p>将$(1)$式两边同时对$F_k$取模，可以得到</p>
<script type="math/tex; mode=display">
F_n\equiv F_{k-1}F_{n-k}\pmod{F_k}</script><p>固定$k$，不断地用这个等式替换$F_{n-k}$，那么每次我们能将下标减去$k$，直到$n&lt;k$。即</p>
<script type="math/tex; mode=display">
F_n\equiv F_{k-1}^{\lfloor\frac nk\rfloor}F_{n\bmod k}\pmod {F_k}</script><p>记$i=\lfloor\frac nk\rfloor,j=n\bmod k$，分类讨论：</p>
<ul>
<li><p>$i=2t$</p>
<p>  此时$F_n\equiv(F_{k-1}^2)^tF_j$，将$(2)$代入得到</p>
<script type="math/tex; mode=display">
  \begin{aligned}
  F_n&\equiv ((-1)^k-F_kF_{k-1}-F_k^2)^tF_j\pmod{F_k}\\
  &\equiv (-1)^{kt}F_j\pmod{F_k}
  \end{aligned}</script></li>
<li><p>$i=2t+1$</p>
<p>  此时用$(1)$式再次替换$F_j$后就变成了$i$是偶数的情况</p>
</li>
</ul>
<p>注意到$j=n\bmod k&lt;k$，因此问题转化为求斐波那契数列某一项的值$\bmod 10^9+7$。</p>
<h1 id="I"><a href="#I" class="headerlink" title="I"></a>I</h1><p><img src="https://i.loli.net/2021/02/18/4lLnjowh97kFXzT.png" alt="image.png"></p>
<p>8会</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2021/04/25/2.17%E6%9D%82%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/2.17%E6%9D%82%E9%A2%98/" class="post-title-link" itemprop="url">2.17杂题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 19:00:58" itemprop="dateCreated datePublished" datetime="2021-04-25T19:00:58+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-17 16:35:30" itemprop="dateModified" datetime="2021-02-17T16:35:30+08:00">2021-02-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="棋盘"><a href="#棋盘" class="headerlink" title="棋盘"></a>棋盘</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><img src="https://i.loli.net/2021/02/17/RxVes6FiXwyqpPH.png" alt="image.png"></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>如果$n$是偶数，那么我们可以直接对棋盘进行黑白染色，每一列都可以取到$\frac n2$的上界。</p>
<p>否则，将$a_i=\lfloor\frac{n}{2}\rfloor$的那些列拿出来，这些列的放法是唯一的，并且它们将整张棋盘分为若干段，每一段互不影响。</p>
<p>考虑这样一种情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">32222223</span><br><span class="line"></span><br><span class="line">10101011</span><br><span class="line">01010100</span><br><span class="line">10101011</span><br><span class="line">01010100</span><br><span class="line">10000001</span><br></pre></td></tr></table></figure>
<p>直接按照黑白染色的方式放的话会放出上面的这种情况，注意到倒数第二列无论是奇数行还是偶数行都已经1被占用了。原因是第一列和最后一列中间夹了偶数列。</p>
<p>我们将正常放会放到的格子称为“白格”，将不会放到的格子称为“黑格”。</p>
<p>解决方法是：对于每一列，从下往上优先放所有能放的黑格，如果还有剩余的棋子，从上往下放白格。</p>
<p>对于这个样例，放出来大概长这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10101001</span><br><span class="line">01010010</span><br><span class="line">10100101</span><br><span class="line">01001010</span><br><span class="line">10010101</span><br></pre></td></tr></table></figure>
<h1 id="Flip-and-Reverse"><a href="#Flip-and-Reverse" class="headerlink" title="Flip and Reverse"></a>Flip and Reverse</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给出一个<code>01</code>串，每次你可以选择一个<code>01</code>个数相等的区间，将这个区间翻转并且<code>01</code>互换。你可以进行任意多次操作，问最终能得到的字典序最小的串。</p>
<script type="math/tex; mode=display">
n\leq 10^5</script><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>将<code>0</code>看作$-1$，<code>1</code>看作$+1$，然后求出这个序列的前缀和，看作是一条每次往右上或者右下的折线。由于<code>01</code>个数相等，每次选择的区间在折线上的两个端点高度必然相等。同时区间翻转可以看作将这一段折线中心对称，<code>01</code>互换可以看作上下翻转，因此这个操作对折线的影响本质是直接水平翻转这一段区间，也就是翻转一段前缀和。</p>
<p>最小化原序列的字典序等价于最小化前缀和的字典序，问题转化为给出一个序列，每次可以选择两个位置，满足这两个位置上的数相同，然后翻转它们构成的区间。</p>
<p>注意这个前缀和有一个性质：相邻两个数之差的绝对值必然为$1$。</p>
<p>记这个前缀和为$s_i$，对于两个相邻的位置$s_i,s_{i+1}$，我们让$s_i$这个数向$s_{i+1}$这个数连一条双向边。注意翻转操作并不会导致边的连接方式改变，因为翻转区间的首尾相同。</p>
<p>考虑直接确定最终的序列。假设当前已经确定的最后一个数是$x$（一开始为$0$），统计$x\rightarrow x+1$和$x\rightarrow x-1$有多少条边。如果存在到$x+1$的连边，并且到$x-1$的连边只有一条，那么此时只能走$x+1$。因为$x+1$必然只能由$x$或者$x+2$走一步得到，如果这次走了$x-1$，那么接下来想要得到$x+1$就必然需要回到$x$，而$x$到$x-1$的连边只有一条，显然不行。</p>
<p>因此，我们断言：如果$x$向$x-1$的连边至少有两条，或者不存在$x$向$x+1$的连边，那么当前位置可以放$0$，否则必须放$1$，同时删去这条经过的边。</p>
<p>这显然是必要条件，接下来我们证明一定存在一种操作的方案。</p>
<p>如果不存在向$x+1$的连边，只有向$x-1$的连边，那么前缀和必然为$x,x-1,x,x-1,\cdots$，此时直接将其还原回序列即可，即不需要进行任何操作。</p>
<p>否则，如果操作到这个位置时，$x$的下一个数恰好为$x-1$，那么我们可以不进行操作，直接跳到下一个数。</p>
<p>否则，$x$的下一个数为$x+1$，由于前缀和序列的性质，此时的序列必然为$x,x+1,\cdots, x+1,x,x-1,\cdots, x-1,x$。选择首尾的两个$x$翻转一次，就能把$x-1$翻转到下一个位置。</p>
<p>因此一定存在一种合法的操作方案。</p>
<h1 id="Latin-Square"><a href="#Latin-Square" class="headerlink" title="Latin Square"></a>Latin Square</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给出一个$n\times n$的矩阵，矩阵的每行每列都是一个排列，定义如下操作：</p>
<ul>
<li>$D$：将矩阵向下循环移动一次</li>
<li>$U$：将矩阵向上循环移动一次</li>
<li>$L$：将矩阵向左循环移动一次</li>
<li>$R$：将矩阵向右循环移动一次</li>
<li>$I$：将每行的排列变成其逆排列</li>
<li>$C$：将每列的排列变成其逆排列</li>
</ul>
<p>给出一个操作序列，问最终得到的矩阵。</p>
<h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>将矩阵的每个数看作一个三元组$(i,j,a_{i,j})$，表示矩阵的第$i$行$j$列为$a_{i,j}$。</p>
<p>可以发现所有操作要么相当于给这个三元组的某一维$+1,-1$，要么相当于交换某两维。</p>
<h1 id="Nim-Shortcuts"><a href="#Nim-Shortcuts" class="headerlink" title="Nim Shortcuts"></a>Nim Shortcuts</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>有两堆石子，两个人玩<code>nim</code>游戏，但是规定必败局面不止有$(0,0)$，还有给定的$m$个局面。多组询问，每次给出一个初始局面，问先手必胜还是必败。</p>
<script type="math/tex; mode=display">
q,m\leq 10^5,x_i,y_i\leq 10^9</script><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>如果$m=0$，那么当$x=y$时先手必败，可以看作是二维平面上一条$y=x$的射线。</p>
<p>否则，对于规定的这些必败点，这个点正上方和正右方的所有点都是必胜点。</p>
<p>考虑如何确定所有的必败点：$x$从小到大枚举，找到当前未确定状态的$y$最小的点，然后将这个点标为必败，将这个点正上方和正右方的所有点标为必胜。</p>
<p><img src="https://i.loli.net/2021/02/17/HSxJKBoew6Ql5Fp.png" alt=""></p>
<h1 id="Longest-Loose-Segment"><a href="#Longest-Loose-Segment" class="headerlink" title="Longest Loose Segment"></a>Longest Loose Segment</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>定义一个区间合法当且仅当$\max+\min&gt;len$。</p>
<p>给出一个序列，$m$次询问，每次会给出$k$个修改，每次修改交换某两个数，输出修改后的数组的最长合法区间。</p>
<script type="math/tex; mode=display">
n\leq 10^6, m\leq 30,\sum k\leq 10^6</script><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><p>修改是交换这个性质似乎是没用的，我们直接考虑如何$O(n)$地求出一个序列的答案。</p>
<p>考虑枚举这个序列的$\min$。单调栈求出每个数在哪个极长的区间里是最小值。假设当前枚举的最小值下标为$i$，对应的区间为$[l,r]$，问题转化为在$[l,r]$这个区间内找到一个数作为区间的$\max$，同时在满足$a_j+a_i&gt;j-i+1$的条件下最大化$a_j$。</p>
<p>观察发现这个限制其实是没用的。如果$a_j+a_i\leq j-i+1$，则意味着这个区间的长度最长只能取到$a_j+a_i$，无法同时包含$i$与$j$。注意到$i$是整个区间的最小值，我们可以直接令这个区间的右端点为$j$，此时这个区间的$\min$一定不小于$a_i$，同时这个区间必然合法。</p>
<p>问题转化为求一段区间的最大值。</p>
<h1 id="Assignment-Problem"><a href="#Assignment-Problem" class="headerlink" title="Assignment Problem"></a>Assignment Problem</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>给出一张完全二分图，左侧有$n$个点，右侧有$m$个点。</p>
<p>你不知道每条边的边权，但是对于右侧的每个点，你知道左侧的点与它连边的边权的大小关系。</p>
<p>对于左侧的每个点，判断是否存在一种合法的分配边权的方式，使得它存在于唯一的最大匹配中。</p>
<script type="math/tex; mode=display">
n\leq 1000,m\leq 11</script><h2 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h2><p>结论：对于任意一个最大匹配，一定存在右侧的一个点，这个点匹配了与它相连的边权最大的点。</p>
<p>因此我们可以枚举是右侧的哪个点匹配了边权最大的点，同时在左侧将这个点删去，删去之后的二分图仍然满足这个结论。</p>
<p>因此最大匹配只有$O(m!)$种，爆搜。</p>
<h1 id="Lockout-vs-tourist"><a href="#Lockout-vs-tourist" class="headerlink" title="Lockout vs tourist"></a>Lockout vs tourist</h1><h2 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h2><p>你和<code>tourist</code>要进行一场1v1的比赛，一共有$n$道题，由于只有两个人，因此每道题只会给最先通过这道题的人$a_i$分。</p>
<p>每次你和<code>tourist</code>会各自选择一道题开始写，你们不知道对方选的是哪道题。<code>tourist</code>非常强，如果你和他选了同一道题，那么他会比你先写完，并且得到这$a_i$分。接下来你们再重新各自选题。</p>
<p>如果你和<code>tourist</code>选的不是同一道题，那么你的机会就来了。你可以获得这道题的分数，但是看到你过了这道题之后<code>tourist</code>会进入疯狂模式，瞬间过掉所有剩下的题。</p>
<p>你想要最大化自己的得分，<code>tourist</code>想要最小化你的得分，双方都采取最优策略并且知道对方采取的是最优策略。问最终你的得分的期望。</p>
<script type="math/tex; mode=display">
n\leq 22, a_i\leq 10^9</script><h2 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h2><p>标准的双人零和博弈：我们可以认为如果你过了某道题，那么<code>tourist</code>的得分是$-a_i$，那么此时无论最终局面如何，两人获得的分数之和都将是$0$。</p>
<p>对于这种双人零和博弈，如果两人都采取最优策略，那么有一个结论是：问题等价于其中一个人先选择策略，然后另一个人看到这个人选择的策略之后再选。</p>
<p>于是我们可以当作<code>tourist</code>先选，然后你可以看到<code>tourist</code>的策略，再决定自己的策略。</p>
<p><code>tourist</code>的策略一定是给每道题分配一个$p_i$，表示选择这道题的概率。假设你最终选了第$i$道题，且$f_S$表示仅考虑$S$集合中的题目，你能获得的得分的期望。那么你此时得分的期望为</p>
<script type="math/tex; mode=display">
(1-p_i)a_i+p_if_{S-\{i\}}=a_i-p_i\times b_i</script><p>这里$b_i$是一个与$p_i$无关的确定常数。</p>
<p>你肯定会选择$a_i-p_i\times b_i$的最大值，那么<code>tourist</code>的目标就是合理地分配$p_i$，最小化这个最大值。</p>
<p>将所有题目按照$a_i$排序，可以求出将最大的$a_i$减到第二大的$a_i$所需要的$p_i$之和、将前两大的$a_i$减到第三大的$a_i$所需的$p_i$之和……，我们可以$O(n)$确定最优的$p_i$。</p>
<p>因此总时间复杂度$O(2^n\times n)$</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2021/04/22/4-21%E6%9D%82%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/22/4-21%E6%9D%82%E9%A2%98/" class="post-title-link" itemprop="url">4.21杂题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-22 20:47:55 / 修改时间：21:50:05" itemprop="dateCreated datePublished" datetime="2021-04-22T20:47:55+08:00">2021-04-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>由于难度差异较大，这篇题解里面只会写部分比较有意思的题。</p>
<h1 id="Nullify-The-Matrix"><a href="#Nullify-The-Matrix" class="headerlink" title="Nullify The Matrix"></a>Nullify The Matrix</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个$n\times m$的棋盘，第$i$行第$j$列的格子的权值为$a_{i,j}$，有两个人要玩游戏。每次当前玩家可以选择一个非零的格子，让这个格子减去一个正整数，但不能减到负数，同时选择一条从这个点到$(n,m)$的最短路径，将路径上的其它位置随意赋值。不能操作的那一方输。你需要判断先手必胜还是后手必胜。</p>
<script type="math/tex; mode=display">
n,m\leq 100,T\leq 10</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>注意到最短路径上每走一步都会从一条副对角线跨到与其相邻的另一条副对角线，这启发我们按照对角线来考虑。</p>
<p>依次考虑这张棋盘的每条副对角线。</p>
<p>如果我们仅考虑某条副对角线，将矩阵的其余部分完全忽略，那么它就变成了一个<code>nim</code>游戏，即每次当前玩家可以任选一堆棋子拿走至少一个，不能操作的玩家输。</p>
<p>加强一下这个游戏，考虑最靠左上的那条非全$0$的对角线，我们不妨假设它的编号为$i$，显然前$i-1$条对角线对游戏不会产生任何影响，接下来我们加入一条限制：每次当前玩家只能在第一条非全$0$的对角线上操作。</p>
<p>当一名玩家拿走第$i$条对角线的所有棋子，他一定可以决定$i+1$到$\min(n,m)$这些对角线的异或，即可以保证单独在这些对角线上进行<code>nim</code>游戏时先手必胜。这名玩家操作完毕之后，两个玩家开始轮流操作第$i+1$条对角线，由于之前这名玩家已经保证了先手必胜，因此这一条对角线最后操作的玩家仍然是他，他可以继续保持最后操作的优势。</p>
<p>因此，我们可以得出一个结论：<strong>对于这个简化版的游戏，先手获胜的条件是第一条非$0$的对角线异或和不为$0$</strong>。</p>
<p>接下来进一步加强这个游戏，考虑原问题。仍然假设第一条非$0$的对角线为$i$。</p>
<p>如果$i$满足异或和不为$0$，也就是在这条对角线上先手必胜，那么先手一开始可以选择这条对角线，接下来我们讨论后手的决策。</p>
<ul>
<li>如果后手操作第$i$条对角线，那么先手也操作这条对角线，最后必然可以使得这条对角线最后是由先手操作的。</li>
<li>如果后手操作其它的对角线，由于先手已经操作了一次第$i$条对角线，因此先手可以使得所有对角线上都是先手必胜。此时先手与后手在同一条对角线上继续操作，由于先手后操作，因此可以保证所有对角线仍然是先手必胜。</li>
</ul>
<p>因此，如果第$i$条对角线先手胜，则先手必胜。</p>
<p>如果第$i$条对角线后手必胜，那么先手一定不会操作它，我们不妨假设存在一条对角线$j$使得一开始这条对角线上先手必胜，我们讨论先后手的策略。</p>
<ul>
<li>先手一开始操作第$j$条对角线，使得$j+1$到$\min(n,m)$这些对角线都是先手必胜。</li>
<li>根据之前的讨论，后手一定不会选择$j$到$\min(n,m)$这些对角线操作，否则后手必败。</li>
<li>而$(i,j-1)$这些对角线上先手必败，而此时后手由于只能选择这些对角线，因此此时先后手翻转，先手采用之前的策略即可，因此先手必胜。</li>
</ul>
<p>如果所有对角线都是先手必败，那么只要先手操作一条对角线后手就跟着操作，可以使得最终先手必败。</p>
<p>因此这题的结论是：<strong>若存在一条对角线先手胜，则先手必胜</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> G[N][N], s[<span class="number">2</span> * N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;G[i][j]), s[i + j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) s[i + j] ^= G[i][j];</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n + m; i++) <span class="keyword">if</span> (s[i]) flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="built_in">puts</span>(<span class="string">"Ashish"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"Jeel"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="小Y的序列"><a href="#小Y的序列" class="headerlink" title="小Y的序列"></a>小Y的序列</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>来源：auoj1622</p>
<p>有一个序列$a$，定义一个位置$i$是好的当且仅当$i$前面有至少$k$个位置小于$a_i$。给定$n,m$，对于每个$k$求出所有每个数不超过$m$的序列中好的位置的个数之和。</p>
<script type="math/tex; mode=display">
n\leq 2\times 10^5, m\leq 10^9</script><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>考虑二项式反演。定义$g_i$表示所有数列中满足前面有恰好$i$个数小于它的位置的个数之和，那么答案就是$g_i$的后缀和。</p>
<p>$g_i$不是很好求，我们定义$f_i$表示在每个数前面钦定$i$个位置，这些位置都小于这个数的个数之和。</p>
<p>那么我们很容易写出$f_k$的表达式。</p>
<script type="math/tex; mode=display">
\begin{aligned}
f_k&=\sum_{i=1}^n\sum_{t=1}^m(t-1)^k{i-1\choose k}m^{n-1-k}\\
&=m^{n-1-k}\sum_{t=1}^m(t-1)^k\sum_{i=1}^n{i-1\choose k}\\
&=m^{n-1-k}{n\choose k+1}\sum_{t=1}^m(t-1)^k
\end{aligned}</script><p>前两项容易求出，而后面的东西是一个自然数幂和，这个东西比较麻烦。</p>
<p>回顾我们熟悉的自然数幂和求法，主要有以下几种（假设求$\sum_{i=1}^n i^k$）</p>
<ul>
<li>插值：这种做法适用于$k$不变的情况，但这道题中$k$是变化的。</li>
<li>斯特林数转下降幂：可以很方便地$O(k^2)$求出一个，但是很难优化。</li>
<li>伯努利数：适用于底数固定，指数变化的情况。</li>
</ul>
<p>因此我们选择伯努利数，它的式子是这样的：</p>
<p>记伯努利数的$EGF$为$B(x)$，则有$B(x)=\frac{x}{e^x-1}$。这个可以通过求逆快速求出。</p>
<p>有</p>
<script type="math/tex; mode=display">
\sum_{i=1}^ni^k=\frac{1}{k+1}\sum_{i=0}^k{k+1\choose i}B_{i}n^{k+1-i}</script><p>求出$f$之后我们有</p>
<script type="math/tex; mode=display">
\begin{aligned}
f_i&=\sum_{j\geq i}g_j{j\choose i}\\
g_i&=\sum_{j\geq i}f_i{j\choose i}(-1)^{j-i}
\end{aligned}</script><p>再跑一遍差卷积即可。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2021/04/19/4-17-%E6%9D%82%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/19/4-17-%E6%9D%82%E9%A2%98/" class="post-title-link" itemprop="url">4.17 杂题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-19 19:10:34 / 修改时间：21:43:31" itemprop="dateCreated datePublished" datetime="2021-04-19T19:10:34+08:00">2021-04-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="T1-Replicate-Replicate-Rfplicbte"><a href="#T1-Replicate-Replicate-Rfplicbte" class="headerlink" title="T1 Replicate Replicate Rfplicbte"></a>T1 Replicate Replicate Rfplicbte</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有一个细胞自动机，对于每个格子，如果它周围（包含它）$9$个格子中$1$的个数为奇数，那么它就会变成$1$，否则变成$0$。</p>
<p>但是在变换的过程中这个自动机有一定几率会出错，每一轮变换之后可能有至多一个格子翻转，你并不知道是哪个格子。现在给出一个状态，你需要求出最小的初始状态使得它有可能达到这个终止状态。</p>
<p>容易发现最小化初始状态的行数时列数也会达到最小值。</p>
<script type="math/tex; mode=display">
w,h\leq 300</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先考虑忽略变异的情况该怎么做。</p>
<p>容易发现每一回合这个自动机都会向外扩展一圈，那么我们可以知道这些格子在第$k-1$回合的时候必然全是$0$。那么我们可以从左上到右下通过第$k$回合每个位置的值倒推回第$k-1$回合。</p>
<p>具体来说，设$f_{i,j}$为第$k$回合的格子，$g_{i,j}$为第$k-1$回合的格子，当我们尝试计算$g_{i,j}$时，对于$i’\leq i,j’\leq j$的$g_{i’,j’}$，它已经计算完毕，因此我们可以通过$f_{i-1,j-1}$以及它周围除$i,j$以外的$8$个格子计算出$g_{i,j}$。</p>
<p>这时我们发现一件事情，由于第一行、最后一行、第一列、最后一列必然是$0$，我们没有用到这些地方的$f$。另外，这些位置的$g$也不需要计算，因此最后两行、两列的$f$是没有用到的。</p>
<p>考虑翻转一个$f$会对算出的$g$产生什么影响，我们可以画出这样一张图：</p>
<p><img src="4-17-杂题/image-20210419201109553.png" alt="image-20210419201109553"></p>
<p>左上角的$f$被翻转了，可以发现此时所有橙色格子计算出的$g$与实际上的$g$恰好相反。</p>
<p><img src="4-17-杂题/image-20210419204925997.png" alt="image-20210419204925997"></p>
<p>假设最后一行与最后一列为已经确定的$0$，那么可以发现黄色格子的$f$与当前计算出的$g$无法匹配，若最后一行或者最后一列恰好没有被翻转，那么倒数第二行或倒数第二列的黄色格子会无法匹配。</p>
<p>因此，只要我们找出所有失配的位置，对它们的$x$和$y$坐标分别取最小值，我们就能够得到变异的点的坐标。</p>
<p>将这个坐标的$f$翻转，重新计算$g$后再尝试找到变异点，如果仍然能找到变异点，说明变异的点不止一个，当前状态即为初始状态。</p>
<p>否则我们不断重复这个过程，直到行之差或者列之差小于等于$2$。</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> G[<span class="number">310</span>][<span class="number">310</span>], g[<span class="number">310</span>][<span class="number">310</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="function">P <span class="title">get</span><span class="params">(<span class="keyword">int</span> lx, <span class="keyword">int</span> rx, <span class="keyword">int</span> ly, <span class="keyword">int</span> ry)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span>(g));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lx + <span class="number">1</span>; i &lt; rx; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = ly + <span class="number">1</span>; j &lt; ry; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">2</span>; t++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt;= <span class="number">2</span>; p++) <span class="keyword">if</span> (t | p) g[i][j] ^= g[i - t][j - p];</span><br><span class="line">            g[i][j] ^= G[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function">P <span class="title">pos</span><span class="params">(rx + <span class="number">1</span>, ry + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> val = [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = G[i][j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">-1</span>; t &lt;= <span class="number">1</span>; t++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">-1</span>; p &lt;= <span class="number">1</span>; p++) res ^= g[i - t][j - p];</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lx; i &lt;= rx; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = ly; j &lt;= ry; j++)</span><br><span class="line">            <span class="keyword">if</span> (val(i, j)) pos.first = min(pos.first, i), pos.second = min(pos.second, j);</span><br><span class="line">    <span class="keyword">return</span> pos;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">310</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) G[i][j] = s[j] == <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lx = <span class="number">1</span>, rx = n, ly = <span class="number">1</span>, ry = m;</span><br><span class="line">    <span class="keyword">auto</span> fuck = [&amp;]() &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1e9</span>, b = <span class="number">-1e9</span>, c = <span class="number">1e9</span>, d = <span class="number">-1e9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lx; i &lt;= rx; i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = ly; j &lt;= ry; j++)</span><br><span class="line">                <span class="keyword">if</span> (G[i][j]) a = min(a, i), b = max(b, i), c = min(c, j), d = max(d, j);</span><br><span class="line">        lx = a, rx = b, ly = c, ry = d;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (; rx - lx &gt; <span class="number">1</span> &amp;&amp; ry - ly &gt; <span class="number">1</span>; <span class="built_in">memcpy</span>(G, g, <span class="keyword">sizeof</span>(g)), fuck()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> res = get(lx, rx, ly, ry);</span><br><span class="line">        <span class="keyword">if</span> (res.first == rx + <span class="number">1</span>) <span class="keyword">continue</span>; </span><br><span class="line">        G[res.first][res.second] ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">auto</span> tmp = get(lx, rx, ly, ry);</span><br><span class="line">        <span class="keyword">if</span> (tmp.first == rx + <span class="number">1</span>) <span class="keyword">continue</span>; </span><br><span class="line">        G[res.first][res.second] ^= <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lx; i &lt;= rx; i++, <span class="built_in">puts</span>(<span class="string">""</span>))</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = ly; j &lt;= ry; j++) <span class="built_in">putchar</span>(G[i][j] ? <span class="string">'#'</span> : <span class="string">'.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-Winding-polygonal-line"><a href="#T2-Winding-polygonal-line" class="headerlink" title="T2 Winding polygonal line"></a>T2 Winding polygonal line</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>平面上有$n$个点，给定一个长度为$n-2$的字符串$s$，$s$由<code>L</code>与<code>R</code>构成，你需要找到一种遍历所有点的方案，使得每次拐弯的方式与$s$相同。</p>
<script type="math/tex; mode=display">
n\leq 2000</script><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>找到$y$坐标最小的点，这个点一定在凸包上，我们从这个点开始出发。</p>
<p>每次拿出一段极长的<code>L</code>或者<code>R</code>。假设现在有$k$个<code>L</code>连在一起，那么对于前$k-1$步，我们找到偏离当前方向最小的点，对于第$k$步，找到偏离当前方向最大的点，这样看起来就非常优秀。<code>R</code>的构造与<code>L</code>类似。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[N], y[N], vis[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">cross</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)x1 * y2 - (LL)y1 * x2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">least1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cross(x[b] - x[a], y[b] - y[a], x[i] - x[a], y[i] - y[a]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pos) pos = i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cross(x[i] - x[b], y[i] - y[b], x[pos] - x[b], y[pos] - y[b]) &gt; <span class="number">0</span>) pos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">least2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cross(x[b] - x[a], y[b] - y[a], x[i] - x[a], y[i] - y[a]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pos) pos = i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cross(x[i] - x[b], y[i] - y[b], x[pos] - x[b], y[pos] - y[b]) &lt; <span class="number">0</span>) pos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">most1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cross(x[b] - x[a], y[b] - y[a], x[i] - x[a], y[i] - y[a]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pos) pos = i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cross(x[i] - x[b], y[i] - y[b], x[pos] - x[b], y[pos] - y[b]) &lt; <span class="number">0</span>) pos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">most2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cross(x[b] - x[a], y[b] - y[a], x[i] - x[a], y[i] - y[a]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pos) pos = i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cross(x[i] - x[b], y[i] - y[b], x[pos] - x[b], y[pos] - y[b]) &gt; <span class="number">0</span>) pos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> lst = <span class="number">1</span>, st = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">if</span> (y[i] &lt; y[lst]) lst = i;</span><br><span class="line">    vis[lst] = <span class="number">1</span>, res.push_back(lst);</span><br><span class="line">    <span class="keyword">double</span> mn = <span class="number">1e9</span>, mx = <span class="number">-1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (i != lst) &#123;</span><br><span class="line">        <span class="keyword">double</span> ang = <span class="built_in">atan2</span>(y[i] - y[lst], x[i] - x[lst]);</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">'L'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ang &lt; mn) mn = ang, st = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ang &gt; mx) mx = ang, st = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[st] = <span class="number">1</span>, res.push_back(st);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">2</span>; t &lt; n; t++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = st;</span><br><span class="line">        <span class="keyword">if</span> (s[t - <span class="number">1</span>] == s[t]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[t - <span class="number">1</span>] == <span class="string">'L'</span>) st = least1(lst, st);</span><br><span class="line">            <span class="keyword">else</span> st = least2(lst, st);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[t - <span class="number">1</span>] == <span class="string">'L'</span>) st = most1(lst, st);</span><br><span class="line">            <span class="keyword">else</span> st = most2(lst, st);</span><br><span class="line">        &#125; </span><br><span class="line">        lst = tmp, vis[st] = <span class="number">1</span>, res.push_back(st);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : res) <span class="keyword">if</span> (!t) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : res) <span class="built_in">printf</span>(<span class="string">"%d "</span>, t);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x[i], &amp;y[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>), solve();</span><br><span class="line">    <span class="comment">// puts("-1");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-Distinctification"><a href="#T3-Distinctification" class="headerlink" title="T3 Distinctification"></a>T3 Distinctification</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>有$n$个数对$(a_i,b_i)$，每次你可以选择一个数对，让它的$a_i$加一或者减一，但是需要满足如下条件：</p>
<ul>
<li>如果存在$j\neq i,a_i=a_j$，那么可以将$a_i$加一，花费$b_i$的代价。</li>
<li>如果存在$j\neq i, a_j=a_i-1$，那么可以将$a_i$减一，花费$-b_i$的代价。</li>
</ul>
<p>你希望使得最终所有$a_i$互不相同，且最小化花费的代价，容易发现这个代价可以是负的。你需要对于每个前缀求出这个最小的代价。</p>
<p>保证$b_i$互不相同。</p>
<script type="math/tex; mode=display">
n\leq 10^5</script><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>设$c_i$表示满足$a_j=i$的$j$的个数。</p>
<p>我们将极长的$[i,j]$使得$a\in [i,j]$均出现过成为一个连续段，容易发现最终每个连续段的左端点必然不变，右端点可以往外拓展。</p>
<p>具体来说，对于一段连续段$[i,j]$，它最终能够拓展到的区间为$[i,i+\sum_{k\in[i, j]} c_k]$。</p>
<p>如果某两端连续段拓展到的区间有交，那么最终这两个连续段必然会合并为一段。</p>
<p>对于一段连续段来说，最终它的最优状态必然是段内的所有数对按照$b_i$从大到小排序，这样花费的代价必然最小。</p>
<p>因此我们可以给每段开一棵线段树，以$b_i$为下标维护这个最小代价，合并两个连续段的时候就是线段树合并。</p>
<p>另外，我们需要开一个并查集维护连续段，每次在并查集上暴力向后跳，判断下一个连通块是否可以合并到当前连通块，容易发现这样的复杂度是$O(n\log n)$的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls, rs, sz; LL res, sum;</span><br><span class="line">&#125; T[N * <span class="number">32</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ncnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ls = T[rt].ls, rs = T[rt].rs;</span><br><span class="line">    T[rt].sum = T[ls].sum + T[rs].sum, T[rt].sz = T[ls].sz + T[rs].sz;</span><br><span class="line">    T[rt].res = T[ls].res + T[rs].res + (LL)T[rs].sz * T[ls].sum; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rt) rt = ++ncnt;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> T[rt].sum = T[rt].res = x, T[rt].sz = <span class="number">1</span>, <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) update(T[rt].ls, l, mid, x);</span><br><span class="line">    <span class="keyword">else</span> update(T[rt].rs, mid + <span class="number">1</span>, r, x);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x |= y, <span class="keyword">void</span>();</span><br><span class="line">    assert(l != r);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    merge(T[x].ls, T[y].ls, l, mid), merge(T[x].rs, T[y].rs, mid + <span class="number">1</span>, r), pushup(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rt[N], fa[N], sz[N]; LL res[N], sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : fa[x] = find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, f; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">auto</span> pos = s.upper_bound(a);</span><br><span class="line">        <span class="keyword">if</span> (pos == s.begin()) f = fa[a] = a, s.insert(a);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pos--;</span><br><span class="line">            <span class="keyword">if</span> (*pos + sz[*pos] &gt;= a) f = *pos;</span><br><span class="line">            <span class="keyword">else</span> f = fa[a] = a, s.insert(a);</span><br><span class="line">        &#125;</span><br><span class="line">        ans -= T[rt[f]].res, update(rt[f], <span class="number">1</span>, n, b), ans += T[rt[f]].res;</span><br><span class="line">        LL tmp = (LL)(a - f + <span class="number">1</span>) * b; ans -= tmp, res[f] += tmp, sz[f]++, sum[f] += b;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">233</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> nxt = f + sz[f];</span><br><span class="line">            <span class="keyword">if</span> (fa[nxt]) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = find(nxt);</span><br><span class="line">                ans -= T[rt[f]].res + T[rt[t]].res, merge(rt[f], rt[t], <span class="number">1</span>, n), ans += T[rt[f]].res;</span><br><span class="line">                ans += res[f] + res[t], sz[f] += sz[t], fa[t] = f, s.erase(t);</span><br><span class="line">                res[f] += res[t] + (LL)(t - f) * sum[t], sum[f] += sum[t], ans -= res[f];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T4-博弈"><a href="#T4-博弈" class="headerlink" title="T4 博弈"></a>T4 博弈</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p><img src="4-17-杂题/image-20210419213031935.png" alt="image-20210419213031935"></p>
<script type="math/tex; mode=display">
n\leq 2\times 10^5, m,k\leq 10^{18}</script><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>这道题正着做非常困难，考虑倒着递推。</p>
<p>我们称一个“终止状态”为一种分配方案，满足所有人都会同意这种方案。</p>
<p>显然，$n$个$0$是一个终止状态。考虑从这个状态往前推。</p>
<p>记录下当前提议的玩家编号，以及距离上一个终止状态剩余了多少金币可以分配（即每往前倒推一个玩家，金币数量$+k$）</p>
<p>如果当前剩余的金币数量$&lt;n$，那么无论如何分配，必然有一个人分配到的金币数量与下一个终止状态相同，那么根据题意这个人会否决提议。</p>
<p>如果当前剩余的金币数量$\geq n$，那么最优的策略必然是这个人给所有人分配一枚金币，然后将剩下的所有金币全部留给自己。</p>
<p>因此我们得到了一个$80$分暴力：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">int</span> turn = (m + k - <span class="number">1</span>) / k, pos = turn % n + <span class="number">1</span>, all = <span class="number">0</span>, tmp = m % k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = turn + <span class="number">1</span>, nw = <span class="number">0</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nw &gt;= n) num[pos] += nw - n, all++, nw = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos == <span class="number">1</span>) pos = n; <span class="keyword">else</span> pos--;</span><br><span class="line">        <span class="keyword">if</span> (nw &lt; tmp) nw = tmp, tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> nw += k;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, num[i] + all);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑优化这个暴力，可以发现两个终止状态中间相隔的轮数是一个定值（最后一次除外），而终止状态中分配的玩家是循环的，且由于只有$n$个人，因此循环节大小至多为$n$。</p>
<p>我们可以快速算出最终一共循环了多少次，对于边角则暴力处理，代码细节比较多。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line">LL num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; LL m, k; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">auto</span> get = [&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> t) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = ((a - t) % n + n) % n;</span><br><span class="line">        <span class="keyword">return</span> res ? res : n;</span><br><span class="line">    &#125;;</span><br><span class="line">    LL turn = m / k + <span class="number">1</span>, pos = (turn - <span class="number">1</span>) % n + <span class="number">1</span>, tmp = m % k, step = (n + k - <span class="number">1</span>) / k;</span><br><span class="line">    LL first = (n - tmp + k - <span class="number">1</span>) / k;</span><br><span class="line">    <span class="keyword">int</span> t = get(pos, first);</span><br><span class="line">    <span class="keyword">if</span> (first * k + tmp &lt;= m) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) num[i]++;</span><br><span class="line">    num[t] += tmp + first * k - n, pos = get(t, step);</span><br><span class="line">    <span class="keyword">if</span> ((first + step) * k + tmp &gt; m) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, num[i]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL delta = step * k - n, all = ((m - tmp) / k - first) / step;</span><br><span class="line">    <span class="built_in">vector</span>&lt;LL&gt; fuck = &#123;pos&#125;; LL nw = pos; </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">233</span>) &#123;</span><br><span class="line">        nw = get(nw, step);</span><br><span class="line">        <span class="keyword">if</span> (nw == pos) <span class="keyword">break</span>;</span><br><span class="line">        fuck.push_back(nw);</span><br><span class="line">    &#125;</span><br><span class="line">    LL hh = all / fuck.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : fuck) num[t] += delta * hh;</span><br><span class="line">    <span class="keyword">for</span> (LL nw = pos, t = hh * fuck.size() + <span class="number">1</span>; t &lt;= all; t++) &#123;</span><br><span class="line">        num[nw] += delta;</span><br><span class="line">        nw = ((nw - step) % n + n) % n;</span><br><span class="line">        <span class="keyword">if</span> (nw == <span class="number">0</span>) nw = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, num[i] + all);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2021/04/15/4-14-%E6%9D%82%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/15/4-14-%E6%9D%82%E9%A2%98/" class="post-title-link" itemprop="url">4.14 杂题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-15 21:06:39 / 修改时间：21:33:46" itemprop="dateCreated datePublished" datetime="2021-04-15T21:06:39+08:00">2021-04-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="T1-CNF2"><a href="#T1-CNF2" class="headerlink" title="T1 CNF2"></a>T1 CNF2</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有$n$个<code>bool</code>变量$b$和$m$条限制，第$i$条限制为$a_{i,1}|a_{i,2}|\cdots|a_{i, k}$，这里$a_{i,x}$可能为$b_t$或$\neg b_t$。记第$i$条限制得到的值为$v_i$，你需要求出一组解满足$v_1\and v_2\and\cdots\and v_k=1$或判断无解。</p>
<p>保证每个变量和其相反变量出现次数的和不超过$2$，在一条限制中至多出现一次。</p>
<script type="math/tex; mode=display">
n, m\leq 2\times 10^5</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>做法一：用类似<code>Dijkstra</code>的方法，将所有限制按照剩余的未确定的变量个数从小到大排序，优先取较小的，然后将其涉及的第一个未确定的变量确定下来，同时更新包含这个变量的相反变量的限制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N], ans[N], ct[N], vis[N], bl[<span class="number">2</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m), <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> k; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k), ct[i] = k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, a; j &lt;= k; j++) </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), p[i].push_back(a), bl[a &lt; <span class="number">0</span>][<span class="built_in">abs</span>(a)] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;P&gt; q; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) q.push(P(-ct[i], i));</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.top().second; q.pop();</span><br><span class="line">        <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>; vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!ct[u]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>), <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t : p[u]) <span class="keyword">if</span> (ans[<span class="built_in">abs</span>(t)] == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = t &lt; <span class="number">0</span>; t = <span class="built_in">abs</span>(t);</span><br><span class="line">            ans[t] = cur; <span class="keyword">int</span> nxt = bl[cur ^ <span class="number">1</span>][t];</span><br><span class="line">            <span class="keyword">if</span> (nxt &amp;&amp; !vis[nxt]) ct[nxt]--, q.push(P(-ct[nxt], nxt)); </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">if</span> (ans[i] == <span class="number">1</span>) <span class="built_in">putchar</span>(<span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">'1'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做法二：对于每个变量，我们将其看作一条边，将所有限制看作点。如果这个变量及其相反变量都在限制中出现过，那么将这两个限制连接起来，否则连一个自环。问题转化为每次可以选择一条边的一个端点标记，需要使得最终所有点都被标记。</p>
<p>对于一个连通块来讲，如果它是树那么肯定不合法，因为边数小于点数。</p>
<p>否则一定存在一种方案。具体来说，我们随便找出一条非树边，选择它的其中一个端点作为根，从根出发找到一棵不经过这条边的生成树。对于生成树上的每条边，选择它的儿子标记，对于选中的这条边，选择根标记。这样可以使得每个点都被标记过。</p>
<h1 id="T3-Son-of-Pipe-Stream"><a href="#T3-Son-of-Pipe-Stream" class="headerlink" title="T3 Son of Pipe Stream"></a>T3 Son of Pipe Stream</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给出一张无向图，每条边有其流量限制$w_i$。$1$号点流入一种叫做<code>Flubber</code>的液体，$2$号点流入水，它们的共同汇点是$3$。给定$v$，对于每条边<code>Flubber</code>的流量$\times v$加上水的流量不能超过$w_i$。记最终<code>Flubber</code>的总流量为$F$，水的流量为$W$，给定$a$，你需要最大化$F^aW^{1-a}$。</p>
<p>如果一条边同时有<code>Flubber</code>与水的流量，那么它们流的方向不能相同。输出方案。</p>
<script type="math/tex; mode=display">
n\leq 200</script><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>首先从$1$号点和$2$号点开始分别跑一遍最大流，记它们的流量分别为$F’,W’$。接着建一个超级源点，同时向这两个点连边，记此时的最大流为$S$。</p>
<p>有一个定理是对于$a,b$，如果满足$a\leq 1, b\leq 1$且$F’a+W’b\leq S$，那么一定存在一个最大流满足其流量恰好为$F’a+W’b$，且它由$F’a$的<code>Flubber</code>与$W’b$的水组成。</p>
<p>不妨令$F’a+W’b=S$，根据简单的求导可以求出，当$F^aW^{1-a}$取得最大值时有$\frac FW=\frac{a}{1-a}$。</p>
<p>考虑怎么构造方案。</p>
<p>将超级源点连向$1$的边的容量改为$F’a$，将连向$2$的边容量改为$W’b$，跑一遍最大流。然后仅保留最大流上的那些边，并且将它们改为单向边，容量为最大流中的流量。</p>
<p>接着从$1$出发，在新图上跑一个大小为$F’a$的流，可以发现此时最大流扣去这个$F’a$的流就得到了一个从$2$开始，流量为$W’b$的流。且这样构造可以使得每条边中两种液体的流向是相同的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">210</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N * N * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next; <span class="keyword">double</span> w;</span><br><span class="line">&#125; e[M], e2[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], cur[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> w)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = &#123; to, head[from], w &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = &#123; from, head[to], w &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde1</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> w)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = &#123; to, head[from], w &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = &#123; from, head[to], <span class="number">0</span> &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dep[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dep)), dep[s] = <span class="number">0</span>; <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; q.push(s);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">            <span class="keyword">if</span> (e[i].w &gt; eps &amp;&amp; dep[e[i].to] == <span class="number">-1</span>) &#123;</span><br><span class="line">                dep[e[i].to] = dep[u] + <span class="number">1</span>, q.push(e[i].to);</span><br><span class="line">                <span class="keyword">if</span> (e[i].to == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">double</span> f, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == t || f &lt; eps) <span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">0</span>, tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].w &amp;&amp; dep[e[i].to] == dep[u] + <span class="number">1</span> &amp;&amp; (tmp = DFS(e[i].to, min(f, e[i].w), t)) &gt; eps) &#123;</span><br><span class="line">            res += tmp, e[i].w -= tmp, e[i ^ <span class="number">1</span>].w += tmp, f -= tmp;</span><br><span class="line">            <span class="keyword">if</span> (f &lt; eps) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (BFS(s, t)) <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span>(head)), res += DFS(s, <span class="number">1e9</span>, t);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> from[M], to[M], w[M], rev[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="keyword">double</span> v, a; <span class="built_in">scanf</span>(<span class="string">"%d%d%lf%lf"</span>, &amp;n, &amp;m, &amp;v, &amp;a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;from[i], &amp;to[i], &amp;w[i]);</span><br><span class="line">    <span class="keyword">auto</span> reset = [&amp;]() &#123;</span><br><span class="line">        ecnt = <span class="number">1</span>, <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) adde(from[i], to[i], w[i]); </span><br><span class="line">    &#125;;</span><br><span class="line">    reset(); <span class="keyword">double</span> F = dinic(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    reset(); <span class="keyword">double</span> W = dinic(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    reset(), adde1(n + <span class="number">1</span>, <span class="number">1</span>, <span class="number">1e9</span>), adde1(n + <span class="number">1</span>, <span class="number">2</span>, <span class="number">1e9</span>); <span class="keyword">double</span> A = dinic(n + <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">double</span> F1 = A * a; F1 = min(F1, F), F1 = max(F1, A - W);</span><br><span class="line">    reset(), adde1(n + <span class="number">1</span>, <span class="number">1</span>, F1), adde1(n + <span class="number">1</span>, <span class="number">2</span>, A - F1), dinic(n + <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(e2, e, <span class="keyword">sizeof</span>(e)), ecnt = <span class="number">1</span>, <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e2[i * <span class="number">2</span>].w &gt; w[i]) adde1(to[i], from[i], e[i * <span class="number">2</span>].w - w[i]), rev[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> adde1(from[i], to[i], w[i] - e2[i * <span class="number">2</span>].w);</span><br><span class="line">    &#125; </span><br><span class="line">    adde1(n + <span class="number">1</span>, <span class="number">1</span>, F1), dinic(n + <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">double</span> t1 = e[i * <span class="number">2</span> + <span class="number">1</span>].w / v, t2 = e[i * <span class="number">2</span>].w;</span><br><span class="line">        <span class="keyword">if</span> (rev[i]) t1 = -t1, t2 = -t2;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.10lf %.10lf\n"</span>, t1 + eps, t2 + eps);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.10lf\n"</span>, <span class="built_in">pow</span>(F1, a) * <span class="built_in">pow</span>(A - F1, <span class="number">1</span> - a) / <span class="built_in">pow</span>(v, a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2021/04/12/4-9%E6%9D%82%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/12/4-9%E6%9D%82%E9%A2%98/" class="post-title-link" itemprop="url">4.9杂题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-12 08:21:56 / 修改时间：16:28:02" itemprop="dateCreated datePublished" datetime="2021-04-12T08:21:56+08:00">2021-04-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="T1-Inverter-SwapSort"><a href="#T1-Inverter-SwapSort" class="headerlink" title="T1 Inverter SwapSort"></a>T1 Inverter SwapSort</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个排列，求出所有逆序对的一个排列，使得依次交换每一对数最终能使得整个数组有序。</p>
<script type="math/tex; mode=display">
n\leq 1000</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑每次找到关于一个位置的所有逆序对。</p>
<p>将最后一个位置拿出来，观察前面的所有数与它形成的逆序对。假设最后一个数为$x$，那么可以发现依次交换$x+1,x+2,\cdots$不会对前面的数的相对顺序造成影响，且可以将最大的数挪到结尾。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N], pos[N], buk[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]), v.push_back(A[i]);</span><br><span class="line">    sort(v.begin(), v.end()), v.resize(unique(v.begin(), v.end()) - v.begin());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        A[i] = lower_bound(v.begin(), v.end(), A[i]) - v.begin() + <span class="number">1</span>;</span><br><span class="line">        buk[A[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) buk[i] += buk[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) A[i] = buk[A[i]]--;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) pos[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) <span class="keyword">if</span> (A[j] &gt; A[i]) </span><br><span class="line">            pos[A[j]] = j;</span><br><span class="line">        <span class="keyword">int</span> lst = A[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = lst + <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span> (pos[j]) </span><br><span class="line">            swap(A[pos[j]], A[i]), res.push_back(make_pair(pos[j], i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : res) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, t.first, t.second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-Blog-Post-Rating"><a href="#T2-Blog-Post-Rating" class="headerlink" title="T2 Blog Post Rating"></a>T2 Blog Post Rating</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>有一个一开始为空的序列，每次你会给序列插入一个元素，然后将整个序列从小到大排序。</p>
<p>现在你手里有一个值$x$，它一开始为$0$，你从小到大查看序列中的每个元素，如果当前元素比$x$大，那么让$x+1$，如果比$x$小，那么让$x-1$，否则保持不变。你需要回答每次插入之后这个值最终会变成多少。</p>
<script type="math/tex; mode=display">
n\leq 5\times 10^5,|a_i|\leq 5\times 10^5</script><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>考虑给定一个序列，如何计算$x$最终的值。</p>
<p>假设现在这个序列已经排好序了，且第$i$个位置的数是$a_i$。</p>
<p>如果$x$在第$i$个位置恰好等于$a_i$，那么显然最终的$x$不能超过$a_i+n-i$。并且容易发现最终的$x$就是$a_i+n-i$的最小值。</p>
<p>加入了修改操作之后，考虑建一棵值域线段树，那么每次修改相当于给一段后缀的排名加上$1$，同时我们需要维护$a_i+n-i$的最小值。</p>
<p>$x$从$0$开始比较恶心，观察到$x$的变化必然是一开始一直减，直到小于或等于当前的数，然后再要么不变，要么$+1$。</p>
<p>二分这个拐点，那么这个拐点必须满足$-i\leq a_i$，即查询$a_i+i\geq 0$的第一个位置，并且可以得出，$x$在这个位置的值为$\max(-i,a_i)$。</p>
<p>假设拐点的位置为$j$，那么我们只需查询$j$之后的数的$a_i+n-i$的最小值，并对此时的$x+n-j$取$\min$即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, tag, x, y;</span><br><span class="line">&#125; T[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    T[rt].x = min(T[rt &lt;&lt; <span class="number">1</span>].x, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].x);</span><br><span class="line">    T[rt].y = max(T[rt &lt;&lt; <span class="number">1</span>].y, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T[rt].tag) <span class="keyword">return</span>;</span><br><span class="line">    T[rt &lt;&lt; <span class="number">1</span>].x -= T[rt].tag, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].x -= T[rt].tag;</span><br><span class="line">    T[rt &lt;&lt; <span class="number">1</span>].y += T[rt].tag, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].y += T[rt].tag;</span><br><span class="line">    T[rt &lt;&lt; <span class="number">1</span>].tag += T[rt].tag, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].tag += T[rt].tag;</span><br><span class="line">    T[rt].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    T[rt].l = l, T[rt].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> T[rt].x = T[rt].y = l, <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span>, l, mid), build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r), pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> T[rt].tag++, T[rt].x--, T[rt].y++, <span class="keyword">void</span>();</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, start, end);</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, start, end);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (T[rt].y &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1e9</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">if</span> (T[rt &lt;&lt; <span class="number">1</span>].y &gt;= <span class="number">0</span>) <span class="keyword">return</span> find(rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> find(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l) <span class="keyword">return</span> T[rt].x;</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">if</span> (start &gt; mid) <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, start);</span><br><span class="line">    <span class="keyword">return</span> min(T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].x, query(rt &lt;&lt; <span class="number">1</span>, start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tree[N], mn, mx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (x -= mn - <span class="number">1</span>; x &lt;= mx - mn + <span class="number">1</span>; x += x &amp; -x) tree[x]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">que</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (x -= mn - <span class="number">1</span>; x; x -= x &amp; -x) res += tree[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), mn = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a; i &lt;= n; i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), v.push_back(a), mn = min(mn, a), mx = max(mx, a);</span><br><span class="line">    build(<span class="number">1</span>, mn, mx);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = v[i - <span class="number">1</span>]; update(<span class="number">1</span>, a, <span class="number">1e9</span>), upd(a);</span><br><span class="line">        <span class="keyword">int</span> pos = find(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos == <span class="number">-1e9</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, -i);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> t = que(pos), tmp = max(pos, -t) + i - t, res = query(<span class="number">1</span>, pos) + i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, min(tmp, res));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-咕"><a href="#T3-咕" class="headerlink" title="T3 咕"></a>T3 咕</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>来源：auoj471</p>
<p>一个随机排列，你从第一个位置走到第$n$个位置，每走一步你可以得知当前数是否是前缀最小值，你可以选择是否拿走这个数，问在最优策略下你拿走$1$的概率。多组数据。</p>
<script type="math/tex; mode=display">
T\leq 10^5,n\leq 10^6</script><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>最优策略必然是：你选择一个位置$x$，然后扔掉$x$及之前的所有数，在$x$之后取走第一个为前缀最小值的位置。</p>
<p>写成$dp$的形式就是，记$f_i$表示已经扔掉了前$i-1$个数，此时在第$i$个数时开始决策，最后拿走$1$的概率。</p>
<p>第$i$个位置为前缀最小值的概率为$\frac 1i$，在是前缀最小值的条件下为$1$的概率为$\frac in$。</p>
<p>因此我们可以得出转移：</p>
<script type="math/tex; mode=display">
f_i=\frac 1i\max(\frac in,f_{i+1})+\frac {i-1}if_{i+1}</script><p>转移里的$\max$非常讨厌，尝试去掉这个东西。</p>
<p>如果$f_{i+1}&gt;\frac in$，那么有$f_i=\frac 1i f_{i+1}+\frac{i-1}if_{i+1}=f_{i+1}$。因此我们只需找到第一个$\frac in&gt;f_{i+1}$的位置，容易发现满足这个条件的必然是一段后缀。</p>
<p>当$\frac in$取到最大值时，有</p>
<script type="math/tex; mode=display">
f_i=\frac 1n+\frac {i-1}if_{i+1}</script><p>记$g_i=nf_i$，那么$g_i=1+\frac {i-1}ig_{i+1}$，显然有$g_{n+1}=0$，那么有</p>
<script type="math/tex; mode=display">
\begin{aligned}
g_n&=1\\
g_{n-1}&=1+\frac{n-2}{n-1}\\
g_{n-2}&=1+\frac{n-3}{n-2}+\frac{n-3}{n-1}\\
&\vdots\\
g_i&=(i-1)\sum_{j=i-1}^{n-1}\frac 1j
\end{aligned}</script><p>后面是一个调和级数，可以预处理调和级数的后缀和，每次二分出第一个$\frac in&gt;f_{i+1}$的位置即可。</p>
<p>另外，这个位置约等于$\frac ne$，也可以用一些奇妙的方法求出这个断点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> e = <span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> wkr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T), inv[<span class="number">1</span>] = frac[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N - <span class="number">10</span>; i++) inv[i] = (LL)(mod - mod / i) * inv[mod % i] % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N - <span class="number">10</span>; i++) wkr[i] = wkr[i - <span class="number">1</span>] + <span class="number">1.</span> / i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N - <span class="number">10</span>; i++) inv[i] = (inv[i - <span class="number">1</span>] + inv[i]) % mod, frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123; <span class="built_in">puts</span>(<span class="string">"1"</span>); <span class="keyword">continue</span>; &#125; </span><br><span class="line">        <span class="keyword">int</span> pos = round(n / e + <span class="number">1</span> - <span class="number">0.5</span> / e), res;</span><br><span class="line">        <span class="keyword">if</span> (wkr[n - <span class="number">1</span>] - wkr[pos - <span class="number">2</span>] &lt; <span class="number">1</span>) pos--;</span><br><span class="line">        res = (LL)(pos - <span class="number">1</span>) * (inv[n - <span class="number">1</span>] - inv[pos - <span class="number">2</span>] + mod) % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL)res * (inv[n] - inv[n - <span class="number">1</span>] + mod) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T4-function"><a href="#T4-function" class="headerlink" title="T4 function"></a>T4 function</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>定义$P(x)$表示满足$1&lt;y&lt;x,y^3\equiv 1\pmod x$的$y$的数量，求在$n$以内有多少正整数满足$P(x)=m$。</p>
<script type="math/tex; mode=display">
n\leq 2\times 10^{10},m<n</script><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>把条件放宽为$1\leq y&lt;x$，先考虑给定一个$x$，如何快速地求出$P(x)$。</p>
<p>显然$x$的每个质因子都可以分开考虑，最后用中国剩余定理合并就可以还原，因此条件等价于：将$x$分解为$\prod p_i^{c_i}$，只需对每个$p_i$都满足$y^3\equiv 1\pmod {p^{c_i}}$。</p>
<p>如果条件满足，那么显然$y$与$p$互质，因此有</p>
<script type="math/tex; mode=display">
\begin{aligned}
y^3&\equiv 1\pmod {p^c}\\
y^3&\equiv y^{\varphi(p^c)}\pmod {p^c}\\
1&\equiv y^{\varphi(p^c)\bmod 3}\pmod {p^c}
\end{aligned}</script><p>容易得出当$3\nmid \varphi(p^c)$时满足条件的$y$只有$1$。</p>
<p>我们有$\varphi(p^c)=(p-1)p^{c-1}$，只需考虑$p=3$或者$3\mid p-1$，且当$p=3,c=1$时是不行的。</p>
<p>设原根为$g$，则阶为$\varphi(p^c)$。不妨设$y=g^k$，由于$y\bot p$，因此这样的$k$一定存在。</p>
<p>故条件转化为</p>
<script type="math/tex; mode=display">
g^{3k}\equiv g^0\pmod {p^c}</script><p>即$3k\equiv 0\pmod {\varphi(p^c)}$。</p>
<p>同时除以$3$，有$k\equiv 0\pmod{\frac {\varphi(p^c)}3}$</p>
<p>因此满足条件的$k$只有$3$个，即$y^3\equiv 1\pmod {p^c}$的解只有$3$个。</p>
<p>因此有</p>
<script type="math/tex; mode=display">
P(x)+1=3^{\sum_{p_i^{c_i}}[p_i=3\and c>1]\or[p_i\bmod 3=1]}</script><p>注意到需要求出$\bmod 3=1$的质数的个数，定义$f(x)=\begin{cases}0&amp;3|x\\1&amp;3|x-1\-1&amp;3|x-2\end{cases}$，筛出$f$以及$n$以内的质数个数就可以解出$\bmod 3=1$的质数个数，而这两个东西都是完全积性的。</p>
<p>使用<code>min25</code>筛的变种即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag[N], prime[N], tot, sum[N], wkr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag[i]) &#123;</span><br><span class="line">            prime[++tot] = i, sum[tot] = sum[tot - <span class="number">1</span>], wkr[tot] = wkr[tot - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">1</span>) sum[tot]++, wkr[tot]++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">2</span>) sum[tot]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; j++) &#123;</span><br><span class="line">            flag[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL val[<span class="number">2</span> * N], g[<span class="number">2</span> * N], p[<span class="number">2</span> * N], n; <span class="comment">// g[i][j]: 1 ~ i, s(n) &gt; p_j</span></span><br><span class="line"><span class="keyword">int</span> id1[N], id2[N], lim;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt;= lim ? id1[x] : id2[n / x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array&lt;LL, 10&gt; S(LL n, int m) &#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; n &lt;&lt; ' ' &lt;&lt; m &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">array</span>&lt;LL, 10&gt; nw; nw.fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; prime[m]) <span class="keyword">return</span> nw;</span><br><span class="line">    <span class="comment">// if (((g[get(n)] + p[get(n)]) % 2 + 2) % 2 != 1) cout &lt;&lt; "FUCK: " &lt;&lt; n &lt;&lt; endl;</span></span><br><span class="line">    LL A = (g[get(n)] + p[get(n)] - <span class="number">1</span>) / <span class="number">2</span> - wkr[m - <span class="number">1</span>];</span><br><span class="line">    nw[<span class="number">1</span>] = A, nw[<span class="number">0</span>] = p[get(n)] - (m - <span class="number">1</span>) - A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt;= tot &amp;&amp; (LL)prime[i] * prime[i] &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (LL j = prime[i], c = <span class="number">1</span>; j * prime[i] &lt;= n; j *= prime[i], c++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = (prime[i] == <span class="number">3</span> &amp;&amp; c &gt; <span class="number">1</span>) || prime[i] % <span class="number">3</span> == <span class="number">1</span>;</span><br><span class="line">            nw[prime[i] % <span class="number">3</span> != <span class="number">2</span>]++; <span class="keyword">auto</span> tmp = S(n / j, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (t) rotate(tmp.begin(), tmp.end() - <span class="number">1</span>, tmp.end());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) nw[k] += tmp[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL m; <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;m), m++;</span><br><span class="line">    <span class="keyword">int</span> ct = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m % <span class="number">3</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span>;</span><br><span class="line">        m /= <span class="number">3</span>, ct++; </span><br><span class="line">    &#125;</span><br><span class="line">    lim = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(n)), sieve(lim); <span class="keyword">int</span> blk = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (LL l = <span class="number">1</span>; l &lt;= n; l = n / (n / l) + <span class="number">1</span>) &#123;</span><br><span class="line">        LL t = n / l;</span><br><span class="line">        blk++, val[blk] = t;</span><br><span class="line">        <span class="keyword">if</span> (t &lt;= lim) id1[t] = blk; <span class="keyword">else</span> id2[n / t] = blk;</span><br><span class="line">        g[blk] = (t % <span class="number">3</span> == <span class="number">1</span>) - <span class="number">1</span>, p[blk] = t - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= blk &amp;&amp; (LL)prime[i] * prime[i] &lt;= val[j]; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = get(val[j] / prime[i]);</span><br><span class="line">            <span class="keyword">if</span> (prime[i] % <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = prime[i] % <span class="number">3</span> == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">                g[j] -= t * (g[pos] - sum[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            p[j] -= p[pos] - (i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">auto</span> res = S(n, <span class="number">1</span>); res[<span class="number">0</span>]++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res[ct]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2021/04/09/4-8%E7%9A%84%E4%B8%80%E4%BA%9B%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/09/4-8%E7%9A%84%E4%B8%80%E4%BA%9B%E9%A2%98/" class="post-title-link" itemprop="url">4.8的一些题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-09 19:54:35" itemprop="dateCreated datePublished" datetime="2021-04-09T19:54:35+08:00">2021-04-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-12 08:20:46" itemprop="dateModified" datetime="2021-04-12T08:20:46+08:00">2021-04-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="T1-Escape-Route"><a href="#T1-Escape-Route" class="headerlink" title="T1 Escape Route"></a>T1 Escape Route</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>来源：JOI2021 Day2T1</p>
<p>有一张无向图，每条边有边权$L_i,C_i$。一天共有$S$个时刻，这些时刻被编号为$0\sim S-1$。每天开始时所有道路都会打开，但是第$i$条道路从时刻$C_i$开始会关闭，然后第二天会重新开放。你需要花费$L_i$的时间通过第$i$条道路，并且通过的过程中道路不能关闭，也就是说你必须在$0\sim C_i-L_i$这些时刻才能走第$i$条边。多组询问，每次给定$U,V,T$，表示从$U$在第一天的第$T$个时刻出发，询问到达$V$的最小时刻。第二天的第$0$时刻等于总的第$S$时刻，以此类推。</p>
<script type="math/tex; mode=display">
N\leq 90,M\leq \frac {N(N-1)}2,S\leq 10^{15},L_i,C_i< S</script>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/04/09/4-8%E7%9A%84%E4%B8%80%E4%BA%9B%E9%A2%98/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2021/01/29/Topcoder%E4%B8%93%E9%A2%983/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/29/Topcoder%E4%B8%93%E9%A2%983/" class="post-title-link" itemprop="url">Topcoder专题3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-29 20:04:24 / 修改时间：20:47:25" itemprop="dateCreated datePublished" datetime="2021-01-29T20:04:24+08:00">2021-01-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="A-DiagonalColumn"><a href="#A-DiagonalColumn" class="headerlink" title="A DiagonalColumn"></a>A DiagonalColumn</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>一个$n\times m$的网格，一开始所有格子都是白色的，你可以进行若干次操作。每次操作你选择一列或者一条从左上到右下的对角线，然后将这条线上的所有格子都染黑。（对角线一共有$n+m-1$条）。问最后有多少种可能的染色方案。</p>
<script type="math/tex; mode=display">
n, m\leq 38</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>想了一早上。</p>
<p>我们先考虑右上角的这个格子。</p>
<p><img src="Topcoder专题3/image-20210129201150129.png" alt="image-20210129201150129"></p>
<p>如果这个格子所在的对角线选了，那么这一列选不选对这个格子最终的颜色并没有影响。此时我们可以直接将这个格子删去，对网格剩下的部分求出方案数。</p>
<p>否则，这个格子一定是白色（否则我们可以当作选了对角线处理），此时这个格子所在的列一定没有被选，考虑这些对角线</p>
<p><img src="Topcoder专题3/image-20210129201721340.png" alt="image-20210129201721340"></p>
<p>由于最后一列没有选，因此这些对角线是否选择会在最后一列的格子中反应出来，即如果这些对角线选择的方案不同，最后的染色方案也一定不同。</p>
<p>考虑更一般的问题：对于下面这个多边形：</p>
<p><img src="Topcoder专题3/image-20210129202306251.png" alt="image-20210129202306251"></p>
<p>考虑最靠右上的这条对角线：如果这条对角线选，那么线上的格子可以删去，接下来是子问题。</p>
<p>否则，第$i$列及之后的列是否选择都会在这条对角线上反应出来，并且这些列不能全部选。此时一定存在最靠前的一列没有被选，我们记这一列为$j$。</p>
<p>注意，此时$[i,j)$这些列全部被选，$(j,m]$这些列可选可不选。</p>
<p>考虑在$j$之后的那些对角线，这些对角线是否选择也能在第$j$列反应出来。如果这些对角线全部选，那么矩形将只留下由第$j-1$条对角线以及第$i-1$列包围的部分，这是子问题。</p>
<p>否则，又有一些列的状态会在某条对角线上反应出来，继续考虑会导致这种“反应”一直嵌套下去，这启发我们重新设计状态。</p>
<p>考虑这样一个状态：记$dp[i][j][k]$表示考虑由第$k$条对角线与第$i$列围成的多边形，其中第$j$列到第$i$列选择方案不同则视为最终方案不同的染色方案数。</p>
<p>此时$dp[m][m+1][n+m-1]$就是答案。</p>
<p>接下来考虑如何转移。</p>
<p><img src="Topcoder专题3/image-20210129203826809.png" alt="image-20210129203826809"></p>
<p>当$j=i+1$时：</p>
<p>如果$k$这条对角线选，转移到$dp[i][j][k-1]$。</p>
<p>否则，$k$对下来的列到第$i$列不能同时选，容斥掉这种情况，接着第$k-n+1$列到第$i$列是否选都会在这条对角线上反应出来，转移到$dp[i][k-n+1][k-1]$。</p>
<p>当$j\leq i$时：</p>
<p>先判掉第$j$列到第$i$列全选的情况，此时这些列可以全部删掉。</p>
<p>否则，一定存在某一列没有被选，枚举这一列，不妨设为$l$。</p>
<p>$l$以上的对角线是否选择都会在第$l$列反应出来，判掉这些对角线全选的情况，此时这些对角线和$j$列之后都可以删掉。</p>
<p>接着枚举最靠下的没有被选的这条对角线，假设为$t$，此时第$t-n+1$列到第$j-1$列是否被选会在这条对角线上反应出来，这恰好可以用我们的$dp$状态表示，转移到$dp[j-1][t-n+1][l-1]$。</p>
<p><a href="https://paste.ubuntu.com/p/DjGM5HG7M3/" target="_blank" rel="noopener">代码</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://planarg.top/2021/01/29/1-24-%E8%80%83%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/77041874_p0_master12001.jpg">
      <meta itemprop="name" content="PlanarG">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PlanarG's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/29/1-24-%E8%80%83%E8%AF%95/" class="post-title-link" itemprop="url">1.24 考试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-29 19:03:13 / 修改时间：20:01:20" itemprop="dateCreated datePublished" datetime="2021-01-29T19:03:13+08:00">2021-01-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">考试</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="T1-Power"><a href="#T1-Power" class="headerlink" title="T1 Power"></a>T1 Power</h1><p><img src="1-24-考试/image-20210129190609220.png" alt="image-20210129190609220"></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/01/29/1-24-%E8%80%83%E8%AF%95/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="PlanarG"
      src="/images/77041874_p0_master12001.jpg">
  <p class="site-author-name" itemprop="name">PlanarG</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">207</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">66</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://planarg.top/" title="https:&#x2F;&#x2F;planarg.top&#x2F;">Title</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">PlanarG</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1.5,"jsonPath":"/live2dw/assets/histoire.model.json"},"display":{"position":"left","width":150,"height":300,"hOffset":35,"vOffset":-25},"mobile":{"show":false},"log":false});</script></body>
</html>
