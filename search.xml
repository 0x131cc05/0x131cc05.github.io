<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>4.7联测</title>
      <link href="/2020/04/08/47-lian-ce/"/>
      <url>/2020/04/08/47-lian-ce/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-ZSY家今天的饭"><a href="#T1-ZSY家今天的饭" class="headerlink" title="T1 ZSY家今天的饭"></a>T1 ZSY家今天的饭</h1><p>一棵$n$个节点的树，树上有$m$个节点有餐厅，现在会随机地在这$m$个节点中选择$k$个节点放东西。你可以从树上任意一个节点出发，然后沿着边走，从任意一个节点离开。问要吃完这$k$个节点的东西，期望下最短要走多远</p><script type="math/tex; mode=display">n\leq 10^5, k\leq m\leq 500, w_i\leq 10^9</script><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>显然最优的路径一定是这$k$个点的虚树抠掉直径走两次，直径走一次</p><p>因此我们可以将答案拆成两个部分计算：虚树大小的期望，以及直径长度的期望</p><p>对于虚树，我们可以考虑对于这棵树上的每条边，它出现在虚树中的概率是多少</p><p>统计这条边两侧餐厅的数量，这个概率很好计算</p><p>对于直径，我们可以考虑枚举直径是啥。如果一棵树有多条直径，那么我们就让这条直径的第一个端点尽量小，在第一个端点尽量小的前提下再让第二个端点尽量小，这样就可以避免重复计数</p><p>预处理出这$m$个餐厅两两之间的路径长度，然后枚举直径，统计有多少个点可能出现即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[<span class="number">510</span>], inv[<span class="number">510</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from], w &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to], w &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL dis[N]; <span class="keyword">int</span> dep[N], fa[N][<span class="number">17</span>], res, sz[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mark[N], n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    dep[u] = dep[f] + <span class="number">1</span>, dis[u] = dis[f] + w, fa[u][<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">17</span>; i++) fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    sz[u] = mark[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) </span><br><span class="line">            dfs(e[i].to, u, e[i].w), sz[u] += sz[e[i].to];</span><br><span class="line">    <span class="keyword">int</span> t = C(m, k) - C(sz[u], k) - C(m - sz[u], k); t = (t % mod + mod) % mod;</span><br><span class="line">    res = (res + (LL)t * w * <span class="number">2</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[a] &lt; dep[b]) swap(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">16</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (dep[fa[a][i]] &gt;= dep[b]) a = fa[a][i];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">16</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i];</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Dis</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dis[a] + dis[b] - <span class="number">2</span> * dis[LCA(a, b)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL G[<span class="number">510</span>][<span class="number">510</span>]; <span class="keyword">int</span> pos[<span class="number">510</span>]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pos[i]), mark[pos[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b, c; i &lt; n; i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c), adde(a, b, c);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= m; j++) </span><br><span class="line">            G[i][j] = G[j][i] = Dis(pos[i], pos[j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            LL tmp = G[i][j]; <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; k++) <span class="keyword">if</span> (k != i &amp;&amp; k != j) &#123;</span><br><span class="line">                LL a = G[k][i], b = G[k][j];</span><br><span class="line">                <span class="keyword">if</span> (a &lt; tmp &amp;&amp; b &lt; tmp) &#123; tot++; <span class="keyword">continue</span>; &#125; </span><br><span class="line">                <span class="keyword">if</span> (a &gt; tmp || b &gt; tmp) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (a == tmp &amp;&amp; k &lt; j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (b == tmp &amp;&amp; k &lt; i) <span class="keyword">continue</span>;</span><br><span class="line">                tot++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = (res - tmp % mod * C(tot, k - <span class="number">2</span>)) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    res = (LL)(res + mod) * Pow(C(m, k), mod - <span class="number">2</span>) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-划愤"><a href="#T2-划愤" class="headerlink" title="T2 划愤"></a>T2 划愤</h1><p>不会<code>Nim</code>积/kel</p><p><img src="1586351569726.png" alt=""></p><p><img src="1586351597589.png" alt=""></p><p><img src="1586351621606.png" alt=""></p><p><img src="1586351721981.png" alt=""></p><h1 id="T3-树上的鼠"><a href="#T3-树上的鼠" class="headerlink" title="T3 树上的鼠"></a>T3 树上的鼠</h1><p>考虑这样一个游戏：有一棵树，一开始$1$号节点有一棵棋子，先手后手轮流移动这枚棋子，先手第一次必须挪动这枚棋子至少一步，之后每个人挪动的距离都必须严格大于上一个人挪动的距离，不能挪动的那一方输</p><p>问对于给出的树，有多少个包含$1$号节点的连通块使得如果在这个连通块上进行游戏，先手必胜</p><script type="math/tex; mode=display">n\leq 10^6</script><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>首先考虑对于一棵确定的树，如何判断先手是否必胜</p><p>先考虑最简单的情况：一条链</p><p>接下来我们认为一条链的长度为这条链上经过的点数</p><p>如果这条链的长度是奇数，并且$1$号节点不是正中间那个点，那么先手第一步可以将这枚棋子挪到这个点上，然后后手怎么挪先手就跟他对称地挪</p><p>否则，无论$1$号节点的位置在哪里，先手只需要将其挪到最靠近正中间的两个点之一，然后就又可以开始对称地挪了</p><p>因此我们可以得到这样一个结论：先手必败当且仅当$1$号节点是直径的中点</p><p>可以发现这个结论也可以拓展到树上</p><p>问题转化为：统计有多少个连通块，使得$1$号点不是直径的中点</p><p>如果我们知道了$1$号点每棵子树深度恰为$j$的连通块的方案数，那么我们就可以枚举最深的那棵子树是啥，然后强制让其它子树的深度小于这棵子树的深度</p><p>设$dp[i][j]$表示以$i$为根的子树，有多少个深度为$j$的连通块，这里我们认为必须选$i$，并且$i$的深度为$0$</p><p>这个定义看起来就很长链剖分，类似于希望的做法，我们对于$dp$数组同时维护一个后缀积，然后合并两棵子树的时候暴力下放需要用到的信息的标记</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from] &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to] &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> F[N * <span class="number">10</span>], G[N * <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> st[N], len[N], tot, son[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) &#123;</span><br><span class="line">            dfs(e[i].to, u);</span><br><span class="line">            <span class="keyword">if</span> (len[e[i].to] &gt;= len[son[u]]) </span><br><span class="line">                son[u] = e[i].to, len[u] = len[e[i].to] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    st[u] = tot, tot += len[u] + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len[u]; i++) G[st[u] + i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= l; j++) &#123;</span><br><span class="line">        pre = (LL)pre * G[st[u] + j] % mod;</span><br><span class="line">        F[st[u] + j] = (LL)F[st[u] + j] * pre % mod, G[st[u] + j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l != len[u]) G[st[u] + l + <span class="number">1</span>] = (LL)G[st[u] + l + <span class="number">1</span>] * pre % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!son[u]) <span class="keyword">return</span> F[st[u]] = G[st[u]] = <span class="number">1</span>, <span class="keyword">void</span>();</span><br><span class="line">    st[son[u]] = st[u] + <span class="number">1</span>, dfs1(son[u], u), G[st[u]] = F[st[u]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f &amp;&amp; e[i].to != son[u]) &#123;</span><br><span class="line">            apply(e[i].to), dfs1(e[i].to, u); <span class="keyword">static</span> <span class="keyword">int</span> tmp[N];</span><br><span class="line">            <span class="comment">// if (u == 2) cout &lt;&lt; "to: " &lt;&lt; e[i].to &lt;&lt; endl;</span></span><br><span class="line">            pushdown(u, len[e[i].to] + <span class="number">1</span>), pushdown(e[i].to, len[e[i].to]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len[e[i].to] + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                tmp[j] = F[st[u] + j];</span><br><span class="line">                <span class="comment">// cout &lt;&lt; F[st[u] + j] &lt;&lt; ' ';</span></span><br><span class="line">                <span class="keyword">if</span> (j) tmp[j] = (tmp[j - <span class="number">1</span>] + tmp[j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">1</span>; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len[e[i].to]; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> a = ((LL)tmp[j + <span class="number">1</span>] * F[st[e[i].to] + j] + (LL)F[st[u] + j + <span class="number">1</span>] * sum) % mod;</span><br><span class="line">                sum = (sum + F[st[e[i].to] + j]) % mod, F[st[u] + j + <span class="number">1</span>] = a;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; sum &lt;&lt; ' ' &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (len[u] != len[e[i].to] + <span class="number">1</span>) </span><br><span class="line">                G[st[u] + len[e[i].to] + <span class="number">2</span>] = (LL)G[st[u] + len[e[i].to] + <span class="number">2</span>] * sum % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// pushdown(u, len[u]);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; "at: " &lt;&lt; u &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt;= len[u]; i++) cout &lt;&lt; F[st[u] + i] &lt;&lt; ' ';</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fuck[N], suf[N], tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) suf[i] = tag[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[<span class="number">1</span>]; i; i = e[i].next) &#123;</span><br><span class="line">        apply(e[i].to), dfs1(e[i].to, <span class="number">1</span>), pushdown(e[i].to, len[e[i].to]);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; e[i].to &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// for (int j = 0; j &lt;= len[e[i].to]; j++)</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; F[st[e[i].to] + j] &lt;&lt; ' ';</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">        F[st[e[i].to]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len[e[i].to]; j++) </span><br><span class="line">            F[st[e[i].to] + j] = (F[st[e[i].to] + j] + F[st[e[i].to] + j - <span class="number">1</span>]) % mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len[e[i].to]; j++) tag[j] = (LL)tag[j] * F[st[e[i].to] + j] % mod;</span><br><span class="line">        suf[len[e[i].to]] = (LL)suf[len[e[i].to]] * F[st[e[i].to] + len[e[i].to]] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, pre = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        pre = (LL)pre * suf[i] % mod;</span><br><span class="line">        fuck[i] = (LL)tag[i] * pre % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[<span class="number">1</span>]; i; i = e[i].next) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len[e[i].to]; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = j ? fuck[j - <span class="number">1</span>] : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (j) t = (LL)t * Pow(F[st[e[i].to] + j - <span class="number">1</span>], mod - <span class="number">2</span>) % mod;</span><br><span class="line">            <span class="keyword">int</span> delta = F[st[e[i].to] + j];</span><br><span class="line">            <span class="keyword">if</span> (j) delta -= F[st[e[i].to] + j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> delta--; </span><br><span class="line">            res = (res + (LL)delta * t) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res = (res + mod) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 博弈 </tag>
            
            <tag> 长链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.31联测T1 简单数学题</title>
      <link href="/2020/04/05/331-lian-ce-t1-jian-dan-shu-xue-ti/"/>
      <url>/2020/04/05/331-lian-ce-t1-jian-dan-shu-xue-ti/</url>
      
        <content type="html"><![CDATA[<p>给定非负整数$x$，质数$p$，求最小的非负整数$n$，使得$f_n\equiv x \pmod p$</p><p>其中$f_n$是斐波那契数列，$f_0 = 0, f_1 = 1, f_i = f_{i-1} + f_{i - 2}$</p><p>保证$p$的个位数为$1$或$9$，多组数据</p><script type="math/tex; mode=display">p\leq 2\times 10^9, T\leq 100, x<p</script><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>通过解特征方程可以得出斐波那契数列的通项公式是</p><script type="math/tex; mode=display">f_n = \frac{1}{\sqrt 5}\left[\left(\frac{1 + \sqrt 5}{2}\right)^n - \left(\frac{1 - \sqrt 5}{2}\right)^n\right]</script><p>有一个结论就是当$p$的个位为$1$或$9$时$5$的二次剩余一定存在</p><p>解出$5$的二次剩余，无论是$\sqrt 5$还是$-\sqrt 5$都无关紧要，因为将$-\sqrt 5$代入原式可以发现值不会变</p><p>设$T = \frac{1 + \sqrt{5}}{2}$，然后让$x$乘上$\sqrt 5$，问题转化为解</p><script type="math/tex; mode=display">T^n - \left(\frac{-1}{T}\right)^n \equiv x \pmod p</script><p>对于$n$是奇数和偶数的情况分别讨论，以$n$是奇数的情况为例</p><script type="math/tex; mode=display">\begin{aligned}T^n + \frac{1}{T^n} &\equiv x &\pmod p\\T^n &\equiv \frac{x \pm \sqrt{x^2 - 4}}{2} &\pmod p\end{aligned}</script><p>解出$T^k \equiv 1\pmod p$，假如$n$是原方程的一个解，那么$n+k$也是原方程的一个解</p><p>如果$k$是奇数，且$n$是偶数，那么我们可以得到一个$n$是奇数的解</p><p><code>BSGS</code>即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mod;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">42899</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashMap</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt; buff[SZ]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = x % SZ;</span><br><span class="line">    buff[t].push_back(P(x, y)), pos.push_back(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = x % SZ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : buff[t]) <span class="keyword">if</span> (v.first == x) <span class="keyword">return</span> v.second;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : pos) buff[t].clear();</span><br><span class="line">    pos.clear();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125; s;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sol;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">BSGS</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">bool</span> flag = <span class="number">1</span>)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (B == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag &amp;&amp; B % mod == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; s.clear();</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(mod)), ls = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++, ls = (LL)ls * A % mod)</span><br><span class="line">        s.insert((LL)B * ls % mod, i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, t = ls; i &lt;= mod; i += m, t = (LL)t * ls % mod) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = s.query(t);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="number">-1</span>) <span class="keyword">return</span> i - res;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fuck;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">BSGS1</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = BSGS(A, B);</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    sol.push_back(a);</span><br><span class="line">    <span class="keyword">if</span> (fuck != <span class="number">-1</span> &amp;&amp; fuck % <span class="number">2</span> == <span class="number">1</span>) sol.push_back(a + fuck);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Cipolla</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Pow(x, (mod - <span class="number">1</span>) / <span class="number">2</span>) != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> a = rand() % mod;</span><br><span class="line">    <span class="keyword">while</span> (Pow(((LL)a * a - x + mod) % mod, (mod - <span class="number">1</span>) / <span class="number">2</span>) != mod - <span class="number">1</span>) a = rand() % mod;</span><br><span class="line">    <span class="keyword">int</span> t = ((LL)a * a - x + mod) % mod; </span><br><span class="line">    <span class="keyword">auto</span> mul = [&amp;](P a, P b) -&gt; P &#123;</span><br><span class="line">        <span class="keyword">int</span> A = ((LL)a.first * b.first + (LL)a.second * b.second % mod * t) % mod;</span><br><span class="line">        <span class="keyword">int</span> B = ((LL)a.first * b.second + (LL)a.second * b.first) % mod;</span><br><span class="line">        <span class="keyword">return</span> P(A, B);</span><br><span class="line">    &#125;;</span><br><span class="line">    P res = P(<span class="number">1</span>, <span class="number">0</span>), tmp = P(a, <span class="number">1</span>); <span class="keyword">int</span> y = (mod + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, tmp = mul(tmp, tmp)) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = mul(res, tmp);</span><br><span class="line">    <span class="keyword">return</span> res.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> inv2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> T, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A = Cipolla(((LL)x * x + <span class="number">4</span>) % mod), B = Cipolla(((LL)x * x - <span class="number">4</span> + mod) % mod), res = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; T &lt;&lt; ' ' &lt;&lt; x &lt;&lt; ' ' &lt;&lt; A &lt;&lt; ' ' &lt;&lt; B &lt;&lt; endl;</span></span><br><span class="line">    fuck = BSGS(T, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (A != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = (LL)(x + A) * inv2 % mod, b = (LL)(x - A + mod) * inv2 % mod;</span><br><span class="line">        sol.clear(), BSGS1(T, a), BSGS1(T, b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t : sol) <span class="keyword">if</span> (t % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="number">-1</span>) res = t;</span><br><span class="line">            res = min(res, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (B != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = (LL)(x + B) * inv2 % mod, b = (LL)(x - B + mod) * inv2 % mod;</span><br><span class="line">        sol.clear(), BSGS1(T, a), BSGS1(T, b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t : sol) <span class="keyword">if</span> (t % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="number">-1</span>) res = t;</span><br><span class="line">            res = min(res, t); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> sqrt5)</span> </span>&#123;</span><br><span class="line">    x = (LL)x * sqrt5 % mod; <span class="keyword">int</span> T = (LL)(sqrt5 + <span class="number">1</span>) * inv2 % mod;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; T &lt;&lt; ' ' &lt;&lt; (LL)(mod - 1) * Pow(T, mod - 2) % mod &lt;&lt; ' ' &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> solve(T, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen("ex_data2.in", "r", stdin), freopen("out.out", "w", stdout);</span></span><br><span class="line">    srand((LL)<span class="keyword">new</span> <span class="keyword">char</span>);</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;x, &amp;mod), inv2 = (mod + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> sqrt5 = Cipolla(<span class="number">5</span>); sqrt5 = min(sqrt5, mod - sqrt5);</span><br><span class="line">        <span class="keyword">int</span> A = solve1(x, sqrt5), B = <span class="comment">/*solve1(x, mod - sqrt5)*/</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="number">-1</span> || B == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, max(A, B));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, min(A, B));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二次剩余 </tag>
            
            <tag> BSGS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.4联测 by ZJK</title>
      <link href="/2020/04/05/44-lian-ce-by-zjk/"/>
      <url>/2020/04/05/44-lian-ce-by-zjk/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-Permutation"><a href="#T1-Permutation" class="headerlink" title="T1 Permutation"></a>T1 Permutation</h1><p>有一棵$n$个点的树，每条边有一个权值$v_i$</p><p>统计有多少个长度为$n$的排列$p$满足</p><p>将路径 $(p_1,p_2)$上的所有边值减$1$，然后将路径 $(p_2,p_3)$ 上的所有边值减$1$，…，将 $(p_{n−1},p_n)$ 上所有边值减$1$，将 $(p_n,p_1)$ 上所有边减$1$之后，每条边的值都是$0$</p><p>保证至少存在一个排列满足条件</p><script type="math/tex; mode=display">n\leq 5000</script><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑对于一个确定的排列，一条被会被减多少次</p><p>对于树上的任意一条边来说，它的两个端点一个是祖先，一个是儿子。我们称儿子所在的子树中的所有点都为白点，剩下的点都为黑点</p><p>将整个排列看作一个环，环上有一些黑点，有一些白点。为了方便起见，我们钦定$1$号点为环的起点</p><p>我们将一段极长的同色段称为连续段，那么可以考虑这样$dp$：对于$u$，我们只考虑$u$子树中的点在最终排列中的相对顺序，统计它们形成了多少段连续段，一个连续段最终排列中一定相邻，然后每次合并两个儿子</p><p>考虑断环为链，如果$u$不是$1$号点，其与父亲的连边权值为$v$，那么$u$的子树中的所有点会形成$\frac{v}{2}$个连续段</p><p>考虑合并两棵子树的时候会发生什么，假如第一棵子树有$a$个连续段，第二棵子树有$b$个连续段，那么把它们合并起来之后一共有$a+b$个连续段。注意此时我们已经断环为链了，因此接下来我们讨论的都是链上的情况</p><p>在这$a+b$个连续段中，有些连续段是可以合起来的，但是每一段合起来的连续段中，相邻的两段不能来自同一棵子树</p><p>考虑容斥，枚举每棵子树有多少段连续段在缩完之后相邻，强制将这些位置缩在一起，然后$dp$即可</p><p>由于我们钦定了$1$为环的起点，因此最后的方案数要乘上$n$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from], w &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to], w &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N], C[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> fuck)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u, e[i].w);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> F[N]; <span class="built_in">memset</span>(F, <span class="number">0</span>, <span class="keyword">sizeof</span>(F)), F[u != <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].w / <span class="number">2</span>; <span class="keyword">static</span> <span class="keyword">int</span> G[N];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= t + v; j++) G[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= t; j++) </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= v; k++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = (LL)F[j] * C[v - <span class="number">1</span>][k - <span class="number">1</span>] % mod * inv[k] % mod;</span><br><span class="line">                    <span class="keyword">if</span> ((v - k) &amp; <span class="number">1</span>) G[j + k] = (G[j + k] + mod - tmp) % mod;</span><br><span class="line">                    <span class="keyword">else</span> G[j + k] = (G[j + k] + tmp) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= t + v; j++) F[j] = G[j];</span><br><span class="line">            t += v;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = fuck / <span class="number">2</span>; i &lt;= t; i++) </span><br><span class="line">        ans = (ans + (LL)C[i - <span class="number">1</span>][fuck / <span class="number">2</span> - <span class="number">1</span>] * frac[i] % mod * F[i]) % mod;</span><br><span class="line">    res = (LL)res * ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;mod), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b, c; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c), adde(a, b, c);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            C[i][j] = C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (C[i][j] &gt;= mod) C[i][j] -= mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (LL)res * n % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-LCM-game"><a href="#T2-LCM-game" class="headerlink" title="T2 LCM game"></a>T2 LCM game</h1><p>一个长度为$k$的序列，序列中的每个数都在$[1,n]$之间</p><p>你需要求出$n^k$种序列的$\mathrm{lcm}$的和与乘积</p><script type="math/tex; mode=display">n\leq 500, k\leq 100</script><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>首先乘积是很好求的，我们对于每一个质因子分别考虑，枚举下一个数填啥，然后只需要考虑最后$\mathrm{lcm}$中这个质数的指数即可</p><p>需要注意的是由于最终$dp$的值需要拿到指数上，因此需要对$\mathrm{mod}-1$取模</p><p>对于第一问，有一个显然的想法是设$dp[i][j]$表示已经填了$i$个数，$\mathrm{lcm}$为$j$的方案数</p><p>注意到当$n$比较小的时候，所有可能的$\mathrm{lcm}$的数量不大，因此可以压状态，即对于每个可能出现的质因子记录这个质因子的次数</p><p>部分暴力代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flag[N], prime[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> G[N][N], G1[N][N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag[i]) prime[++tot] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; j++) &#123;</span><br><span class="line">            flag[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ct = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (tmp % prime[j] == <span class="number">0</span>) tmp /= prime[j], ct++;</span><br><span class="line">            G[j][ct]++, G1[i][prime[j]] = ct;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[M][<span class="number">30</span>], k, f[N][<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">if_n_is_ssssssssssssssmall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">30</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> p[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c[] = &#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>&#125;;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">10000</span>; j++) <span class="keyword">if</span> (f[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">int</span> buk[<span class="number">20</span>]; <span class="keyword">int</span> tmp = j;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--) buk[i] = tmp % c[i], tmp /= c[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">                <span class="keyword">static</span> <span class="keyword">int</span> nw[<span class="number">20</span>]; <span class="keyword">int</span> code = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= <span class="number">9</span>; l++) nw[l] = max(G1[k][p[l]], buk[l]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= <span class="number">9</span>; l++) code = code * c[l] + nw[l];</span><br><span class="line">                f[i][code] = (f[i][code] + f[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">10000</span>; j++) <span class="keyword">if</span> (f[k][j]) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> buk[<span class="number">20</span>]; <span class="keyword">int</span> tmp = j, nw = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--) buk[i] = tmp % c[i], tmp /= c[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) nw = (LL)nw * Pow(p[i], buk[i]) % mod;</span><br><span class="line">        res = (res + (LL)nw * f[k][j]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑优化这个过程，其中一个瓶颈在于合并两个$\mathrm{lcm}$，可以发现这是一个类似于$\max$卷积的东西</p><p>如果用类似<code>FWT</code>的方法，求出两个$dp$的高维前缀和，那么就可以直接对高维前缀和点值相乘，然后再<code>IFWT</code>回去</p><p>OIwiki上对高维前缀和解释得很清楚</p><p><img src="https://sr7h8m.coding-pages.com//post-images/1586090124846.png" alt=""></p><p>然后实现出来这是一个类似于<code>FFT</code>的东西，部分代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">encode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> base[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> code = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dimension; i++) </span><br><span class="line">        code *= up[i], code += base[i];</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nw = dimension, step = <span class="number">1</span>; nw &gt;= <span class="number">1</span>; step *= up[nw--]) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum; i += step * up[nw])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + step * (up[nw] - <span class="number">1</span>); j += step)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; step; k++)</span><br><span class="line">                    Inc(a[j + k + step], a[j + k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IFWT</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nw = dimension, step = <span class="number">1</span>; nw &gt;= <span class="number">1</span>; step *= up[nw--]) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum; i += step * up[nw])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + step * (up[nw] - <span class="number">2</span>); j &gt;= i; j -=  step)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; step; k++)</span><br><span class="line">                    Dec(a[j + k + step], a[j + k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里<code>a[i]</code>表示$\mathrm{lcm}$在压缩之后为$i$的方案数</p><p>直接上<code>FWT</code>对$dp$进行优化，可以获得$68$分的好成绩</p><p>考虑进一步优化</p><p>我们将所有质数分为两类：大于$\sqrt n$的和小于等于$\sqrt n$的</p><p>对于大于$\sqrt n$的那些质数，他们在某个数的所有质因子中最多出现一次</p><p>我们按照最大质因子的大小将所有数分为为$A,B$，那么最后的$\mathrm{lcm}$一定可以被表示成$\mathrm{lcm}(\mathrm{lcm}_{i\in A} i, \mathrm{lcm}_{j\in B}j)$的形式</p><p>由于$A$中的质数在每个数的质因子中至多出现一次，因此我们考虑枚举这个质数。设$f_{i,j,k}$表示考虑了大于等于$i$的那些质数，我们选择了$j$个含有这其中的某个质数的数，$B$中质因子的$\mathrm{lcm}$为$k$的所有方案的权值之和</p><p>转移的时候，设$g_{i,j,k}$表示只考虑$[1,i]$的数，填了$j$个位置，$\mathrm{lcm}$为$k$的方案数</p><p>对于每个大于$\sqrt n$的质数$p$，最大质因子为$p$的数为$2p, 3p, \cdots$，给这些数都除上$p$，就能用$g$转移了。如果此次填的数多余一个，那么还要乘上一个$p$的权值，因为$p$也是最终所有数的$\mathrm{lcm}$的因数</p><p>最后再用$f_{\sqrt n+ 1}$和$B$中的数合并即可，转移的时候使用<code>FWT</code>优化</p><p>需要注意的是，转移和合并的时候的状态是不一样的，因为转移的时候每个数不大于$\sqrt n$，而最终合并的时候每个数都是$O(n)$级别。前者的状态数小于$1000$，而后者的状态数大约有$70000$</p><p>这样可以获得$84$分的好成绩</p><p>继续考虑如何优化，注意到有很多$p$的$\lfloor\frac{n}{p}\rfloor$是相同的，也就是说它们转移时所用的$g$的状态也是相同的，我们将这些$p$归为一类，一起转移</p><p>具体地，设$h_{i,j}$表示考虑长度为$i$的序列，每个元素都在$[1,j]$之间，且每种数都出现过的方案数</p><p>然后枚举当前这一类质数有多少个数出现，填了多少个位置，再算出从这些$p$中选出$i$个相乘的和即可</p><p>我最后只改了$84$分，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123; x += y, x -= x &gt;= mod ? mod : <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dec</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123; x -= y, x += x &lt; <span class="number">0</span> ? mod : <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">int</span> t = x + y; <span class="keyword">return</span> t &gt;= mod ? t - mod : t; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">int</span> t = x - y; <span class="keyword">return</span> t &lt; <span class="number">0</span> ? t + mod : t; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag[N], prime[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> G[N][N], G1[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag[i]) prime[++tot] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; j++) &#123;</span><br><span class="line">            flag[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ct = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (tmp % prime[j] == <span class="number">0</span>) tmp /= prime[j], ct++;</span><br><span class="line">            G[j][ct]++, G1[i][prime[j]] = ct;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> task1 &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dimension, lim, sum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> up[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> type = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    lim = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(n)), sum = <span class="number">1</span>; <span class="keyword">int</span> hh = n;</span><br><span class="line">    <span class="keyword">if</span> (!type) hh = lim;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prime[i] &gt; lim) <span class="keyword">break</span>;</span><br><span class="line">        dimension = i, up[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = hh; </span><br><span class="line">        <span class="keyword">while</span> (tmp /= prime[i]) up[i]++; </span><br><span class="line">        sum *= up[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">encode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> base[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> code = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dimension; i++) </span><br><span class="line">        code *= up[i], code += base[i];</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getLCM</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = dimension; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = code % up[i]; code /= up[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t; j++) res = (LL)res * prime[i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(<span class="keyword">int</span> code, <span class="keyword">int</span> result[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = dimension; i &gt;= <span class="number">1</span>; i--) </span><br><span class="line">        result[i] = code % up[i], code /= up[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">unpack</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> result[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dimension; i++) &#123;</span><br><span class="line">        result[i] = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">while</span> (n % prime[i] == <span class="number">0</span>) n /= prime[i], result[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nw = dimension, step = <span class="number">1</span>; nw &gt;= <span class="number">1</span>; step *= up[nw--]) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum; i += step * up[nw])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + step * (up[nw] - <span class="number">1</span>); j += step)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; step; k++)</span><br><span class="line">                    Inc(a[j + k + step], a[j + k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IFWT</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nw = dimension, step = <span class="number">1</span>; nw &gt;= <span class="number">1</span>; step *= up[nw--]) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum; i += step * up[nw])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + step * (up[nw] - <span class="number">2</span>); j &gt;= i; j -=  step)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; step; k++)</span><br><span class="line">                    Dec(a[j + k + step], a[j + k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g[i][j][k]: [1, i]的数，选j个，lcm为k</span></span><br><span class="line"><span class="keyword">int</span> g[<span class="number">80</span>][M][<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve_g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lim; i++) &#123;</span><br><span class="line">        g[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; sum; l++) <span class="keyword">if</span> (g[i][j - <span class="number">1</span>][l]) &#123;</span><br><span class="line">                <span class="keyword">static</span> <span class="keyword">int</span> buk[<span class="number">60</span>]; decode(l, buk);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> nw = <span class="number">1</span>; nw &lt;= i; nw++) &#123;</span><br><span class="line">                    <span class="keyword">static</span> <span class="keyword">int</span> hh[<span class="number">60</span>];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= dimension; t++) </span><br><span class="line">                        hh[t] = max(G1[nw][prime[t]], buk[t]);</span><br><span class="line">                    Inc(g[i][j][encode(hh)], g[i][j - <span class="number">1</span>][l]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; "g: " &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt;= k; i++)</span></span><br><span class="line">    <span class="comment">//     for (int j = 0; j &lt; sum; j++)</span></span><br><span class="line">    <span class="comment">//         cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; getLCM(j) &lt;&lt; ' ' &lt;&lt; g[1][i][j] &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; "end" &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> C[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// f[i][j][k]: 考虑了[i, n]的质数，已经有j个位置确定好了，[1, sqrt(n)]的lcm为k</span></span><br><span class="line"><span class="keyword">int</span> f[N][M][<span class="number">1010</span>], tp[<span class="number">1010</span>], id[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pre(), solve_g();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            C[i][j] = Add(C[i - <span class="number">1</span>][j - <span class="number">1</span>], C[i - <span class="number">1</span>][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    f[tot + <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tot; i &gt; dimension; i--) &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; "solve: " &lt;&lt; prime[i] &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; j++) <span class="keyword">if</span> (f[i + <span class="number">1</span>][j][<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> nw = <span class="number">0</span>; nw + j &lt;= k; nw++) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; j &lt;&lt; ' ' &lt;&lt; nw &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">int</span> w = C[nw + j][j]; <span class="keyword">static</span> <span class="keyword">int</span> A[<span class="number">1010</span>], B[<span class="number">1010</span>];</span><br><span class="line">                <span class="keyword">if</span> (nw) w = (LL)w * prime[i] % mod;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; sum; l++) A[l] = f[i + <span class="number">1</span>][j][l], B[l] = g[n / prime[i]][nw][l];</span><br><span class="line">                FWT(A), FWT(B);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; sum; l++) A[l] = (LL)A[l] * B[l] % mod;</span><br><span class="line">                IFWT(A); </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; sum; l++) Inc(f[i][j + nw][l], (LL)A[l] * w % mod);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; prime[dimension + 1] &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// for (int j = 0; j &lt;= k; j++)</span></span><br><span class="line">    <span class="comment">//     for (int l = 0; l &lt; sum; l++)</span></span><br><span class="line">    <span class="comment">//         cout &lt;&lt; j &lt;&lt; ' ' &lt;&lt; getLCM(l) &lt;&lt; ' ' &lt;&lt; f[dimension + 1][j][l] &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum; i++) tp[i] = getLCM(i);</span><br><span class="line">    <span class="keyword">int</span> last = sum; pre(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> fk[<span class="number">110</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; last; i++) </span><br><span class="line">        unpack(tp[i], fk), id[i] = encode(fk);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> B[<span class="number">100010</span>]; <span class="built_in">memset</span>(B, <span class="number">0</span>, <span class="keyword">sizeof</span>(B));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; j++) <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) mx = j;</span><br><span class="line">        <span class="keyword">if</span> (mx &gt; dimension) <span class="keyword">continue</span>;</span><br><span class="line">        unpack(i, fk), B[encode(fk)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    FWT(B); <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[<span class="number">100010</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; sum; l++) A[l] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; last; l++) A[id[l]] = f[dimension + <span class="number">1</span>][i][l];</span><br><span class="line">        FWT(A);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; sum; l++)</span><br><span class="line">            A[l] = (LL)A[l] * Pow(B[l], k - i) % mod;</span><br><span class="line">        IFWT(A);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; sum; l++) &#123;</span><br><span class="line">            res = (res + (LL)getLCM(l) * A[l] % mod * C[k][i]) % mod;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; "fuck: " &lt;&lt; getLCM(l) &lt;&lt; ' ' &lt;&lt; (LL)getLCM(l) * A[l] % mod * C[k][i] % mod &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; k &lt;&lt; ' ' &lt;&lt; i &lt;&lt; ' ' &lt;&lt; C[k][i] &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; res &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> task2 &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[M][<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp)), dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (G[i][tp + <span class="number">1</span>]) tp++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;= tp; a++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= tp; b++) </span><br><span class="line">                    dp[j][max(a, b)] = (dp[j][max(a, b)] + (LL)dp[j - <span class="number">1</span>][a] * G[i][b]) % (mod - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, t = <span class="number">1</span>; j &lt;= tp; j++, t = (LL)t * prime[i] % mod)</span><br><span class="line">            res = (LL)res * Pow(t, dp[k][j]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k, sieve();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, task1::solve(), task2::solve());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-Easy-Data-Structure"><a href="#T3-Easy-Data-Structure" class="headerlink" title="T3 Easy Data Structure"></a>T3 Easy Data Structure</h1><p>参考farewell to mount celeste</p>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 状态压缩 </tag>
            
            <tag> 容斥 </tag>
            
            <tag> FWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.28联测T1 数一数</title>
      <link href="/2020/04/03/328-lian-ce-t1-shu-yi-shu/"/>
      <url>/2020/04/03/328-lian-ce-t1-shu-yi-shu/</url>
      
        <content type="html"><![CDATA[<p>有一个 $n$ 行 $m$ 列的表格，每个位置上有$0$或者$1$，对于每一列，第$i$行是1的概率是$P_i$，每一列仅会出现一个$1$。</p><p>你可以选择一个初始位置$(x,y)$，表示第$x$行$y$列的格子，然后每次移动可以走到$(x−1,y+1),(x,y+1),(x+1,y+1)$这三个格子里面的一个，直到$y=m$，你的得分为中途走过的格子的值的和。</p><p>假设对于随机生成的$n$行$m$列的表格，能得到的最大得分的期望为$f(m)$。</p><p>求：$\lim_{m\rightarrow \infty} \frac{f(m)}{m}$</p><script type="math/tex; mode=display">n\leq 6</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>如果每个位置上是$1$还是$0$已经确定好了，那么这就是一道很简单的$dp$题，从后往前按列$dp$即可</p><p>现在每个位置出现的数是随机的，那么根据套路我们可以尝试将$dp$状态压下来，换个说法就是$dp$套$dp$</p><p>爆搜出每一种可能的状态，在$n=6$的时候只有$478$种</p><p>当$m\rightarrow \infty$的时候，我们可以认为每列的转移形成了一张图，可以进一步地在这张图上高斯消元。最终我们只关系每种状态出现次数的比例</p><p>我们钦定一种状态的出现次数为$1$，可以求出其它状态的出现次数，从而求出所有状态出现次数的比例</p><p>最后枚举这张图上的每一条边，考虑这条边出现的概率以及是否会对答案产生贡献即可</p><p>这道题我在考试的时候调了很久，最后发现wa的原因是<code>(int)(0.3 * 10) = 2</code></p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> G[N][N], tot, n, inc[N][N], p[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ID</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mp.count(s)) <span class="keyword">return</span> mp[s];</span><br><span class="line">    <span class="keyword">return</span> mp[s] = ++tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">trans</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;base, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    vector&lt;int&gt; res(n), tmp = base; int A = 0, B = 0;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) tmp[i] += tmp[i - <span class="number">1</span>], A = max(A, tmp[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// int t = tmp[i] + (i == pos); </span></span><br><span class="line">        <span class="comment">// if (i) t = max(t, tmp[i - 1] + (i - 1 == pos));</span></span><br><span class="line">        <span class="comment">// if (i &lt; n - 1) t = max(t, tmp[i + 1] + (i + 1 == pos));</span></span><br><span class="line">        <span class="keyword">int</span> t = tmp[i]; </span><br><span class="line">        <span class="keyword">if</span> (i) t = max(t, tmp[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>) t = max(t, tmp[i + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (i == pos) t++;</span><br><span class="line">        res[i] = t, B = max(B, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) res[i] -= res[i - <span class="number">1</span>];</span><br><span class="line">    res[<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">int</span> s = ID(base), t = ID(res);</span><br><span class="line">    G[s][t] = (G[s][t] + p[pos]) % mod;</span><br><span class="line">    <span class="keyword">if</span> (A != B) inc[s][t] = (inc[s][t] + p[pos]) % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = ID(status);</span><br><span class="line">    <span class="keyword">if</span> (vis[id]) <span class="keyword">return</span>;</span><br><span class="line">    vis[id] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) build(trans(status, i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N][N], res[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Gauss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; j++) </span><br><span class="line">            A[i][j] = G[j][i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot; i++) </span><br><span class="line">        A[i][i] = (A[i][i] - <span class="number">1</span> + mod) % mod;</span><br><span class="line">    A[tot][tot] = <span class="number">1</span>, A[tot][tot + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= tot; j++) <span class="keyword">if</span> (A[j][i]) &#123;</span><br><span class="line">            swap(A[i], A[j]); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        assert(A[i][i]); <span class="keyword">int</span> inv = Pow(A[i][i], mod - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= tot; j++) <span class="keyword">if</span> (A[j][i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = (LL)inv * A[j][i] % mod;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= tot + <span class="number">1</span>; k++) </span><br><span class="line">                A[j][k] = (A[j][k] - (LL)A[i][k] * t % mod + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tot; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> inv = Pow(A[i][i], mod - <span class="number">2</span>);</span><br><span class="line">        res[i] = (LL)A[i][tot + <span class="number">1</span>] * inv % mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) <span class="keyword">if</span> (A[j][i]) </span><br><span class="line">            A[j][tot + <span class="number">1</span>] = (A[j][tot + <span class="number">1</span>] - (LL)res[i] * A[j][i] % mod + mod) % mod, A[j][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for (int i = 1; i &lt;= tot; i++) cout &lt;&lt; res[i] &lt;&lt; ' ';</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) sum = (sum + res[i]) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) res[i] = (LL)res[i] * Pow(sum, mod - <span class="number">2</span>) % mod;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; j++) <span class="keyword">if</span> (inc[i][j]) </span><br><span class="line">            ans = (ans + (LL)res[i] * inc[i][j]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); <span class="keyword">int</span> inv = Pow(<span class="number">10</span>, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">double</span> t; <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;t);</span><br><span class="line">        p[i] = ((LL)(t * <span class="number">10</span>)) * inv % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">base</span><span class="params">(n)</span></span>;</span><br><span class="line">    build(base), Gauss(), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, process());</span><br><span class="line"><span class="comment">//    cout &lt;&lt; tot &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高斯消元 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4220 [WC2018] 通道</title>
      <link href="/2020/04/03/wc2018-tong-dao/"/>
      <url>/2020/04/03/wc2018-tong-dao/</url>
      
        <content type="html"><![CDATA[<p>给出三棵树，求出</p><script type="math/tex; mode=display">\mathrm{dis}_{T_1}(a,b) + \mathrm{dis}_{T_2}(a,b) + \mathrm{dis}_{T_3}(a,b)</script><p>的最大值，边权为正</p><script type="math/tex; mode=display">n\leq 10^5, w\leq 10^{12}</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这题跟暴力写挂长得很像，但是暴力写挂只有两棵树，而这道题有三棵</p><p>但是需要注意的一点是，暴力写挂的边权有负数，因此不能直接求直径，而这道题的边权都是正的</p><p>考虑对于第一棵树边分治，在第二棵树上<code>dfs</code>。在合并两棵子树对应的边分树的时候，我们需要求出它们在第三棵树上的直径</p><p>具体来说，我们对于每个点单独考虑只有这个点在边分树上的情况，跟暴力写挂一样把这条链存下来。对于这条链上的每一个点，我们维护这个点左侧的点在$T_3$上的直径，右侧的点在$T_3$上的直径，合并的时候就是普通的合并直径</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, LL&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dis1(a, b) + dep2[a] + dep2[b] - 2dep2[lca2(a, b)] + dis3(a, b)</span></span><br><span class="line"><span class="comment"> * 对T1边分治，在T2上合并边分树，维护T3的加权直径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三度化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next; LL w;</span><br><span class="line">&#125; e[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N * <span class="number">2</span>], ecnt = <span class="number">1</span>, ncnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, LL w)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; "--adde: " &lt;&lt; from &lt;&lt; ' ' &lt;&lt; to &lt;&lt; ' ' &lt;&lt; w &lt;&lt; endl;</span></span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from], w &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to], w &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt; G1[N], G2[N], G3[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rebuild</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last = u, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G1[u]) <span class="keyword">if</span> (v.first != f) t = v.first;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G1[u]) <span class="keyword">if</span> (v.first != f) &#123;</span><br><span class="line">        Rebuild(v.first, u), adde(last, v.first, v.second);</span><br><span class="line">        <span class="keyword">if</span> (v.first != t) adde(last, ++ncnt, <span class="number">0</span>), last = ncnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T2, T3</span></span><br><span class="line">LL dep2[N], dep3[N]; <span class="keyword">int</span> dep[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> st[<span class="number">18</span>][N * <span class="number">2</span>], lg[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G2[u]) <span class="keyword">if</span> (v.first != f) </span><br><span class="line">        dep2[v.first] = dep2[u] + v.second, dfs1(v.first, u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn, fir[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    st[<span class="number">0</span>][++dfn] = u, fir[u] = dfn, dep[u] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G3[u]) <span class="keyword">if</span> (v.first != f) </span><br><span class="line">        dep3[v.first] = dep3[u] + v.second, dfs2(v.first, u), st[<span class="number">0</span>][++dfn] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dep[x] &lt; dep[y] ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">17</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= dfn; j++)</span><br><span class="line">            st[i][j] = Min(st[i - <span class="number">1</span>][j], st[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= dfn; i++) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LCA on T3</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line">    a = fir[a], b = fir[b];</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) swap(a, b);</span><br><span class="line">    <span class="keyword">int</span> len = lg[b - a + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> Min(st[len][a], st[len][b - (<span class="number">1</span> &lt;&lt; len) + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Dis</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dep3[a] + dep3[b] - <span class="number">2</span> * dep3[LCA(a, b)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并直径</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b; LL A, B, dis;</span><br><span class="line">&#125; val[<span class="number">2</span>][N * <span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> data <span class="title">Max</span><span class="params">(data a, data b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.dis &gt; b.dis ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> data <span class="title">Merge</span><span class="params">(data a, data b, LL diff)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((!a.a) || (!b.a)) <span class="keyword">return</span> a.a ? a : b;</span><br><span class="line">    <span class="keyword">static</span> LL tmp[<span class="number">4</span>]; <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    tmp[<span class="number">0</span>] = Dis(a.a, b.a) + a.A + b.A, tmp[<span class="number">1</span>] = Dis(a.a, b.b) + a.A + b.B;</span><br><span class="line">    tmp[<span class="number">2</span>] = Dis(a.b, b.a) + a.B + b.A, tmp[<span class="number">3</span>] = Dis(a.b, b.b) + a.B + b.B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) <span class="keyword">if</span> (tmp[i] &gt; tmp[pos]) pos = i;</span><br><span class="line">    data res = (data)&#123; (pos &amp; <span class="number">2</span>) ? a.b : a.a, (pos &amp; <span class="number">1</span>) ? b.b : b.a, (pos &amp; <span class="number">2</span>) ? a.B : a.A, (pos &amp; <span class="number">1</span>) ? b.B : b.A, tmp[pos] &#125;;</span><br><span class="line">    <span class="keyword">if</span> (diff != <span class="number">233</span>) ans = max(ans, tmp[pos] + diff); </span><br><span class="line">    <span class="keyword">return</span> Max(res, Max(a, b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边分治</span></span><br><span class="line"><span class="keyword">int</span> sz[N * <span class="number">2</span>], cur, fucked[N * <span class="number">4</span>], n, ch[<span class="number">2</span>][N * <span class="number">30</span>]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lst[N * <span class="number">2</span>], lst1[N * <span class="number">2</span>], RT[N * <span class="number">2</span>], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> nw, LL dis)</span> </span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lst[u]) lst[u] = RT[u] = ++tot;</span><br><span class="line">        <span class="keyword">else</span> tot++, ch[lst1[u]][lst[u]] = tot, lst[u] = tot;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; "fuck: " &lt;&lt; u &lt;&lt; ' ' &lt;&lt; dis &lt;&lt; ' ' &lt;&lt; dep2[u] &lt;&lt; endl;</span></span><br><span class="line">        lst1[u] = nw, val[nw][tot] = (data)&#123; u, u, dis + dep2[u], dis + dep2[u], dis * <span class="number">2</span> + dep2[u] * <span class="number">2</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f &amp;&amp; !fucked[i]) dfs(e[i].to, u, nw, dis + e[i].w), sz[u] += sz[e[i].to];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> &amp;rt1, <span class="keyword">int</span> rt2, LL diff)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((!rt1) || (!rt2)) <span class="keyword">return</span> rt1 |= rt2, <span class="keyword">void</span>();</span><br><span class="line"><span class="comment">//    cout &lt;&lt; ch[0][rt1] &lt;&lt; ' ' &lt;&lt; ch[1][rt1] &lt;&lt; ' ' &lt;&lt; ch[0][rt2] &lt;&lt; ' ' &lt;&lt; ch[1][rt2] &lt;&lt; endl;</span></span><br><span class="line">    Merge(val[<span class="number">0</span>][rt1], val[<span class="number">1</span>][rt2], diff), Merge(val[<span class="number">1</span>][rt1], val[<span class="number">0</span>][rt2], diff);</span><br><span class="line">    val[<span class="number">0</span>][rt1] = Merge(val[<span class="number">0</span>][rt1], val[<span class="number">0</span>][rt2], <span class="number">233</span>), val[<span class="number">1</span>][rt1]= Merge(val[<span class="number">1</span>][rt1], val[<span class="number">1</span>][rt2], <span class="number">233</span>);</span><br><span class="line">    Merge(ch[<span class="number">0</span>][rt1], ch[<span class="number">0</span>][rt2], diff), Merge(ch[<span class="number">1</span>][rt1], ch[<span class="number">1</span>][rt2], diff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找中心边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetEG</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> tot)</span> </span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f &amp;&amp; !fucked[i]) &#123;</span><br><span class="line">            GetEG(e[i].to, u, tot), sz[u] += sz[e[i].to];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(tot - <span class="number">2</span> * sz[e[i].to]) &lt; tmp) </span><br><span class="line">                tmp = <span class="built_in">abs</span>(tot - <span class="number">2</span> * sz[e[i].to]), cur = i;</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Divide</span><span class="params">(<span class="keyword">int</span> ed)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; "--find: " &lt;&lt; e[ed].to &lt;&lt; ' ' &lt;&lt; e[ed ^ 1].to &lt;&lt; endl;</span></span><br><span class="line">    fucked[ed] = fucked[ed ^ <span class="number">1</span>] = <span class="number">1</span>, dfs(e[ed].to, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), dfs(e[ed ^ <span class="number">1</span>].to, <span class="number">0</span>, <span class="number">1</span>, e[ed].w);</span><br><span class="line">    <span class="keyword">auto</span> find = [&amp;](<span class="keyword">int</span> u) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        cur = <span class="number">-1</span>, tmp = <span class="number">1e9</span>, GetEG(u, <span class="number">0</span>, sz[u]);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> L = find(e[ed].to), R = find(e[ed ^ <span class="number">1</span>].to);</span><br><span class="line">    <span class="keyword">if</span> (~L) Divide(L); <span class="keyword">if</span> (~R) Divide(R);</span><br><span class="line"><span class="comment">//    cout &lt;&lt; "--end" &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Divide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ncnt = n, Rebuild(<span class="number">1</span>, <span class="number">0</span>), tmp = <span class="number">1e9</span>, GetEG(<span class="number">1</span>, <span class="number">0</span>, n), Divide(cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G2[u]) <span class="keyword">if</span> (v.first != f) </span><br><span class="line">        dfs3(v.first, u), Merge(RT[u], RT[v.first], <span class="number">-2</span> * dep2[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b; LL c; read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        read(a), read(b), read(c);</span><br><span class="line">        G1[a].push_back(P(b, c)), G1[b].push_back(P(a, c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        read(a), read(b), read(c);</span><br><span class="line">        G2[a].push_back(P(b, c)), G2[b].push_back(P(a, c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        read(a), read(b), read(c);</span><br><span class="line">        G3[a].push_back(P(b, c)), G3[b].push_back(P(a, c));</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>), dfs2(<span class="number">1</span>, <span class="number">0</span>), ST(), Divide(), dfs3(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//    Merge(RT[2], RT[3], 0);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 边分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4565 [CTSC2018] 暴力写挂  </title>
      <link href="/2020/03/31/p4565-ctsc2018-bao-li-xie-gua/"/>
      <url>/2020/03/31/p4565-ctsc2018-bao-li-xie-gua/</url>
      
        <content type="html"><![CDATA[<p>给出两棵带边权的树$T_1, T_2$，你需要求出</p><script type="math/tex; mode=display">\mathrm{dep}_{T_1}(a) + \mathrm{dep}_{T_1}(b) - \mathrm{dep}_{T_1}(\mathrm{lca}_{T_1}(a,b)) - \mathrm{dep}_{T_2}(\mathrm{lca}_{T_2}(a,b))</script><p>的最大值</p><p>边权可能为负</p><script type="math/tex; mode=display">n\leq 4\times 10^5</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这个题有两种做法</p><p>首先将这个式子改写一下</p><script type="math/tex; mode=display">\frac 12[\mathrm{dis}_{T_1}(a, b) + \mathrm{dep}_{T_1}(a) +  \mathrm{dep}_{T_1}(b) - 2\mathrm{dep}_{T_2}(\mathrm{lca}_{T_2}(a,b))]</script><p>这个式子的最后一项是拆不掉的</p><p>考虑对第一棵树进行点分治，那么当前枚举的中心点会将当前连通块分为若干棵子树。我们将当前连通块里面的其它点拿出来，到$T2$上建一棵虚树，再在这棵虚树上进行树形$dp$</p><p>此时我们需要保证$a,b$在$T1$中落在当前中心点的两个不同的子树内，并且$a,b$在$T2$中落在当前根的不同子树内。由于点分治的时候中心点分出的子树可能有很多个，因此这样做复杂度会爆炸</p><p>如果当前中心点只有两棵子树，那么我们可以将这两棵子树分别染成黑色和白色。接着我们枚举$a,b$在$T2$上的$\mathrm{lca}$，问题转化为在当前点的两棵不同的子树中找到一个黑点，一个白点，使得这两个点的权值之和最大</p><p>而“当前中心点只有两棵子树”这个限制可以使用边分治实现</p><p>首先我们将整棵树三度化，转化为一棵二叉树</p><p><img src="1585639193685.png" alt=""></p><p>转化之后可以得到</p><p><img src="1585639347536.png" alt=""></p><p>注意，我们要保证转化之后两点之间的距离不变</p><p>实现过程就是：对于当前根，我们记录一个<code>last</code>表示上一次新建的虚点，一开始<code>last</code>的值就等于根</p><p>每遇到一个儿子，我们将这个儿子挂到<code>last</code>下面，边权为当前根到这个儿子的边权，同时新建一个虚点，将这个虚点挂到<code>last</code>下，同时边权为$0$，最后令<code>last</code>等于新建的虚点</p><p>代码很短</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rebuild</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last = u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G1[u]) <span class="keyword">if</span> (v.first != f) &#123;</span><br><span class="line">        Rebuild(v.first, u), adde(last, v.first, v.second);</span><br><span class="line">        adde(last, ++ncnt, <span class="number">0</span>), last = ncnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们就可以开始愉快地边分治了</p><p>类似点分治的方法，每次我们根据子树大小选出一条中心边，然后这条中心边会将当前连通块分为两个部分。我们将这两个部分的点分别染成黑色和白色，然后丢到$T2$上建虚树，再跑一遍树形$dp$。最后对这两个部分继续分治下去</p><p>如果虚树的实现不够优秀，那么这样的时间复杂度就为$O(n\log^2 n)$，但这个方法不是我想讨论的重点</p><p>类似于动态点分治，其实也是有“动态边分治”，也就是边分树这种东西的</p><p>每次选择当前分治的中心边，为这条边新建一个节点，然后左右两边递归分治，容易发现这样得到的是一棵树型的结构，并且每个叶子都对应原树中的一个点</p><p>对于原树中的每一个点，类似动态开点线段树，我们求出仅保留这个点的所有祖先的边分树</p><p>接着，我们枚举$a,b$在$T2$上的$\mathrm{lca}$，类似线段树合并的方法，每次合并当前节点的两个儿子对应的边分树，同时更新答案</p><p>时间复杂度跟线段树合并的时间复杂度一样，为$O(n\log n)$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * dis1(a, b) + dep1[a] + dep1[b] - dep2[lca(a, b)]</span></span><br><span class="line"><span class="comment"> * 对T1建边分树，维护左右儿子的dep1 + dis1(a, t0 / t1)的最大值</span></span><br><span class="line"><span class="comment"> * 对T2dfs，同时合并对应的边分树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三度化之后的树</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;</span><br><span class="line">&#125; e[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N * <span class="number">2</span>], ecnt = <span class="number">1</span>, ncnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; "adde: " &lt;&lt; from &lt;&lt; ' ' &lt;&lt; to &lt;&lt; ' ' &lt;&lt; w &lt;&lt; endl;</span></span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from], w &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to], w &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T1, T2</span></span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt; G1[N], G2[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个点在T1中的深度</span></span><br><span class="line">LL dep[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三度化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rebuild</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last = u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G1[u]) <span class="keyword">if</span> (v.first != f) &#123;</span><br><span class="line">        dep[v.first] = dep[u] + v.second, Rebuild(v.first, u), adde(last, v.first, v.second);</span><br><span class="line">        adde(last, ++ncnt, <span class="number">0</span>), last = ncnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sz[N * <span class="number">2</span>], cur, fucked[N * <span class="number">4</span>], n; LL ans = <span class="number">-1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边分树结构</span></span><br><span class="line"><span class="keyword">int</span> lst[N], lst1[N], tot, tmp = <span class="number">1e9</span>, RT[N], ch[<span class="number">2</span>][N * <span class="number">30</span>]; LL val[<span class="number">2</span>][N * <span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对T1中的每个点单独求出其在边分树上的链</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> nw, LL dis)</span> </span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lst[u]) lst[u] = RT[u] = ++tot;</span><br><span class="line">        <span class="keyword">else</span> ch[lst1[u]][lst[u]] = ++tot, lst[u] = tot;</span><br><span class="line">        lst1[u] = nw, val[nw][lst[u]] = dis + dep[u], val[nw ^ <span class="number">1</span>][lst[u]] = <span class="number">-1e18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f &amp;&amp; !fucked[i]) </span><br><span class="line">            dfs(e[i].to, u, nw, dis + e[i].w), sz[u] += sz[e[i].to];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并边分树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> &amp;rt1, <span class="keyword">int</span> rt2, LL diff)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rt1 || !rt2) <span class="keyword">return</span> rt1 |= rt2, <span class="keyword">void</span>();</span><br><span class="line">    ans = max(ans, max(val[<span class="number">0</span>][rt1] + val[<span class="number">1</span>][rt2] + diff, val[<span class="number">1</span>][rt1] + val[<span class="number">0</span>][rt2] + diff));</span><br><span class="line">    val[<span class="number">0</span>][rt1] = max(val[<span class="number">0</span>][rt1], val[<span class="number">0</span>][rt2]), val[<span class="number">1</span>][rt1] = max(val[<span class="number">1</span>][rt1], val[<span class="number">1</span>][rt2]);</span><br><span class="line">    Merge(ch[<span class="number">0</span>][rt1], ch[<span class="number">0</span>][rt2], diff), Merge(ch[<span class="number">1</span>][rt1], ch[<span class="number">1</span>][rt2], diff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找中心边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetEG</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> tot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f &amp;&amp; !fucked[i]) &#123;</span><br><span class="line">            GetEG(e[i].to, u, tot);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(tot - <span class="number">2</span> * sz[e[i].to]) &lt; tmp) </span><br><span class="line">                tmp = <span class="built_in">abs</span>(tot - <span class="number">2</span> * sz[e[i].to]), cur = i;</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Divide</span><span class="params">(<span class="keyword">int</span> ed)</span> </span>&#123;</span><br><span class="line">    fucked[ed] = fucked[ed ^ <span class="number">1</span>] = <span class="number">1</span>, dfs(e[ed].to, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), dfs(e[ed ^ <span class="number">1</span>].to, <span class="number">0</span>, <span class="number">1</span>, e[ed].w);</span><br><span class="line">    <span class="keyword">auto</span> find = [&amp;](<span class="keyword">int</span> u) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        cur = <span class="number">-1</span>, tmp = <span class="number">1e9</span>, GetEG(u, <span class="number">0</span>, sz[u]);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> L = find(e[ed].to), R = find(e[ed ^ <span class="number">1</span>].to);</span><br><span class="line">    <span class="keyword">if</span> (~L) Divide(L); <span class="keyword">if</span> (~R) Divide(R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Divide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ncnt = n, Rebuild(<span class="number">1</span>, <span class="number">0</span>), tmp = <span class="number">1e9</span>, GetEG(<span class="number">1</span>, <span class="number">0</span>, n), Divide(cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在T2上边分树合并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, LL dis)</span> </span>&#123;</span><br><span class="line">    ans = max(ans, dep[u] * <span class="number">2</span> - dis * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G2[u]) <span class="keyword">if</span> (v.first != f) </span><br><span class="line">        dfs(v.first, u, dis + v.second), Merge(RT[u], RT[v.first], -dis * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b, c; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        G1[a].push_back(P(b, c)), G1[b].push_back(P(a, c));</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b, c; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        G2[a].push_back(P(b, c)), G2[b].push_back(P(a, c));</span><br><span class="line">    &#125;</span><br><span class="line">    Divide(), dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 边分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.17 省选集训 day5</title>
      <link href="/2020/03/17/317-sheng-xuan-ji-xun-day5/"/>
      <url>/2020/03/17/317-sheng-xuan-ji-xun-day5/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-买到"><a href="#T1-买到" class="headerlink" title="T1 买到"></a>T1 买到</h1><p>给定一张$N$个点的无向完全图，点的标号从$1$开始。对于一个非空点集$S$，你需要找到一条路径，起点和终点均任意，满足$S$中的每个点在路径上出现了恰好一次，且不能经过集合外的其他点。</p><p>在到达了一个点$u$之后（包括起点和终点），你需要先“激活”这个点，才能进行之后的操作。你并不是必须在到达该点之后立刻激活，而是可以等待一段时间。同时，假如当前时刻为$t$，那么激活该点所需要花费的时间就是$A[u][t\mod T]$。</p><p>另外，对于一条边$e$，如果你从t时刻开始从边的起点出发向终点走去，那么在这条边上所需要花费时间就是$B[e][t\mod T]$。同样地，你也可以选择在起点等待一段时间再出发。</p><p>在路径起点开始的时候，为$0$时刻。</p><p>现在有$Q$次询问，每次都会给定一个非空点集$S$。你需要找到一条花费时间最少的路径，包括其在路径上走的方法。你只需要给出这个最少的花费时间。</p><script type="math/tex; mode=display">N\leq 20,Q\leq 2^N-1,T\leq 10^4</script><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>显然到达一个点的时间越早越优秀</p><p>预处理出在模$T$意义下的每个时刻准备激活每个点时的最小耗费时间，以及走每条边的最小耗费时间即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">21</span>][<span class="number">1</span> &lt;&lt; <span class="number">20</span>], A[<span class="number">21</span>][M], B[<span class="number">21</span>][<span class="number">21</span>][M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> F[<span class="number">21</span>][M], G[<span class="number">21</span>][<span class="number">21</span>][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, T; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; T; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; T; k++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;B[i][j][k]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        F[i][T - <span class="number">1</span>] = A[i][T - <span class="number">1</span>]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; T - <span class="number">1</span>; j++)</span><br><span class="line">            F[i][T - <span class="number">1</span>] = min(F[i][T - <span class="number">1</span>], A[i][j] + j + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = T - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            F[i][j] = min(F[i][j + <span class="number">1</span>] + <span class="number">1</span>, A[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            G[i][j][T - <span class="number">1</span>] = B[i][j][T - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; T - <span class="number">1</span>; k++)</span><br><span class="line">                G[i][j][T - <span class="number">1</span>] = min(G[i][j][T - <span class="number">1</span>], B[i][j][k] + k + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = T - <span class="number">2</span>; k &gt;= <span class="number">0</span>; k--)</span><br><span class="line">                G[i][j][k] = min(G[i][j][k + <span class="number">1</span>] + <span class="number">1</span>, B[i][j][k]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; T; k++) G[j][i][k] = G[i][j][k];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dp[i][<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>] = F[i][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); s++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (s &amp; (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = dp[i][s] % T;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span> (!(s &amp; (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>))) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = dp[i][s] + G[i][j][tmp], w = t + F[j][t % T];</span><br><span class="line">                dp[j][s | (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)] = min(dp[j][s | (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)], w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> q; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> s; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;s); <span class="keyword">int</span> res = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (s &amp; (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)) </span><br><span class="line">            res = min(res, dp[i][s]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-口罩"><a href="#T2-口罩" class="headerlink" title="T2 口罩"></a>T2 口罩</h1><p>给定一棵$N$个点的带标号无根树。定义一次操作为，把树中的某一条边去掉，然后再加上一条边，使得它仍然是一棵树。</p><p>你需要进行恰好$K$次这样的操作。请你求出，你可以得到多少棵不同的树。</p><p>两棵树定义为不同，当且仅当存在一条无向边$(x, y)$，在一棵树中出现、在另一棵树中不出现。</p><p>由于答案可能很大，请你输出其在模$10^9 + 7$意义下的结果</p><script type="math/tex; mode=display">N\leq 5000</script><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>容易发现，最终树的形态一定是将整棵树分为至多$k$个连通块，然后这些连通块再由若干条新边连成一棵树</p><p>如果我们确定了每个连通块的大小，假如在最终的连边方案中有一条边$(u,v)$，注意此时$u,v$代表的是两个连通块，那么这条边的端点一共有$sz_u\times sz_v$种选法</p><p>那么单独考虑每个连通块对总方案数的贡献，就是这个连通块的大小的度数次方</p><p>注意这里我们并没有要求此时连的边必须与原树上的边不同，因此会导致重复计数，如何去重我们后面再说</p><p>考虑由这些连通块构成的<code>prufer</code>序，显然每个连通块在这个序列中出现了度数$-1$次，少乘了一次</p><p>而每个连通块的大小之和为$n$</p><p>因此如果整棵树被分为了$i$个连通块，那么添加$i-1$条边使得整棵树连通的方案数为$n^{i-2}\times$所有连通块大小的乘积</p><p>因此我们需要求出对于每一种将整棵树分为$i(i\leq k)$个连通块的方案中，每个连通块大小的乘积之和</p><p>考虑这个东西的组合意义，就是从每个连通块中选出一个点的方案数</p><p>因此设$dp[i][j][1/0]$表示以$i$为根的子树，被划分为了$j$个连通块，其中根节点所在的连通块是否选了点的方案数</p><p>现在我们求出了将整棵树分为$i$个连通块并将这些连通块连接起来的方案数，如何去重呢</p><p>设$f[i]$表示将整棵树分为$i$个连通块，且连接的边都不是原树上的边的方案数</p><p>那么当前答案应该减去</p><script type="math/tex; mode=display">\sum_{j=1}^{i-1}{n-j\choose i-j}f[j]</script><p>因为每一种存在$j$个连通块的方案，断开$i-j$条连通块内部的边之和都能得到一种存在$i$个连通块的不合法方案</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from] &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to] &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][N][N], k, sz[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][u][<span class="number">1</span>] = dp[<span class="number">1</span>][u][<span class="number">1</span>] = sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) &#123;</span><br><span class="line">            dfs(e[i].to, u); <span class="keyword">static</span> <span class="keyword">int</span> tmp[<span class="number">2</span>][N];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sz[u] + sz[e[i].to]; j++) tmp[<span class="number">0</span>][j] = tmp[<span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sz[u] &amp;&amp; j &lt;= k; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= sz[e[i].to] &amp;&amp; l &lt;= k; l++) &#123;</span><br><span class="line">                    tmp[<span class="number">0</span>][j + l] = (tmp[<span class="number">0</span>][j + l] + (LL)dp[<span class="number">0</span>][u][j] * dp[<span class="number">1</span>][e[i].to][l]) % mod;</span><br><span class="line">                    tmp[<span class="number">0</span>][j + l - <span class="number">1</span>] = (tmp[<span class="number">0</span>][j + l - <span class="number">1</span>] + (LL)dp[<span class="number">0</span>][u][j] * dp[<span class="number">0</span>][e[i].to][l]) % mod;</span><br><span class="line">                    tmp[<span class="number">1</span>][j + l] = (tmp[<span class="number">1</span>][j + l] + (LL)dp[<span class="number">1</span>][u][j] * dp[<span class="number">1</span>][e[i].to][l]) % mod;</span><br><span class="line">                    tmp[<span class="number">1</span>][j + l - <span class="number">1</span>] = (tmp[<span class="number">1</span>][j + l - <span class="number">1</span>] + (LL)dp[<span class="number">1</span>][u][j] * dp[<span class="number">0</span>][e[i].to][l]) % mod;</span><br><span class="line">                    tmp[<span class="number">1</span>][j + l - <span class="number">1</span>] = (tmp[<span class="number">1</span>][j + l - <span class="number">1</span>] + (LL)dp[<span class="number">0</span>][u][j] * dp[<span class="number">1</span>][e[i].to][l]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sz[u] + sz[e[i].to] &amp;&amp; j &lt;= k; j++) </span><br><span class="line">                dp[<span class="number">0</span>][u][j] = tmp[<span class="number">0</span>][j], dp[<span class="number">1</span>][u][j] = tmp[<span class="number">1</span>][j];</span><br><span class="line">            sz[u] += sz[e[i].to];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> F[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>, k++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt; n; i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>), F[<span class="number">1</span>] = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= k; i++) </span><br><span class="line">        F[i] = (LL)Pow(n, i - <span class="number">2</span>) * dp[<span class="number">1</span>][<span class="number">1</span>][i] % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= k; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) </span><br><span class="line">            F[i] = (F[i] - (LL)F[j] * C(n - j, i - j)) % mod;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) res = (res + F[i]) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (res + mod) % mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-了吗"><a href="#T3-了吗" class="headerlink" title="T3 了吗"></a>T3 了吗</h1><p>给定一棵$N$个点的有根树，其中$1$是树根，除了$1$以外的其他点$u$有唯一的父亲$Father_u$。每个点$u$都有两个权值$V_u$和$W_u$。其中$W_u$是给定的，而且满足$W_u\in\{0,1\}$。</p><p>每个点的$V_u$则是你决定的。同时，给定了一个非负整数常数$K$。</p><p>设$Sum_u = \sum_{v\in Son_u}V_v$，其中$Son_u$表示$u$的儿子集合。对于一个合法的方案，<br>任意点$u$均需要满足：<br>（1） 若$W_u = 1$，$V_u = 2 \times Sum_u$；<br>（2） 若$W_u = 0$，$Sum_u \leq V_u \leq Sum_u + K$。</p><p>请你对于每个$0 \leq s \leq S$的$s$求出，在所有的合法方案中，最终满足$V_1 = s$的合<br>法方案有多少个。由于答案可能很大，你只需要求出其在模$998244353$意义下的结果。</p><p>如果对于每个$s$均输出答案，那么输出会过大。所以，你只需要输出所有答案的异或和。</p><script type="math/tex; mode=display">N,K,S\leq 10^6</script><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>考虑一个点权值的生成函数$F_u(x)$</p><p>如果$w_u=1$，那么</p><script type="math/tex; mode=display">F_u(x)=\prod_{v\in son_u}F_v(x^2)</script><p>否则</p><script type="math/tex; mode=display">F_u(x)=\frac{x^{k+1}-1}{x-1}\prod_{v\in son_u}F_v(x)</script><p>容易发现，最后$F_1(x)$一定可以被表示为若干个形如$\frac{(x^n)^{k+1}-1}{x^n-1}$的幂的乘积的形式</p><p>容易发现一个很重要的性质：这里的$n$都是$2$的幂</p><p>因此，$F_1(x)$的表达式中本质不同的底数只有$\log s$种</p><p>我们对分子分母分别求出它们的乘积，最后再求一遍逆</p><p>开一个桶，记录一下每种底数的次数，然后最后用二项式定理展开</p><p>第$i$个底数可能有值的地方只有$x^{2^i},x^{2^{i+1}},x^{2^{i+2}},\cdots$这些位置</p><p>因此我们倒着合并这些多项式，每次用$x$的系数来表示$x^{2^i}$的系数就行了</p><p>另一个优化是，可以发现求出分母也就求出了分子，因此我们可以只<code>NTT</code>一边</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from] &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to] &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> val[N], ans[<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w &gt; <span class="number">20</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (val[u]) w++; <span class="keyword">else</span> ans[w]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> poly[N &lt;&lt; <span class="number">2</span>], res[N &lt;&lt; <span class="number">2</span>], res1[N &lt;&lt; <span class="number">2</span>], B[N &lt;&lt; <span class="number">2</span>], s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r[N &lt;&lt; <span class="number">2</span>], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Wn[<span class="number">2</span>][<span class="number">22</span>][N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>, step = <span class="number">0</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>, step++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = Pow(<span class="number">3</span>, (mod - <span class="number">1</span>) / mid), t1 = Pow(t, mod - <span class="number">2</span>);</span><br><span class="line">        Wn[<span class="number">0</span>][step][<span class="number">0</span>] = Wn[<span class="number">1</span>][step][<span class="number">0</span>] = <span class="number">1</span>, Wn[<span class="number">1</span>][step][<span class="number">1</span>] = t, Wn[<span class="number">0</span>][step][<span class="number">1</span>] = t1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; (mid &gt;&gt; <span class="number">1</span>); i++) &#123;</span><br><span class="line">            Wn[<span class="number">1</span>][step][i] = (LL)Wn[<span class="number">1</span>][step][i - <span class="number">1</span>] * t % mod;</span><br><span class="line">            Wn[<span class="number">0</span>][step][i] = (LL)Wn[<span class="number">0</span>][step][i - <span class="number">1</span>] * t1 % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dec</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123; x -= y, x += x &lt; <span class="number">0</span> ? mod : <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">int</span> t = x - y; <span class="keyword">return</span> t &lt; <span class="number">0</span> ? t + mod : t; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">int</span> t = x + y; <span class="keyword">return</span> t &gt;= mod ? t - mod : t; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123; x += y, x -= x &gt;= mod ? mod : <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>, step = <span class="number">0</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>, step++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, t; j &lt; i + (mid &gt;&gt; <span class="number">1</span>); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = Wn[type][step][j - i]; </span><br><span class="line">                t = (LL)w * a[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = Sub(a[j], t), Inc(a[j], t);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">if</span> (!type) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, inv = Pow(len, mod - <span class="number">2</span>); i &lt; len; i++) </span><br><span class="line">        a[i] = (LL)a[i] * inv % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">GetR</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> A[], <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">void</span>(B[<span class="number">0</span>] = Pow(A[<span class="number">0</span>], mod - <span class="number">2</span>));</span><br><span class="line">    Inv(A, B, (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>); <span class="keyword">static</span> <span class="keyword">int</span> tmpa[N &lt;&lt; <span class="number">2</span>]; <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n * <span class="number">2</span>) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    GetR(len, l);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) tmpa[i] = A[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; len; i++) tmpa[i] = <span class="number">0</span>;</span><br><span class="line">    NTT(tmpa, len, <span class="number">1</span>), NTT(B, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) B[i] = (<span class="number">2</span> - (LL)tmpa[i] * B[i] % mod + mod) * B[i] % mod;</span><br><span class="line">    NTT(B, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; len; i++) B[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> tmpb[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n * <span class="number">2</span>) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) tmpb[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (n &gt;&gt; <span class="number">1</span>); i++) tmpb[i &lt;&lt; <span class="number">1</span>] = B[i];</span><br><span class="line">    GetR(len, l), NTT(A, len, <span class="number">1</span>), NTT(tmpb, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) B[i] = (LL)A[i] * tmpb[i] % mod;</span><br><span class="line">    NTT(B, len, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;k, &amp;s), k++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, a; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), adde(a, i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val[i]);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>); inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= s + <span class="number">1</span>; i++) inv[i] = (LL)(mod - mod / i) * inv[mod % i] % mod;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= <span class="number">2</span> * s) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    pre(len), res1[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> up = s &gt;&gt; i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= up; j++) poly[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, t = <span class="number">1</span>; j &lt;= min(ans[i], up); j++) &#123;</span><br><span class="line">            poly[j] = (ans[i] - j) &amp; <span class="number">1</span> ? mod - t : t;</span><br><span class="line">            t = (LL)t * inv[j + <span class="number">1</span>] % mod * (ans[i] - j) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        mul(poly, res1, up);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i * k &lt;= s; i++) res[i * k] = res1[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s + <span class="number">1</span>; i &lt; len; i++) res1[i] = <span class="number">0</span>;</span><br><span class="line">    Inv(res1, B, s + <span class="number">1</span>);</span><br><span class="line">    len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= <span class="number">2</span> * s) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    GetR(len, l), NTT(res, len, <span class="number">1</span>), NTT(B, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) B[i] = (LL)res[i] * B[i] % mod;</span><br><span class="line">    NTT(B, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s; i++) hh ^= B[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, hh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> FFT </tag>
            
            <tag> 状态压缩 </tag>
            
            <tag> 容斥 </tag>
            
            <tag> 生成函数 </tag>
            
            <tag> 多项式求逆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.14 省选集训 day4</title>
      <link href="/2020/03/15/314-sheng-xuan-ji-xun-day4/"/>
      <url>/2020/03/15/314-sheng-xuan-ji-xun-day4/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-Manager"><a href="#T1-Manager" class="headerlink" title="T1 Manager"></a>T1 Manager</h1><p>给出一棵有根树，每个点有一个权值$a_i$。定义一个点的价值为其子树（包括这个点自己）中的所有点的权值的中位数。对于每个$i\in [1,n]$，输出当$i$的权值变为$10^5$时整棵树的价值之和</p><script type="math/tex; mode=display">n\leq 2\times 10^5,a_i\leq 10^5</script><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>对于一个序列来说，将所有数从小到大排序，如果我们修改的数在中位数左边（包括中位数这个位置），那么会导致修改后的中位数往右移动一个位置</p><p>也就是说，如果一开始中位数右边的第一个数与中位数相等，那么这次修改不会产生任何影响</p><p>然后这道题就很简单了，我们考虑每个点对答案的贡献，如果修改的点在这个点的子树中，且修改的点在修改之前的权值小于等于中位数，那么这个点的贡献为中位数右边的第一个数；否则这个点的贡献是中位数</p><p>查找一个点子树中的中位数可以主席树，对一棵子树的区间加可以在这个点上打<code>tag</code>，最后用树状数组维护，再<code>dfs</code>一遍即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from] &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to] &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[N], rk[N], sz[N], dfsn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>, dfn[u] = ++dfsn, rk[dfn[u]] = u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u), sz[u] += sz[e[i].to];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcurts</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;tcurts&gt; tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, ls, rs, sum;</span><br><span class="line">&#125; T[N * <span class="number">32</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ncnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rt = ++ncnt; T[rt].l = l, T[rt].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> rt;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    T[rt].ls = build(l, mid), T[rt].rs = build(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r; <span class="keyword">int</span> nw = ++ncnt; T[nw] = T[rt], T[nw].sum++;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> nw;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) T[nw].ls = update(T[nw].ls, pos);</span><br><span class="line">    <span class="keyword">else</span> T[nw].rs = update(T[nw].rs, pos);</span><br><span class="line">    <span class="keyword">return</span> nw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> rt1, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> left = T[T[rt1].ls].sum - T[T[rt].ls].sum;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= left) <span class="keyword">return</span> query(T[rt].ls, T[rt1].ls, k);</span><br><span class="line">    <span class="keyword">return</span> query(T[rt].rs, T[rt1].rs, k - left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N], n, RT[N], mx; LL ans[N], tree[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= mx; x += x &amp; -x) tree[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    upd(l, x), upd(r + <span class="number">1</span>, -x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">que</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= x &amp; -x) res += tree[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m[N]; LL fuck, all;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : tmp[u]) upd(t.l, t.r, t.x);</span><br><span class="line">    fuck += m[u];</span><br><span class="line">    ans[u] = que(num[u]) + all - fuck; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs1(e[i].to, u);</span><br><span class="line">    fuck -= m[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : tmp[u]) upd(t.l, t.r, -t.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]), mx = max(mx, num[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, a; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), adde(a, i);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>), RT[<span class="number">0</span>] = build(<span class="number">1</span>, mx);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) RT[i] = update(RT[i - <span class="number">1</span>], num[rk[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = query(RT[dfn[i] - <span class="number">1</span>], RT[dfn[i] + sz[i] - <span class="number">1</span>], (sz[i] + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> mid1 = sz[i] == <span class="number">1</span> ? <span class="number">1e5</span> : query(RT[dfn[i] - <span class="number">1</span>], RT[dfn[i] + sz[i] - <span class="number">1</span>], (sz[i] + <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        tmp[i].push_back((tcurts)&#123; <span class="number">1</span>, mid, mid1 &#125;), tmp[i].push_back((tcurts)&#123; mid + <span class="number">1</span>, mx, mid &#125;), m[i] = mid, all += mid;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-GCD再放送"><a href="#T2-GCD再放送" class="headerlink" title="T2 GCD再放送"></a>T2 GCD再放送</h1><p>定义一个序列$\{a_1,a_2,\cdots,a_k\}$的价值之和为其所有区间的$\gcd$之和，即</p><script type="math/tex; mode=display">\sum_{i=1}^k\sum_{j=i}^k\gcd\{a_i,\cdots, a_j\}</script><p>现在给出$n$个序列，这$n$个序列会随机地拼接成一个大的序列，求出这$n!$种拼接方式最后形成的序列的价值之和，对$10^9+7$取模</p><script type="math/tex; mode=display">n,\sum k\leq 10^5,b_i\leq 10^5</script><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>首先反演一波，单独考虑一个序列的答案</p><p>设$F(x)$为$\gcd$恰好为$x$的区间个数，$G(x)$为$\gcd$为$x$的倍数的区间个数</p><p>$G(x)$很好求，即考虑哪些数是$x$的倍数，这样这个序列就变成了一个$01$串，$1$代表这个位置的数是$x$的倍数，我们只需要统计有多少个区间全是$1$</p><script type="math/tex; mode=display">\begin{aligned}G(x)&=\sum_{x|d}F(d)\\F(x)&=\sum_{x|d}G(d)\mu(\frac dx)\\ans&=\sum_{i\geq 1}i\times F(i)\\&=\sum_{i\geq 1}i\times \sum_{i|d}G(d)\mu(\frac di)\\&=\sum_{d\geq 1}G(d)\sum_{i|d}i\times \mu(\frac di)\\&=\sum_{d\geq 1}G(d)\varphi(d)\end{aligned}</script><p>如果每个区间的长度都是$1$，那么我们可以直接考虑对于一个区间$[l,r]$，对于某个约数在多少个排列里面这个区间全是$1$</p><p>这个的方案数显然就是一个组合数再乘一个阶乘</p><p>事实上我们并不需要枚举$l$，我们只需要知道这个区间的长度就行了，即我们只需要知道这两个端点中间夹了多少个$1$</p><p>考虑更一般的情况，容易发现最后每个区间$[l,r]$的左右端点只有四种情况：</p><ul><li>左右端点落在同一段内</li><li>左右端点一个落在一个全$1$段，另一个落在某一段的前缀$1$/后缀$1$中</li><li>一个落在前缀$1$，另一个落在后缀$1$中</li><li>两个端点都落在全$1$段中</li></ul><p>枚举左右端点直接有多少个完整的全$1$段，我们可以将同一类的区间揉在一起统计</p><p>因此维护全$1$段的段数、段长之和、段长的平方之和以及前后缀段的前缀之和、后缀之和以及前缀后缀的乘积之和即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N], n, frac[N], st[N], ed[N], bel[N], inv[N], sum2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _p[N], _s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pos[d].size()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> full = <span class="number">0</span>, full1 = <span class="number">0</span>, full2 = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">0</span>, suf = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : pos[d]) _p[bel[t]] = _s[bel[t]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> add = [&amp;](<span class="keyword">int</span> len) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">        res = (res + (LL)len * (len + <span class="number">1</span>) / <span class="number">2</span> % mod * frac[n]) % mod;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> process = [&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> A = bel[a], B = bel[b], len = b - a + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (A == B) &#123;</span><br><span class="line">            add(len);</span><br><span class="line">            <span class="keyword">if</span> (a == st[A] &amp;&amp; b == ed[B]) full++, full1 += len, full2 = (full2 + (LL)len * len) % mod;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a == st[A]) _p[A] = len;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (b == ed[A]) _s[A] = len;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> l = a == st[A] ? A : A + <span class="number">1</span>, r = b == ed[B] ? B : B - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (l &lt;= r) &#123;</span><br><span class="line">                full += r - l + <span class="number">1</span>, full1 += ed[r] - st[l] + <span class="number">1</span>, full2 = ((LL)full2 + sum2[r] - sum2[l - <span class="number">1</span>] + mod) % mod;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) add(ed[i] - st[i] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a != st[A]) _s[A] = ed[A] - a + <span class="number">1</span>, add(_s[A]);</span><br><span class="line">            <span class="keyword">if</span> (b != ed[B]) _p[B] = b - st[B] + <span class="number">1</span>, add(_p[B]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos[d].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j + <span class="number">1</span> &lt; pos[d].size() &amp;&amp; pos[d][j + <span class="number">1</span>] == pos[d][j] + <span class="number">1</span>) j++;</span><br><span class="line">        process(pos[d][i], pos[d][j]), i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos[d].size(); i++) </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || bel[pos[d][i]] != bel[pos[d][i - <span class="number">1</span>]]) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = bel[pos[d][i]];</span><br><span class="line">            pre += _p[cur], suf += _s[cur], sum = (sum + (LL)_p[cur] * _s[cur]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> A = ((LL)pre * suf - sum) % mod, B = ((LL)full1 * full1 - full2) % mod;</span><br><span class="line">    A = (A + mod) % mod, B = (B + mod) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= full; i++) <span class="keyword">if</span> (n - i - <span class="number">2</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = (LL)A * C(full, i) % mod;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; full) tmp = (tmp + (LL)(pre + suf) * full1 % mod * C(full - <span class="number">1</span>, i)) % mod;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; full - <span class="number">1</span>) tmp = (tmp + (LL)B * C(full - <span class="number">2</span>, i)) % mod;</span><br><span class="line">        res = (res + (LL)tmp * frac[i] % mod * frac[n - i - <span class="number">2</span>] % mod * (n - i - <span class="number">1</span>)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> phi[N], flag[N], prime[N], pcnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N - <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag[i]) prime[++pcnt] = i, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pcnt &amp;&amp; i * prime[j] &lt;= N - <span class="number">10</span>; j++) &#123;</span><br><span class="line">            flag[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                phi[i * prime[j]] = phi[i] * prime[j]; <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            phi[i * prime[j]] = phi[i] * (prime[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> tp = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> k; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k), st[i] = tp + <span class="number">1</span>, ed[i] = tp + k;</span><br><span class="line">        <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[++tp]), bel[tp] = i, mx = max(mx, num[tp]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= num[tp]; j++) <span class="keyword">if</span> (num[tp] % j == <span class="number">0</span>) &#123;</span><br><span class="line">                pos[j].push_back(tp);</span><br><span class="line">                <span class="keyword">if</span> (j != num[tp] / j) pos[num[tp] / j].push_back(tp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = ed[i] - st[i] + <span class="number">1</span>;</span><br><span class="line">        sum2[i] = (sum2[i - <span class="number">1</span>] + (LL)len * len) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; sieve();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mx; i++) res = (res + (LL)solve(i) * phi[i]) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-dict"><a href="#T3-dict" class="headerlink" title="T3 dict"></a>T3 dict</h1><p>给定一个$1\cdots n$的排列$p_{1\cdots n}$，定义两个大小为$n$的不可重集合$A,B$的字典序比较方式为：</p><p>先比较$A$和$B$的第$p_1$小元素，较小的那个字典序较小，否则就比较第$p_2$小的元素，以此类推</p><p>现在给定$p_{1\cdots n}$和一个大小为$n$的不可重集合$B$，求有多少个值在$1\cdots m$，大小为$n$的不可重集合$A$满足$A$的字典序比$B$小，答案对$998244353$取模</p><script type="math/tex; mode=display">n,m\leq 2\times 10^5</script><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>按照比较字典序的方法，我们枚举在哪一次比较时，$A$的元素比$B$的对应元素要小</p><p>这样$A$在这一位之前的元素都必须与$B$在这一位之前的元素相同，而$A$后面的元素可以随便选</p><p>将$B$中的元素从小到大排序，假设现在比较到了第$p_i$小的元素，这就意味着$p_1,p_2,\cdots,p_{i-1}$这些位置中填的数已经确定了</p><p>假设在这些位置之中，比$p_i$小的最大的位置为$p_j$，比$p_i$大的最小的位置为$p_k$</p><p>如果$p_j$不存在，那么我们认为$p_j=0$；如果$p_k$不存在，那么我们认为$p_k=n+1$</p><p>显然在$p_j$以及$p_j$之前的位置、在$p_k$以及$p_k$之后的这些位置的方案数已经确定了，因为$p_j,p_k$这两个位置的值必须等于$B$中对应的值，在$p_i$处填的数无论如何也不会影响到这些位置</p><p>因此我们只需要考虑$(p_j,p_k)$这些位置</p><p>假设$B_{p_i}$减去$B_{p_j}$的值为$r+1$，那么$A_{p_i}$至多为$A_{p_j}+r$</p><p>假设$B_{p_k}$减去$B_{p_j}$的值是$t+1$，那么$A_{p_i}$至多为$A_{p_j}+t$</p><p>设$a$为$p_i-p_j-1$，即$p_i$左边的空位的个数，$b$为$p_k-p_i-1$，即$p_i$右边的空位的个数</p><p>那么此时这一段的方案数就是</p><script type="math/tex; mode=display">\sum_{i=1}^r{i-1\choose a}{t-i\choose b}</script><p>如果$i$能取到$t$的上界，那么这个式子就是一个简单的组合恒等式，显然它等于${m\choose a+b+1}$</p><p>然后，似乎没有什么好的优化方法</p><p>注意到一件事情，当$i-1&lt;a$或$t-i&lt;b$时显然对答案的贡献是$0$</p><p>当$r-a$比较小的时候，我们暴力枚举$i$</p><p>否则，我们考虑用$i=[1,t]$的答案减去$i=[r+1,t]$的答案</p><p>这样的复杂度是对的，因为这实际上是一个启发式分裂的过程，因此复杂度为$n\log n$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> up, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> tot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (up &lt;= <span class="number">0</span> || tot &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, A = min(tot - b, up) - a, B = tot - b - up;</span><br><span class="line">    <span class="keyword">if</span> (A &lt; B) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = a + <span class="number">1</span>; i &lt;= up &amp;&amp; tot - i &gt;= b; i++) </span><br><span class="line">            res = (res + (LL)C(i - <span class="number">1</span>, a) * C(tot - i, b)) % mod;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = C(tot, a + b + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = up + <span class="number">1</span>; tot - i &gt;= b; i++) </span><br><span class="line">            res = (res - (LL)C(i - <span class="number">1</span>, a) * C(tot - i, b)) % mod;</span><br><span class="line">        res = (res + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N], p[N], tree[N], n; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l, r, down, up, val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> data &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> l &lt; b.l;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;data&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">    sort(num + <span class="number">1</span>, num + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i]);</span><br><span class="line">    frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, coef = <span class="number">1</span>; s.insert((data)&#123; <span class="number">1</span>, n, <span class="number">1</span>, m, <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> pos = *--s.upper_bound((data)&#123; p[i] &#125;); s.erase(pos);</span><br><span class="line">        coef = (LL)coef * Pow(pos.val, mod - <span class="number">2</span>) % mod;</span><br><span class="line">        res = (res + (LL)coef * process(num[p[i]] - pos.down, p[i] - pos.l, pos.r - p[i], pos.up - pos.down + <span class="number">1</span>)) % mod;</span><br><span class="line">        <span class="keyword">if</span> (p[i] != pos.l) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = C(num[p[i]] - pos.down, p[i] - pos.l); coef = (LL)coef * w % mod;</span><br><span class="line">            s.insert((data)&#123; pos.l, p[i] - <span class="number">1</span>, pos.down, num[p[i]] - <span class="number">1</span>, w&#125;);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (p[i] != pos.r) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = C(pos.up - num[p[i]], pos.r - p[i]); coef = (LL)coef * w % mod;</span><br><span class="line">            s.insert((data)&#123; p[i] + <span class="number">1</span>, pos.r, num[p[i]] + <span class="number">1</span>, pos.up, w &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫比乌斯反演 </tag>
            
            <tag> 启发式合并 </tag>
            
            <tag> 主席树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF582D Number of Binominal Coefficients</title>
      <link href="/2020/03/13/cf582d-number-of-binominal-coefficients/"/>
      <url>/2020/03/13/cf582d-number-of-binominal-coefficients/</url>
      
        <content type="html"><![CDATA[<p>统计有序对$(k,n)$的数量，满足$0\leq k\leq n\leq A$，且$n\choose k$能被$p^a$整除</p><script type="math/tex; mode=display">1\leq p,a\leq 10^9,0\leq A\leq 10^{1000}</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>库默尔定理：</p><p>组合数$n+m\choose m$所含$p$的次数为$n,m$在$p$进制下相加的进位次数</p><p>证明：次数为</p><script type="math/tex; mode=display">\sum_{i\geq 1}\lfloor\frac{n+m}{p_i}\rfloor-\sum_{i\geq 1}\lfloor\frac{n}{p_i}\rfloor-\sum_{i\geq 1}\lfloor\frac{m}{p_i}\rfloor\\=\sum_{i\geq 1}\lfloor\frac{n+m}{p_i}\rfloor-\lfloor\frac{n}{p_i}\rfloor-\lfloor\frac{m}{p_i}\rfloor</script><p>$\lfloor\frac{n}{p_i}\rfloor$表示$n$在$p$进制下去掉最后$i$位，如果$n+m$在第$i+1$位收到了来自第$i$位的进位，那么就意味着</p><p>$\lfloor\frac{n+m}{p_i}\rfloor-\lfloor\frac{n}{p_i}\rfloor-\lfloor\frac{m}{p_i}\rfloor=1$</p><p>因此上面的式子等价于$m+n$在$p$进制下的进位次数</p><p>有用的$a$只有$3500$左右</p><p>因此我们可以数位<code>dp</code></p><p><code>dp[i][j][1/0][1/0]</code>代表当前到了第$i$位，进位次数为$j$，当前$n+m$是否与$A$相等，下一位是否必须进位到这一位</p><p>这个题的转移非常恶心</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>, N = <span class="number">3510</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][<span class="number">2</span>][N][N], a[N], p, n, lim;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &gt;= <span class="number">2</span> * p - <span class="number">2</span>) <span class="keyword">return</span> (LL)p * p % mod;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; p) <span class="keyword">return</span> (LL)(r + <span class="number">2</span>) * (r + <span class="number">1</span>) / <span class="number">2</span> % mod;</span><br><span class="line">    <span class="keyword">return</span> ((LL)(r - p + <span class="number">1</span>) * p + (LL)(p - r + p - <span class="number">1</span>) * (r + <span class="number">2</span>) / <span class="number">2</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> get(r) - get(l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span> ? x : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> cnt, <span class="keyword">int</span> t1, <span class="keyword">int</span> t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == n + <span class="number">1</span>) <span class="keyword">return</span> t2 == <span class="number">0</span> &amp;&amp; cnt &gt;= lim;</span><br><span class="line">    <span class="keyword">if</span> (~dp[t1][t2][cur][cnt]) <span class="keyword">return</span> dp[t1][t2][cur][cnt];</span><br><span class="line">    <span class="keyword">int</span> &amp;sum = dp[t1][t2][cur][cnt]; sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t2) &#123;</span><br><span class="line">            sum = (sum + (LL)DP(cur + <span class="number">1</span>, cnt, <span class="number">1</span>, <span class="number">0</span>) * (p - <span class="number">1</span> - a[cur]) % mod + (LL)DP(cur + <span class="number">1</span>, cnt + <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * (p - a[cur])) % mod;</span><br><span class="line">            sum = (sum + (LL)DP(cur + <span class="number">1</span>, cnt, <span class="number">0</span>, <span class="number">0</span>) * get(p, p + a[cur] - <span class="number">1</span>) % mod + (LL)DP(cur + <span class="number">1</span>, cnt + <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>) * get(p - <span class="number">1</span>, p + a[cur] - <span class="number">2</span>)) % mod; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum = (sum + (LL)DP(cur + <span class="number">1</span>, cnt, <span class="number">1</span>, <span class="number">0</span>) * (a[cur] + <span class="number">1</span>) % mod + (LL)DP(cur + <span class="number">1</span>, cnt + <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * a[cur]) % mod;</span><br><span class="line">            sum = (sum + (LL)DP(cur + <span class="number">1</span>, cnt, <span class="number">0</span>, <span class="number">0</span>) * get(a[cur] - <span class="number">1</span>) % mod + (LL)DP(cur + <span class="number">1</span>, cnt + <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>) * get(a[cur] - <span class="number">2</span>)) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t2) sum = (sum + (LL)DP(cur + <span class="number">1</span>, cnt, <span class="number">0</span>, <span class="number">0</span>) * get(p, <span class="number">2</span> * p - <span class="number">2</span>) % mod + (LL)DP(cur + <span class="number">1</span>, cnt + <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>) * get(p - <span class="number">1</span>, <span class="number">2</span> * p - <span class="number">2</span>)) % mod;</span><br><span class="line">        <span class="keyword">else</span> sum = (sum + (LL)DP(cur + <span class="number">1</span>, cnt, <span class="number">0</span>, <span class="number">0</span>) * get(p - <span class="number">1</span>) % mod + (LL)DP(cur + <span class="number">1</span>, cnt + <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>) * get(p - <span class="number">2</span>)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = (sum + mod) % mod;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> t[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;p, &amp;lim, s + <span class="number">1</span>); <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (lim &gt;= <span class="number">3500</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) t[i] = s[i] - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">233</span>) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) <span class="keyword">if</span> (t[i]) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;</span><br><span class="line">        LL nw = <span class="number">0</span>; <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            nw = nw * <span class="number">10</span> + t[i];</span><br><span class="line">            <span class="keyword">if</span> (!l &amp;&amp; nw &gt;= p) tmp[++l] = nw / p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (l) tmp[++l] = nw / p;</span><br><span class="line">            nw %= p;</span><br><span class="line">        &#125;</span><br><span class="line">        a[++n] = nw;</span><br><span class="line">        len = l, <span class="built_in">memcpy</span>(t, tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (l + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, DP(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 数位 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF521E Cycling City</title>
      <link href="/2020/03/13/cf521e-cycling-city/"/>
      <url>/2020/03/13/cf521e-cycling-city/</url>
      
        <content type="html"><![CDATA[<p>给出一张$n$个点$m$条边的无向图，求图中是否存在两个点，满足这两个点之间至少有三条除起点、终点外不共点的简单路径</p><p>如果不存在，输出<code>NO</code>，否则需要输出任意一种方案</p><script type="math/tex; mode=display">n\leq 2\times 10^5</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先建出原图的任意一棵生成树，考虑以下三种情况</p><p><img src="1584107840916.png" alt=""></p><p>我们可以发现，如果存在一条树边被至少两条非树边覆盖，那么就一定是<code>YES</code></p><p>可以用树上差分找到两条相交的路径，然后这两条路径的交一定满足条件</p><p>只需要<code>dfs</code>出这三条路径即可，注意只能走树边以及选出的两条边</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> from, to, next;&#125; e[N * <span class="number">20</span>], e2[N * <span class="number">10</span>];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt, vis[N], fa[N][<span class="number">18</span>], dep[N], ok[N * <span class="number">10</span>], ecnt2; <span class="built_in">map</span>&lt;P, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fir, sec; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = f, dep[u] = dep[f] + <span class="number">1</span>, vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">17</span>; i++) fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">        adde(v, u); <span class="keyword">int</span> a = v, b = u; <span class="keyword">if</span> (a &gt; b) swap(a, b);</span><br><span class="line">        ok[mp[P(a, b)]] = <span class="number">1</span>, dfs(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[a] &lt; dep[b]) swap(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (dep[fa[a][i]] &gt;= dep[b]) a = fa[a][i];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i];</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; add[N], del[N], fuck[N]; <span class="keyword">bool</span> flg;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lca = LCA(a, b);</span><br><span class="line">    add[a].insert(id), add[b].insert(id), del[lca].insert(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i &amp;&amp; !flg; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs2(e[i].to, u);</span><br><span class="line">    <span class="keyword">if</span> (flg) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : add[u]) fuck[u].insert(v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f &amp;&amp; fuck[e[i].to].size()) fuck[u].insert(*fuck[e[i].to].begin());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : del[u]) fuck[u].erase(v);</span><br><span class="line">    <span class="keyword">if</span> (fuck[u].size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        fir = *fuck[u].begin(), fuck[u].erase(fuck[u].begin()), sec = *fuck[u].begin();</span><br><span class="line">        flg = <span class="literal">true</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp[N], to, stk[N], top, hh, tmp2[N * <span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == to) &#123;</span><br><span class="line">        hh = <span class="number">1</span>, <span class="built_in">printf</span>(<span class="string">"%d "</span>, top);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= top; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, stk[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>); <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) <span class="keyword">if</span> (!tmp[v]) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = u, b = v; <span class="keyword">if</span> (a &gt; b) swap(a, b); <span class="keyword">int</span> t = mp[P(a, b)];</span><br><span class="line">        <span class="keyword">if</span> (tmp2[t]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!ok[t] &amp;&amp; t != fir &amp;&amp; t != sec) <span class="keyword">continue</span>;</span><br><span class="line">        tmp2[t] = <span class="number">1</span>, stk[++top] = v, dfs3(v), top--;</span><br><span class="line">        <span class="keyword">if</span> (hh) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> b1, <span class="keyword">int</span> b2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> p[<span class="number">5</span>];</span><br><span class="line">    p[<span class="number">1</span>] = LCA(a1, b1), p[<span class="number">2</span>] = LCA(a1, b2), p[<span class="number">3</span>] = LCA(a2, b1), p[<span class="number">4</span>] = LCA(a2, b2);</span><br><span class="line">    sort(p + <span class="number">1</span>, p + <span class="number">5</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> dep[a] &gt; dep[b];&#125;);</span><br><span class="line">    <span class="keyword">int</span> A = p[<span class="number">1</span>], B = p[<span class="number">2</span>];</span><br><span class="line">    hh = <span class="number">0</span>, to = B, stk[top = <span class="number">1</span>] = A, dfs3(A), hh = <span class="number">0</span>, top = <span class="number">1</span>, dfs3(A), hh = <span class="number">0</span>, top = <span class="number">1</span>, dfs3(A);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b); <span class="keyword">if</span> (a &gt; b) swap(a, b);</span><br><span class="line">        G[a].push_back(b), G[b].push_back(a), e2[++ecnt2] = (edge)&#123;a, b, <span class="number">0</span>&#125;, mp[P(a, b)] = ecnt2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (!vis[i]) dfs(i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ecnt2; i++) <span class="keyword">if</span> (!ok[i]) mark(e2[i].from, e2[i].to, i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (!fa[i][<span class="number">0</span>]) &#123;</span><br><span class="line">        dfs2(i, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (flg) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"YES"</span>), work(e2[fir].from, e2[fir].to, e2[sec].from, e2[sec].to);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>析合树</title>
      <link href="/2020/03/13/xi-he-shu/"/>
      <url>/2020/03/13/xi-he-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="连续段"><a href="#连续段" class="headerlink" title="连续段"></a>连续段</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>对于排列$P$，如果对于一段区间$[l,r]$，满足$P_{l\sim r}$是连续的，那么我们将区间$[l,r]$称为连续段</p><p>形式化地来讲， 如果$[l,r]$是连续段，那么不存在 $x &lt; l$ 或 $x &gt; r$，使得存在$l&lt;a&lt;r,l&lt;b&lt;r$，满足$P_a &lt; P_x &lt; P_b$</p><p>比如对于排列<code>1 3 2 4 5</code>，<code>2 4 5</code>不是连续段，因为其值域不连续；而<code>3 2 4 5</code>是一个连续段</p><p>我们将排列$P$的所有连续段构成的集合记为$I_P$</p><a id="more"></a><h2 id="连续段的性质"><a href="#连续段的性质" class="headerlink" title="连续段的性质"></a>连续段的性质</h2><p>对于两个相交的区间$A,B$，如果$A,B$均为连续段，那么</p><ul><li>$A\cap B$是连续段</li></ul><p>若存在$x\not \in A\cap B$使得存在$a\in A\cap B,b\in A\cap B$使得$P_a&lt;P_x&lt;P_b$，那么无论$x$落在哪个区域都会导致$A,B$至少一个区间不再是连续段，与假设矛盾</p><ul><li>$A\cup B$是连续段</li></ul><p>$A$值域连续，$B$值域连续，显然$A\cup B$值域连续</p><ul><li>$A\setminus B,B\setminus A$是连续段</li></ul><p>$A\cap B$的值域就是$A,B$的值域相交的部分，因为$A\cap B$是连续段，故$A\setminus B,B\setminus A$也是连续段</p><h1 id="析合树"><a href="#析合树" class="headerlink" title="析合树"></a>析合树</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><h3 id="本原连续段"><a href="#本原连续段" class="headerlink" title="本原连续段"></a>本原连续段</h3><p>对于排列$P$，如果$A\in I_P$，且不存在$B\in I_P,B\not= A$使得$A,B$不存在包含关系但是相交，那么我们称$A$是$P$的一个<strong>本原连续段</strong></p><p>例如在排列<code>1 2 3 4</code>中，<code>2 3</code>就不是本原连续段，因为<code>1 2</code>与它相交但是互不包含</p><p>显然每个长度为$1$的区间都是本原连续段</p><p>根据本原连续段的定义，任意两个本原连续段间只能存在包含或相离关系，即它们形成了一棵树状的结构，我们将这个树状结构称为析合树</p><h3 id="析点与合点"><a href="#析点与合点" class="headerlink" title="析点与合点"></a>析点与合点</h3><p>析合树上的每一个点都是一个本原连续段，并且有析点和合点之分</p><p>考虑对于排列<code>9 1 10 3 2 5 7 6 8 4</code>建出析合树</p><p><img src="1584107146871.png" alt=""></p><p>图中蓝色代表合点，橙色代表析点</p><p>对于析合树上的一个点，我们将它的所有儿子按照在排列中的下标排好</p><p>那么对于合点，<strong>完整包含其儿子的任意一个子串都是连续段</strong></p><p>比如，对于图中$[5,8]$这个节点，它有$3$个儿子$[5,5],[6,7],[8,8]$</p><p>那么$[5,7],[6,8]$也是连续段</p><p>也就是它的所有儿子是按照值域排好的，要么从大到小，要么从小到大</p><p>与合点相对的是析点，<strong>它的任意一个完整包含其儿子的子串都不是连续段</strong></p><p>比如，对于$[1,10]$这个节点，它的儿子是$[9,9],[1,1],[10,10],[2,8]$</p><p>显然$[9,9]\cup[1,1]$不是连续段，$[10,10],[2,8]$同理</p><p>合点的性质很好证明，下面来证明析点的性质</p><p>我们考虑一个析点的所有儿子</p><p>如果存在它儿子序列的一个子区间，使得这个区间也是连续段，我们考虑满足这种条件的最大区间</p><p>由于它是最大的，因此找不到另一个与它相交，但不包含的区间</p><p>也就是说，这一段区间也是一个本原连续段，我们应该为它新建一个节点，与析合树的定义矛盾</p><p>析合树的另一个性质是：合点至少有$2$个儿子，而析点至少有$4$个儿子</p><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>考虑使用增量法构造析合树，即先构造出前$i-1$个点的析合森林，然后再加入第$i$个点</p><p>构造其实很简单，大致分为四步</p><ol><li>如果最后一个点是合点，并且当前点能合并到合点中，那么就合并，并且将合并之后的点作为当前点</li><li>否则，如果上一个点与当前点能够合并，那么我们新建一个合点，将上一个点与这一个点作为它的两个儿子</li><li>否则，向前找到最后一个点，使得这个点到当前点中间的所有点能构成连续段，新建一个析点，并将这些点作为它的儿子。可以证明一定存在这样一个点</li><li>重复以上操作直到不能合并为止，即最后一个点的左端点小于$i$作为右端点的所有连续段中，最靠左的左端点</li></ol><p>那么问题来了，如何判断一个区间是否是连续段</p><p>一个区间是连续段当且仅当这个区间的值域连续，也就是</p><script type="math/tex; mode=display">\max_{i=l}^ra_i-\min_{i=l}^ra_i=r-l</script><p>因此使用<code>RMQ</code>即可$O(1)$判断一个区间是否是连续段</p><p>第二个问题是，如何找到所有右端点是$i$的连续段的最靠左的左端点呢</p><p>由于$P$是一个排列，因此对于$P$的任意一个区间，都有</p><script type="math/tex; mode=display">\max_{i=l}^ra_i-\min_{i=l}^ra_i\geq r-l\\\max_{i=l}^ra_i-\min_{i=l}^ra_i-r+l\geq 0</script><p>故我们可以用线段树维护上式的最小值，然后找到第一个为$0$的位置即可</p><p>考虑加入$i$时会对区间造成哪些影响</p><p>首先，所有区间的$r$会$+1$，即区间减</p><p>然后我们使用单调栈维护$\min,\max$，每次弹栈的时候栈中相邻两个元素之间的区间的$\min/\max$一定是相同的，我们可以先将其减去其原来的值，最后再加上$a_i$</p><p>代码如下（对应<code>CF526F Pudding Monsters</code>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RMQ</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> lg[N], mn[<span class="number">19</span>][N], mx[<span class="number">19</span>][N];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) mn[<span class="number">0</span>][i] = mx[<span class="number">0</span>][i] = a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">18</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= n; j++) &#123;</span><br><span class="line">                mn[i][j] = min(mn[i - <span class="number">1</span>][j], mn[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)]);</span><br><span class="line">                mx[i][j] = max(mx[i - <span class="number">1</span>][j], mx[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)]);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = lg[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> min(mn[len][l], mn[len][r - (<span class="number">1</span> &lt;&lt; len) + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = lg[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> max(mx[len][l], mx[len][r - (<span class="number">1</span> &lt;&lt; len) + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SEG</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> l, r, mn, mx, tag;</span><br><span class="line">    &#125; T[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">        T[rt].mn = min(T[rt &lt;&lt; <span class="number">1</span>].mn, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mn);</span><br><span class="line">        T[rt].mx = max(T[rt &lt;&lt; <span class="number">1</span>].mx, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">        T[rt &lt;&lt; <span class="number">1</span>].mn += T[rt].tag, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mn += T[rt].tag;</span><br><span class="line">        T[rt &lt;&lt; <span class="number">1</span>].mx += T[rt].tag, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mx += T[rt].tag;</span><br><span class="line">        T[rt &lt;&lt; <span class="number">1</span>].tag += T[rt].tag, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].tag += T[rt].tag, T[rt].tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        T[rt].l = l, T[rt].r = r; </span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(rt &lt;&lt; <span class="number">1</span>, l, mid), build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) &#123;</span><br><span class="line">            T[rt].tag += x, T[rt].mn += x, T[rt].mx += x;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T[rt].tag) pushdown(rt);</span><br><span class="line">        <span class="keyword">if</span> (start &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, start, end, x);</span><br><span class="line">        <span class="keyword">if</span> (end &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, start, end, x);</span><br><span class="line">        pushup(rt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = T[rt].l, r = T[rt].r;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">if</span> (T[rt].tag) pushdown(rt);</span><br><span class="line">        <span class="keyword">if</span> (!T[rt &lt;&lt; <span class="number">1</span>].mn) <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Judge</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> D.Max(l, r) - D.Min(l, r) == r - l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stk1[N], stk2[N], tp1, tp2;</span><br><span class="line"><span class="keyword">int</span> stk[N], tp, L[N * <span class="number">2</span>], R[N * <span class="number">2</span>], M[N * <span class="number">2</span>], ncnt, type[N * <span class="number">2</span>], ch[N * <span class="number">2</span>];</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * L, R: 该连续段在排列中对应的下标</span></span><br><span class="line"><span class="comment"> * type: 1代表该点为合点，否则为析点</span></span><br><span class="line"><span class="comment"> * ch: 该点的儿子数量</span></span><br><span class="line"><span class="comment"> * stk1, stk2: 区间min, max的单调栈</span></span><br><span class="line"><span class="comment"> * M: 合点的最后一个儿子的左端点，用于判断是否能够合并</span></span><br><span class="line"><span class="comment"> * stk: 当前析合森林中所有的根</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (tp1 &amp;&amp; a[i] &lt;= a[stk1[tp1]]) </span><br><span class="line">            T.update(<span class="number">1</span>, stk1[tp1 - <span class="number">1</span>] + <span class="number">1</span>, stk1[tp1], a[stk1[tp1]]), tp1--;</span><br><span class="line">        <span class="keyword">while</span> (tp2 &amp;&amp; a[i] &gt;= a[stk2[tp2]]) </span><br><span class="line">            T.update(<span class="number">1</span>, stk2[tp2 - <span class="number">1</span>] + <span class="number">1</span>, stk2[tp2], -a[stk2[tp2]]), tp2--;</span><br><span class="line">        T.update(<span class="number">1</span>, stk1[tp1] + <span class="number">1</span>, i, -a[i]), T.update(<span class="number">1</span>, stk2[tp2] + <span class="number">1</span>, i, a[i]);</span><br><span class="line">        stk1[++tp1] = i, stk2[++tp2] = i;</span><br><span class="line">        <span class="keyword">int</span> nw = ++ncnt, Li = T.query(<span class="number">1</span>); L[nw] = R[nw] = i;</span><br><span class="line">        <span class="keyword">while</span> (tp &amp;&amp; L[stk[tp]] &gt;= Li) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type[stk[tp]] &amp;&amp; Judge(M[stk[tp]], i)) &#123;</span><br><span class="line">                R[stk[tp]] = i, ch[stk[tp]]++, nw = stk[tp--];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Judge(L[stk[tp]], i)) &#123;</span><br><span class="line">                ncnt++, type[ncnt] = <span class="number">1</span>, ch[ncnt] = <span class="number">2</span>;</span><br><span class="line">                L[ncnt] = L[stk[tp]], R[ncnt] = i, M[ncnt] = L[nw], tp--, nw = ncnt;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ncnt++, ch[ncnt] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    ch[ncnt]++, tp--;</span><br><span class="line">                &#125; <span class="keyword">while</span> (tp &amp;&amp; !Judge(L[stk[tp]], i));</span><br><span class="line">                L[ncnt] = L[stk[tp]], R[ncnt] = i, tp--, nw = ncnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++tp] = nw, T.update(<span class="number">1</span>, <span class="number">1</span>, i, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[N], y[N], id[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x[i], &amp;y[i]), id[i] = i;</span><br><span class="line">    sort(id + <span class="number">1</span>, id + n + <span class="number">1</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">        <span class="keyword">return</span> x[a] &lt; x[b];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = y[id[i]];</span><br><span class="line">    D.build(), T.build(<span class="number">1</span>, <span class="number">1</span>, n), build();</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ncnt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type[i]) res += (LL)ch[i] * (ch[i] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 析合树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF583E Superior Periodic Subarrays</title>
      <link href="/2020/03/13/cf583e-superior-periodic-subarrays/"/>
      <url>/2020/03/13/cf583e-superior-periodic-subarrays/</url>
      
        <content type="html"><![CDATA[<p>给出一个无限长的循环序列$a_0,a_1,\cdots,a_{n-1},\cdots$，循环节是$n$，即$a_i= a_{i\mod n}$</p><p>现在你要统计数对$(l,s)$的数量，满足$0\leq l&lt;n,1\leq s&lt;n$，且以$l$开头，循环节为$s$的无限序列的每一个元素都比原序列中它对应位置的那个数要大</p><p><img src="https://cdn.luogu.com.cn/upload/vjudge_pic/CF582C/3459142ae634f6d125367238083d1b99f717b1ba.png" alt=""></p><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>假如我们已经确定好了$l,s$，那么如何判断构造好的序列是否满足题意中的条件呢</p><p>取$s,n$的$\gcd=g$，显然$a_l$会与$a_{l},a_{l+g},a_{l+2g},\cdots$比较，即$a_l$必须是这些数中最大的哪个数</p><p>我们将$a_0\cdots a_n$按照下标$\mod g$的情况分类，那么选出的数必须要是它所在的那一类中最大的数</p><p>这启发我们枚举$g$，然后将原序列复制一份并且拼在其后面，将所有满足这个位置上的数是它所在类中的最大数的位置标成$1$，其余位置标成$0$，那么一个序列$l,s$需要满足$l$到$l+s-1$这些位置全部为$1$</p><p>然后就很简单了，我们从后向前枚举，同时处理出当前位置出发的极长$1$序列的长度，$s$的方案数只与$g$以及这个长度有关，可以预处理出来</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N], g[N], t[N], mx[N], len[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) g[i] = gcd(i, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) t[j] = t[j - <span class="number">1</span>] + (g[j] == i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) mx[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) mx[j % i] = max(mx[j % i], num[j]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[j % n] == mx[j % i]) len[j] = len[j + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> len[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) </span><br><span class="line">            res += t[min(n - <span class="number">1</span>, len[j])];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF568C New Language</title>
      <link href="/2020/03/13/cf568c-new-language/"/>
      <url>/2020/03/13/cf568c-new-language/</url>
      
        <content type="html"><![CDATA[<p>有一个长度为$n$的单词，每个字母要么是元音，要么是辅音。有$m$条规则，每条规则形如“如果$a$的字母类型为$t_1$，则$b$的字母类型为$t_2$”</p><p>你需要找到满足这$m$条限制的一个长度为$n$的单词，这个单词的字典序不能小于$s$</p><p>如果有多个单词满足条件，输出字典序最小的那个</p><script type="math/tex; mode=display">n\leq 200,m\leq 4n(n-1)</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>在<code>2SAT</code>中，如果$u$向$v$连了一条边，那么就意味着，如果$u$成立，那么$v$也成立</p><p>我们将每个字母拆成两个点，第一个点代表这个字母为元音，第二个点代表这个字母为辅音。我们将这两个点称为“对立点”</p><p>然后，对于题面中的每一条规则，假设这条规则是“如果$a$是元音，则$b$是辅音”</p><p>那么我们这样连边：从$a$的元音节点向$b$的辅音节点连边，从$b$的元音节点向$a$的辅音节点连边</p><p>前者的原因显然，后者成立的原因是如果原命题成立，那么它的逆否命题也成立</p><p>然后我们在建出的图上跑强连通分量，如果最后存在一个点，使得它与它的对立点在同一个强连通分量中，那么这个<code>2SAT</code>就无解。因为原命题和它的反命题不可能同时成立</p><p>回到这道题，我们从后到前枚举答案与$s$的$lcp$，然后判断后面的字母能否满足条件，遇到第一个满足条件的位置就<code>break</code></p><p>然后我们再从前到后依次贪心地确定每一位即可</p><p>由于这个题中规则的数量巨大，因此每一次暴力跑会T飞，在一开始的时候就将所有规则构成的强连通分量预处理出来，然后每次在这个强连通分量的基础上加边即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">410</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * N * <span class="number">2</span>], e2[N * N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt, vis[N], stk[N], top, dfn[N], low[N], dfsn, head2[N], ecnt2;</span><br><span class="line"><span class="keyword">int</span> scc, belong[N], Belong[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    from = Belong[from], to = Belong[to];</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde2</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e2[++ecnt2] = (edge)&#123;to, head2[from]&#125;, head2[from] = ecnt2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> ls)</span> </span>&#123;</span><br><span class="line">    stk[++top] = u, vis[u] = <span class="number">1</span>;</span><br><span class="line">    dfn[u] = low[u] = ++dfsn;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (i != ls) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[e[i].to]) Tarjan(e[i].to, i), low[u] = min(low[u], low[e[i].to]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (vis[e[i].to]) low[u] = min(low[u], dfn[e[i].to]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (low[u] == dfn[u]) &#123;</span><br><span class="line">        scc++; <span class="keyword">int</span> v = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (v != u) &#123;</span><br><span class="line">            v = stk[top--];</span><br><span class="line">            belong[v] = scc, vis[v] = <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Clear</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    fill(head + <span class="number">1</span>, head + n + <span class="number">1</span>, <span class="number">0</span>), fill(dfn + <span class="number">1</span>, dfn + n + <span class="number">1</span>, <span class="number">0</span>), scc = ecnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Just_DOIT</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    assert((n &amp; <span class="number">1</span>) ^ <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (!dfn[Belong[i]]) Tarjan(Belong[i], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; i++) </span><br><span class="line">        <span class="keyword">if</span> (belong[Belong[i]] == belong[Belong[i + n / <span class="number">2</span>]]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ID</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t * n + x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    adde(ID(t ^ <span class="number">1</span>, x), ID(t, x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> t1, <span class="keyword">int</span> t2, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    adde(ID(t1, x), ID(t2, y)), adde(ID(t2 ^ <span class="number">1</span>, y), ID(t1 ^ <span class="number">1</span>, x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nxt[<span class="number">30</span>][<span class="number">2</span>], vowel[<span class="number">30</span>]; <span class="keyword">char</span> s[N], t[N];</span><br><span class="line"><span class="keyword">int</span> T1[N * N], T2[N * N], from[N * N], to[N * N], m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">    Clear(n * <span class="number">2</span>);</span><br><span class="line">    ecnt = ecnt2, <span class="built_in">memcpy</span>(e, e2, <span class="keyword">sizeof</span>(edge) * (ecnt2 + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++) head[i] = head2[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cur; i++) mark(vowel[t[i] - <span class="string">'a'</span>], i);</span><br><span class="line">    <span class="keyword">return</span> Just_DOIT(n * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str + <span class="number">1</span>); <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> cur[<span class="number">2</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        nxt[i][<span class="number">0</span>] = cur[<span class="number">0</span>], nxt[i][<span class="number">1</span>] = cur[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (i) cur[str[i] == <span class="string">'V'</span>] = i - <span class="number">1</span>, vowel[i - <span class="number">1</span>] = str[i] == <span class="string">'V'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++) Belong[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1, c2; <span class="built_in">scanf</span>(<span class="string">"%d %c %d %c"</span>, &amp;from[i], &amp;c1, &amp;to[i], &amp;c2);</span><br><span class="line">        T1[i] = c1 == <span class="string">'V'</span>, T2[i] = c2 == <span class="string">'V'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) mark(T1[i], T2[i], from[i], to[i]);</span><br><span class="line">    <span class="keyword">if</span> (!Just_DOIT(n * <span class="number">2</span>)) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++) Belong[i] = belong[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head[i]; j; j = e[j].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = belong[i], b = belong[e[j].to];</span><br><span class="line">            <span class="keyword">if</span> (a != b) adde2(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>); </span><br><span class="line"><span class="comment">//    cout &lt;&lt; nxt[0][0] &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) t[j] = s[j];</span><br><span class="line">        <span class="keyword">if</span> (i != n) t[i + <span class="number">1</span>] = nxt[s[i + <span class="number">1</span>] - <span class="string">'a'</span> + <span class="number">1</span>][<span class="number">0</span>] + <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (t[i + <span class="number">1</span>] != <span class="string">'a'</span> - <span class="number">1</span> &amp;&amp; check(min(n, i + <span class="number">1</span>))) &#123;</span><br><span class="line">            pos = i; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i != n) t[i + <span class="number">1</span>] = nxt[s[i + <span class="number">1</span>] - <span class="string">'a'</span> + <span class="number">1</span>][<span class="number">1</span>] + <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (i != n &amp;&amp; t[i + <span class="number">1</span>] != <span class="string">'a'</span> - <span class="number">1</span> &amp;&amp; check(min(n, i + <span class="number">1</span>))) &#123;</span><br><span class="line">            pos = i; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!~pos) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pos; i++) t[i] = s[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pos + <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> a = i == pos + <span class="number">1</span> ? nxt[s[i] - <span class="string">'a'</span> + <span class="number">1</span>][<span class="number">0</span>] : nxt[<span class="number">0</span>][<span class="number">0</span>], b = i == pos + <span class="number">1</span> ? nxt[s[i] - <span class="string">'a'</span> + <span class="number">1</span>][<span class="number">1</span>] : nxt[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        a += <span class="string">'a'</span>, b += <span class="string">'a'</span>; </span><br><span class="line">        <span class="keyword">if</span> (a == <span class="string">'a'</span> - <span class="number">1</span>) a = <span class="string">'z'</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="string">'a'</span> - <span class="number">1</span>) b = <span class="string">'z'</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) swap(a, b);</span><br><span class="line">        t[i] = a;</span><br><span class="line">        <span class="keyword">if</span> (t[i] != <span class="string">'z'</span> + <span class="number">1</span> &amp;&amp; check(i)) <span class="keyword">continue</span>;</span><br><span class="line">        t[i] = b;</span><br><span class="line">        <span class="keyword">if</span> (t[i] &lt; <span class="string">'a'</span> || t[i] &gt; <span class="string">'z'</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">putchar</span>(t[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 2-SAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF585E Present for Vitalik the Philatelist</title>
      <link href="/2020/03/13/cf585e-present-for-vitalik-the-philatelist/"/>
      <url>/2020/03/13/cf585e-present-for-vitalik-the-philatelist/</url>
      
        <content type="html"><![CDATA[<p>给出一个长度为$n$的序列$A$，你需要统计<code>pair</code>$(X,S)$的数量</p><p>其中$X$是$A$中的一个数，$S$是$A$的一个子集，且$A$不属于$S$</p><p>要求$\gcd\{S\}\neq 1,\gcd\{X,S\}=1$</p><p>统计所有满足条件的<code>pair</code>的数量，对$10^9+7$取模</p><script type="math/tex; mode=display">n\leq 5\times 10^5,a_i\leq 10^7</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>设$F(x)$表示$S$的$\gcd$是$x$的倍数，且$X$不是$x$的倍数的<code>pair</code>的数量</p><p>$G(x)$表示$S$的$\gcd$恰好是$x$，且$X$不是$x$的倍数的<code>pair</code>的数量</p><p>那么$F,G$满足</p><script type="math/tex; mode=display">F(x)=\sum_{x|d}G(d)\\G(x)=\sum_{x|d}F(d)\mu(\frac{d}{x})</script><p>假设序列中$x$的倍数有$b_x$个</p><p>那么$F(x)=(2^{b_x}-1)(n-b_x)$</p><p>最后的答案就是</p><script type="math/tex; mode=display">\sum_{x\geq 2}G(x)=\sum_{x\geq 2}\sum_{x|d}F(d)\mu(\frac{d}{x})\\=\sum_{d\geq2}F(d)\sum_{x|d,x\geq 1}\mu(\frac{d}{x})\\=-\sum_{d\geq 2}F(d)\mu(d)</script><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buk[N], mu[N], flag[N], prime[N], pcnt, Pow2[<span class="number">500010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N - <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag[i]) prime[++pcnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pcnt &amp;&amp; i * prime[j] &lt;= N - <span class="number">10</span>; j++) &#123;</span><br><span class="line">            flag[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            mu[i * prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, mx = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), sieve();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), buk[a]++, mx = max(mx, a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= mx; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span>; j &lt;= mx; j += i) buk[i] += buk[j];</span><br><span class="line">    Pow2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) Pow2[i] = Pow2[i - <span class="number">1</span>] * <span class="number">2</span> % mod;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= mx; i++) &#123;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; buk[i] &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">int</span> t = (LL)(Pow2[buk[i]] - <span class="number">1</span>) * (n - buk[i]) % mod;</span><br><span class="line">        res = (res - mu[i] * t) % mod;</span><br><span class="line">    &#125;  </span><br><span class="line">    res = (res + mod) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 莫比乌斯反演 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF521D Shop</title>
      <link href="/2020/03/12/cf521d-shop/"/>
      <url>/2020/03/12/cf521d-shop/</url>
      
        <content type="html"><![CDATA[<p>给出$n$个数以及$m$个操作，有$3$种操作：</p><ul><li>将$x_i$改为$a_i$</li><li>将$x_i$加上$a_i$</li><li>将$x_i$乘上$a_i$</li></ul><p>第$i$个操作的编号为$i$，你可以从中选出最多$k$个操作并决定操作顺序，要使得$\prod x_i$最大</p><p>要求输出方案</p><script type="math/tex; mode=display">n,k,m\leq 10^5</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>假设我们已经确定好了要选哪些操作，现在要为这些操作决定顺序</p><p>那么显然操作$1$应该在操作$2$之前，操作$2$应该在操作$3$之前</p><p>同时，我们注意到，如果我们单独考虑一个操作$3$，那么这个操作无论作用于哪个数，最终的答案都是不变的</p><p>这启发我们将前两种操作也转换成操作$3$的形式</p><p>首先，$2$操作是可以被转化成$3$操作的</p><p>假设$2$操作之前这个数是$x$，操作之后变成了$x+a$，那么我们可以将它看作一次$a=\frac{x+a}{x}$的操作$3$</p><p>显然对于同一个数，如果有两个$2$操作，我们会选择$a_i$更大的那一个执行</p><p>因此对于所有$2$操作我们将其按照加的数排序，如果有一个$2$操作在最终方案中被选了，那么所有对$x_i$进行操作，并且加的数比当前操作大的那些操作在最终方案中都会被选</p><p>因此实际上，对于每一个$2$操作，它对所有数乘积的贡献已经确定好了</p><p>具体来说，我们将所有$2$操作按照加的数从大到小排序，同时维护每个数当前经过之前的操作之后变成了多少</p><p>假如此时这个数变成了$x’$，那么选当前操作对答案的贡献就是$\frac{x’+a_i}{x’}$，同时$x’+=a_i$</p><p>然后我们将转换后的$2$操作与$3$操作合在一起排序就可以了</p><p>现在考虑操作$1$</p><p>如果对于同一个数，多次进行操作$1$是没用的，我们只会选$a_i$最大的那一个执行</p><p>这里先说一个结论：<strong>所有操作$2$可以看作$a_i$为$a_i-x_i$</strong>的操作$2$</p><p>如果在最终排序中，这个操作排在所有操作$2$之前，显然没有问题</p><p>否则，可以注意到，所有选出的操作$2$的先后顺序是没有关系的。也就是说，即使我们是按照$a_i$从大到小排序，最后所有的操作$2$之间仍然是可以互换的，而答案显然不变</p><p>因此如果在最优方案中，我们选择了这个操作$1$，我们完全可以将它挪到最前面操作，就可以保证它恰好加上了$a_i-x_i$</p><p>需要注意的一个小细节是，如果当前乘的数$&lt;1$了，那么显然不操作更优秀</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    LL a, b; <span class="keyword">int</span> type, id;</span><br><span class="line">&#125; q[N * <span class="number">3</span>], q2[N * <span class="number">3</span>], q3[N * <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> type[N], x[N], y[N];</span><br><span class="line">LL a[N]; <span class="keyword">int</span> b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k, n, m, tot = <span class="number">0</span>, tot2 = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;type[i], &amp;x[i], &amp;y[i]);</span><br><span class="line">        <span class="keyword">if</span> (type[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (y[i] &gt; y[b[x[i]]]) b[x[i]] = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type[i] == <span class="number">2</span>) &#123;</span><br><span class="line">            q2[++tot2] = (node)&#123;y[i], x[i], <span class="number">2</span>, i&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> q[++tot] = (node)&#123;y[i], <span class="number">1</span>, <span class="number">3</span>, i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (b[i])</span><br><span class="line">        q2[++tot2] = (node)&#123;y[b[i]] - a[i], i, <span class="number">1</span>, b[i]&#125;;</span><br><span class="line">    sort(q2 + <span class="number">1</span>, q2 + tot2 + <span class="number">1</span>, [](node a, node b)&#123;<span class="keyword">return</span> a.a &gt; b.a;&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot2; i++) &#123;</span><br><span class="line">        q[++tot] = (node)&#123;q2[i].a + a[q2[i].b], a[q2[i].b], q2[i].type, q2[i].id&#125;;</span><br><span class="line">        a[q2[i].b] += q2[i].a;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + tot + <span class="number">1</span>, [](node a, node b)&#123;<span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">double</span>)a.a / a.b &gt; (<span class="keyword">long</span> <span class="keyword">double</span>)b.a / b.b;&#125;);</span><br><span class="line">    k = min(k, tot);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i].a &lt;= q[i].b) &#123;</span><br><span class="line">            k = i - <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q3[i] = q[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, k);</span><br><span class="line">    sort(q3 + <span class="number">1</span>, q3 + k + <span class="number">1</span>, [](node a, node b)&#123;<span class="keyword">return</span> a.type &lt; b.type;&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, q3[i].id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF708E Student&#39;s Camp</title>
      <link href="/2020/03/12/cf708e-students-camp/"/>
      <url>/2020/03/12/cf708e-students-camp/</url>
      
        <content type="html"><![CDATA[<p>有一堆长为$m$，高为$n-2$的砖块</p><p>每个白天，从海边会吹来一阵风，除了最上面以及最下面的两行，其余每行最左边的砖块都各自有$p=\frac ab$的概率会被吹走</p><p>每个晚上，有另一阵风会吹向海边，除了最上面以及最下面的两行，其余每行最右边的砖块也各自有$p$的概率会被吹走</p><p>一共有$k$天，求$k$天之后第一行与最后一行仍然连通的概率，对$10^9+7$取模</p><script type="math/tex; mode=display">n,m\leq 1500, a, b\leq 10^9, k\leq 10^5</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>显然每行最后剩下的砖块一定是一段连续的区间</p><p>设$p_i={k\choose i}p^i(1-p)^{k-i}$，那么一行最后剩下$[l,r]$的概率为$p_{l-1}\times p_{m-r}$，我们记这个概率为$p_{l,r}$</p><p>设$f_{i,l,r}$表示考虑了前$i+1$行，其中第$i$行最后剩下的砖块为$[l,r]$的概率</p><p>那么显然有</p><script type="math/tex; mode=display">f_{i,l,r}=p_{l,r}\sum_{[l',r']\cap[l,r]\neq \emptyset}f_{i-1,l',r'}</script><p>接着设$fr_{i,r}$表示第$i$行所有右端点等于$r$的$f_{i,l,r}$之和，设$fl_{i,l}$表示第$i$行所有左端点等于$l$的$f_{i,l,r}$之和</p><p>类似地，设$sr_{i,r}$表示第$i$行所有右端点小于等于$r$的$f_{i,l,r}$之和，$sl_{i,l}$表示第$i$行所有左端点大于等于$l$的$f_{i,l,r}$之和</p><p>那么可以将$f$的转移改写为</p><script type="math/tex; mode=display">f_{i,l,r}=p_{l,r}\times (sr_{i-1,m}-sr_{i-1,l-1}-sl_{i-1,r+1})</script><p>即，所有区间的和减去右端点在$l$左边的，再减去左端点在$r$右边的</p><p>然后有一个神奇的转化，注意到左右是完全对称的，即所有右端点$\leq i$的区间之和等于左端点$\geq m-i+1$的区间之和</p><p>这意味这我们可以直接将$fl,sl$这两个东西扔掉了，因此有</p><script type="math/tex; mode=display">\begin{aligned}fr_{i,r}&=fl_{i,m-r+1},sr_{i,r}=sl_{i,m-r+1}\\f_{i,l,r}&=p_{l,r}\times (sr_{i-1,m}-sr_{i-1,l-1}-sl_{i-1,r+1})\\&=p_{l,r}\times (sr_{i-1,m}-sr_{i-1,l-1}-sr_{i-1,m - r})\end{aligned}</script><p>现在考虑如何求$fr_{i,j}$，$sr_{i,j}$直接对$fr_{i,j}$求前缀和就好了</p><p>推一波式子</p><script type="math/tex; mode=display">\begin{aligned}fr_{i,r}&=\sum_{l=1}^rp_{l,r}\times (sr_{i-1,m}-sr_{i-1,l-1}-sr_{i-1,m-r})\\&=\sum_{l=1}^rp_{l-1}\times p_{m-r+1}\times (sr_{i-1,m}-sr_{i-1,l-1}-sr_{i-1,m-r})\\&=(sr_{i-1,m}-sr_{i-1,m-r})\times p_{m-r+1}\times \sum_{l=1}^r p_{l-1}\\&-p_{m-r+1}\times \sum_{l=1}^rsr_{i-1,l-1}\times p_{l-1}\end{aligned}</script><p>然后我们再求出$\sum sr_{i-1,l-1}\times p_{l-1}$的前缀和就行了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y = <span class="number">0</span>)</span> </span>&#123;x += y, x -= x &gt;= mod ? mod : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dec</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y = <span class="number">0</span>)</span> </span>&#123;x -= y, x += x &lt; <span class="number">0</span> ? mod : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;x += y; <span class="keyword">return</span> x &gt;= mod ? x - mod : x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;x -= y; <span class="keyword">return</span> x &lt; <span class="number">0</span> ? x + mod : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar(); <span class="keyword">int</span> flg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) flg |= c == <span class="string">'-'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">if</span> (flg) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    x &lt; <span class="number">10</span> ? <span class="built_in">putchar</span>(<span class="string">'0'</span> + x) : (print(x / <span class="number">10</span>), <span class="built_in">putchar</span>(<span class="string">'0'</span> + x % <span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[M], inv[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> P[M], P1[M], dp[N][N], sum[N], sum1[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, a, b, t; read(n), read(m), read(a), read(b), read(t);</span><br><span class="line">    frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    inv[t] = Pow(frac[t], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = t - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) inv[i] = (LL)inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">int</span> p = (LL)a * Pow(b, mod - <span class="number">2</span>) % mod, p1 = mod + <span class="number">1</span> - p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; i++) </span><br><span class="line">        P[i] = (LL)C(t, i) * Pow(p, i) % mod * Pow(p1, t - i) % mod;</span><br><span class="line">    P1[<span class="number">0</span>] = P[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) P1[i] = Add(P1[i - <span class="number">1</span>], P[i]);</span><br><span class="line">    dp[<span class="number">0</span>][m] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) sum[j] = Add(sum[j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) sum1[j] = Add(sum1[j - <span class="number">1</span>], (LL)sum[j] * P[j] % mod);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[i][j] = Sub((LL)P1[j - <span class="number">1</span>] * Sub(sum[m], sum[m - j]) % mod, sum1[j - <span class="number">1</span>]);</span><br><span class="line">            dp[i][j] = (LL)dp[i][j] * P[m - j] % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) Inc(res, dp[n][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC023F 01 on Tree</title>
      <link href="/2020/03/12/agc023f-01-on-tree/"/>
      <url>/2020/03/12/agc023f-01-on-tree/</url>
      
        <content type="html"><![CDATA[<p>给出一棵$N$个点的树，每个点上有一个$0$或$1$的数字。问在这$N$个节点构成的所有排列中，节点上的数形成的逆序对数最少是多少，规定父亲必须排在儿子前面</p><script type="math/tex; mode=display">N\leq 2\times 10^5</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这种题有一个经典的贪心模型</p><p>考虑维护$n$个集合，一开始第$i$个集合中的元素只有$i$</p><p>接着将所有集合排序，如果$A$集合中的元素排在$B$集合中的元素前面时得到的逆序对个数比$B$排在$A$前面时要少，那么我们认为$A&lt;B$</p><p>因此我们需要对每个集合维护这个集合内$0,1$的数量</p><p>注意这里我们只考虑集合与集合间的逆序对数</p><p>显然一开始当每个集合中都只有一个元素时我们会将所有标上$0$的点都排在标上$1$的点前面</p><p>接着我们取出最小的集合，如果没有“父亲必须排在儿子前面”这一条限制，我们可以将其直接加入到序列中</p><p>如果这个集合中最浅点的父亲被选了，那么这个集合也可以选了，此时我们一定会立即选择这个集合</p><p>因此我们将这个集合与其父亲所在的集合合并，表示“如果父亲的集合被选了，那么会立即选择这个集合”，然后将答案加上父亲所在的集合与这个集合之间的逆序对数</p><p>我们不停地重复这个过程，直到所有点都合并为一个点即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N], p[N], c0[N], c1[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> u, c0, c1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">    LL t1 = (LL)c1 * b.c0, t2 = (LL)c0 * b.c1;</span><br><span class="line">    <span class="keyword">if</span> (t1 != t2) <span class="keyword">return</span> t1 &lt; t2;</span><br><span class="line">    <span class="keyword">return</span> u &lt; b.u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : fa[x] = find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;node&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), c0[i] = a == <span class="number">0</span>, c1[i] = a == <span class="number">1</span>, fa[i] = i;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">1</span>) s.insert((node)&#123;i, c0[i], c1[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = s.begin()-&gt;u; s.erase(s.begin());</span><br><span class="line">        <span class="keyword">int</span> t = find(p[u]); </span><br><span class="line">        <span class="keyword">if</span> (t != <span class="number">1</span>) s.erase((node)&#123;t, c0[t], c1[t]&#125;);</span><br><span class="line">        res += (LL)c1[t] * c0[u], c1[t] += c1[u], c0[t] += c0[u];</span><br><span class="line">        fa[u] = t;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="number">1</span>) s.insert((node)&#123;t, c0[t], c1[t]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.10 省选集训day2</title>
      <link href="/2020/03/10/310-sheng-xuan-ji-xun-day2/"/>
      <url>/2020/03/10/310-sheng-xuan-ji-xun-day2/</url>
      
        <content type="html"><![CDATA[<p>day1太过自闭了，所以题解就先咕了</p><h1 id="T1-调兵遣将"><a href="#T1-调兵遣将" class="headerlink" title="T1 调兵遣将"></a>T1 调兵遣将</h1><p>给出一个序列，第$i$个元素为$w_i$</p><p>我们这样定义一种合法方案：选出原序列的若干个互不相交也互不包含的子区间，且至少选$1$个区间，使得这些区间的$\gcd$相等</p><p>你需要对于每个元素，求出它在多少种方案中被选中了</p><script type="math/tex; mode=display">n\leq 5\times 10^4,1\leq w_i\leq 10^9</script><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑一个区间的$\gcd$。如果我们固定这个区间的右端点，那么随着左端点向左不断移动的过程中，这个区间的$\gcd$只会变化$\log w_i$次</p><p>也就是说，如果此时左端点在某个范围内移动的话，区间的$\gcd$是不会变化的，这样的范围至多有$\log w_i$个</p><p>二分出这些范围，于是我们得到了若干个三元组$(l,r,p)$，表示右端点为$p$，左端点在$[l,r]$中的区间的$\gcd$是相等的</p><p>枚举最终方案中所有区间的$\gcd$，将$\gcd$等于这个的所有三元组拿出来$dp$</p><p>如果算方案数的话很简单，设$dp[i]$表示最后选择的区间的右端点为$i$的方案数，然后线段树优化即可</p><p>转移的时候分$i&lt;l$以及$l\leq i&lt; r$两种情况讨论，需要维护区间$dp[i]$的和以及区间$dp[i]\times i$的和</p><p>考虑如何计算当前枚举的$\gcd$对一个点的贡献</p><p>我们增加若干个三元组$(p,l,r)$，定义与上面的三元组相反，表示左端点是$p$，右端点在$[l,r]$中的区间的$\gcd$不变</p><p>对前缀的第一种三元组$dp$，对后缀的第二种三元组$dp$，然后用总方案数减去不包含当前点/当前区间的方案就可以了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a + b;</span><br><span class="line">    <span class="keyword">return</span> t &gt;= mod ? t - mod : t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a - b;</span><br><span class="line">    <span class="keyword">return</span> t &lt; <span class="number">0</span> ? t + mod : t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    a += b, a -= a &gt;= mod ? mod : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tree[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += x &amp; -x) Inc(tree[x], y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= x &amp; -x) Inc(res, tree[x]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Sub(query(r), query(l - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += x &amp; -x) tree[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; p1, p2, q1, q2, res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[<span class="number">17</span>][N], num[N], lg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) g[<span class="number">0</span>][i] = num[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">16</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= n; j++)</span><br><span class="line">            g[i][j] = gcd(g[i - <span class="number">1</span>][j], g[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = lg[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> gcd(g[len][l], g[len][r - (<span class="number">1</span> &lt;&lt; len) + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, p, ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;node&gt; &gt; mp, mp1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Just_DOIT</span><span class="params">(<span class="built_in">vector</span>&lt;node&gt; &amp;p, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : p) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = t.l, r = t.r, p = t.p, A = <span class="number">0</span>, B = <span class="number">0</span>, C = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!type) &#123;</span><br><span class="line">            A = p1.query(<span class="number">1</span>, l - <span class="number">1</span>) + <span class="number">1</span>, B = p2.query(l, r - <span class="number">1</span>), C = p1.query(l, r - <span class="number">1</span>); </span><br><span class="line">            res = ((LL)A * (r - l + <span class="number">1</span>) + (LL)C * r - B) % mod;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            A = q1.query(r + <span class="number">1</span>, n) + <span class="number">1</span>, B = q2.query(l + <span class="number">1</span>, r), C = q1.query(l + <span class="number">1</span>, r);</span><br><span class="line">            res = ((LL)A * (r - l + <span class="number">1</span>) + B - (LL)C * l) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        t.ans = res = (res + mod) % mod;</span><br><span class="line">        <span class="keyword">if</span> (!type) p1.update(p, res), p2.update(p, (LL)res * p % mod);</span><br><span class="line">        <span class="keyword">else</span> q1.update(p, res), q2.update(p, (LL)res * p % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : p) </span><br><span class="line">        <span class="keyword">if</span> (!type) p1.clear(t.p), p2.clear(t.p);</span><br><span class="line">        <span class="keyword">else</span> q1.clear(t.p), q2.clear(t.p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(num[i]);</span><br><span class="line">    pre(); <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val;</span><br><span class="line">    <span class="keyword">auto</span> getL = [&amp;](<span class="keyword">int</span> R, <span class="keyword">int</span> p) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> g = get(R, p), l = <span class="number">1</span>, r = R, mid, ans = <span class="number">-1</span>;</span><br><span class="line">        val.push_back(g);</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (get(mid = (l + r) &gt;&gt; <span class="number">1</span>, p) == g) ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> getR = [&amp;](<span class="keyword">int</span> L, <span class="keyword">int</span> p) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> g = get(p, L), l = L, r = n, mid, ans = <span class="number">-1</span>;</span><br><span class="line">        val.push_back(g);</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (get(p, mid = (l + r) &gt;&gt; <span class="number">1</span>) == g) ans = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = i;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = getL(cur, i); </span><br><span class="line">            mp[get(t, i)].push_back((node)&#123; t, cur, i, <span class="number">0</span> &#125;);</span><br><span class="line">            cur = t - <span class="number">1</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = i;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = getR(cur, i);</span><br><span class="line">            mp1[get(i, t)].push_back((node)&#123; cur, t, i, <span class="number">0</span> &#125;);</span><br><span class="line">            cur = t + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(val.begin(), val.end()), val.resize(unique(val.begin(), val.end()) - val.begin());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : val) &#123;</span><br><span class="line">        Just_DOIT(mp[v], <span class="number">0</span>), Just_DOIT(mp1[v], <span class="number">1</span>); <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos;</span><br><span class="line">        <span class="built_in">vector</span>&lt;node&gt; L = mp[v], R = mp1[v];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : L) pos.push_back(t.p);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : R) pos.push_back(t.p);</span><br><span class="line">        pos.push_back(<span class="number">0</span>), pos.push_back(n + <span class="number">1</span>);</span><br><span class="line">        sort(pos.begin(), pos.end()), pos.resize(unique(pos.begin(), pos.end()) - pos.begin());</span><br><span class="line">        Inc(L[<span class="number">0</span>].ans, <span class="number">1</span>), Inc(R[<span class="number">0</span>].ans, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; L.size(); i++) Inc(L[i].ans, L[i - <span class="number">1</span>].ans);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; R.size(); i++) Inc(R[i].ans, R[i - <span class="number">1</span>].ans);</span><br><span class="line">        <span class="keyword">int</span> all = L.rbegin() -&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, pre = <span class="number">-1</span>, suf = R.size() - <span class="number">1</span>; i + <span class="number">1</span> &lt; pos.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = pos[i] + <span class="number">1</span>, r = pos[i + <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (l &gt; r) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (pre + <span class="number">1</span> &lt; L.size() &amp;&amp; L[pre + <span class="number">1</span>].p &lt; l) pre++;</span><br><span class="line">            <span class="keyword">while</span> (suf &gt;= <span class="number">0</span> &amp;&amp; R[suf].p &lt;= r) suf--;</span><br><span class="line">            <span class="keyword">int</span> A = pre &gt;= <span class="number">0</span> ? L[pre].ans : <span class="number">1</span>, B = suf &gt;= <span class="number">0</span> ? R[suf].ans : <span class="number">1</span>, tmp = (all - (LL)A * B % mod + mod) % mod;</span><br><span class="line">            res.update(l, tmp), res.update(r + <span class="number">1</span>, mod - tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, pre = <span class="number">-1</span>, suf = R.size() - <span class="number">1</span>; i &lt; pos.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = pos[i];</span><br><span class="line">            <span class="keyword">if</span> (p &lt; <span class="number">1</span> || p &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (pre + <span class="number">1</span> &lt; L.size() &amp;&amp; L[pre + <span class="number">1</span>].p &lt; p) pre++;</span><br><span class="line">            <span class="keyword">while</span> (suf &gt;= <span class="number">0</span> &amp;&amp; R[suf].p &lt;= p) suf--;</span><br><span class="line">            <span class="keyword">int</span> A = pre &gt;= <span class="number">0</span> ? L[pre].ans : <span class="number">1</span>, B = suf &gt;= <span class="number">0</span> ? R[suf].ans : <span class="number">1</span>, tmp = (all - (LL)A * B % mod + mod) % mod;</span><br><span class="line">            res.update(p, tmp), res.update(p + <span class="number">1</span>, mod - tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, res.query(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-一掷千金"><a href="#T2-一掷千金" class="headerlink" title="T2 一掷千金"></a>T2 一掷千金</h1><p>有一棵$n\times m$个节点的树，每个节点有一个坐标$(i,j)$，其中$(1,1)$是根，而$(x,y)$的父亲是$(\max(1,x-1),\max(1,y-1))$</p><p>一开始每个节点是黑色或者白色，先手和后手轮流操作。每次轮到的人会选择一个白色节点，然后选择一个它的祖先（可以是它自己），接着翻转这条路径上所有点的颜色，不能操作的那一方输</p><p>输入会给出$K$个矩形，表示这些矩形里面的点都是白色，而其余的点是黑色</p><p>你需要输出当前局面的<code>SG</code>值</p><script type="math/tex; mode=display">K,n\leq 10^5,m\leq 10^9</script><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>很奇妙的一道题</p><p>首先有一个重要的结论：对于这种每个节点为黑/白色，翻转若干个节点，且最后一个节点必须是白色的博弈，我们可以将其看作若干个子游戏，每个子游戏有且仅有一个点是白色。原游戏的<code>SG</code>值等于这个子游戏的<code>SG</code>值</p><p>这个结论使用于所有翻转颜色，且对第一个/最后一个元素的颜色有限制的问题</p><p>比如，考虑一段序列<code>AABBABA</code>，每次可以选择一个右端点为<code>B</code>的区间翻转，那么这个游戏等价于三个子游戏，这三个子游戏分别为<code>AABAAAA</code>，<code>AAABAAA</code>，<code>AAAAABA</code></p><p>如何证明呢？我们将原来的游戏修改一下：每个点有若干个棋子，一开始所有的白色节点都有一个棋子。每次你可以选择一个有棋子的位置，再选择它的一个祖先，删去当前点的棋子，在到它祖先路径上的其它节点上都放一个棋子</p><p>容易发现每个棋子是互不影响的，因此可以将其拆成若干个子游戏，每个子游戏都只有一个棋子。而对于一个点来说，如果这个点上面有奇数个棋子，等价于只有一个棋子；如果这个点上有偶数个棋子，等价于没有棋子，这时因为在计算<code>SG</code>值的时候是异或，因此它们相互抵消了</p><p>回到这道题，考虑只有一个点是白色的情况，假如这个点是$x$，我们将这种局面记为$W(x)$</p><p>显然$W(x)$只与$x$的祖先个数有关，通过打表可以发现$W(x)$的<code>SG</code>为$lowbit(\max(i,j))$，其中$(i,j)$是$x$的坐标</p><p>因此，我们要计算所有被染成白色的点的$lowbit(\max(i,j))$的异或和</p><p>扫描线一下，考虑使用线段树维护区间$lowbit$异或和</p><p>直接维护有点麻烦，因为要计算区间$lowbit$异或，必须要借助数位$dp$</p><p>题解的做法非常奇妙：强制让这棵线段树的下标为$[0,2^d-1]$</p><p>这样的好处是，对于每个点所代表的区间，一定是形如$[a\times 2^b,a\times 2^b+2^c-1(c&lt;b)]$的形式</p><p>可以发现，对于满足这个条件的一个区间$[l,r]$，这个区间的$lowbit$异或和为$\frac{r-l+1}{2}\oplus lowbit(l)$，$\frac{r-l+1}{2}$之后的那些位都作为最低位出现了偶数次，被抵消了</p><p>然后我们在线段树上标记永久化一下就好了，注意一个点的标记永远都$\geq 0$，因为减操作总是撤销操作</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tag, sum, res, ls, rs;</span><br><span class="line">&#125; T[N * <span class="number">34</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ncnt, rt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((r - l + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) ^ (l &amp; -l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T[rt].tag) T[rt].res = get(l, r), T[rt].sum = r - l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        T[rt].sum = T[rt].res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (T[rt].ls) T[rt].sum += T[T[rt].ls].sum, T[rt].res ^= T[T[rt].ls].res;</span><br><span class="line">        <span class="keyword">if</span> (T[rt].rs) T[rt].sum += T[T[rt].rs].sum, T[rt].res ^= T[T[rt].rs].res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rt) rt = ++ncnt;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> T[rt].tag += x, pushup(rt, l, r);</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) update(T[rt].ls, l, mid, start, end, x);</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) update(T[rt].rs, mid + <span class="number">1</span>, r, start, end, x);</span><br><span class="line">    pushup(rt, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query1</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rt) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (T[rt].tag) <span class="keyword">return</span> min(end, r) - max(l, start) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> T[rt].sum;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) res += query1(T[rt].ls, l, mid, start, end);</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) res += query1(T[rt].rs, mid + <span class="number">1</span>, r, start, end);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query2</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> ok = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    ok |= T[rt].tag;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ok) <span class="keyword">return</span> get(l, r);</span><br><span class="line">        <span class="keyword">return</span> T[rt].res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) res ^= query2(T[rt].ls, l, mid, start, end, ok);</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) res ^= query2(T[rt].rs, mid + <span class="number">1</span>, r, start, end, ok);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P; </span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt; add[N], del[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, m, lim = <span class="number">1</span>, res = <span class="number">0</span>; read(k), read(n), read(m);</span><br><span class="line">    <span class="keyword">while</span> (lim &lt;= m) lim &lt;&lt;= <span class="number">1</span>; lim--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c, d; read(a), read(b), read(c), read(d);</span><br><span class="line">        add[a].push_back(P(b, d)), del[c + <span class="number">1</span>].push_back(P(b, d));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t : add[i]) update(rt, <span class="number">0</span>, lim, t.first, t.second, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t : del[i]) update(rt, <span class="number">0</span>, lim, t.first, t.second, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (query1(rt, <span class="number">0</span>, lim, <span class="number">1</span>, i) &amp; <span class="number">1</span>) res ^= i &amp; -i;</span><br><span class="line">        res ^= query2(rt, <span class="number">0</span>, lim, i + <span class="number">1</span>, lim);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-树拓扑序"><a href="#T3-树拓扑序" class="headerlink" title="T3 树拓扑序"></a>T3 树拓扑序</h1><p>给出一棵树，问这棵树的所有反拓扑序（即儿子必须排在父亲前面）的逆序对总数是多少</p><script type="math/tex; mode=display">n\leq 500</script><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>记$dp[i][j][k]$表示考虑$i$的子树中的节点构成的拓扑序，其中满足$j$排在第$k$个位置的序列有多少个</p><p>$F[i]$表示$i$的拓扑序总数，$G[i]$表示$i$的所有拓扑序的逆序对总数</p><p>假设现在要合并$u,v$，其中$u$是父亲，此时$u$的序列长度为$A$，$v$的序列长度为$B$</p><p>我们将所有的$j$分为两种，第一种$j$在$v$的子树里，第二种$j$不在$v$的子树里</p><p>如果$j$在$v$的子树中，我们枚举$u$之前的序列在最终的序列中有多少个元素插入到了$j$之前，假设有$t$个，那么方案数为</p><script type="math/tex; mode=display">{k-1+t\choose t}\times {B-k+A-t-1\choose B-k}</script><p>需要注意的是最后一个位置的元素是固定的，只能是根节点</p><p>如果$j$在$u$的子树中，转移类似</p><p>求出方案数之和，考虑如何计算逆序对个数</p><p>对于$dp[v][a][b]$来说，如果$u$构成的序列有$t$个插入到了$a$前面，那么$u$的所有满足$j&gt;a,k<t$或者$j<a,k>t$的$dp[u][j][k]$都将产生$1$个逆序对</p><p>因此我们对$dp$做一个二维前缀和就行了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[N][N][N], F[N], G[N]; <span class="comment">// i的子树内j排在第k位的序列数量; i子树的序列数量; i子树的答案</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[N][N]; <span class="comment">// dp的前缀和</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lst[N][N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nw = F[u], A = son[u].size(), B = son[v].size(), tmp = C(A + B - <span class="number">1</span>, B);</span><br><span class="line">    G[u] = ((LL)G[u] * F[v] + (LL)F[u] * G[v]) % mod * tmp % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= A; j++)</span><br><span class="line">            pre[i][j] = ((LL)pre[i][j - <span class="number">1</span>] + pre[i - <span class="number">1</span>][j] - pre[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[u][i][j] + mod) % mod,</span><br><span class="line">                lst[i][j] = dp[u][i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> j : son[u])</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= A; k++) dp[u][j][k] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= A; k++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> j : son[u]) <span class="keyword">if</span> (lst[j][k]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt;= B; t++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k == A &amp;&amp; t != B) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> val = (LL)C(t + k - <span class="number">1</span>, t) * C(max(<span class="number">0</span>, A - k - <span class="number">1</span>) + B - t, B - t) % mod;</span><br><span class="line">                dp[u][j][k + t] = (dp[u][j][k + t] + (LL)val * F[v] % mod * lst[j][k]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= B; k++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> j : son[v]) <span class="keyword">if</span> (dp[v][j][k]) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; A; t++) &#123;</span><br><span class="line">                <span class="keyword">int</span> val = (LL)C(t + k - <span class="number">1</span>, t) * C(B - k + A - t - <span class="number">1</span>, A - t - <span class="number">1</span>) % mod;</span><br><span class="line">                dp[u][j][k + t] = (dp[u][j][k + t] + (LL)val * dp[v][j][k] % mod * F[u]) % mod;</span><br><span class="line">                <span class="keyword">int</span> L = (pre[n][t] - pre[j][t] + mod) % mod, R = (pre[j][A] - pre[j][t] + mod) % mod;</span><br><span class="line">                G[u] = (G[u] + (LL)val * (L + R) % mod * dp[v][j][k]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">    F[u] = (LL)F[u] * F[v] % mod * tmp % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : son[v]) son[u].push_back(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from] &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to] &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    F[u] = <span class="number">1</span>, dp[u][u][<span class="number">1</span>] = <span class="number">1</span>, son[u].push_back(u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u), Merge(u, e[i].to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, G[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 博弈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC033E Go around a Circle</title>
      <link href="/2020/03/07/agc033e-go-around-a-circle/"/>
      <url>/2020/03/07/agc033e-go-around-a-circle/</url>
      
        <content type="html"><![CDATA[<p>一个圆上均匀分布着$N$个点，有$N$条弧连接着这些点。给出一个由<code>RB</code>构成的长度为$M$的串$S$，你需要给每条弧分配一个<code>R</code>或<code>B</code>的字符，使得从这个圆上任意一点开始走，都存在一种方案，每次将跨过弧的字符写下来，最终都能得到$S$</p><p>求合法方案数，对$10^9+7$取模</p><script type="math/tex; mode=display">N,M\leq 2\times 10^5</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>我们分几种情况讨论一下</p><p><strong>1.$S$中所有字符都相同</strong></p><p>我们不妨设这个字符为<code>R</code></p><p>如果存在一个点，连接这个点的两条弧都是<code>B</code>，那么从这个点开始走就凉了</p><p>否则我们可以在那条<code>R</code>边上来回走</p><p>此时相当于要给环上若干条边染成<code>B</code>，使得不存在相邻的<code>B</code></p><p>断环为链，枚举第一条边的颜色，然后$dp$一下就行了</p><p><strong>2.$S$中存在不相同字符</strong></p><p>为了方便起见，我们还是设$S$的第一个字符为<code>R</code></p><p>显然环上不能出现两个连续的<code>B</code></p><p>接下来我们证明一个结论：对于任意一段极长的<code>R</code>，它的长度一定是奇数</p><p>使用反证法，假设至少存在一段<code>R</code>，它的长度是偶数</p><p>我们把这一段<code>R</code>以及它左右两侧的<code>B</code>拉出来</p><p>将第一个<code>R</code>的左端点标记为圆点，第二个<code>R</code>的左端点标记为方点，第三个<code>R</code>的左端点又标记为圆点……以此类推</p><p>如果我们从一个圆点出发，可以发现它到左右两侧的<code>B</code>都需要走奇数步，这意味着$S$中的第一个<code>B</code>必须出现在奇数位置</p><p>如果我们从一个方点出发，可以发现它到左右两侧的<code>B</code>都需要走偶数步，这意味着$S$的的第一个<code>B</code>必须出现在偶数位置，矛盾</p><p>因此可以得出结论：每一段极长的<code>R</code>的长度必定是奇数</p><p>我们将每一段<code>R</code>与它右边的<code>B</code>匹配，长度为偶数，这意味着如果存在合法方案，那么$N$必须是偶数</p><p>如果$S$中第一个<code>B</code>前面有$a$个<code>R</code></p><p>如果$a$是奇数，那么连续的<code>R</code>的长度不能大于$a$，否则不能大于$a+1$</p><p>$a$是奇数的时候考虑这一段的第一个$R$的左端点，显然这一段的长度不能大于$a$</p><p>$a$是偶数的时候考虑这一段的第一个$R$右端点，它只能向右走，因此这一段的长度不能大于$a+1$</p><p>容易发现这样一个事实，从一个点开始走，当跨过第一个<code>B</code>的时候，所在的位置的唯一确定的</p><p>并且，对于每一个与<code>B</code>相连的位置，一定存在一个起点，从这个起点出发跨过第一个<code>B</code>的时候会到达这个点</p><p>因此，假如$S$中除了开头以外，存在一段连续的极长<code>R</code>的长度为$b$，且$b$为奇数，那么每一段极长的<code>R</code>的长度不能超过$b$</p><p>我们可以求出考虑了上面的所有约束之后，每一段<code>R</code>的最长的长度</p><p>问题转化为：给环上的每一条边染色，使得不存在连续的<code>B</code>，每一段<code>R</code>的长度是奇数且最大不超过$x$</p><p>可以进一步转化为将$\frac N2$分为若干段，每一段的长度不超过$\lceil\frac x2\rceil$的方案数</p><p>断环为链，设$f[i]$表示将$1\sim i$分成若干段，且$i$是最后一段的结尾的方案数</p><p>初值为$f[k]=2k$，即此时长度为$k$的段代表$2k-1$个<code>R</code>接上一个<code>B</code>，而这$2k$个端点都能成为起点</p><p>前缀和优化即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N], g[N], dp[<span class="number">2</span>][<span class="number">2</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;n, &amp;m, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">if</span> (s[i] != s[<span class="number">1</span>]) &#123;</span><br><span class="line">        flag = <span class="literal">true</span>; <span class="keyword">break</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fir = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">if</span> (s[i] != s[<span class="number">1</span>]) &#123;</span><br><span class="line">            fir = i - <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lim = fir | <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = fir + <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">if</span> (s[i] != s[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt;= m &amp;&amp; s[j] == s[<span class="number">1</span>]) j++;</span><br><span class="line">            <span class="keyword">if</span> (j &lt;= m &amp;&amp; (j - i - <span class="number">1</span>) % <span class="number">2</span> == <span class="number">1</span>) lim = min(lim, j - i - <span class="number">1</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        n /= <span class="number">2</span>, lim = (lim + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lim; i++) f[i] = i * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, diff = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            diff = (diff + g[i]) % mod, f[i] = (f[i] + diff) % mod;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt;= n) g[i + <span class="number">1</span>] = (g[i + <span class="number">1</span>] + f[i]) % mod;</span><br><span class="line">            <span class="keyword">if</span> (i + lim + <span class="number">1</span> &lt;= n) g[i + lim + <span class="number">1</span>] = (g[i + lim + <span class="number">1</span>] - f[i] + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[n]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">1</span>; t++) &#123;</span><br><span class="line">                dp[t][<span class="number">0</span>][i] = (dp[t][<span class="number">1</span>][i - <span class="number">1</span>] + dp[t][<span class="number">0</span>][i - <span class="number">1</span>]) % mod;</span><br><span class="line">                dp[t][<span class="number">1</span>][i] = dp[t][<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ((LL)dp[<span class="number">1</span>][<span class="number">0</span>][n] + dp[<span class="number">0</span>][<span class="number">0</span>][n] + dp[<span class="number">0</span>][<span class="number">1</span>][n]) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC034E Complete Compress</title>
      <link href="/2020/03/06/agc034e-complete-compress/"/>
      <url>/2020/03/06/agc034e-complete-compress/</url>
      
        <content type="html"><![CDATA[<p>给出一棵$N$个点的树，有些节点上有棋子，定义树上路径长度为经过的边数</p><p>每一轮，你可以选择两个距离至少为$2$的棋子$(u,v)$，然后将$u$向$v$挪动一步，同时将$v$向$u$挪动一步</p><p>问至少需要多少步才能让所有棋子都挪到一起，如果无解输出$-1$</p><script type="math/tex; mode=display">N\leq 2000</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>枚举最后所有棋子到达的点，将这个点提为根，容易发现挪动棋子只有两种情况</p><ul><li>选择两个互为祖先关系的棋子，然后让它们一个深度$+1$，一个深度$-1$</li><li>选择两个互不为祖先关系的棋子，让两个棋子的深度都$-1$</li></ul><p>接着有一个结论：所有$1$操作是没有用的</p><p>假如我们在某次操作中选择了$1$操作，接下来是一次$2$操作，可以发现这样一个性质，如果将这两个操作的顺序互换，对结果不会产生影响</p><p>因此，我们可以将所有的$1$操作都换到最后去，这样所有的$1$操作就没用了</p><p>现在就只剩下$2$操作了，那么如何判断是否合法呢</p><p>每次操作会导致所有棋子的深度之和$-2$，不会改变奇偶性，因此如果当前的深度总和为奇数，则经过若干次操作过后的深度之和不能低于$1$</p><p>假设某次都只能跨过根选择两个棋子，即选择的棋子必须在根的两棵子树中，我们假设根的每棵子树的棋子深度之和分别为$a_1,a_2,\cdots, a_m$，此时显然必须满足$\max\{a_1,\cdots a_m\}\leq \frac{\sum a_i}{2}$</p><p>如果$\max$过大，我们可以递归到这棵子树中继续进行$2$操作</p><p>我们对这棵树进行两次<code>dfs</code>，第一次<code>dfs</code>求出每个点子树中的棋子个数以及所有棋子的深度之和，第二次<code>dfs</code>求出当前子树所剩余的最小深度之和</p><p>在第二次<code>dfs</code>的时候，我们找到子树深度之和最大的儿子，如果这个儿子能得到的最小的深度之和仍然比其它儿子的深度之和要大，那么无论如何都消不完了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sum: 子树内棋子个数 dp: 子树内最少操作步数</span></span><br><span class="line"><span class="keyword">int</span> sum[N], dp[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> val[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    sum[u] = val[u], dp[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) &#123;</span><br><span class="line">            dfs(e[i].to, u);</span><br><span class="line">            sum[u] += sum[e[i].to], dp[u] += dp[e[i].to] + sum[e[i].to];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子树的最小剩余深度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) </span><br><span class="line">            <span class="keyword">if</span> (dp[e[i].to] &gt;= dp[mx]) </span><br><span class="line">                mx = e[i].to;</span><br><span class="line">    <span class="keyword">if</span> (!mx) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = dfs2(mx, u) + sum[mx];</span><br><span class="line">    <span class="keyword">if</span> (dp[u] - dp[mx] - sum[mx] &gt;= tmp) <span class="keyword">return</span> dp[u] &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp - (dp[u] - dp[mx] - sum[mx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d%s"</span>, &amp;n, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) val[i] = s[i] == <span class="string">'1'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dfs(i, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!dfs2(i, <span class="number">0</span>)) res = min(res, dp[i] / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">1e8</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC034D Manhattan Max Matching</title>
      <link href="/2020/03/06/agc034d-manhattan-max-matching/"/>
      <url>/2020/03/06/agc034d-manhattan-max-matching/</url>
      
        <content type="html"><![CDATA[<p>二维平面上有若干个数量相同的蓝点和红点</p><p>有$BC_i$个蓝点的坐标为$(BX_i, BY_i)$，有$RC_i$个红点的坐标为$(RX_i, RY_i)$</p><p>你需要将这些蓝点和红点配对，使得每一对的曼哈顿距离之和尽量大</p><script type="math/tex; mode=display">N\leq 1000, RX_i,RY_i,BX_i,BY_i<10^9,\sum BC_i=\sum RC_i</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>每个点的坐标在被计算的时候一共有四种情况，$(x,y),(-x,y),(x,-y),(-x,-y)$</p><p>注意到$A,B$两点的曼哈顿距离可以写成$\max\{X_A+Y_A-X_B-Y_B,X_A-Y_A-X_B+Y_B,\\ -X_A+Y_A+X_B-Y_B,-X_A-Y_A+X_B+Y_B\}$的形式</p><p>可以发现每个点当且仅当它的曼哈顿距离被正确计算的时候才是最大的，而这道题又要求每一对的曼哈顿距离之和最大</p><p>因此我们可以将所有点分成四类，其中$(x,y)$与$(-x,-y)$相匹配，$(x,-y)$与$(-x,-y)$相匹配</p><p>考虑如何建图</p><p>将图分为两侧，左侧为所有蓝点，右侧为所有红点</p><p>中间新建四个点，第一个点与左侧所有点的连边费用为$x+y$，与右侧的点的连边费用为$-x-y$</p><p>第二个点与左侧所有点的连边费用为$-x-y$，与右侧所有点的连边费用为$x+y$</p><p>剩下两个点同理</p><p>然后在这张图上跑一边最大费用流就是答案</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w, c;</span><br><span class="line">&#125; e[N * <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from], w, -c&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to], <span class="number">0</span>, c&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis[N], cur[N]; LL dis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis)), <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; q.push(t), vis[t] = <span class="number">1</span>, dis[t] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop(), vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">            <span class="keyword">if</span> (e[i ^ <span class="number">1</span>].w &amp;&amp; dis[e[i].to] &gt; dis[u] - e[i].c) &#123;</span><br><span class="line">                dis[e[i].to] = dis[u] - e[i].c;</span><br><span class="line">                <span class="keyword">if</span> (!vis[e[i].to]) q.push(e[i].to), vis[e[i].to] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[s] &lt; <span class="number">1e17</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == t || !f) <span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u], tmp; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to] &amp;&amp; e[i].w &amp;&amp; dis[u] - e[i].c == dis[e[i].to] &amp;&amp; </span><br><span class="line">            (tmp = DFS(e[i].to, t, min(f, e[i].w)))) &#123;</span><br><span class="line">                res += tmp, f -= tmp, e[i].w -= tmp, e[i ^ <span class="number">1</span>].w += tmp, ans += (LL)tmp * e[i].c;</span><br><span class="line">                <span class="keyword">if</span> (!f) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (SPFA(s, t)) <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span>(head)), DFS(s, t, <span class="number">1e9</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, s, t; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), s = n * <span class="number">2</span> + <span class="number">5</span>, t = s + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, c; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;c);</span><br><span class="line">        adde(s, i, c, <span class="number">0</span>);</span><br><span class="line">        adde(i, <span class="number">2</span> * n + <span class="number">1</span>, <span class="number">1e9</span>, -x - y), adde(i, <span class="number">2</span> * n + <span class="number">2</span>, <span class="number">1e9</span>, x + y);</span><br><span class="line">        adde(i, <span class="number">2</span> * n + <span class="number">3</span>, <span class="number">1e9</span>, y - x), adde(i, <span class="number">2</span> * n + <span class="number">4</span>, <span class="number">1e9</span>, x - y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, c; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;c);</span><br><span class="line">        adde(i + n, t, c, <span class="number">0</span>);</span><br><span class="line">        adde(<span class="number">2</span> * n + <span class="number">1</span>, i + n, <span class="number">1e9</span>, x + y), adde(<span class="number">2</span> * n + <span class="number">2</span>, i + n, <span class="number">1e9</span>, -x - y);</span><br><span class="line">        adde(<span class="number">2</span> * n + <span class="number">3</span>, i + n, <span class="number">1e9</span>, x - y), adde(<span class="number">2</span> * n + <span class="number">4</span>, i + n, <span class="number">1e9</span>, y - x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, -dinic(s, t));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC038E Gachapon</title>
      <link href="/2020/03/06/agc038e-gachapon/"/>
      <url>/2020/03/06/agc038e-gachapon/</url>
      
        <content type="html"><![CDATA[<p>有一个随机数生成器，在每个时刻会生成一个数</p><p>给出$N$对$A_i,B_i$，表示每个时刻生成$i$的概率为$\frac{A_i}{\sum A_i}$</p><p>当所有的$i$均满足$i$至少被生成了$B_i$次时停止生成，问期望停止时间</p><p>$N,\sum A_i, \sum B_i\leq 400$，对$998244353$取模</p><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先<code>min-max</code>容斥一下，将问题转化为求出对于每个$\{1,2,\cdots n\}$的子集，这个子集中至少有一个数满足条件的期望时间</p><p>设这个子集为$S$，如果只考虑生成出的$S$集合中的数，显然生成的数的总数不会超过$\sum_{i\in S}B_i$</p><p>如果要考虑生成出的其它数，那么期望时刻等于不考虑那些数时的期望再乘上$\frac{\sum A_i}{\sum_{i\in S}A_i}$</p><p>将期望转化为概率</p><p>停止的期望时间$=$第$0$次操作之后还未停止的概率$+$第$1$次操作之后还未停止的概率$+\cdots$第$\sum B_i$次操作之后还未停止的概率</p><p>先考虑暴力$dp$，枚举$S$集合，设$dp[i][j]$表示考虑了$S$集合中的前$i$个元素，当前凑出来的生成序列一共有$j$个元素，且所有数的生成次数均小于上界的概率</p><p>枚举当前数被生成了多少次，那么有</p><script type="math/tex; mode=display">dp[i][j]=\sum_{k=0}^{\min(j,b_i)}dp[i-1][j-k]\times \left(\frac{A_{S_i}}{\sum_{i\in S} A_{i}}\right)^k\times {j\choose k}</script><p>现在考虑一起算所有的$S$</p><p>设$dp[i][j][k][0/1]$表示当前考虑第$i$个数，序列中一共塞了$j$个数，此时我们所选择的数的$A_i$之和为$k$，选了奇数/偶数种数的概率</p><p>转移与上面类似</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">410</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][N][N][N], A[N], B[N], C[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, s = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A[i], &amp;B[i]), s = (s + A[i]) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">400</span>; i++) &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) C[i][j] = (C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t = <span class="number">0</span>, t1 = <span class="number">0</span>; i &lt;= n; t += B[i] - <span class="number">1</span>, t1 += A[i], i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= t; j++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= t1; k++) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i][j][k] = (dp[<span class="number">0</span>][i][j][k] + dp[<span class="number">0</span>][i - <span class="number">1</span>][j][k]) % mod;</span><br><span class="line">                dp[<span class="number">1</span>][i][j][k] = (dp[<span class="number">1</span>][i][j][k] + dp[<span class="number">1</span>][i - <span class="number">1</span>][j][k]) % mod;</span><br><span class="line">                <span class="keyword">int</span> p = (LL)k * Pow(k + A[i], mod - <span class="number">2</span>) % mod, p1 = Pow(p, j);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; B[i]; l++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> w = (LL)C[j + l][j] * p1 % mod * Pow(<span class="number">1</span> + mod - p, l) % mod;</span><br><span class="line">                    dp[<span class="number">0</span>][i][j + l][k + A[i]] = (dp[<span class="number">0</span>][i][j + l][k + A[i]] + (LL)dp[<span class="number">1</span>][i - <span class="number">1</span>][j][k] * w) % mod;</span><br><span class="line">                    dp[<span class="number">1</span>][i][j + l][k + A[i]] = (dp[<span class="number">1</span>][i][j + l][k + A[i]] + (LL)dp[<span class="number">0</span>][i - <span class="number">1</span>][j][k] * w) % mod;</span><br><span class="line">                    <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) dp[<span class="number">1</span>][i][l][A[i]] = (dp[<span class="number">1</span>][i][j + l][A[i]] + w) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">1</span>; t++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">400</span>; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">400</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = (LL)dp[t][n][j][k] * s % mod * Pow(k, mod - <span class="number">2</span>) % mod;</span><br><span class="line">                <span class="keyword">if</span> (t &amp; <span class="number">1</span>) ans = (ans + w) % mod;</span><br><span class="line">                <span class="keyword">else</span> ans = (ans - w + mod) % mod; </span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 容斥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC034F RNG and XOR</title>
      <link href="/2020/03/06/agc034f-rng-and-xor/"/>
      <url>/2020/03/06/agc034f-rng-and-xor/</url>
      
        <content type="html"><![CDATA[<p>一开始有一个为$0$的数$X$</p><p>对于$0\leq i\leq 2^N-1$，每次你会以$\frac{A_i}{\sum A_i}$的概率选择$i$，然后将$X$异或$i$</p><p>对于每一个$0\leq i\leq 2^N-1$，你需要求出$X$变成$i$的期望时刻</p><script type="math/tex; mode=display">N\leq 18</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>我们可以将问题转化为，对于每一个$i$，求出$i$变成$0$的期望时刻</p><p>记$p_i=\frac{A_i}{\sum A_i}$，$x_i$为$i$变成$0$的期望时刻</p><p>容易得出下面的转移</p><script type="math/tex; mode=display">x_i=\sum_{j=0}^{2^N-1}x_{i\oplus j}p_j+1\\x_i-1=\sum_{j=0}^{2^N-1}x_{i\oplus j}p_j</script><p>注意当$i=0$时这个转移是错的</p><p>因此，我们可以得出</p><script type="math/tex; mode=display">(x_0,x_1,x_2,\cdots,x_{2^N-1})\oplus (p_0,p_1,p_2,\cdots,p_{2^N-1})\\=(?,x_1-1,x_2-1,x_3-1,\cdots,x_{2^N-1}-1)</script><p>注意$?$部分不是$x_0-1$，而是$x_0$由上式转移而来的结果</p><p>如果我们对于等式右边的每一项求和，可以得到</p><script type="math/tex; mode=display">\sum_{i=0}^{2^N-1}\sum_{j=0}^{2^N-1}x_{i\oplus j}p_j\\=\sum_{i=0}^{2^N-1}x_i\sum_{j=0}^{2^N-1}p_{i\oplus j}\\=\sum_{i=0}^{2^N-1}x_i\sum_{j=0}^{2^N-1}p_j=\sum_{i=0}^{2^N-1}x_i</script><p>等式右边的所有数之和应该与等式左边的所有数之和相等，即变换之和和不变</p><p>那么有</p><script type="math/tex; mode=display">?=\sum_{i=0}^{2^N-1}x_i-\sum_{i=1}^{2^N-1}(x_i-1)\\=x_0+2^N-1\\(x_0,x_1,\cdots,x_{2^N-1})\oplus (p_0,p_1,\cdots,p_{2^N-1})\\=(x_0+2^N-1,x_1-1,x_2-1,\cdots,x_{2^N-1}-1)</script><p>我们可以想办法将等式右边中每一项的未知数删掉</p><p>注意到如果将$p_0$减$1$，那么右边的第$i$项收到的影响为$x_ip_0$，即减少了$x_i$</p><p>因此有</p><script type="math/tex; mode=display">(x_0,x_1,\cdots,x_{2^N-1})\oplus (p_0-1,p_1,\cdots,p_{2^N-1})\\=(2^N-1,-1,-1,\cdots,-1)</script><p><code>FWT</code>能做卷积，同样也能做卷积的逆变换</p><p>但是如果这样写，写完会发现答案不对，而且$x_0$求出来并不是$0$</p><p>事实上，这样的卷积方程是有通解的。如果我们将所有数全部加上$k$</p><script type="math/tex; mode=display">x_i=\sum_{j=0}^{2^N-1}x_{i\oplus j}p_j+1\\x_i+k=\sum_{j=0}^{2^N-1}(x_{i\oplus j}+k)p_j+1=\sum_{j=0}^{2^N-1}x_{i\oplus j}p_j+k+1</script><p>可以看出，给这个式子的每一项都加上相同的常数，方程仍然成立</p><p>显然，我们知道$x_0=0$，那么此时我们求出的$x_0$应该就是这个常数</p><p>所以将求出来的每一项减去$x_0$即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">18</span>, mod = <span class="number">998244353</span>, i2 = (mod + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + (mid &gt;&gt; <span class="number">1</span>); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = a[j]; a[j] = (t + a[j + (mid &gt;&gt; <span class="number">1</span>)]) % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (t - a[j + (mid &gt;&gt; <span class="number">1</span>)] + mod) % mod;</span><br><span class="line">                <span class="keyword">if</span> (!type) a[j] = (LL)a[j] * i2 % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (LL)a[j + (mid &gt;&gt; <span class="number">1</span>)] * i2 % mod;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N], B[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, sum = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), n = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]), B[i] = mod - <span class="number">1</span>, sum = (sum + A[i]) % mod;</span><br><span class="line">    sum = Pow(sum, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) A[i] = (LL)A[i] * sum % mod;</span><br><span class="line">    B[<span class="number">0</span>] = n - <span class="number">1</span>, A[<span class="number">0</span>] = (A[<span class="number">0</span>] + mod - <span class="number">1</span>) % mod;</span><br><span class="line">    FWT(A, n, <span class="number">1</span>), FWT(B, n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) B[i] = (LL)B[i] * Pow(A[i], mod - <span class="number">2</span>) % mod;</span><br><span class="line">    FWT(B, n, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (B[i] - B[<span class="number">0</span>] + mod) % mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> FWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF643G Choosing Ads</title>
      <link href="/2020/03/06/cf643g-choosing-ads/"/>
      <url>/2020/03/06/cf643g-choosing-ads/</url>
      
        <content type="html"><![CDATA[<p>给出一个序列$a$以及一个介于$20$到$100$之间的正整数$p$，需要支持两种操作</p><ul><li>将区间$[l,r]$修改为$x$</li><li>询问区间$[l,r]$有哪些数出现次数超过了$p\%$</li></ul><p>对于每一个询问，最多可以输出$\lfloor\frac{100}{p}\rfloor$个数，可以输出不正确的结果，但必须保证所有出现次数超过$p\%$的数都被输出了</p><script type="math/tex; mode=display">n,q\leq 1.5*10^5</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>我们先考虑$p\geq 51$怎么做</p><p>此时问题等价于，给出一个序列，支持区间赋值以及询问区间众数，保证众数出现次数超过了一半</p><p>区间出现次数超过一半的众数是一个很经典的问题，可以使用摩尔投票法解决</p><p>如果我们每次选择两个不同的数删去，那么最后留下来的数一定是众数</p><p>因为众数的出现次数超过了一半，就算每次选择众数以及另一个数删除，仍然能保证最后留下的是众数</p><p>那么我们可以将这个结论推广到$p\geq 20$的情况</p><p>举个例子，比如$p=34$</p><p>即保证有两种数出现次数严格大于$1/3$，求这两种数</p><p>我们将策略改为每次选择三个不同的数删去，同样可以得到正确的结果</p><p>如果删去的数至少有两个不是众数，那么这样一定不优秀，因为非众数被多抵消了一个</p><p>如果删去的数包含两个众数，那么最后剩下的一定还是这两个众数，因为它们出现次数大于$1/3$，就算把所有非众数全部抵消完，仍然不能将这两种数消完</p><p>因此，我们维护一段区间内每次将$\lfloor\frac{100}{p}\rfloor$个数删去，最后留下的哪些数即可</p><p>时间复杂度$O(k^2n\log n)$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">150010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    P num[<span class="number">5</span>];</span><br><span class="line">    Data() &#123;<span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));&#125;</span><br><span class="line">    Data(<span class="keyword">int</span> a) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line">        num[<span class="number">0</span>].first = a, num[<span class="number">0</span>].second = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lim;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Data <span class="title">Merge</span><span class="params">(<span class="keyword">const</span> Data &amp;a, <span class="keyword">const</span> Data &amp;b)</span> </span>&#123;</span><br><span class="line">    Data res = a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) <span class="keyword">if</span> (b.num[i].second) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j++)</span><br><span class="line">            <span class="keyword">if</span> (res.num[j].first == b.num[i].first) &#123;</span><br><span class="line">                res.num[j].second += b.num[i].second;</span><br><span class="line">                flag = <span class="literal">true</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j++)</span><br><span class="line">            <span class="keyword">if</span> (!res.num[j].second) &#123;</span><br><span class="line">                res.num[j] = b.num[i];</span><br><span class="line">                flag = <span class="literal">true</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> mn = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j++)</span><br><span class="line">            mn = min(mn, res.num[j].second);</span><br><span class="line">        <span class="keyword">if</span> (mn &gt;= b.num[i].second) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j++) res.num[j].second -= b.num[i].second;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j++)</span><br><span class="line">            <span class="keyword">if</span> (res.num[j].second == mn &amp;&amp; !flag) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>, res.num[j].first = b.num[i].first;</span><br><span class="line">                res.num[j].second = b.num[i].second - mn;</span><br><span class="line">            &#125; <span class="keyword">else</span> res.num[j].second -= mn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, tag; Data val;</span><br><span class="line">&#125; T[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    T[rt].val = Merge(T[rt &lt;&lt; <span class="number">1</span>].val, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cover</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r;</span><br><span class="line">    T[rt].val = Data(x), T[rt].val.num[<span class="number">0</span>].second = r - l + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    cover(rt &lt;&lt; <span class="number">1</span>, T[rt].tag), cover(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, T[rt].tag);</span><br><span class="line">    T[rt &lt;&lt; <span class="number">1</span>].tag = T[rt].tag, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].tag = T[rt].tag, T[rt].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    T[rt].l = l, T[rt].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> T[rt].val = Data(a[l]), <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; build(rt &lt;&lt; <span class="number">1</span>, l, mid), build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> cover(rt, x), T[rt].tag = x, <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">if</span> (T[rt].tag) pushdown(rt);</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, start, end, x);</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, start, end, x);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Data <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> T[rt].val;</span><br><span class="line">    <span class="keyword">if</span> (T[rt].tag) pushdown(rt);</span><br><span class="line">    <span class="keyword">if</span> (end &lt;= mid) <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span>, start, end);</span><br><span class="line">    <span class="keyword">if</span> (start &gt; mid) <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, start, end);</span><br><span class="line">    <span class="keyword">return</span> Merge(query(rt &lt;&lt; <span class="number">1</span>, start, end), query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, start, end));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, q, p; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;q, &amp;p), lim = <span class="number">100</span> / p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, A, B, C; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;op, &amp;A, &amp;B);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;C), update(<span class="number">1</span>, A, B, C);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Data res = query(<span class="number">1</span>, A, B);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, lim);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lim; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, res.num[i - <span class="number">1</span>].first);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF704B Ant Man</title>
      <link href="/2020/03/05/cf704b-ant-man/"/>
      <url>/2020/03/05/cf704b-ant-man/</url>
      
        <content type="html"><![CDATA[<p>有$n$个元素，第$i$个元素有五个参数$x_i,a_i,b_i,c_i,d_i$</p><p>你需要求出一个$1\sim n$的排列$p$，使得$p_1=s,p_n=e$，同时最小化这个排列的权值</p><p>我们定义一个排列的权值和为$\sum f(p_i,p_{i+1})$，其中$f(i,j)$的值有两种情况</p><ul><li>$i&gt;j$，此时$f(i,j)=x_i-x_j+c_i+b_j$</li><li>$i&lt;j$，此时$f(i,j)=x_j-x_i+d_i+a_j$</li></ul><script type="math/tex; mode=display">n\leq 5\times 10^3,s\neq e,1\leq x_1<x_2<\cdots x_n\leq 10^9,a_i,b_i,c_i,d_i\leq 10^9</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>让$a_i,c_i$加上$x_i$，让$b_i,d_i$减去$x_i$</p><p>我们将在这个排列上行走的过程看做连边，对于路径排列中相邻的两个位置$p_i,p_{i+1}$，我们将其看做是从$p_i$向$p_{i+1}$连了一条有向边</p><p>我们将从左往右的边称为“前向边”，将从右往左的边称为“反向边”</p><p>可以看出，这其实是一个前向边与反向边匹配的过程</p><p>设$dp[i][j]$表示已经考虑了$1\sim i$这些位置，还有$j$条前向边等待匹配</p><p>从$e$向$s$也连接一条边，这样的话对于这个序列中的任意两个相邻的位置$(i,i+1)$，都应该满足这个条件：</p><ul><li>跨过这两个位置的前向边数量$=$跨过这两个位置的反向边数量</li></ul><p>接下来考虑从$dp[i-1][j]$转移出去</p><p>即$k$表示跨过$(i-1,i)$的正向边减去反向边有多少条</p><p>如果$i\leq \min(s,e)$或者$i&gt;\max(s,e)$，此时$k=j$</p><p>否则，如果$s<e$，此时相当于多了一条反向边，$k=j-1$；如果$s>e$，此时相当于多了一条正向边，$k=j+1$</p><p>如果$k<0$或者$k>n$，显然不合法</p><p>考虑接下来在$i$这个位置该如何转移，有四种情况</p><ul><li>一条正向边连向了$i$，同时$i$连出了一条反向边，未匹配的边减少$1$。代价为$a_i+c_i$（$d+b$已经在这条边的开头被计算过了）</li><li>一条正向边连向了$i$，同时$i$连出了一条正向边，未匹配的边不变。代价为$a_i+d_i$，同时要求$j&gt;0$（要不然哪来的未匹配的正向边）</li><li>钦定一条反向边会连向$i$，同时$i$连出了一条反向边，未匹配的边不变。代价为$b_i+c_i$，同时要求$k&gt;0$</li><li>钦定一条反向边会连向$i$，同时$i$连出了一条正向边，未匹配的边增加$1$。代价为$b_i+d_i$，同时要求$k&gt;0,j&gt;0$，否则这个序列左侧和右侧将不连通</li></ul><p>如果$i$是$s$或者$e$需要特殊转移</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line">LL dp[<span class="number">2</span>][N], A[N], B[N], C[N], D[N], dis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(LL &amp;x, LL y)</span> </span>&#123;<span class="keyword">if</span> (y &lt; x) x = y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, s, e; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;s, &amp;e);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;dis[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;A[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;B[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;C[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;D[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        C[i] += dis[i], B[i] -= dis[i], A[i] += dis[i], D[i] -= dis[i];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp)), dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = i &amp; <span class="number">1</span>; <span class="built_in">memset</span>(dp[cur], <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp[cur]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = j;</span><br><span class="line">            <span class="keyword">if</span> (min(s, e) &lt;= i &amp;&amp; i &lt; max(s, e)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s &lt; e) tmp--;</span><br><span class="line">                <span class="keyword">else</span> tmp++;</span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (tmp &lt; <span class="number">0</span> || tmp &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (i != s &amp;&amp; i != e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmp) update(dp[cur][j], dp[cur ^ <span class="number">1</span>][j] + C[i] + B[i]);</span><br><span class="line">                <span class="keyword">if</span> (j) update(dp[cur][j], dp[cur ^ <span class="number">1</span>][j] + A[i] + D[i]);</span><br><span class="line">                <span class="keyword">if</span> (j &amp;&amp; tmp) update(dp[cur][j], dp[cur ^ <span class="number">1</span>][j - <span class="number">1</span>] + B[i] + D[i]);</span><br><span class="line">                update(dp[cur][j], dp[cur ^ <span class="number">1</span>][j + <span class="number">1</span>] + A[i] + C[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == s) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j) update(dp[cur][j], dp[cur ^ <span class="number">1</span>][j - <span class="number">1</span>] + D[i]);</span><br><span class="line">                update(dp[cur][j], dp[cur ^ <span class="number">1</span>][j] + C[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                update(dp[cur][j], dp[cur ^ <span class="number">1</span>][j + <span class="number">1</span>] + A[i]);</span><br><span class="line">                update(dp[cur][j], dp[cur ^ <span class="number">1</span>][j] + B[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s &lt; e &amp;&amp; s &lt;= i &amp;&amp; i &lt; e || ((i &lt; min(s, e) || i &gt;= max(s, e)) &amp;&amp; i != n)) </span><br><span class="line">            dp[cur][<span class="number">0</span>] = <span class="number">1e18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[n &amp; <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF679E Bear and Bad Powers of 42</title>
      <link href="/2020/03/05/cf679e-bear-and-bad-powers-of-42/"/>
      <url>/2020/03/05/cf679e-bear-and-bad-powers-of-42/</url>
      
        <content type="html"><![CDATA[<p>我们称所有$42$的幂为<code>bad number</code>，其余的数为<code>good number</code></p><p>维护一个序列$A$，保证一开始每个数都是<code>good number</code>，支持三个操作</p><ul><li>$1\ i$ 输出$A_i$</li><li>$2\ a\ b\ x$ 将区间$[a,b]$都设为$x$，保证$x$是一个<code>good number</code></li><li>$3\ a\ b\ x$ 将区间$[a,b]$都加上$x$，如果操作结束之后这个区间至少存在一个<code>bad number</code>，则重复这一操作，直至所有数都变成<code>good number</code></li></ul><script type="math/tex; mode=display">n,q\leq 10^5,a_i,x\leq 10^9</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>$10^9$范围内$42$的幂是很少的，这意味着实际上$3$操作执行的总次数是$O(n)$级别的，我们可以模拟这个操作</p><p>那么如何快速判断当前区间是否需要再次操作呢</p><p>对于每个位置我们维护这个位置当前的数到下一个<code>bad number</code>所需要加的值，对于区间我们维护这个东西的最小值</p><p>如果当前区间的最小值$&lt; x$，这意味着有些数减爆了，我们递归下去处理减爆的数即可</p><p>因为一个数被减爆的次数不多，因此这样的势能线段树复杂度是对的</p><p>如果一次操作之后全局最小值等于$0$，这意味着当前至少有一个数是<code>bad number</code>，此时我们再次执行这个区间加操作，知道全局最小值大于$0$即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line">LL Pow[<span class="number">13</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Rank</span><span class="params">(<span class="keyword">const</span> LL &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lower_bound(Pow, Pow + <span class="number">12</span>, x) - Pow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, level; LL diff, tag, cover;</span><br><span class="line">&#125; T[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Cover</span><span class="params">(<span class="keyword">int</span> rt, LL val)</span> </span>&#123;</span><br><span class="line">    T[rt].level = Rank(val), T[rt].diff = Pow[T[rt].level] - val, T[rt].tag = <span class="number">0</span>, T[rt].cover = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Increase</span><span class="params">(<span class="keyword">int</span> rt, LL val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T[rt].cover) T[rt].cover += val;</span><br><span class="line">    <span class="keyword">else</span> T[rt].tag += val;</span><br><span class="line">    T[rt].diff -= val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T[rt].cover) Cover(rt &lt;&lt; <span class="number">1</span>, T[rt].cover), Cover(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, T[rt].cover), T[rt].cover = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (T[rt].tag) Increase(rt &lt;&lt; <span class="number">1</span>, T[rt].tag), Increase(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, T[rt].tag), T[rt].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    T[rt].diff = min(T[rt &lt;&lt; <span class="number">1</span>].diff, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].diff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    T[rt].l = l, T[rt].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> Cover(rt, t[l]), <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; </span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span>, l, mid), build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r), pushup(rt); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> val, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> type ? Cover(rt, val) : Increase(rt, val), <span class="keyword">void</span>();</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, start, end, val, type);</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, start, end, val, type);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T[rt].diff &gt;= <span class="number">0</span>) <span class="keyword">return</span> T[rt].diff;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        LL val = Pow[T[rt].level] - T[rt].diff;</span><br><span class="line">        T[rt].level = Rank(val), T[rt].diff = Pow[T[rt].level] - val;</span><br><span class="line">        <span class="keyword">return</span> T[rt].diff;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    LL res1 = query(rt &lt;&lt; <span class="number">1</span>), res2 = query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> pushup(rt), min(res1, res2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> Pow[T[rt].level] - T[rt].diff;</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span>, pos);</span><br><span class="line">    <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">11</span>; i++) Pow[i] = Pow[i - <span class="number">1</span>] * <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">int</span> n, q; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t[i]);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, a, b, c; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;op, &amp;a);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(<span class="number">1</span>, a));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;b, &amp;c), update(<span class="number">1</span>, a, b, c, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;b, &amp;c);</span><br><span class="line">            <span class="function"><span class="keyword">do</span> <span class="title">update</span><span class="params">(<span class="number">1</span>, a, b, c, <span class="number">0</span>)</span></span>; <span class="keyword">while</span> (!query(<span class="number">1</span>)); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF704D Captain America</title>
      <link href="/2020/03/05/cf704d-captain-america/"/>
      <url>/2020/03/05/cf704d-captain-america/</url>
      
        <content type="html"><![CDATA[<p>二维平面上有$n$个点，第$i$个点的坐标为$(x_i,y_i)$</p><p>你需要将每个点涂成红色或者蓝色，涂成红色的代价为$r$，涂成蓝色的代价为$b$</p><p>有$m$个限制，第$i$个限制可以描述为三个整数$(t_i,l_i,d_i)$，表示</p><ul><li>如果$t_i=1$，那么在直线$x=l_i$上红色与蓝色的点个数之差的绝对值不超过$d_i$</li><li>如果$t_i=2$，那么在直线$y=l_i$上红色与蓝色的点个数之差的绝对值不超过$d_i$</li></ul><p>你需要找出满足上述条件的最小代价，要求输出方案</p><script type="math/tex; mode=display">n,m\leq 10^5,r,b,l_i\leq 10^9</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>不妨设$r\leq b$</p><p>如果我们将每一行看做一个点，将每一列也看做一个点，然后将原来二维平面上的一个点看做连接所在行与所在列的一条边，显然得到的将会是一个二分图</p><p>每个限制等价于要求某一行/某一列红色的点数在一段区间内，可以看做是源点/汇点到这一行/这一列所代表的点的边的流量有一个上下界</p><p>由于$r\leq b$，我们想让红色的点尽量多，因此这实际上是一个上下界最大流问题</p><p>回忆一下上下界最大流是咋求的，如果一条边$u\rightarrow v$的流量限制为$[l,r]$，那么我们将这条边的容量改为$r-l$，同时将<code>extra[v]</code>加上$l$，将<code>extra[u]</code>减去$l$</p><p>同时需要从汇点向源点连一条容量为无穷大的边</p><p>这里<code>extra[i]</code>表示$i$点需要补偿的额外流量</p><p>如果最后<code>extra[u]</code>大于$0$，我们就从源点向这个点连边，容量为<code>extra[u]</code>，否则我们从这个点向汇点连边</p><p>求完可行流之后删去汇点向源点的连边，在残量网络上继续增广即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int LL</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;</span><br><span class="line">&#125; e[N * <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt = <span class="number">1</span>, extra[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from], w&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to], <span class="number">0</span>&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> down, <span class="keyword">int</span> up)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> delta = up - down; adde(from, to, delta);</span><br><span class="line">    extra[to] += down, extra[from] -= down;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dep[N], cur[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span>(dep)), dep[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; q.push(s);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">            <span class="keyword">if</span> (e[i].w &amp;&amp; !dep[e[i].to]) &#123;</span><br><span class="line">                assert(e[i].w &gt; <span class="number">0</span>);</span><br><span class="line">                dep[e[i].to] = dep[u] + <span class="number">1</span>, q.push(e[i].to);</span><br><span class="line">                <span class="keyword">if</span> (e[i].to == t) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == t || !f) <span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u], tmp; i; i = e[i].next) </span><br><span class="line">        <span class="keyword">if</span> (e[i].w &amp;&amp; dep[e[i].to] == dep[u] + <span class="number">1</span> &amp;&amp; (tmp = DFS(e[i].to, min(f, e[i].w), t))) &#123;</span><br><span class="line">            e[i].w -= tmp, e[i ^ <span class="number">1</span>].w += tmp, f -= tmp, res += tmp;</span><br><span class="line">            <span class="keyword">if</span> (!f) <span class="keyword">break</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (BFS(s, t)) <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span>(head)), res += DFS(s, <span class="number">1e18</span>, t);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">FUCKYPJ</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = T + <span class="number">1</span>, t = s + <span class="number">1</span>, tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">if</span> (extra[i] &gt; <span class="number">0</span>) </span><br><span class="line">            adde(s, i, extra[i]), tot += extra[i];</span><br><span class="line">        <span class="keyword">else</span> adde(i, t, -extra[i]);</span><br><span class="line">    adde(T, S, <span class="number">0</span>, <span class="number">1e9</span>);</span><br><span class="line">    <span class="keyword">if</span> (dinic(s, t) != tot) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[S]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to == T) res = e[i].w, e[i].w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> res + dinic(S, T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[N], y[N], id[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; X, Y, X1, Y1, X2, Y2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, r, b, flag = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>, &amp;n, &amp;m, &amp;r, &amp;b);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; b) swap(r, b), flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;x[i], &amp;y[i]), X[x[i]]++, Y[y[i]]++;</span><br><span class="line">    <span class="keyword">int</span> A = X.size(), B = Y.size(), s = A + B + <span class="number">1</span>, t = s + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t, l, d; <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;t, &amp;l, &amp;d);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!X1.count(l)) X1[l] = d;</span><br><span class="line">            <span class="keyword">else</span> X1[l] = min(X1[l], d);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Y1.count(l)) Y1[l] = d;</span><br><span class="line">            <span class="keyword">else</span> Y1[l] = min(Y1[l], d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ct = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : X) &#123;</span><br><span class="line">        <span class="keyword">int</span> t1 = t.first, all = t.second;</span><br><span class="line">        X2[t1] = ++ct; <span class="keyword">int</span> lim = X1.count(t1) ? X1[t1] : <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">int</span> L = (all - lim + <span class="number">1</span>) / <span class="number">2</span>, R = min(n, (all + lim) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span>;</span><br><span class="line">        adde(s, ct, L, R);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> T : Y) &#123;</span><br><span class="line">        <span class="keyword">int</span> t1 = T.first, all = T.second;</span><br><span class="line">        Y2[t1] = ++ct; <span class="keyword">int</span> lim = Y1.count(t1) ? Y1[t1] : <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">int</span> L = max(<span class="number">0l</span>l, (all - lim + <span class="number">1</span>) / <span class="number">2</span>), R = min(n, (all + lim) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span>;</span><br><span class="line">        adde(ct, t, L, R);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        adde(X2[x[i]], Y2[y[i]], <span class="number">0</span>, <span class="number">1</span>), id[i] = ecnt - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = FUCKYPJ(s, t, t);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (LL)res * r + (LL)(n - res) * b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = e[id[i]].w ^ flag;</span><br><span class="line">            <span class="keyword">if</span> (!t) <span class="built_in">putchar</span>(<span class="string">'r'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">'b'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC024D Isomorphism Freak</title>
      <link href="/2020/03/05/agc024d-isomorphism-freak/"/>
      <url>/2020/03/05/agc024d-isomorphism-freak/</url>
      
        <content type="html"><![CDATA[<p>定义一棵树$T$上两个点等价当且仅当以这两个点为根时得到的数同构</p><p>定义$T$的权值为$T$的等价类数量</p><p>$T$一开始有$N$个节点，你可以在这棵树上加若干个叶子，问加完之和这棵树的权值最小是多少，以及在满足权值最小的前提之下$T$中的最小叶子数</p><script type="math/tex; mode=display">N\leq 100</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>通过观察样例可以得出，如果这棵树的直径包含的点数为$d$，那么第一问的答案为$\lfloor\frac{d}{2}\rfloor$</p><p>容易看出这实际上是答案的下界，因为如果$a,b$两点在直径上不对称，那么从$a,b$出发的最长路径长度都不一样，因此这两个点不可能等价</p><p>而我们又一定能够构造出等价类个数恰好等于$\lfloor\frac{d}{2}\rfloor$的方案，因此第一问的答案就是这个</p><p>接下来考虑如何构造</p><p>如果直径中包含偶数个点，我们从这条直径最中间那条边将直径分为两半，左边和右边应当对称</p><p>我们根据到这条边两个端点中较近的那个点的距离将所有点分为$\frac{d}{2}$个等价类</p><p>可以发现此时左侧和右侧的子树的相同层的节点的儿子个数也应该是相同的</p><p>因此可以用类似<code>BFS</code>的方式确定第二问的答案，我们一层一层地<code>BFS</code>，每一层记录儿子个数最多的那个节点，然后将当前层所有点的儿子个数都整成这个最大值</p><p>如果直径中包含奇数个点，有两种构造方式</p><p>第一种是在直径上接一个点，转化为直径长度为偶数的情况，此时第一问的答案不会增加</p><p>第二种是我们找到直径最中间的那个点，然后将其它点到这个点的距离将所有点分为$\lfloor\frac{d}{2}\rfloor$个等价类</p><p>可以发现此时如果将这个点作为根，那么相同深度的点的儿子个数也应当相同</p><p>类似之前<code>BFS</code>的方法，找到每一层儿子个数最多的点即可</p><p>代码如下</p><p>``` cpp</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><p>using namespace std;</p><p>const int N = 110;</p><p>typedef long long LL;</p><p>vector<int> G[N];</p><p>int dep[N], mx, pos, tmp[N], fuck[N], n;</p><p>void dfs(int u, int f) {<br>    dep[u] = dep[f] + 1, tmp[u] = u, fuck[u] = dep[u];<br>    if (dep[u] &gt; mx) mx = dep[u], pos = u;<br>    for (auto v : G[u]) if (v != f) {<br>        dfs(v, u);<br>        if (fuck[v] &gt; fuck[tmp[u]]) tmp[u] = v;<br>        fuck[u] = max(fuck[u], fuck[v]);<br>    }<br>}</p><p>int ans1;</p><p>inline LL work1(int pos) {<br>    mx = 0, dfs(pos, 0);<br>    if (mx != ans1) return 1e18;<br>    vector<int> A, B; A.push_back(pos);<br>    for (auto v : G[pos]) B.push_back(v);<br>    LL nw = B.size();<br>    while (233) {<br>        swap(A, B), B.clear(); int t = 0;<br>        for (auto u : A) {<br>            t = max((int)G[u].size() - 1, t);<br>            for (auto v : G[u]) if (dep[v] &gt; dep[u])<br>                B.push_back(v);<br>        }<br>        if (!t) return nw;<br>        if (1e18 / t &lt; nw) return 1e18;<br>        nw *= t;<br>    }<br>}</p><p>inline LL work2(int A, int B) {<br>    int nw = n + 1;<br>    for (auto &amp;v : G[A]) if (v == B) { v = nw; break; }<br>    for (auto &amp;v : G[B]) if (v == A) { v = nw; break; }<br>    G[nw].push_back(A), G[nw].push_back(B);<br>    ans1++; LL ans = work1(nw); ans1—;<br>    for (auto &amp;v : G[A]) if (v == nw) { v = B; break; }<br>    for (auto &amp;v : G[B]) if (v == nw) { v = A; break; }<br>    G[nw].clear();<br>    return ans;<br>}</p><p>int main() {<br>    scanf(“%d”, &amp;n);<br>    for (int i = 1, a, b; i &lt; n; i++)<br>        scanf(“%d%d”, &amp;a, &amp;b), G[a].push_back(b), G[b].push_back(a);<br>    dfs(1, 0); int A = pos; mx = 0;<br>    dfs(A, 0); int B = pos;<br>    vector<int> hh;<br>    while (233) {<br>        hh.push_back(A);<br>        if (A == B) break;<br>        A = tmp[A];<br>    }<br>    printf(“%d “, ans1 = (hh.size() + 1) / 2);<br>    LL ans2 = 1e18;<br>    for (int i = 1; i &lt;= n; i++)<br>        for (auto j : G[i]) if (i &lt; j) ans2 = min(ans2, work2(i, j));<br>    if (hh.size() &amp; 1) {<br>        int mid = hh[hh.size() / 2];<br>        printf(“%lld\n”, min(work1(mid), ans2));<br>    } else {<br>        printf(“%lld\n”, ans2);<br>    }<br>    return 0;<br>}<br>``</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC024F Simple Subsequence Problem</title>
      <link href="/2020/03/05/agc024f-simple-subsequence-problem/"/>
      <url>/2020/03/05/agc024f-simple-subsequence-problem/</url>
      
        <content type="html"><![CDATA[<p>给出$N+1$个$01$串$S_0,S_1,\cdots S_N$，下标为$i$的串的长度为$2^i$</p><p>每个串的每一位都代表了一个二进制串，如果$S_i$的第$j$位为$1$，表示存在一个长度为$i$的二进制串，这个串是$j$的二进制表示，在最高位之前补$0$。注意这里认为一个字符串的下标是从$0$开始的</p><p>我们记表示出来的这些串构成的集合为$S$</p><p>你需要找到一个字典序最小的二进制串，使得这个串是$S$中至少$K$个串的子序列</p><script type="math/tex; mode=display">N\leq 20,K\leq |S|</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>如果判断$A$是否是$B$的子序列，我们可以建出子序列自动机。对于每一次匹配我们找到下一个$0$以及下一个$1$的位置，再根据$A$这一位是啥来决定跳到哪里</p><p>由于要求答案的字典序最小，显然我们需要逐位确定答案，难点在于不能快速确定当前状态是多少个串的子序列</p><p>考虑沿用之前子序列自动机的方法，但不同的是，这里我们枚举目标串还能用于匹配的后缀是啥。相当于我们将所有串分成了若干类，每一类在匹配完当前的答案串之和剩余的串是相同的</p><p>设$dp[s_1][s_2]$表示有多少个串满足，当前答案串为$s_1$，这个串还能用于匹配的后缀为$s_2$</p><p>每次我们枚举答案的下一位是$0$还是$1$。如果下一位是$0$，那么这就意味着$s_2$在第一个$0$之前的所有位都不能用于匹配了，此时我们需要将第一个$0$以及前面的所有位删去。如果下一位是$1$，那么我们需要把第一个$1$以及前面的所有位删去。用这种类似$dp$的方法，我们就能确定当前的答案串是多少个串的子串</p><p>由于$s_1$和$s_2$的长度之和不会超过$N+1$，因此状态总是是$2^{N+1}$。为了方便，我们用$s_2$的最高位来表示还未匹配的串的长度，当前串在匹配$0/1$之和的状态是可以预处理出来的</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最高位代表其长度 1 &lt;&lt; i -&gt; 长度为 i </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *dp[<span class="number">1</span> &lt;&lt; N], tp[<span class="number">2</span>][<span class="number">1</span> &lt;&lt; N], fir[<span class="number">1</span> &lt;&lt; N]; <span class="keyword">char</span> s[<span class="number">1</span> &lt;&lt; N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span> &lt;&lt; n + <span class="number">1</span>], dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1</span> &lt;&lt; n + <span class="number">1</span>; i++) fir[i] = fir[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s); <span class="keyword">int</span> base = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; base; j++) </span><br><span class="line">            dp[<span class="number">1</span>][base | j] = s[j] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> all = base - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; base; j++) </span><br><span class="line">            tp[<span class="number">1</span>][base | j] = j;</span><br><span class="line">        tp[<span class="number">0</span>][base * <span class="number">2</span> - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + <span class="number">1</span> &lt; base; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = all ^ j, pos = fir[t]; </span><br><span class="line">            tp[<span class="number">0</span>][base | j] = (<span class="number">1</span> &lt;&lt; pos - <span class="number">1</span>) | (j &amp; ((<span class="number">1</span> &lt;&lt; pos - <span class="number">1</span>) - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> base = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = base - <span class="number">1</span>; s &gt;= <span class="number">0</span>; s--) &#123;</span><br><span class="line">            dp[base + s] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span> &lt;&lt; n + <span class="number">1</span> - i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n + <span class="number">1</span> - i); j++) dp[base + s][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">1</span> &lt;&lt; (n + <span class="number">1</span> - (i - <span class="number">1</span>)); j++) <span class="keyword">if</span> (tp[s &amp; <span class="number">1</span>][j])</span><br><span class="line">                dp[base + s][tp[s &amp; <span class="number">1</span>][j]] += dp[(base + s) &gt;&gt; <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; (<span class="number">1</span> &lt;&lt; n + <span class="number">1</span> - i); j++) tot += dp[base + s][j];</span><br><span class="line">            <span class="keyword">if</span> (tot &gt;= k) res = base + s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = fir[res];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res &amp; (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)) <span class="built_in">putchar</span>(<span class="string">'1'</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 状态压缩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC021E Ball Eat Chameleons</title>
      <link href="/2020/03/05/agc021e-ball-eat-chameleons/"/>
      <url>/2020/03/05/agc021e-ball-eat-chameleons/</url>
      
        <content type="html"><![CDATA[<p>有$n$只神奇的变色龙，每只变色龙是红色或者蓝色，一开始所有变色龙都是蓝色的</p><p>如果一只红色的变色龙吃下的蓝球数严格大于其吃下的红球数，那么它会变成蓝色，蓝色变色龙同理</p><p>有$k$个红蓝球，定义一种颜色序列是合法的当且仅当存在一种给变色龙喂球的方式，使得最后所有的变色龙都是红色</p><p>给定$n,k$，求方案数，对$998244353$取模</p><script type="math/tex; mode=display">n,k\leq 5\times 10^5</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>对于一只变色龙来说，我们考虑它什么时候会是红色</p><ul><li>吃下的红球数大于其吃下的蓝球数</li><li>吃下的红球数等于其吃下的蓝球数，并且最后一个吃下的是蓝球</li></ul><p>第一种变色龙需要的红球数量比蓝球数量多$1$，而第二种变色龙需要的红球数量和蓝球数量相等</p><p>同时，我们知道这样一个结论：如果某个序列能使得所有变色龙都变成红色，那么将这个序列中的蓝球变为红球仍然能够满足条件</p><p>因此我们需要构造一种贪心策略，使得所有变色龙需要的红球数量更少</p><p>记$R,B$分别代表红球数量和蓝球数量，我们分几种情况讨论</p><ul><li>$R&lt;B$</li></ul><p>无论怎么分配，总会有一只变色龙吃到的红球比蓝球少，那么这只变色龙就无法变为红色，因此方案数为$0$</p><ul><li>$R=B$</li></ul><p>所有的变色龙都只能是第二种变色龙，因为没有红球可以拿来浪费</p><p>最后一个球肯定是某一只变色龙吃下的最后一个球，因此这个球只能是蓝色</p><p>我们构造这样一种贪心策略：找到$n$对匹配的$RB$，这里的匹配指的是$B$在$R$后面并且每个$B,R$只能用一次，然后喂给所有变色龙（用前$n$个$R$匹配最后$n$个$B$，可以保证最后一个$B$此时一定被一只变色龙吃掉）</p><p>接着，将所有剩下的球都塞给吃掉最后那个$B$的变色龙</p><p>接下来，我们证明上面贪心的正确性</p><p><strong>1.如果一只变色龙能够变为红色，那么它需要的红球数越少越好</strong></p><p>本来这只变色龙占用的第二个红球是有可能使得一只蓝色变色龙变为红色的，但是现在被浪费了，因此一定不优秀</p><p>因此我们要尽可能使得有尽量多的变色龙最后吃到球的序列是$RB$</p><p><strong>2.一种合法方案必须存在$n$个匹配</strong></p><p>如果匹配数小于$n$，我们消去所有匹配的位置之后剩下的是一串$BBB\cdots RRR\cdots$的序列，并且$RB$数量相等</p><p>但是此时，仍然有变色龙是蓝色的</p><p>此时如果我们要将一只蓝色的变色龙变成红色，必然会使得红球的数量比蓝球的数量多减少一个，然后剩下的红球数量就小于蓝球数量了</p><p>所以，我们可以得出当$R=B$时的充分必要条件</p><p>1.最后一个球是蓝色<br>2.存在至少$n$对匹配的$RB$</p><p>那么如何计数呢？考虑到卡特兰数实际上就是$R,B$存在完美匹配的方案数，那么我们可以考虑将序列变为折线</p><p>我们考虑这样一条折线：</p><p>一开始在原点，依次考虑序列中的每一个位置，如果某一个位置是红球，那么往右上走一步；如果某一个位置是蓝球，那么往右下走一步</p><p>当我们从第一象限走到了第四象限，这就意味着一个蓝球没能与之前的红球匹配，换句话说，这个蓝球被浪费掉了，等价于浪费一个红球（少了一组匹配）</p><p>因此，我们需要保证的条件是：没有被浪费的红球仍然大于等于$n$个，即被浪费的蓝球小于等于$B−n$个。这等价于折线不能跨越$y=−(B−n)$这条直线，并且最后走到了$(k−1,1)$这个点，最后再走一步到达$(k,0)$</p><p>那么有</p><script type="math/tex; mode=display">\begin{cases}R+B=k-1\\ R-B=2(-(B-n)-1)-1\end{cases}\Rightarrow R=2n-2</script><p>方案数为${k-1\choose R}-{k-1\choose 2n-2}={k-1\choose R}-{k-1\choose 2R-n+1}$</p><ul><li>$R&gt;B$</li></ul><p>稍微更改一下贪心策略</p><p>我们知道最多有$R−B$个红球可以被浪费掉，因此$RB$匹配的数量至少要是$n−(R−B)$个</p><p>因此策略为：选出$n−(R−B)$只变色龙吃$RB$，剩下的变色龙随便分配，只需要满足每只变色龙吃到的红球数大于蓝球数即可</p><p>如果$RB$对的数量少于这个数，那么剩下的每一只变色龙必然会浪费一个红球，不可能出现“红蓝相等，且最后一个是蓝球”的情况，因为这样的话必然会产生新的$RB$对，与尽量匹配这个条件矛盾</p><p>与$R=B$的情况类似，这等价与一条从$(0,0)$到$(k,0)$的折线，没有浪费的蓝球仍然大于等于$n−(R−B)$个，即浪费的蓝球小于等于$B−(n−(R−B))=R−n$个，不能跨越$y=−(R−n)$这条折线</p><p>计算与上面类似，可以算出方案数为${k\choose R}-{k\choose 2R-n+1}$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &gt; n || r &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, res = <span class="number">0</span>; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k; </span><br><span class="line">    frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> R = n; R &lt;= k; R++) <span class="keyword">if</span> (R &gt;= k - R) &#123;</span><br><span class="line">        <span class="keyword">if</span> (R == k - R) res = (res + C(k - <span class="number">1</span>, R) - C(k - <span class="number">1</span>, R * <span class="number">2</span> - n + <span class="number">1</span>)) % mod;</span><br><span class="line">        <span class="keyword">else</span> res = (res + C(k, R) - C(k, R * <span class="number">2</span> - n + <span class="number">1</span>)) % mod;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (res + mod) % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC029C Lexicographic constraints</title>
      <link href="/2020/03/05/agc029c-lexicographic-constraints/"/>
      <url>/2020/03/05/agc029c-lexicographic-constraints/</url>
      
        <content type="html"><![CDATA[<p>有$N$个字符串排成一行，第$i$个字符串是$S_i$，长度为$A_i$</p><p>现在要求任意相邻的两个字符串$S_{i},S_{i+1}$都满足$S_i&lt;S_{i+1}$，即$S_i$的字典序比$S_{i+1}$小，问构成$S_1,S_2,\cdots, S_N$的字符集大小至少是多少</p><script type="math/tex; mode=display">N\leq 2\times 10^5, A_i\leq 10^9</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>先二分答案$mid$，考虑如何从$S_i$推到$S_{i+1}$</p><p>如果$A_i&lt;A_{i+1}$，我们可以直接在$S_i$后面塞$A_{i+1}-A_i$个$0$</p><p>否则我们保留$S_i$的前$A_{i+1}$位，并给$S_i$在$mid$进制下$+1$即可</p><p>开个<code>set</code>维护$S_i$中所有非$0$的位置，这样的位置只有$O(N)$个</p><p>进位的时候我们不停地将$S_i$的最后一位拿出来，判断是否等于$mid-1$，如果不等于的话让它加$1$，同时进位结束，否则删去这个位置，继续尝试进位</p><p>如果一直进到了最高位都不够，那么$mid$就是不合法的</p><p>注意需要特判$1$进制，因为一进位就炸了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;P&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="keyword">if</span> (A[i] &lt;= A[i - <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">while</span> (s.size() &amp;&amp; s.rbegin() -&gt; first &gt; A[i]) s.erase(*s.rbegin());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = A[i]; ; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!j) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (s.size() &amp;&amp; j == s.rbegin() -&gt; first) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.rbegin() -&gt; second &lt; mid - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> t = *s.rbegin(); s.erase(t), t.second++;</span><br><span class="line">                    s.insert(t); <span class="keyword">break</span>;    </span><br><span class="line">                &#125; <span class="keyword">else</span> s.erase(*s.rbegin());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (mid == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                s.insert(P(j, <span class="number">1</span>)); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n, mid, ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid - <span class="number">1</span>, ans = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC024E Sequence Growing Hard</title>
      <link href="/2020/03/05/agc024e-sequence-growing-hard/"/>
      <url>/2020/03/05/agc024e-sequence-growing-hard/</url>
      
        <content type="html"><![CDATA[<p>统计序列$(A_0,A_1,\cdots,A_N)$的数量，其中$A_0,A_1,\cdots, A_N$也是序列，满足</p><ul><li>$A_i$的长度为$i$，且每个数都在$[1,K]$之间</li><li>$A_i$是$A_{i+1}$的子序列</li><li>$A_i$的字典序小于$A_{i+1}$</li></ul><p>对$M$取模</p><script type="math/tex; mode=display">N,K\leq 300, M\leq 10^9</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>由于$A_{i-1}$是$A_i$的子序列，并且$A_i$的长度恰好比$A_{i-1}$的长度多$1$</p><p>因此我们可以看做$A_i$在$A_{i-1}$的基础上插入了一个数</p><p>插入的这个数后面那个数一定小于这个数（如果后面那个数等于插入的数，则可以将当前数往后挪动）</p><p>因此这个序列可以看做一棵树，一开始我们让数的根节点为$0$，每次如果我们将$x$插入$y$之前，那么看做$y$作为父亲向$x$连了一条边</p><p>这棵树的儿子是有顺序的，可以发现一棵树唯一地对应了一个序列，因此我们只需要统计有多少种不同的树即可</p><p>唯一的限制是：父亲节点的权值必须小于儿子的权值</p><p>考虑从叶子向根$dp$，设$dp[i][j]$表示$j$的子树有$i$个节点的方案数</p><p>转移的时候枚举当前根最靠左的儿子所在的子树的大小，可以得到</p><script type="math/tex; mode=display">dp[i][j]=\sum_{k=1}^{i-1}dp[i-k][j]{i-2\choose k-1}\sum_{l\geq j+1} dp[k][l]</script><p>可以前缀和优化</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[N][N], C[N][N], sum[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, mod; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;k, &amp;mod), n++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) C[i][j] = (C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) sum[<span class="number">1</span>][i] = k - i + <span class="number">1</span>, dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt; i; t++) </span><br><span class="line">                dp[i][j] = (dp[i][j] + (LL)dp[i - t][j] * C[i - <span class="number">2</span>][t - <span class="number">1</span>] % mod * sum[t][j + <span class="number">1</span>]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &gt;= <span class="number">1</span>; j--) sum[i][j] = (sum[i][j + <span class="number">1</span>] + dp[i][j]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[n][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC028D Chords</title>
      <link href="/2020/03/05/agc028d-chords/"/>
      <url>/2020/03/05/agc028d-chords/</url>
      
        <content type="html"><![CDATA[<p>圆上有$2N$个点，你需要将它们两两配对，因此一共会连出$N$条边</p><p>这$N$条边中有$K$条边是已经确定好的，第$i$条边连接$A_i,B_i$</p><p>你需要求出剩下的所有配对方式中连通块个数的总和</p><p>$N\leq 300$，对$10^9+7$取模</p><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>考虑统计每一个连通块在多少种匹配里面出现过，将它们加起来就是答案</p><p>每个连通块中一定有一个编号最小的点$i$，也一定有一个编号最大的点$j$</p><p>考虑用$i,j$表示一个连通块，设$f[i][j]$表示仅考虑$i\leq k\leq j$的所有点的匹配，该连通块在多少种匹配里面出现过</p><p>如果这些点中至少有一条连到$[i,j]$之外的边，我们认为$f[i][j]=0$</p><p>直接统计$i,j$连通的方案数不是很好算，考虑用总数减去不合法的状态</p><p>记$g[i]$表示$i$个点匹配的方案数，显然有$g[i]=(i-1)\times(i-3)\times\cdots 1$，且$i$必须为偶数</p><p>记$h[i][j]$表示$[i,j]$中有多少个点没有连出的边</p><p>那么可以得到转移：</p><script type="math/tex; mode=display">f[i,j]=g[h[i,j]]-\sum_{k=i}^{j-1}f[i][k]\times g[h[k+1][j]]</script><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">610</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N][N], g[N], G[N], cnt[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k), n *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), G[a] = b, G[b] = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j++) </span><br><span class="line">            cnt[i][j] = cnt[i][j - <span class="number">1</span>] + !G[j];</span><br><span class="line">    g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">        g[i] = (LL)g[i - <span class="number">2</span>] * (i - <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j &amp;&amp; flag; k++)</span><br><span class="line">                <span class="keyword">if</span> (G[k] &amp;&amp; (G[k] &lt; i || G[k] &gt; j)) flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!flag) <span class="keyword">continue</span>;</span><br><span class="line">            f[i][j] = g[cnt[i][j]];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; k++) </span><br><span class="line">                f[i][j] = (f[i][j] - (LL)f[i][k] * g[cnt[k + <span class="number">1</span>][j]] % mod + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j++)</span><br><span class="line">            res = (res + (LL)f[i][j] * g[n - k * <span class="number">2</span> - cnt[i][j]]) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 容斥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARC102F Revenge of BBuBBBlesort!</title>
      <link href="/2020/03/05/arc102f-revenge-of-bbubbblesort/"/>
      <url>/2020/03/05/arc102f-revenge-of-bbubbblesort/</url>
      
        <content type="html"><![CDATA[<p>给出一个$1\sim N$的排列$p_1,p_2,\cdots,p_N$，每次你可以选择三个连续的位置$i-1,i,i+1$，满足$p_{i-1}&gt;p_i&gt;p_{i+1}$并交换$p_{i-1}$和$p_{i+1}$。问能否经过若干次操作使得最后的排列是$1,2,\cdots n$</p><script type="math/tex; mode=display">N\leq 3\times 10^5</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>将操作反过来，问题转化为对于$a=\{1,2,\cdots n\}$，判断能否通过交换若干次$i-1,i+1$，满足$a_{i-1}&lt;a_i&lt;a_{i+1}$，从而达到状态$p$</p><p>可以发现一个性质：如果我们以$i$为中心进行了一次翻转，那么$i-1,i+1$就永远都不能成为翻转的中心了</p><p>考虑证明这个性质，假设翻转了$i$，那么翻转之后$a_{i-2}<a_{i-1}>a_i&gt;a_{i+1}&lt;a_{i+2}$</p><p>考虑能否在$a_{i-1}$这个地方再进行一次翻转，要么需要把$a_i$换走，要么需要把$a_{i-1}$换走</p><p>如果要把$a_i$换走，那么就只能在$a_{i+1}$进行操作，因此$a_i$是换不走的</p><p>否则我们只能将$a_{i-1}$换走，但是这会导致换走之后$a_{i-2}&gt;a_{i-1}$，仍然不满足条件，因此结论成立</p><p>我们称此时$i-1,i+1$为不动点</p><p>因此，如果某一个位置上的数一开始就满足$p_i=i$，那么这个位置是无论如何都不能被换走的，因为换走之后就再也换不回来了</p><p>同理，如果一个数一开始往左换了，那么这个数会一直往左，如果这个数开始是往右换的，那么这个数会一直往右</p><p>因此，如果两个位置都需要往左/往右换，那么这两个数在换的过程中的相对顺序不会发生变化，否则必定有一个数跨过了另一个数，与上一行的结论矛盾</p><p>假设$a&lt;b&lt;c$，此时我们交换了$a,c$，并且这两个位置都变成了不动点，这意味着$b$换不走了，因此$a$无论如何都不可能换到$b$右边去</p><p>因此我们每次交换的中心都必定满足$p_i=i$</p><p>如果两个相邻的位置满足$p_i=i,p_{i+1}=i+1$，显然$i$左边的数永远无法换到$i+1$右边去，$i+1$右边的数也无法换到$i$左边来</p><p>考虑根据这个将原排列分成极长的若干段，每段必须满足所有偶数位置的数都满足$p_i=i$，且所有奇数位置的数都满足$p_i\neq i$</p><p>假设这一段为$[l,r]$，那么这一段区间中所有数的值都必须在$[l,r]$中，因为这一段是换不出去的</p><p>将所有奇数位置的数按照往左/往右换分成两类，往左换的必须递增，往右换的必须递减</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num[l] == l) l++;</span><br><span class="line">    <span class="keyword">if</span> (num[r] == r) r--;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i += <span class="number">2</span>) </span><br><span class="line">        <span class="keyword">if</span> (num[i] != i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i += <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (num[i] == i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> mn = <span class="number">1e9</span>, mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) </span><br><span class="line">        mn = min(mn, num[i]), mx = max(mx, num[i]);</span><br><span class="line">    <span class="keyword">if</span> (mn != l || mx != r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l, a = <span class="number">0</span>, b = <span class="number">0</span>; i &lt;= r; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[i] &lt; i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a &gt; num[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            a = num[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &gt; num[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            b = num[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fuck[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]), fuck[i] = num[i] == i;</span><br><span class="line">    <span class="keyword">int</span> ls = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fuck[i] &amp;&amp; fuck[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!check(ls, i - <span class="number">2</span>)) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No"</span>), <span class="number">0</span>;</span><br><span class="line">            ls = i + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!fuck[i] &amp;&amp; !fuck[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!check(ls, i - <span class="number">1</span>)) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No"</span>), <span class="number">0</span>;</span><br><span class="line">            ls = i;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!check(ls, n)) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No"</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC027E ABBreviate</title>
      <link href="/2020/03/05/agc027e-abbreviate/"/>
      <url>/2020/03/05/agc027e-abbreviate/</url>
      
        <content type="html"><![CDATA[<p>给出一个仅包含<code>a</code>和<code>b</code>的串$s$，你可以进行若干次如下的操作</p><ul><li>将两个相邻的<code>a</code>替换为<code>b</code></li><li>将两个相邻的<code>b</code>替换为<code>a</code></li></ul><p>问$s$经过若干次操作之后可能形成多少种不同的串</p><p>$|s|\leq 10^5$，对$10^9+7$取模</p><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>非常神仙的一道题</p><p>如果给出的串不能操作，即形如<code>abab...</code>，那么答案为$1$</p><p>如果我们令<code>a</code>$=1$，<code>b</code>$=2$，然后考虑$s$在模$3$意义下的和，可以发现在每次操作之后的和是不变的</p><p>不难得出这样一个结论：如果$s$经过若干次操作之后能变为一个字符$c$，那么要么$s=c$，要么$s$在模$3$意义下的和与$c$相等，且$s$中有相邻且相同的字符</p><p>现在考虑这样一个问题：给出串$t$，如何判断$s$经过若干次操作之后能否得到$t$？</p><p>显然$t$一定是这样得到的：将$s$划分为若干段，每段依次对应$t$中的一个字符</p><p>如果我们对$s$贪心地划分，即每次找到长度最短的一段，使得这一段在模$3$下的和与$t$的当前字符相等，接下来我们尝试证明这样一个结论：$s$能转化为$t$当且仅当最后剩余的一段在模$3$下的和为$0$</p><p>我们尝试将最后多余的一段与倒数第二段合并，如果合并之后的串能操作，那么结论成立</p><p>否则合并之后的串形如<code>abab...</code>，这说明倒数第二段一定只有一个字符且与$t$的对应字符相同，否则倒数第二段必然有两个相邻且相同的字符，与不能合并矛盾</p><p>我们不妨假设这个字符为<code>a</code>，由于最后一段的和为$0$，这意味着最后一个字符必然是$a$</p><p>此时我们可以留下最后一个字符与$t$的最后一个字符匹配，前面的串继续向前合并，显然这个向前合并的串的和也是$0$</p><p>由于$s$串至少存在一对相邻且相同的字符，因此当合并的过程接触到这个字符的时候合并就结束了，此时$s$的每一段都能操作且对应$t$的某个字符</p><p>考虑倒推，设$dp[i]$表示最后一段的结尾为$i$的方案数</p><p>如果$i+1\sim |s|$的和为$0$，那么$dp[i]$的初值为$1$，否则为$0$</p><p>由于是贪心匹配，因此我们需要记录从当前位置开始，至少要选多少个字符才能使得和为$1/2$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> pre[N], dp[N], nxt[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>); <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        pre[i] = (pre[i - <span class="number">1</span>] + s[i] - <span class="string">'a'</span> + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"1"</span>), <span class="number">0</span>;</span><br><span class="line">    nxt[<span class="number">0</span>] = nxt[<span class="number">1</span>] = nxt[<span class="number">2</span>] = n + <span class="number">1</span>, dp[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre[i - <span class="number">1</span>] == pre[n] &amp;&amp; i != <span class="number">1</span>) dp[i] = <span class="number">1</span>;</span><br><span class="line">        dp[i] = (dp[i] + dp[i + <span class="number">1</span>]) % mod;</span><br><span class="line">        <span class="keyword">int</span> nw = s[i] - <span class="string">'a'</span> + <span class="number">1</span>, t = (pre[i - <span class="number">1</span>] + <span class="number">3</span> - nw) % <span class="number">3</span>;</span><br><span class="line">        dp[i] = (dp[i] + dp[nxt[t] + <span class="number">1</span>]) % mod, nxt[pre[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC021F Trinity</title>
      <link href="/2020/03/04/agc021f-trinity/"/>
      <url>/2020/03/04/agc021f-trinity/</url>
      
        <content type="html"><![CDATA[<p>有一个$N\times M$的网格，每个格子被涂成了黑色或者白色</p><p>有三个数组$A,B,C$，其中$A$的长度为$N$，$B,C$的长度都是$M$</p><p>$A_i$表示第$i$行的所有黑色格子中列的最小值。如果这一行没有黑色格子，那么$A_i=M+1$</p><p>$B_i,C_i$分别表示第$i$列的所有黑色格子中行的最小值以及最大值。如果这一列没有黑色格子，那么$B_i=N+1,C_i=0$</p><p>你需要计算对于所有的染色方式，有多少种可能的$(A,B,C)$会出现</p><p>$N\leq 8000, M\leq 200$，对$998244353$取模</p><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>考虑一列一列地染色，并且我们只考虑那些出现过黑色格子的行</p><p>设$dp[i][j]$表示已经考虑了前$i$列，其中有$j$行被染成过黑色的方案数</p><p>假设现在要从$dp[i][j]$转移到$dp[i+1][j+k]$</p><p>如果$k=0$，这意味着这一列我们只能在那些已经出现过黑色格子的行染色。由于此时两种方案不同当且仅当这一列的$B,C$不同，因此方案数为${j+1\choose 2}+1$</p><p>如果$k\neq 0$，如果这$k$行和原来的$j$行已经排列好了，那么要么我们在新增的这$k$行之前/之后染色，要么这$k$行的第一行/最后一行对应$B_{i+1},C_{i+1}$</p><p>考虑在开头新增一行，在结尾新增一行，可以发现此时方案数为$j+k+2\choose k+2$。含义是，如果选的这$k+2$行没有选到开头或者结尾的那两行，那么我们将选择的第一行和最后一行看做是原来就有的，并在这一列被染黑的行。将中间的$k$行看做是本次新添加的行</p><p>如果选的这$k+2$行选到了开头或者结尾，代表本次添加的新的行成为了此列被染黑的行的最小值/最大值，同样对应着本次新添加的$k$行</p><p>可以发现这个东西是可以$FFT$优化的，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">8010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">210</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[M][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r[N &lt;&lt; <span class="number">2</span>], A[N &lt;&lt; <span class="number">2</span>], B[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, w = <span class="number">1</span>, t; j &lt; i + (mid &gt;&gt; <span class="number">1</span>); j++, w = (LL)w * Wn % mod)</span><br><span class="line">                t = (LL)a[j + (mid &gt;&gt; <span class="number">1</span>)] * w % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!type) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, inv = Pow(len, mod - <span class="number">2</span>); i &lt; len; i++)</span><br><span class="line">        a[i] = (LL)a[i] * inv % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">2</span>; i++) </span><br><span class="line">        frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n * <span class="number">2</span>) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) B[i] = inv[i + <span class="number">2</span>];</span><br><span class="line">    NTT(B, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) A[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) A[j] = (LL)dp[i - <span class="number">1</span>][j] * inv[j] % mod;</span><br><span class="line">        NTT(A, len, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) A[j] = (LL)A[j] * B[j] % mod;</span><br><span class="line">        NTT(A, len, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) </span><br><span class="line">            dp[i][j] = ((LL)frac[j + <span class="number">2</span>] * A[j] + (LL)dp[i - <span class="number">1</span>][j] * (<span class="number">1</span> + C(j + <span class="number">1</span>, <span class="number">2</span>))) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) res = (res + (LL)dp[m][i] * C(n, i)) % mod;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> FFT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARC101F Robots and Exits</title>
      <link href="/2020/03/04/arc101f-robots-and-exits/"/>
      <url>/2020/03/04/arc101f-robots-and-exits/</url>
      
        <content type="html"><![CDATA[<p>数轴上有$N$个机器人，第$i$个机器人的坐标为$X_i$</p><p>有$M$个出口，第$i$个出口的坐标为$Y_i$</p><p>你可以给若干条指令，每次让所有机器人向左移动$1$个单位长度或者向右移动$1$个单位长度</p><p>当一个机器人到达出口时，这个机器人会从这个出口离开数轴。你需要求出有多少种让所有机器人都离开数轴的方案，两种方案不同当且仅当至少存在一个机器人，这个机器人在这两中方案中使用的出口不同</p><p>保证坐标互不相同</p><script type="math/tex; mode=display">N,M\leq 10^5,X_i,Y_i\leq 10^9</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>先将第一个出口左边以及最后一个出口右边所有的机器人删掉，对答案没有影响</p><p>接着对于剩余的机器人，我们求出它距离左边/右边离他最近的出口的距离，记为$(a_i,b_i)$</p><p>将每个机器人想象成二维平面上的一个点$(a_i,b_i)$，我们从起点开始走</p><p>如果当前操作使得$\max\{向左走的步数-向右走的步数\}$增大了，我们认为此时我们往右走了一步</p><p>如果当前操作使得$\max\{向右走的步数-向左走的步数\}$增大了，我们认为此时我们往上走了一步</p><p>这样走若干步之后，所形成的路径构成了一条折线，那么每个机器人对应的出口取决于这条折线是先与$x=a_i$相交还是先与$y=b_i$相交。我们将这两条线称为这个点的边界</p><p>记$dp[i]$表示考虑了$i$以及其左下角的所有点，并且折线与$i$对应的矩形的上边界相交的方案数</p><p>除了与上边界相交的点，其它的点与折线的交点均是右边界</p><p>容易得出这个转移：</p><script type="math/tex; mode=display">dp[i]=\sum_{a_j<a_i,b_j<b_i}dp[j]+1</script><p>扫描线+树状数组即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x += y, x -= x &gt;= mod ? mod : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    Inc(sum[rt], y);</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, x, y);</span><br><span class="line">    <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> sum[rt];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) Inc(res, query(rt &lt;&lt; <span class="number">1</span>, l, mid, start, end));</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) Inc(res, query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, start, end));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[N], y[N], val[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125; p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;y[i]);</span><br><span class="line">    sort(y + <span class="number">1</span>, y + m + <span class="number">1</span>); <span class="keyword">int</span> all = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = lower_bound(y + <span class="number">1</span>, y + m + <span class="number">1</span>, x[i]) - y;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; m || a == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        p[++all] = (Point)&#123;x[i] - y[a - <span class="number">1</span>], y[a] - x[i]&#125;, val[++tot] = y[a] - x[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(val + <span class="number">1</span>, val + tot + <span class="number">1</span>), tot = unique(val + <span class="number">1</span>, val + tot + <span class="number">1</span>) - val - <span class="number">1</span>; </span><br><span class="line">    sort(p + <span class="number">1</span>, p + all + <span class="number">1</span>, [](Point a, Point b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.x == b.x) <span class="keyword">return</span> a.y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">    &#125;);</span><br><span class="line">    update(<span class="number">1</span>, <span class="number">0</span>, tot, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= all; i++) &#123;</span><br><span class="line">        p[i].y = lower_bound(val + <span class="number">1</span>, val + tot + <span class="number">1</span>, p[i].y) - val;</span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; p[i].x == p[i - <span class="number">1</span>].x &amp;&amp; p[i].y == p[i - <span class="number">1</span>].y) <span class="keyword">continue</span>;</span><br><span class="line">        update(<span class="number">1</span>, <span class="number">0</span>, tot, p[i].y, query(<span class="number">1</span>, <span class="number">0</span>, tot, <span class="number">0</span>, p[i].y - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(<span class="number">1</span>, <span class="number">0</span>, tot, <span class="number">0</span>, tot));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARC093 Bichrome Spanning Tree</title>
      <link href="/2020/03/04/arc093-bichrome-spanning-tree/"/>
      <url>/2020/03/04/arc093-bichrome-spanning-tree/</url>
      
        <content type="html"><![CDATA[<p>给一张$N$个点$M$条边的图，每条边有权值$W_i$</p><p>给定$X$，你需要统计有多少种给每条边黑白染色的方式，使得最后满足所有边不同色的最小生成树的边权之和恰好为$X$</p><script type="math/tex; mode=display">N\leq 1000, M\leq 2000,W_i\leq 10^9,X\leq 10^{12}</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这题没什么好说的，分类讨论一下</p><p>首先求出这张图的最小生成树，假设这棵生成树为$T$，其边权之和为$Y$</p><p><strong>1.$X&lt;Y$</strong></p><p>此时显然无解，直接输出$0$即可</p><p><strong>2.$X=Y$</strong></p><p>设$a$表示不在$T$中，且至少在一棵最小生成树上的边的数量</p><p>设$b$表示不在任意一棵最小生成树上的边的数量</p><p>假设$T$的边没有全部被染成相同颜色，那么此时$T$就满足条件，方案数为$2^{N-1}\times 2^{M-N+1}$，即其它边可以随便染色</p><p>否则，只要$a$中存在一条边与$T$不同色就是合法的，方案数为$2\times (2^a-1)\times 2^b$</p><p><strong>3.$X&gt;Y$</strong></p><p>$T$中的边必须被染成相同的颜色</p><p>设$a$表示所在的最小生成树的边权之和$=X$的边的数量</p><p>设$b$表示所在的最小生成树的边权之和$&gt;X$的边的数量</p><p>$a$中的边至少有一条不与$T$同色，$b$中的边随便染色</p><p>方案数为$2\times (2^a-1)\times 2^b$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from], w&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to], w&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N][<span class="number">11</span>], mx[N][<span class="number">11</span>], dep[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = f, dep[u] = dep[f] + <span class="number">1</span>, mx[u][<span class="number">0</span>] = w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        mx[u][i] = max(mx[u][i - <span class="number">1</span>], mx[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u, e[i].w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[a] &lt; dep[b]) swap(a, b);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (dep[fa[a][i]] &gt;= dep[b]) </span><br><span class="line">        res = max(res, mx[a][i]), a = fa[a][i];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (fa[a][i] != fa[b][i]) &#123;</span><br><span class="line">        res = max(res, mx[a][i]), a = fa[a][i];</span><br><span class="line">        res = max(res, mx[b][i]), b = fa[b][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(res, max(mx[a][<span class="number">0</span>], mx[b][<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> from[M], to[M], t[M], w[M], id[M], F[N], pw2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == F[x] ? x : F[x] = find(F[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; LL X; <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>, &amp;n, &amp;m, &amp;X); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) F[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;from[i], &amp;to[i], &amp;w[i]), id[i] = i;</span><br><span class="line">    sort(id + <span class="number">1</span>, id + m + <span class="number">1</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> w[a] &lt; w[b];</span><br><span class="line">    &#125;);</span><br><span class="line">    LL mn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = from[id[i]], b = to[id[i]];</span><br><span class="line">        <span class="keyword">if</span> (find(a) != find(b)) </span><br><span class="line">            t[id[i]] = <span class="number">1</span>, adde(a, b, w[id[i]]), F[find(a)] = find(b), mn += w[id[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (X &lt; mn) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), pw2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) pw2[i] = pw2[i - <span class="number">1</span>] * <span class="number">2</span> % mod;</span><br><span class="line">    <span class="keyword">if</span> (X == mn) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">if</span> (!t[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w[i] == get(from[i], to[i])) a++;</span><br><span class="line">            <span class="keyword">else</span> b++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = (LL)(pw2[n - <span class="number">1</span>] - <span class="number">2</span>) * pw2[m - (n - <span class="number">1</span>)] % mod;</span><br><span class="line">        res = (res + (LL)<span class="number">2</span> * (pw2[a] - <span class="number">1</span>) * pw2[b]) % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">if</span> (!t[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> diff = w[i] - get(from[i], to[i]);</span><br><span class="line">            <span class="keyword">if</span> (diff == X - mn) a++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; X - mn) b++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (LL)<span class="number">2</span> * (pw2[a] - <span class="number">1</span>) * pw2[b] % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC026F Manju Game</title>
      <link href="/2020/03/04/agc026f-manju-game/"/>
      <url>/2020/03/04/agc026f-manju-game/</url>
      
        <content type="html"><![CDATA[<p>有一个长度为$N$的序列$a$，两个人轮流取数，遵循以下规则</p><ul><li>每个数只能取一次</li><li>在第一轮先手可以随意取，但之后的每一轮每个人只能取与前一个人取的位置相邻的位置。如果这样的位置不存在，那么可以随便选一个位置</li></ul><p>先手和后手都希望自己取出的数之和尽量大，问两人在都采取最优策略的情况下取出的数之和分别为多少</p><script type="math/tex; mode=display">N\leq 3\times 10^5,a_i\leq 1000</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先先手可以直接选择这个序列的第一个或者最后一个元素，这样后手的方案就是唯一的</p><p>当$N$为偶数的时候，先手可以取到所有奇数位置或者所有偶数位置</p><p>当$N$为奇数的时候，先手第一次可以取第二个数，此时如果后手取第一个数一定对后手不利，因此后手只能跟着先手取，此时先手也能取到所有偶数位置的数</p><p>先手除了这两种选择还可以选择这个序列中的任意一个元素，然后后手选择这个元素左边/右边与其相邻的元素，之后先手就只能跟着后手轮流选</p><p>如果后手选的那一侧有偶数个数（包括后手选的那一个），那么这一侧的最后一个元素一定是先手取走的。这就意味着接下来后手可以在另一侧随便选择一个数取走，对于先手来说还不如将所有奇数位置或者将所有偶数位置的数取走优秀</p><p>因此我们可以得到一个结论：如果先手选择了从中间开始取数，那么这个位置左边和右边都必定有奇数个数</p><p>显然当$N$为偶数的时候这样的位置是不存在的，因此此时答案就是奇数位置的和与偶数位置的和的最大值，接下来我们讨论当$N$为奇数的情况</p><p>可以发现此时实际上先手和后手不停地在干这样一件事：先手选择当前区间中的一个数-&gt;后手选择左/右的子区间-&gt;后手取走这个区间所有下标为奇数的数，先手取走这个区间所有下标为偶数的数-&gt;递归到另一边的子区间-&gt;…-&gt;先手取走当前区间所有奇数位置/偶数位置的数</p><p>这个过程等价于：初始时先手的分数为所有偶数位置的数之和，每次先手可以：</p><ul><li>将自己的分数加上当前区间奇数位置的数减去偶数位置的数之和，并结束游戏</li><li>取一个偶数位置的数，将区间划分为两个子区间，随后后手选择一个区间继续游戏</li></ul><p>我们可以将这个过程看做一棵二叉树：叶子节点的权值为这个区间奇数位置的数之和减去偶数位置的数之和，后手每次可以选择当前点的一个儿子走过去</p><p>显然后手可以走到这棵二叉树权值最小的那个叶子</p><p>问题等价于：先手要取走若干个偶数位置的数，使得剩下的每一段的奇数位置的数之和减去偶数位置的数之和的最小值尽可能大</p><p>记$sum$表示奇数位置减去偶数位置的前缀和</p><p>二分这个最小值，设其为$mid$</p><p>记$dp[i]$表示最后一段的结尾是否有可能是$i$，转移非常显然：</p><ul><li>$dp[-1]=1$</li><li>$dp[2i+1]|=dp<a href="sum[2i+1]-sum[2j+2]\geq mid">2j+1</a>$</li></ul><p>显然这里我们只需要记录当前为$1$的$dp$状态中，$sum[2i+2]$最小的状态就行了</p><p>时间复杂度$O(N\log N)$，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N], sum[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); <span class="keyword">int</span> A = <span class="number">0</span>, B = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]), sum[i] = sum[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>) sum[i] += num[i], A += num[i];</span><br><span class="line">        <span class="keyword">else</span> sum[i] -= num[i], B += num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, max(A, B), min(A, B));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](<span class="keyword">int</span> mid) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mn = <span class="number">0</span>; <span class="keyword">static</span> <span class="keyword">int</span> dp[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>) </span><br><span class="line">            <span class="keyword">if</span> (sum[i] - mn &gt;= mid) &#123;</span><br><span class="line">                mn = min(mn, sum[i + <span class="number">1</span>]), dp[i] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> dp[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = A + B, mid, res = B;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check(mid = (l + r) &gt;&gt; <span class="number">1</span>)) res = B + mid, l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, res, A + B - res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 博弈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC030D Inversion Sum</title>
      <link href="/2020/03/04/agc030d-inversion-sum/"/>
      <url>/2020/03/04/agc030d-inversion-sum/</url>
      
        <content type="html"><![CDATA[<p>给出$n$个数以及$m$个操作，每个操作都是“交换$X_i,Y_i$”，并且有$1/2$的概率执行，问所有操作执行完毕后序列的逆序对个数的期望</p><script type="math/tex; mode=display">n,m\leq 3000</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>不妨对每一对位置分开统计，即记$dp[i][j]$表示位置$i$的数比位置$j$的数大的概率</p><p>假如这一次操作交换了$i,j$两个位置，那么会影响到$dp[x][j],dp[x][i],dp[j][x],dp[i][x]$这四种位置的值</p><p>这一次操作之后，$j$比$x$大的概率应该与$i$比$x$大的概率相等，因为交换的概率是$1/2$</p><p>然后就很简单了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>, i2 = (mod + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, q, tot = <span class="number">1</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) tot &lt;&lt;= <span class="number">1</span>, tot %= mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            dp[i][j] = a[i] &gt; a[j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        dp[l][r] = dp[r][l] = (LL)(dp[l][r] + dp[r][l]) * i2 % mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span> (j != r &amp;&amp; j != l) &#123;</span><br><span class="line">            dp[j][r] = dp[j][l] = (LL)(dp[j][r] + dp[j][l]) * i2 % mod;</span><br><span class="line">            dp[l][j] = dp[r][j] = (LL)(dp[l][j] + dp[r][j]) * i2 % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            res = (res + dp[i][j]) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL)res * tot % mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARC103D Distance Sums</title>
      <link href="/2020/03/04/arc103d-distance-sums/"/>
      <url>/2020/03/04/arc103d-distance-sums/</url>
      
        <content type="html"><![CDATA[<p>给出$n$个互不相同的$D_i$，你需要构造一棵树，使得第$i$个点到全树的距离之和等于$D_i$，每条边的边权都是$1$</p><script type="math/tex; mode=display">n\leq 10^5,1\leq D_i\leq 10^{12}</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先要知道一个很重要的结论：一棵树的重心到全树的距离之和最小</p><p>这个结论比较显然，因为将当前点往$size$更大的那一边挪，距离之和会变小，最后一定会挪到重心</p><p>那么我们把重心提出来作为这棵树的根，此时有另一个结论：父亲节点的$D$一定比儿子小</p><p>每次我们将$D$最大的那个点拿出来删掉，同时维护其它节点子树的大小，根据当前拿出来的点的子树大小，我们可以算出它父亲的$D$。由于每个$D$都互不相同，我们可以确定它的父亲，然后更新父亲的$size$即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line">LL D[N]; <span class="keyword">int</span> id[N], sz[N];</span><br><span class="line"><span class="built_in">map</span>&lt;LL, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Fuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    G[from].push_back(to), G[to].push_back(from);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) <span class="keyword">if</span> (v != f) </span><br><span class="line">        res += dfs(v, u) + sz[v];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;D[i]), mp[D[i]] = i, sz[i] = <span class="number">1</span>, id[i] = i;</span><br><span class="line">    sort(id + <span class="number">1</span>, id + n + <span class="number">1</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> D[a] &gt; D[b];&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = id[i];</span><br><span class="line">        LL tmp = D[v] - n + sz[v] * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (!mp.count(tmp) || tmp &gt;= D[v]) Fuck();</span><br><span class="line">        adde(v, mp[tmp]), sz[mp[tmp]] += sz[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfs(id[n], <span class="number">0</span>) != D[id[n]]) Fuck();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[i]) <span class="keyword">if</span> (v &gt; i) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, i, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC023E Inversions</title>
      <link href="/2020/03/04/agc023e-inversions/"/>
      <url>/2020/03/04/agc023e-inversions/</url>
      
        <content type="html"><![CDATA[<p>给定一个长度为$N$的序列$A$，你需要统计所有满足$P_i\leq A_i$的排列的逆序对个数之和</p><p>$N\leq 2\times 10^5$，对$10^9+7$取模</p><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先考虑如何统计方案数</p><p>我们记$B_i$表示$A_k\geq i$的个数，即$i$能放的位置的数量，那么答案为</p><script type="math/tex; mode=display">\prod_{i=1}^nB_i-(n-i)</script><p>这个式子的含义是，考虑从大到小依次放入$n\sim 1$，比$i$大的数会占去$n-i$个位置，一共有$B_i$个位置可以容纳$i$以及比$i$大的数</p><p>接着我们枚举两个位置$i,j(i&lt;j)$，考虑这两个位置所形成的逆序对对答案的贡献</p><p>我们分三种情况讨论</p><p><strong>1.$A_i=A_j$</strong></p><p>这两个位置的数是对称的，即交换这两个位置的数对答案不会产生任何影响。因此在总方案中，有一半的情况满足$P_i&gt;P_j$，直接将总方案数除以$2$即可</p><p><strong>2.$A_i&lt;A_j$</strong></p><p>$P_i$的最大值不能超过$A_i$，这意味着如果这两个位置要形成逆序对的话，$P_j$的值也不能超过$A_i$，这样就转化为了$A_i=A_j$的情况</p><p><strong>3.$A_i&gt;A_j$</strong></p><p>用总数减去$P_i&lt;P_j$的情况，也可以转化为$A_i=A_j$</p><p>注意到这三种情况中，除了第一种情况，另外两种情况均会对$A_i$产生修改，如何快速维护修改并求出对应的方案数呢</p><p>假设我们要将$A_i$改成$A_j(A_j&lt;A_i)$</p><p>这会导致$B_{A_j}$到$B_{A_i}$减$1$</p><p>设$D_i=\frac{B_i-(n-i)-1}{B_i-(n-i)}$，那么这一次修改会导致答案乘上$\prod_{k=i+1}^{j}D_k$</p><p>记录一下$D$的前缀积$D’_i$，转化为答案乘以$\frac{D’_j}{D’_i}$</p><p>由于$D$可能为$0$，因此还要记录一下某个位置前面/后面第一个为$0$的位置</p><p>树状数组维护区间和就行了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inv2 = (mod + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FUCK</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> tree[N];</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += x &amp; -x) tree[x] = (tree[x] + y) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= x &amp; -x) res = (res + tree[x]) % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (query(r) - query(l - <span class="number">1</span>) + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; X, Y, Z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N], num[N], pre[N], lst[N], nxt[N], ct[N];</span><br><span class="line"><span class="keyword">bool</span> fuck[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), A[a]++, num[i] = a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--) A[i] += A[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span>; pre[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        A[i] -= n - i, tot = (LL)tot * A[i] % mod;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t = (LL)(A[i] - <span class="number">1</span>) * Pow(A[i], mod - <span class="number">2</span>) % mod;</span><br><span class="line">        <span class="keyword">if</span> (t) pre[i] = (LL)pre[i - <span class="number">1</span>] * t % mod;</span><br><span class="line">        <span class="keyword">else</span> pre[i] = pre[i - <span class="number">1</span>], fuck[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    nxt[n + <span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        nxt[i] = nxt[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (fuck[i]) nxt[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        lst[i] = lst[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (fuck[i]) lst[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        res = (res + (LL)ct[num[i]] * tot % mod * inv2) % mod;</span><br><span class="line">        <span class="keyword">if</span> (num[i] != <span class="number">1</span>) &#123;</span><br><span class="line">            res = (res + (LL)Y.query(max(<span class="number">1</span>, lst[num[i]]), num[i] - <span class="number">1</span>) * pre[num[i]] % mod</span><br><span class="line">                * tot % mod * inv2) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num[i] != n) &#123;</span><br><span class="line">            res = (res + (LL)Z.query(num[i] + <span class="number">1</span>, n) * tot) % mod;</span><br><span class="line">            res = (res - (LL)X.query(num[i] + <span class="number">1</span>, min(n, nxt[num[i] + <span class="number">1</span>] - <span class="number">1</span>)) * Pow(pre[num[i]], mod - <span class="number">2</span>) % mod</span><br><span class="line">                * tot % mod * inv2 % mod + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        X.update(num[i], pre[num[i]]), Y.update(num[i], Pow(pre[num[i]], mod - <span class="number">2</span>)), Z.update(num[i], <span class="number">1</span>), ct[num[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC023D Go Home</title>
      <link href="/2020/03/04/agc023d-go-home/"/>
      <url>/2020/03/04/agc023d-go-home/</url>
      
        <content type="html"><![CDATA[<p>在一条街上有$N$座公寓，第$i$座公寓的坐标为$X_i$，有$P_i$个人住在这座公寓里面</p><p>所有人都在一家公司里面上班，这家公司的坐标为$S$，下班的时候，所有人将会乘坐同一辆公交车回家</p><p>每一时刻所有在公交车上的人都会投一次票，以决定此时公交车应该往左开还是往右开。公交车会往票数更多的那个方向开，如果票数相同，则向左开。当公交车到达一座公寓的时候，住在这座公寓里面的人会马上下车</p><p>每个人都是自私的，希望自己能够尽早回家，但这并不意味着每次投票的时候总是投向自己家的方向，因为这样不一定最优</p><p>问当所有人都采取最优策略的时候，这辆公交车需要多久才能将所有人都送回家</p><script type="math/tex; mode=display">N\leq 10^5,S,X_i,P_i\leq 10^9</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>很有意思的一道题</p><p>考虑倒推</p><p>如果只有两座公寓，它们坐落在$S$的两侧，左侧的公寓有$a$个人，右侧的公寓有$b$个人，不妨设$a\geq b$</p><p>如果右侧的人在投票的时候希望往右开，肯定干不过左侧的人希望往左开，公交车仍然会朝左开而不是朝右</p><p>那么对于右侧的这些人来讲，他们还不如先投往左的票，帮助左侧的人到达他们的家，在到家之后再投朝右的票</p><p>于是我们可以将这两座公寓合并，只留下左侧的公寓，现在这座公寓里面一共有$a+b$个人</p><p>由于在某个时刻，还没有下车的人一定是一段前缀和一段后缀，因此这样倒推是对的</p><p>需要注意的是如果我们连续多次选择删去同一个方向的公寓，那么代价是没有必要计算的</p><p>比如左侧有一座公寓$a$，右侧有两座公寓$b,c$，我们依次删去了$c,b$</p><p>显然最终的方案是，公交车先到了$a$，然后开向$c$，在途中顺便经过$b$，显然$b$的代价不需要计算</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line">LL num[N]; <span class="keyword">int</span> pos[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, s; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>, &amp;pos[i], &amp;num[i]);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n, ls = <span class="number">0</span>; LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos[l] &gt; s) &#123; res += pos[r] - s; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos[r] &lt; s) &#123; res += s - pos[l]; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">int</span> nw;</span><br><span class="line">        <span class="keyword">if</span> (num[l] &gt;= num[r]) nw = <span class="number">1</span>, num[l] += num[r];</span><br><span class="line">        <span class="keyword">else</span> nw = <span class="number">-1</span>, num[r] += num[l];</span><br><span class="line">        <span class="keyword">if</span> (nw != ls) res += pos[r] - pos[l];</span><br><span class="line">        ls = nw;</span><br><span class="line">        <span class="keyword">if</span> (nw == <span class="number">-1</span>) l++; <span class="keyword">else</span> r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC022F Checkers</title>
      <link href="/2020/03/04/agc022f-checkers/"/>
      <url>/2020/03/04/agc022f-checkers/</url>
      
        <content type="html"><![CDATA[<p>令$X=10^{100}$，在一条数轴上有$N$个点，第$i$个点的坐标为$X^i$</p><p>每一轮，你会选择当前仍然存在的两个不同的点$A,B$，将$A$移动到其关于$B$的对称点，并把$B$删掉</p><p>容易发现这样进行$N-1$轮后会剩下一个点，你需要求出这个点的坐标有多少种可能的取值</p><p>$N\leq 50$，对$998244353$取模</p><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>神仙题</p><p>如果在一次操作中，$A$跨过了$B$，$B$被删掉了，那么我们将$A$作为父亲，$B$作为儿子，从$A$向$B$连一条边</p><p>我们最终会得到一棵树，这棵树的根节点就是最后被保留下来的点，我们会从叶子到根按照树的形态依次执行每个操作，直到最后剩下根节点</p><p>举个例子，考虑这样一棵树：根节点为$a$，它有两个儿子$b,c$</p><p>假设操作顺序是这样的：$a$先跨过并删去了$b$，接着跨过了$c$</p><p>第一次跨越时，$a$的坐标变为了$2b-a$；第二次跨越时，$a$的坐标变为了$a-2b+2c$</p><p>我们可以发现最终每个点对答案的贡献的系数一定是形如$\pm 2^d$的形式，其中$d$是这个点的深度</p><p>由于$X$非常大，因此我们认为两种方案中如果存在一个点它的贡献系数不一样，这两种方案就是不同的</p><p>深度很好考虑，但是如何确定一个点贡献的正负号呢</p><p>假设$a$节点是树根，考虑$a$的正负号会被哪些节点影响</p><p>每操作一次$a$的儿子会导致$a$的正负性变化一次，因此如果$a$有奇数个儿子，那么$a$<strong>此时</strong>的符号就为负，否则为正</p><p>操作完$a$的子树之后，我们考虑$a$的父亲对其的影响</p><p>$a$的父亲会将其所有儿子排列起来依次操作过去，此时若$a$节点之后一共排了偶数个儿子，$a$以及它的子树的贡献将被全部取反</p><p>这样每个点的正负性与它的每个祖先都有关系，很不好处理</p><p>考虑差分，即考虑$a$<strong>最终的贡献</strong>与其父亲<strong>最终的贡献</strong>是否相同，这样就可以很好地处理“将子树全部取反”这个操作</p><p>如果树的形态确定了，考虑从叶子到根依次求出差分值，假设当前已经求好了$u$的所有儿子以及它们所在的子树的差分，现在要加入$u$</p><p>如果$u$有奇数个儿子，那么$u$以及$u$的所有儿子的差分将会异或$1$</p><p>考虑$u$的儿子的操作顺序，如果$v$后面有偶数个儿子，将$v$的差分异或$1$</p><p>对于一个有$m$个儿子的点，显然必须有$\lfloor\frac{m}{2}\rfloor$个儿子的差分不需要异或$1$，$\lceil\frac{m}{2}\rceil$个儿子的差分需要异或$1$</p><p>然后我们就可以开始愉快地$dp$了</p><p>考虑从根往叶子递推，直接确定每个点最后的差分是啥</p><p>记$dp[i][k]$表示已经挂了$i$个节点，当前的最后一层有$k$个节点被钦定将会有奇数个儿子的本质不同的方案数</p><p>枚举当前这一层要挂的点数，假设为$m$</p><p>首先给每个被钦定有奇数个儿子的点都挂一个儿子，并将这个儿子作为这个点最先被操作的儿子。如果不考虑这个儿子的儿子，那么这个儿子的差分将为$1$</p><p>接着就转化成了每个点都要挂上偶数个儿子的情况（有奇数个儿子的点的第一个被操作的儿子已经被确定了，其所有儿子的差分将会被异或上两次$1$，等价于没有异或）</p><p>这意味着，$m-k$必须要是偶数，且其中有$\frac{m-k}{2}$个点的差分为$0$</p><p>但是此时我们还未考虑新挂上的这些点的儿子，也就是说此时我们求出来的差分值并不是最后每个点的差分值。如果这一次我们挂上的某个点将会有奇数个儿子，那么它的差分值将会异或$1$</p><p>枚举这一层实际上有多少个点的差分值是$1$，假设有$d$个</p><p>这意味着当前这一层至少会有$|d-\frac{m-k}{2}|$个点在之后会拥有奇数个儿子</p><p>实际上我们只能统计这一层恰有$|d-\frac{m-k}{2}|$个点有奇数个儿子的情况，在其它情况中，为了保持最后差分为$1$的点的数量不变，每次必然会钦定两个差分不同的儿子将会有奇数个儿子</p><p>此时我们直接交换这两个点的操作顺序，并将其中一个点的所有儿子合并到另一个点的儿子里面，可以保持所有点的符号不变，即答案不变。因此不能算这种情况，会导致重复计数</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">51</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[N][N]; <span class="comment">// 已经挂了i个点，最后一层有j个点有奇数个儿子，还未考虑儿子的挂法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = dp[<span class="number">1</span>][<span class="number">0</span>] = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n - i; j++) <span class="comment">// 当前这一层的点数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j; k++) &#123; <span class="comment">// 上一层奇数个儿子的点的数量</span></span><br><span class="line">                <span class="keyword">if</span> ((j - k) &amp; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> delta = (j - k) / <span class="number">2</span>; <span class="comment">// 未考虑下一层时，这一层有多少个点与父亲符号不同</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt;= j; t++) &#123; <span class="comment">// 实际有多少个符号不同</span></span><br><span class="line">                    <span class="keyword">int</span> tmp = <span class="built_in">abs</span>(t - delta); <span class="comment">// 这一层有奇数个儿子的点的数量</span></span><br><span class="line">                    dp[i + j][tmp] = (dp[i + j][tmp] + (LL)dp[i][k] * C(n - i, j) % mod * C(j, t)) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[n][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC020F Arcs on a Circle</title>
      <link href="/2020/03/04/agc020f-arcs-on-a-circle/"/>
      <url>/2020/03/04/agc020f-arcs-on-a-circle/</url>
      
        <content type="html"><![CDATA[<p>有一个周长为$C$的圆，你有$N$条弧，第$i$条弧的长度为$L_i$</p><p>弧会在圆上独立且随机地放置，问整个圆都被覆盖的概率</p><script type="math/tex; mode=display">N\leq 6, C,L_i\leq 50</script><p>输入的每个数都是正整数</p><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先断环为链，我们选取这些弧中最长弧的起点作为链的起点</p><p>之所以选择最长弧，是因为这样可以保证，在最终的覆盖中一定不存在一条弧完全包含这条弧</p><p>注意到一个有趣的性质：所有弧的长度均为整数，圆的周长也是整数</p><p>假设所有弧的放置位置都已经确定下来了，那么如何判断两条弧的关系呢</p><p>显然这与两条弧的放置位置有关，但是由于放置位置可以是实数，不好处理</p><p>有一种神奇的思路是：我们将所有弧的起点离散化，即将一条长度为$l$的弧的起点$x$分为整数部分$a$和小数部分$b$。对于整数部分我们不需要特别处理，对于小数部分我们将其离散化，即$(n-1)!$地枚举所有弧起点小数部分的相对大小关系。特别地，第一条已经确定的弧不需要枚举</p><p>此时的端点总数变成了$NC$个</p><p>接下来我们只需要尝试在每个端点放弧就行了，设$dp[i][j][s]$表示已经考虑了左端点$\leq i$的位置，此时右端点最大覆盖到了$j$，已经放了$s$集合中的弧的方案数</p><p>注意转移的时候我们需要保证$j$始终不小于$i$，即圆上的每一条线段均被覆盖</p><p>最终的答案需要除以$(n-1)!$再除以$c^{n-1}$。除以$(n-1)!$是因为我们枚举了小数的相对顺序，除以$c^{n-1}$是因为每条弧的起点的整数部分是可以随便定的，每条弧有$c$种选法，因此总方案数为$c^{n-1}$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id[N], l[N]; <span class="keyword">double</span> dp[<span class="number">350</span>][<span class="number">1</span> &lt;&lt; <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, c, frac = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;c); <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;l[i]), id[i] = i;</span><br><span class="line">    sort(l + <span class="number">1</span>, l + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123; <span class="comment">// 枚举小数的相对大小</span></span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[l[n] * n][<span class="number">1</span> &lt;&lt; n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * c; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nw = id[(i - <span class="number">1</span>) % n + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nw == n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n * c; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> s = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; s &gt; <span class="number">0</span>; s--) <span class="keyword">if</span> (dp[j][s] &amp;&amp; !(s &amp; (<span class="number">1</span> &lt;&lt; nw - <span class="number">1</span>))) </span><br><span class="line">                    dp[min(n * c, max(j, i + l[nw] * n))][s | (<span class="number">1</span> &lt;&lt; nw - <span class="number">1</span>)] += dp[j][s];</span><br><span class="line">        &#125;</span><br><span class="line">        ans += dp[n * c][(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>], frac++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (next_permutation(id + <span class="number">1</span>, id + n));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.12lf\n"</span>, ans / frac / <span class="built_in">pow</span>(c, n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARC096F Sweet Alchemy</title>
      <link href="/2020/03/03/arc096f-sweet-alchemy/"/>
      <url>/2020/03/03/arc096f-sweet-alchemy/</url>
      
        <content type="html"><![CDATA[<p>有一棵$N$个点的树，第$i$个点的父亲是$p_i$，权值为$m_i$</p><p>给定两个整数$X,D$</p><p>你要为每个点分配$c_i$，使得</p><ul><li>$c_{p_i}\leq c_i\leq c_{p_i}+D$</li><li>$\sum m_ic_i\leq X$</li><li>$\sum c_i$尽可能大</li></ul><script type="math/tex; mode=display">N\leq 50, X,D,m_i\leq 10^9</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>第一个限制看起来很奇怪，每个点都必须比它的父亲大</p><p>我们将问题转换一下，将给每个点分配$c_i$看做对这棵树进行若干次子树加，这样就可以保证每个点的权值一定比其父亲权值大，且每个点作为根进行的加操作次数不能超过$D$</p><p>其实就是将原来的$c_i$差分了一下，记$a_i$为差分之后每个点的权值</p><p>接着，对于第$i$个点，我们将这个点的$m_i$变为其子树的$m_i$之和，含义是对这个点的子树进行一次加操作需要的代价</p><p>那么问题就变为了要给每个点分配$a_i$，使得</p><ul><li>对于$i\in [2,n]$，满足$a_i\leq D$</li><li>$\sum m_ia_i\leq X$</li><li>$\sum sz_ia_i$尽可能大，其中$sz_i$表示节点$i$的子树大小</li></ul><p>可以看出这就是普通的背包问题。但是与一般背包问题不同的是，这里每个物品的体积、背包总容量都特别大，物品总数和每个物品的价值都很小</p><p>有一种贪心是将所有物品按照价值/体积排序，但是显然直接这样贪心是错的，因为有可能一个物品的体积太大导致剩余的空间没有被很好地利用</p><p>注意到一件事情：如果这些物品价值的最大值为$k$，那么在最终方案中，如果两个物品$a,b$满足$a$的价值/体积大于$b$的价值/体积，那么$b$取的次数一定$k$</p><p>因为，$b$取$k$次耗费的代价和体积一定大于$a$再取一次需要耗费的代价和体积</p><p>所以我们可以将每个物品拿$k$个出来跑普通的背包，对于剩下的物品沿用那个错误的贪心就行了</p><p>在本问题中，$k=n$，背包中物品价值总和不会超过$n^3$</p><p>记$dp[i][j]$表示考虑了前$i$个物品，价值总和为$j$时最少需要多少空间，时间复杂度$O(n^5)$，但是跑不满，可以优化到$O(n^4\log n)$</p><p>注意爆<code>long long</code></p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">51</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line">LL dp[N][N * N * N], sum[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[N], w[N], id[N]; LL pre[N], pre1[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, d; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; sum[i], w[i] = <span class="number">1</span>, id[i] = i;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">1</span>) <span class="built_in">cin</span> &gt;&gt; p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) </span><br><span class="line">        sum[p[i]] += sum[i], w[p[i]] += w[i];</span><br><span class="line">    <span class="keyword">int</span> lim = min(d, n);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp)), dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= (i - <span class="number">1</span>) * lim * n; j++) <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] &lt;= m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= lim; k++) &#123;</span><br><span class="line">                dp[i][j + k * w[i]] = min(dp[i][j + k * w[i]], dp[i - <span class="number">1</span>][j] + k * sum[i]);</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j + k * w[i]] &gt; m) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(id + <span class="number">1</span>, id + n + <span class="number">1</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> w[a] * sum[b] &gt; w[b] * sum[a];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre[i - <span class="number">1</span>] &gt;= m) &#123;</span><br><span class="line">            pre[i] = pre[i - <span class="number">1</span>] + <span class="number">1</span>; <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> at = id[i], tmp = at == <span class="number">1</span> ? <span class="number">1e9</span> : d - lim;</span><br><span class="line">        <span class="keyword">if</span> (sum[at] &gt;= m &amp;&amp; tmp) pre[i] = m;</span><br><span class="line">        <span class="keyword">else</span> pre[i] = pre[i - <span class="number">1</span>] + tmp * sum[at], pre1[i] = pre1[i - <span class="number">1</span>] + (LL)tmp * w[at];</span><br><span class="line">    &#125;   </span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n * n * lim; i++) <span class="keyword">if</span> (dp[n][i] &lt;= m) &#123;</span><br><span class="line">        LL remain = m - dp[n][i];</span><br><span class="line">        <span class="keyword">int</span> pos = upper_bound(pre + <span class="number">1</span>, pre + n + <span class="number">1</span>, remain) - pre - <span class="number">1</span>;</span><br><span class="line">        res = max(res, i + pre1[pos] + w[id[pos + <span class="number">1</span>]] * ((remain - pre[pos]) / sum[id[pos + <span class="number">1</span>]]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC027D Modulo Matrix</title>
      <link href="/2020/03/03/agc027d-modulo-matrix/"/>
      <url>/2020/03/03/agc027d-modulo-matrix/</url>
      
        <content type="html"><![CDATA[<p>给定一个正整数$N$</p><p>你需要构造一个$N\times N$的矩阵$a$，并且满足如下条件</p><ul><li>$1\leq a_{i,j}\leq 10^{15}$</li><li>$a_{i,j}$互不相同</li><li>存在一个正整数$m$满足：对于任意的两个相邻的格子$x,y$，总有$\max(x,y)\mod \min(x,y)=m$</li></ul><script type="math/tex; mode=display">2\leq N\leq 500</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>考虑构造$m=1$</p><p>将所有格子按照奇偶性黑白染色，使得任意两个相邻的格子的颜色不同</p><p>接下来，我们钦定白色格子一定比其相邻的黑色格子大</p><p>如何保证$\max(x,y)\mod \min(x,y)=1$呢</p><p>一个很自然的想法是，对于每个白色格子，填上与其相邻的四个黑色格子所填的数的$\text{lcm}+1$</p><p>为了保证每个数互不相同，需要给每一个黑色格子分配一个质数</p><p>这样模出来显然是$1$</p><p>但是这样四个格子的乘积会超过$10^{15}$的上界，因为每个黑色格子分配的质数是$N^2$级别的</p><p>此时有一个巧妙的优化方法，对于每条主对角线，我们给它分配一个质数；对于每条副对角线，我们也给它分配一个质数，每个黑色格子的权值就是其所在的主对角线乘以其所在的副对角线</p><p>这样可以保证每个黑色格子里面的数都互不相同</p><p>白色格子的取值仍然是其周围的黑色格子的权值的$\text{lcm}+1$，这样白色格子的权值从原来的$N^8$级别下降到了$N^4$级别，就不会超过上界了</p><p>代码如下</p><p>``` cpp</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><p>using namespace std;</p><p>const int N = 10010;</p><p>typedef long long LL;</p><p>int flag[N], prime[N], pcnt;</p><p>inline void sieve() {<br>    for (int i = 2; i &lt;= N - 10; i++) {<br>        if (!flag[i]) prime[++pcnt] = i;<br>        for (int j = 1; j &lt;= pcnt &amp;&amp; i <em> prime[j] &lt;= N - 10; j++) {<br>            flag[i </em> prime[j]] = 1;<br>            if (i % prime[j] == 0) break;<br>        }<br>    }<br>}</p><p>LL G[510][510];</p><p>LL gcd(LL a, LL b) {<br>    return b ? gcd(b, a % b) : a;<br>}</p><p>inline LL lcm(LL a, LL b) {<br>    return a / gcd(a, b) * b;<br>}</p><p>template<typename... T><br>inline LL lcm(LL a, T… b) {<br>    LL t = lcm(b…);<br>    return a / gcd(a, t) * t;<br>}</p><p>int main() {<br>    int n; scanf(“%d”, &amp;n), sieve();<br>    if (n == 2) return puts(“4 7\n23 10”), 0;<br>    for (int i = 0; i &lt;= n + 1; i++)<br>        for (int j = 0; j &lt;= n + 1; j++) G[i][j] = 1;<br>    for (int i = 1; i &lt;= n; i++)<br>        for (int j = 1; j &lt;= n; j++) if ((i + j) &amp; 1) {<br>            int a = i + j, b = i - j; a = (a - 1) / 2, b = (b + n + 1) / 2;<br>            G[i][j] = (LL)prime[a] * prime[b + n - 1];<br>        }<br>    for (int i = 1; i &lt;= n; i++, puts(“”))<br>        for (int j = 1; j &lt;= n; j++) {<br>            if (!((i + j) &amp; 1)) G[i][j] = (LL)lcm(G[i - 1][j], G[i][j - 1], G[i + 1][j], G[i][j + 1]) + 1;<br>            printf(“%lld “, G[i][j]);<br>        }<br>}<br>``</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC025D Choosing Points</title>
      <link href="/2020/03/03/agc025-choosing-points/"/>
      <url>/2020/03/03/agc025-choosing-points/</url>
      
        <content type="html"><![CDATA[<p>给定$N,D_1,D_2$，你需要找到$N^2$个不同的整点，使得</p><ul><li>每个点的坐标$(i,j)$满足$0\leq i,j\leq 2N$</li><li>任意两个点的距离的平方都不是$D_1$或$D_2$</li></ul><script type="math/tex; mode=display">N\leq 300, D_1, D_2\leq 2\times 10^5</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先有一个结论：如果将网格图上所有距离为定值的点对互相连边，得到的图一定是二分图</p><p>接着我们根据$D_1,D_2$这两个限制对这$N^2$个点染两次色</p><p>那么最后每个点一共有四种情况：在第一次染色中被染了黑/白；在第二次染色中被染了黑/白</p><p>我们可以看做一共有四种颜色，并且相同颜色的点内部没有边</p><p>由于一共有$4N^2$个点可以选择，我们选这四种颜色中，点数最多的那个集合就可以了，这个集合里面的点数一定大于$N^2$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> G[<span class="number">2</span>][N * <span class="number">2</span>][N * <span class="number">2</span>], n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt; dir;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : dir) &#123;</span><br><span class="line">        <span class="keyword">int</span> tx = x + v.first, ty = y + v.second;</span><br><span class="line">        <span class="keyword">if</span> (tx &gt; n * <span class="number">2</span> || ty &gt; n * <span class="number">2</span> || tx &lt; <span class="number">1</span> || ty &lt; <span class="number">1</span> || G[t][tx][ty]) <span class="keyword">continue</span>;</span><br><span class="line">        G[t][tx][ty] = <span class="number">3</span> - G[t][x][y], dfs(tx, ty, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Just_DOIT</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    dir.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * n; j++)</span><br><span class="line">            <span class="keyword">if</span> ((LL)i * i + (LL)j * j == d) </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">4</span>; t++) </span><br><span class="line">                    dir.push_back(P(t &amp; <span class="number">1</span> ? i : -i, t &amp; <span class="number">2</span> ? j : -j));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n * <span class="number">2</span>; j++) <span class="keyword">if</span> (!G[t][i][j]) </span><br><span class="line">            G[t][i][j] = <span class="number">1</span>, dfs(i, j, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt; fuck[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d1, d2; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;d1, &amp;d2);</span><br><span class="line">    Just_DOIT(<span class="number">0</span>, d1), Just_DOIT(<span class="number">1</span>, d2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n * <span class="number">2</span>; j++)</span><br><span class="line">            fuck[G[<span class="number">0</span>][i][j] + G[<span class="number">1</span>][i][j] * <span class="number">2</span> - <span class="number">3</span>].push_back(P(i, j));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="keyword">if</span> (fuck[i].size() &gt;= n * n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n * n; j++) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, fuck[i][j].first - <span class="number">1</span>, fuck[i][j].second - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARC099F Eating Symbols Hard</title>
      <link href="/2020/03/03/arc099f-eating-symbols-hard/"/>
      <url>/2020/03/03/arc099f-eating-symbols-hard/</url>
      
        <content type="html"><![CDATA[<p>数轴上有$2\times 10^9+1$个位置：从$-10^9$到$10^9$，一开始这些位置上的数都是$0$</p><p>有一个指针$p$，一开始$p=0$</p><p>给定一个由<code>&lt;,&gt;,+,-</code>构成的序列$S$，我们根据这个序列对数轴进行如下操作：</p><ul><li>如果下一个字符为<code>+</code>，那么数轴上$p$这个位置的数会增加$1$</li><li>如果下一个字符为<code>-</code>，那么数轴上$p$这个位置的数会减少$1$</li><li>如果下一个字符为<code>&gt;</code>，那么$p$会增加$1$</li><li>如果下一个字符为<code>&lt;</code>，那么$p$会减少$1$</li></ul><p>你需要统计$S$有多少个非空子串，满足如果根据这个子串来进行操作，最终得到的数轴与根据$S$进行操作得到的数轴完全相同</p><script type="math/tex; mode=display">|S|\leq 2.5\times 10^5</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>考虑<code>hash</code>，假设最终数轴上第$i$个位置的数是$A_i$，那么可以将整个数轴压缩为</p><script type="math/tex; mode=display">\sum_{i}A_ix^i</script><p>序列$S$的<code>hash</code>值很好求出来，如何求出一个指定区间的<code>hash</code>值呢</p><p>假设需要求的区间是$[l,r]$，并且我们知道$[1,l-1]$与$[1,r]$的<code>hash</code>值</p><p>显然我们不能直接将这两个位置的<code>hash</code>值相减，因为指针$p$的起点不一样</p><p>假设在$l-1$时，指针为$p_1$；在$r$时，指针为$p_2$，$[1,i]$的<code>hash</code>值为$h_i$</p><p>那么$[l,r]$合法的条件是</p><script type="math/tex; mode=display">\frac{h_r-h_{l-1}}{x^{p_1}}=h_{|S|}\Rightarrow h_r=h_{|S|}x^{p_1}+h_{l-1}</script><p>将等式右边的数压入<code>map</code>即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">250010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod[] = &#123;<span class="number">1000000007</span>, <span class="number">1000000009</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P[] = &#123;<span class="number">131</span>, <span class="number">233</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Pow[<span class="number">2</span>][N * <span class="number">2</span>]; <span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">FUCK</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    Data(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) &#123;val[<span class="number">0</span>] = a, val[<span class="number">1</span>] = b;&#125; </span><br><span class="line"></span><br><span class="line">    Data <span class="keyword">operator</span> + (<span class="keyword">const</span> Data &amp;b) &#123;</span><br><span class="line">        Data res;</span><br><span class="line">        res.val[<span class="number">0</span>] = (val[<span class="number">0</span>] + b.val[<span class="number">0</span>]) % mod[<span class="number">0</span>];</span><br><span class="line">        res.val[<span class="number">1</span>] = (val[<span class="number">1</span>] + b.val[<span class="number">1</span>]) % mod[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Data <span class="keyword">operator</span> - (<span class="keyword">const</span> Data &amp;b) &#123;</span><br><span class="line">        Data res;</span><br><span class="line">        res.val[<span class="number">0</span>] = (val[<span class="number">0</span>] - b.val[<span class="number">0</span>] + mod[<span class="number">0</span>]) % mod[<span class="number">0</span>];</span><br><span class="line">        res.val[<span class="number">1</span>] = (val[<span class="number">1</span>] - b.val[<span class="number">1</span>] + mod[<span class="number">1</span>]) % mod[<span class="number">1</span>]; </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Data <span class="keyword">operator</span> * (<span class="keyword">const</span> <span class="keyword">int</span> b) &#123;</span><br><span class="line">        Data res = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">int</span> a = b &gt;= <span class="number">0</span> ? Pow[<span class="number">0</span>][b] : FUCK(P[<span class="number">0</span>], (LL)(mod[<span class="number">0</span>] - <span class="number">2</span>) * (-b) % (mod[<span class="number">0</span>] - <span class="number">1</span>), mod[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> c = b &gt;= <span class="number">0</span> ? Pow[<span class="number">1</span>][b] : FUCK(P[<span class="number">1</span>], (LL)(mod[<span class="number">1</span>] - <span class="number">2</span>) * (-b) % (mod[<span class="number">1</span>] - <span class="number">1</span>), mod[<span class="number">1</span>]);</span><br><span class="line">        res.val[<span class="number">0</span>] = (LL)res.val[<span class="number">0</span>] * a % mod[<span class="number">0</span>];</span><br><span class="line">        res.val[<span class="number">1</span>] = (LL)res.val[<span class="number">1</span>] * c % mod[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Data &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (val[<span class="number">0</span>] != b.val[<span class="number">0</span>]) <span class="keyword">return</span> val[<span class="number">0</span>] &lt; b.val[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> val[<span class="number">1</span>] &lt; b.val[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;Data, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">(Data &amp;a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    a = a + (Data)&#123;Pow[<span class="number">0</span>][b], Pow[<span class="number">1</span>][b]&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">decrease</span><span class="params">(Data &amp;a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    a = a - (Data)&#123;Pow[<span class="number">0</span>][b], Pow[<span class="number">1</span>][b]&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d%s"</span>, &amp;n, s + <span class="number">1</span>); Data all;</span><br><span class="line">    Pow[<span class="number">0</span>][<span class="number">0</span>] = Pow[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n * <span class="number">2</span>; j++)</span><br><span class="line">            Pow[i][j] = (LL)Pow[i][j - <span class="number">1</span>] * P[i] % mod[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, ls = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'&lt;'</span>) ls--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'&gt;'</span>) ls++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'+'</span>) increase(all, ls + n);</span><br><span class="line">        <span class="keyword">else</span> decrease(all, ls + n);</span><br><span class="line">    &#125;</span><br><span class="line">    Data fuck; mp[all] = <span class="number">1</span>; LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, ls = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'&lt;'</span>) ls--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'&gt;'</span>) ls++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'+'</span>) increase(fuck, ls + n);</span><br><span class="line">        <span class="keyword">else</span> decrease(fuck, ls + n);</span><br><span class="line">        res += mp[fuck], mp[fuck + all * ls]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC020D Min Max Repetition</title>
      <link href="/2020/03/03/agc020d-min-max-repetition/"/>
      <url>/2020/03/03/agc020d-min-max-repetition/</url>
      
        <content type="html"><![CDATA[<p>定义$f(A,B)$为一个字符串，其中$A,B$是正整数，满足</p><ul><li>$f(A,B)$的长度为$A+B$</li><li>$f(A,B)$有$A$个<code>A</code>，有$B$个<code>B</code></li><li>$f(A,B)$的最长的由相同字符构成的子串的长度应该尽可能地小</li><li>$f(A,B)$是满足上述条件中字典序最小的一个</li></ul><p>$Q$次询问，每次给出$A_i,B_i,C_i,D_i$，要求输出$f(A_i,B_i)$从$C_i$开始，到$D_i$结束的子串</p><script type="math/tex; mode=display">Q\leq 10^3,A_i,B_i\leq 5\times 10^8,D_i-C_i+1\leq 100</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>不妨设$A\leq B$</p><p>如果最长的相同子串长度为$k$，那么我们可以得出</p><script type="math/tex; mode=display">\lceil\frac{B}{k}\rceil\leq A+1\Rightarrow k=\lceil\frac{B}{A+1}\rceil</script><p>即$B$最少能被划分为$\lceil\frac{B}{k}\rceil$段，$A$最多能提供$A+1$个位置</p><p>由于还要要求字典序最小，因此我们考虑贪心地构造这个串</p><p>我们一位一位地枚举，对于当前这一位我们优先尝试填<code>A</code>。如果填入<code>A</code>之后，剩余部分仍然满足最长相同子串长度$\leq k$，并且当前串的结尾的<code>A</code>不多于$k$个，那么在这里填<code>A</code>就是合法的，否则我们只能填<code>B</code></p><p>通过观察可以发现，答案一定长成这样：<code>AA...ABAA...ABA...ABB...BABB...BAB...B</code></p><p>即在某一位及这一位之前尽量填<code>A</code>，在这一位之后尽量填<code>B</code>，记这个位置为$p$</p><p>形式化地说，在$p$这一位以及之前的所有位，我们填字符的规则是每$k$个<code>A</code>一个<code>B</code></p><p>那么可以计算出这个位置之前<code>A</code>,<code>B</code>的数量</p><p>显然剩下还没有用的<code>B</code>有$B-\lfloor\frac{p}{k+1}\rfloor$个，从而可以推出<code>A</code>的数量</p><p>我们只需计算出剩下的<code>A</code>最多还能塞下多少个<code>B</code>即可</p><p>$p$这个位置显然越靠后越好，可以二分出这个位置</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int LL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> A, B, C, D; <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>, &amp;A, &amp;B, &amp;C, &amp;D);</span><br><span class="line">        <span class="keyword">int</span> len = (max(A, B) + min(A, B)) / (min(A, B) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1e9</span>, mid, pos = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> t1 = A - mid / (len + <span class="number">1</span>) * len - mid % (len + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> t2 = B - mid / (len + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> h1 = t1 * len + (mid % (len + <span class="number">1</span>) || !mid ? len : len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (t1 &gt;= <span class="number">0</span> &amp;&amp; t2 &gt;= <span class="number">0</span> &amp;&amp; h1 &gt;= t2) pos = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        assert(pos &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = C; i &lt;= min(D, pos); i++) </span><br><span class="line">            <span class="built_in">putchar</span>(i % (len + <span class="number">1</span>) ? <span class="string">'A'</span> : <span class="string">'B'</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = min(D, max(pos, C - <span class="number">1</span>)) + <span class="number">1</span>; i &lt;= D; i++) </span><br><span class="line">            <span class="built_in">putchar</span>((A + B - i + <span class="number">1</span>) % (len + <span class="number">1</span>) ? <span class="string">'B'</span> : <span class="string">'A'</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC020E Encoding Subsets</title>
      <link href="/2020/03/03/agc020e-encoding-subsets/"/>
      <url>/2020/03/03/agc020e-encoding-subsets/</url>
      
        <content type="html"><![CDATA[<p>对于一个仅包含$0,1$的串我们定义如下的“折叠”操作</p><ul><li>如果$A$能被表示成$P$，$B$能被表示成$Q$，那么$AB$可以被表示成$PQ$</li><li>如果$A$能被表示成$P$，那么$AA\cdots A(k个A)$能被表示成$(P\times K)$</li></ul><p>举个例子，串$001001001$能被表示成$001001001,00(1(0\times 2)\times 2)1,(001\times 3)$</p><p>定义串$A$是串$B$的子集当前仅当$A$中是$1$的所有位置在$B$中也是$1$</p><p>给定一个$01$串$S$，问$S$的所有子集的折叠方式的总和</p><p>对$998244353$取模，$|S|\leq 100$</p><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>考虑直接对$S$串$dp$</p><p>如果$S$串的长度为$0$，那么方案数只有一种</p><p>如果$S$的长度为$1$，如果$S$的第一个字符为$1$的话方案数就有两种，否则只有一种</p><p>对于其他情况，$S$的长度大于等于$2$</p><p>枚举$i$，表示在最终的拆分中，$S[i\sim |S|]$这些位置折叠在一起，前面的位置可折叠也可不折叠</p><p>如果$i=|S|$，我们认为最后一个字符没有折叠</p><p>我们记$solve(S)$表示$S$串的答案，$fold(S)$表示$S$串的最后一次操作为折叠操作的答案</p><p>那么有</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (s.size() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span> + (s[<span class="number">0</span>] == <span class="string">'1'</span>);</span><br><span class="line">    <span class="keyword">if</span> (g.count(s)) <span class="keyword">return</span> g[s];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">string</span> L, R;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s.size() - i; j++) L += s[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = s.size() - i + <span class="number">1</span>; j &lt;= s.size(); j++) R += s[j - <span class="number">1</span>];</span><br><span class="line">        res = (res + (LL)solve(L) * fold(R)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g[s] = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来考虑怎么计算$fold(S)$</p><p>枚举最后一次折叠的周期，显然这个周期必须是$|S|$的约数</p><p>假设周期是$j$，我们可以得到一个新的长度为$j$的串，我们记这个串为$s$，$s[i]$为$1$当且仅当$S[i],S[i+j],S[i+2j],\cdots$这些位置都为$1$</p><p>接着，你会发现这个转移似乎要用到$solve(s)$</p><p>于是你得到了两个互相递归调用的函数</p><p>但是实际上这个复杂度是不会爆炸的，因为有记忆化，而状态总数是很少的</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; f, g;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="built_in">string</span> s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; divs[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fold</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.size() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span> + (s[<span class="number">0</span>] == <span class="string">'1'</span>);</span><br><span class="line">    <span class="keyword">if</span> (f.count(s)) <span class="keyword">return</span> f[s];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> l : divs[s.size()]) &#123;</span><br><span class="line">        <span class="built_in">string</span> tmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; i++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; flag &amp;&amp; j &lt;= s.size(); j += l)</span><br><span class="line">                <span class="keyword">if</span> (s[j - <span class="number">1</span>] != <span class="string">'1'</span>) flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (flag) tmp += <span class="string">'1'</span>;</span><br><span class="line">            <span class="keyword">else</span> tmp += <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = (res + solve(tmp)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[s] = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (s.size() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span> + (s[<span class="number">0</span>] == <span class="string">'1'</span>);</span><br><span class="line">    <span class="keyword">if</span> (g.count(s)) <span class="keyword">return</span> g[s];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">string</span> L, R;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s.size() - i; j++) L += s[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = s.size() - i + <span class="number">1</span>; j &lt;= s.size(); j++) R += s[j - <span class="number">1</span>];</span><br><span class="line">        res = (res + (LL)solve(L) * fold(R)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g[s] = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s; <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N - <span class="number">10</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span>; j &lt;= N - <span class="number">10</span>; j += i) divs[j].push_back(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve(s));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC100D Colorful Sequences</title>
      <link href="/2020/03/03/agc100d-colorful-sequences/"/>
      <url>/2020/03/03/agc100d-colorful-sequences/</url>
      
        <content type="html"><![CDATA[<p>给定两个正整数$N,K$，以及一个长度为$M$的数组$A$，保证$A$中的每一个数都是$1$到$K$之间的整数</p><p>我们认为一个序列是多彩的当且仅当这个序列至少存在一个长度为$K$的子串，使得这个子串中$1$到$K$均出现过</p><p>你需要统计所有长度为$N$的多彩的序列中，$A$作为子串一共出现了多少次</p><script type="math/tex; mode=display">N\leq 25000, K\leq 400, M\leq N</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>如果无视“存在一个长度为$K$的子串使得$1\sim K$均出现过”这一条件，$A$在所有长度为$N$的序列中一共出现了$(N-M+1)K^{N-M}$次</p><p>接下来考虑加上这一限制</p><p>直接统计不是很好做，可以考虑用总数减去不合法的情况，即$A$在所有序列中出现的总数减去在不满足条件的序列中的出现次数</p><p>我们分两种情况讨论</p><p><strong>1.$A$中没有重复元素</strong></p><p>记$f[i][j]$表示长度为$i$，且末尾共有$j$个不同的数的不合法序列个数</p><p>记$g[i][j]$表示长度为$i$，且末尾共有$j$个不同的数，的所有不合法序列中，包含$A$的总次数</p><p>此时答案仅与$M$有关，与$A$具体是什么无关</p><p>接下来我们考虑$f[i][j]$如何转移</p><p>第一种情况是接上一个与最后$j$个字符都不相同的字符，转移到的状态是$f[i+1][j+1]$，方案数为$K-j$</p><p>第二种情况是接上的字符会导致与最后的$j$个字符出现相同，转移到的状态是$f[i+1][1\sim j]$，方案数只有$1$种</p><p>$g$的转移需要$f$，与$f$的转移类似</p><p>直接$dp$是$O(N^2K)$的，前缀和优化一下可以做到$O(NK)$</p><p><strong>2.$A$中有重复元素</strong></p><p>如果$A$出现的位置确定了，那么$A$前后的序列不会互相影响</p><p>因此我们实际上要统计的是，有多少个序列在接上$A$之后仍然是不合法的</p><p>容易发现$A$只有它的最长不相同前缀以及最长不相同后缀是有用的，如果$A$本身就合法，那么不合法的方案数就是$0$</p><p>考虑沿用之前的$dp$，可以发现这样一件事情：对于$f[i][j]$来说，如果最后$j$个字符是确定的，那么方案数是$\frac{f[i][j]\times (K-j)!}{K!}$，即每个排列作为结尾的方案数是相等的</p><p>发现这个重要的性质之后就很简单了，我们考虑如何统计有多少个序列在接上$A$之和仍然是不合法的</p><p>假设原序列的长度是$i$，$A$的最长不相同前缀长度为$d$</p><p>那么贡献为</p><script type="math/tex; mode=display">\sum_{j=d}^{k-1}\frac{f[i+d][j]\times (K-d)!}{K!}</script><p>我们需要枚举$A$的出现位置以及$j$，因此时间复杂度为$O(nk)$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">25010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">410</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, f[N][M], g[N][M], p1[M], p2[M], frac[M], inv[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Just_DOIT</span><span class="params">(<span class="keyword">int</span> len = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        p1[<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>], p2[<span class="number">0</span>] = g[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= min(i - <span class="number">1</span>, k - <span class="number">1</span>); j++) &#123;</span><br><span class="line">            p1[j] = (p1[j - <span class="number">1</span>] + f[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">            p2[j] = (p2[j - <span class="number">1</span>] + g[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> A = p1[min(i - <span class="number">1</span>, k - <span class="number">1</span>)], B = p2[min(i - <span class="number">1</span>, k - <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= min(i, k - <span class="number">1</span>); j++) &#123;</span><br><span class="line">            f[i][j] = (LL)f[i - <span class="number">1</span>][j - <span class="number">1</span>] * (k - j + <span class="number">1</span>) % mod;</span><br><span class="line">            g[i][j] = (LL)g[i - <span class="number">1</span>][j - <span class="number">1</span>] * (k - j + <span class="number">1</span>) % mod;</span><br><span class="line">            f[i][j] = ((LL)f[i][j] + A - p1[j - <span class="number">1</span>] + mod) % mod, g[i][j] = ((LL)g[i][j] + B - p2[j - <span class="number">1</span>] + mod) % mod;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= len) g[i][j] = (g[i][j] + f[i][j]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Make_Your_Dream_COMETRUE</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, t = (LL)inv[k] * frac[k - len] % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; k; i++) &#123;</span><br><span class="line">        res = (res + (LL)f[left + len][i] * t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N], lst[M], hh[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;k, &amp;m), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lst[A[i]]) tmp = max(tmp, lst[A[i]]);</span><br><span class="line">        lst[A[i]] = i, mx = max(mx, i - tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> all = (LL)(n - m + <span class="number">1</span>) * Pow(k, n - m) % mod;</span><br><span class="line">    <span class="keyword">if</span> (mx &gt;= k) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, all);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mx == m) &#123;</span><br><span class="line">        Just_DOIT(mx); <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++) res = (res + g[n][i]) % mod;</span><br><span class="line">        <span class="keyword">int</span> tmp = (LL)frac[k] * inv[k - mx] % mod;</span><br><span class="line">        res = (LL)res * Pow(tmp, mod - <span class="number">2</span>) % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (all - res + mod) % mod);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Just_DOIT(); <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) </span><br><span class="line">            <span class="keyword">if</span> (A[j] == A[i]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            left = i - <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + m &lt;= n; i++) </span><br><span class="line">        hh[i] = Make_Your_Dream_COMETRUE(i, left);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m - i + <span class="number">2</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">if</span> (A[m - i + <span class="number">1</span>] == A[j]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            right = i - <span class="number">1</span>; <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = all;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + m &lt;= n; i++) </span><br><span class="line">        res = (res - (LL)hh[i] * Make_Your_Dream_COMETRUE(n - i - m, right) % mod + mod) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合计数</title>
      <link href="/2019/12/16/zu-he-ji-shu/"/>
      <url>/2019/12/16/zu-he-ji-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="非常基础的东西"><a href="#非常基础的东西" class="headerlink" title="非常基础的东西"></a>非常基础的东西</h2><ul><li>组合数</li></ul><script type="math/tex; mode=display">{n\choose m}=\frac{n !}{m ! \times(n-m) !}</script><ul><li><code>Pascal</code>公式</li></ul><script type="math/tex; mode=display">{n\choose m}={n-1\choose m}+{n-1\choose m-1}</script><ul><li>二项式定理</li></ul><script type="math/tex; mode=display">(x+y)^n=\sum_{i=0}^n{n\choose i}x^iy^{n-i}</script><ul><li><code>Lucas</code>定理</li></ul><script type="math/tex; mode=display">{n\choose m}\mod p=\prod {n_i\choose m_i}\mod p</script><p>这里$n_i,m_i$分别表示$n,m$在$p$进制下的第$i$位</p><a id="more"></a><h2 id="一些组合恒等式"><a href="#一些组合恒等式" class="headerlink" title="一些组合恒等式"></a>一些组合恒等式</h2><script type="math/tex; mode=display">\begin{gathered}{n\choose m}={n\choose n-m}\\  \sum_{i=0}^n{n\choose i}=2^n\\  \sum_{i=0}^n{n\choose i}[2\mid i]=\sum_{i=0}^n{n\choose i}[2\nmid i]=2^{n-1}\\  \sum_{i=0}^m{n+i\choose n}={n+m+1\choose m}\\  \sum_{i=m}^n{i\choose m}={n+1\choose m+1}\\  {n\choose m}{m\choose k}={n\choose k}{n-k\choose m-k}\\  \sum_{i=0}^k{n\choose i}{m\choose k-i}={n+m\choose k}\end{gathered}</script><p>这里解释一下最后四个恒等式</p><p>对于倒数第四个，我们可以认为每次钦定选择的最后一个位置，枚举$i$的时候代表最后一个取的位置是$n+i+1$，然后再在前面的位置随便选取$n$个</p><p>因此它的组合意义是，一共有$n+m+1$个数，我们要从中选出$n+1$个数，即${n+m+1\choose n+1}={n+m+1\choose m}$</p><p>对于倒数第三个同理，即枚举最后一个选择的位置</p><p>对于倒数第二个，我们可以认为它的组合意义是先从$n$个数里面选择$m$个数，再从这$m$个数中选择$k$个数</p><p>那么，这个过程等价于先从$n$个数里面选择$k$个数，再从剩下的数中选择$m−k$个数，就是等式右边</p><p>对于最后一个，我们可以认为它是将$n+m$个数分成了两部分，第一部分是前$n$个数，第二部分是后$m$个数。然后再在这$n+m$个数中选择$k$个数，而等式左边枚举了前$n$个数中被选出的数的个数，因此这两个过程是等价的</p><h2 id="常见数列"><a href="#常见数列" class="headerlink" title="常见数列"></a>常见数列</h2><ul><li>斐波那契数列</li></ul><script type="math/tex; mode=display">F_n=F_{n-1}+F_{n-2}</script><ul><li>错排数</li></ul><script type="math/tex; mode=display">\begin{gathered}D_n=(n-1)(D_{n-1}+D_{n-2})\\  D_n=n!\sum_{i=0}^n(-1)^i\frac{1}{i!}\end{gathered}</script><p>考虑递推式的意义：我们将错排写成轮换的形式，考虑第$n$个位置所在的循环，那么有两种可能：一是加入了前$n−1$个数的轮换，二是与另外某个数形成了一个大小为$2$的循环</p><p>第一种情况中，它可能排在任意一个数的后面，因此方案数是$n−1$</p><p>第二种情况中，另外一个数有$n−1$种选法，因此方案数也是$n−1$</p><p>接下来看下面这个通项公式，这里实际上容斥的是有哪些位置没有错排</p><p>那么显然有</p><script type="math/tex; mode=display">\begin{aligned} D_n&=\sum_{i=0}^n(-1)^i{n\choose i}(n-i)!\\  &=n!\sum_{i=0}^n(-1)^i\frac{1}{i!} \end{aligned}</script><ul><li>卡特兰数</li></ul><script type="math/tex; mode=display">\begin{gathered}C_n=\sum_{i=0}^{n-1}C_iC_{n-i-1}\\  C_n={2n\choose n}-{2n\choose n+1}=\frac{1}{n+1}{2n\choose n}\\  C_n=\frac{2(2n-1)}{n+1}C_{n-1}\end{gathered}</script><ul><li>斯特林数</li></ul><script type="math/tex; mode=display">\begin{gathered}\begin{bmatrix}n\\ m\end{bmatrix}=\begin{bmatrix}n-1\\ m-1\end{bmatrix}+(n-1)\begin{bmatrix}n-1\\ m\end{bmatrix}\\  \begin{Bmatrix}n\\ m\end{Bmatrix}=\begin{Bmatrix}n-1\\ m-1\end{Bmatrix}+m\begin{Bmatrix}n-1\\ m\end{Bmatrix}\\  \begin{Bmatrix}n\\ m\end{Bmatrix}=\frac{1}{m!}\sum_{k=0}^m(-1)^k{m\choose k}(m-k)^n\end{gathered}</script><p>第一类斯特林数代表将$n$个数分成$m$个圆排列的方案数</p><p>第二类斯特林数代表将$n$个数分成$m$个集合的方案数</p><p>通项公式实际上还是容斥，容斥哪些集合是空的，由于集合与集合是没有区别的，因此最后要除以$m!$</p><ul><li>贝尔数</li></ul><script type="math/tex; mode=display">B_n=\sum_{k=0}^n\begin{Bmatrix}n\\ k\end{Bmatrix}\\  B_{n+1}=\sum_{k=0}^n{n\choose k}B_k</script><p>即将$n$个数划分成若干个集合的方案数</p><p>递推公式表示枚举第$n+1$个数和哪些数不在同一个集合中</p><h2 id="自然数幂之和"><a href="#自然数幂之和" class="headerlink" title="自然数幂之和"></a>自然数幂之和</h2><script type="math/tex; mode=display">S_k(n)=\sum_{i=1}^ni^k</script><ul><li>拉格朗日插值</li></ul><p>它是一个$k+1$次多项式</p><ul><li>斯特林数</li></ul><p>我们知道</p><script type="math/tex; mode=display">n^m=\sum_{i=0}^m\begin{Bmatrix}m\\ i\end{Bmatrix}n^{\underline i}=\sum_{i=0}^m\begin{Bmatrix}m\\ i\end{Bmatrix}i!{n\choose i}</script><p>其中$n^{\underline i}$即$n$的$i$次下降幂，表示从$n$个数中有序地选出$i$个不同的数的方案数</p><p>考虑$nm$的组合意义，即有序地选$m$个$1\sim n$的数，可以相同的方案数</p><p>右边式子中枚举的$i$表示将选出来的相同的数缩在一起之后，有多少类数，显然方案数为将$m$个数划分成$i$个集合的方案数，乘以在$1\sim n$中有序地选出$i$个数的方案数</p><p>结合上面的式子以及斯特林反演，可以得到</p><script type="math/tex; mode=display">\begin{aligned} n^{\underline m}&=\sum_{i=0}^m(-1)^{m-i}\begin{bmatrix}m\\ i\end{bmatrix}n^i\\  &=\sum_{i=0}^{m-1}(-1)^{m-i}\begin{bmatrix}m\\ i\end{bmatrix}n^i+n^m\\  n^m&=n^{\underline m}-\sum_{i=0}^{m-1}(-1)^{m-i}\begin{bmatrix}m\\ i\end{bmatrix}n^i\\  S_m(n)&=m!\sum_{i=1}^n{i\choose m}-\sum_{i=1}^n\sum_{j=0}^{m-1}(-1)^{m-j}\begin{bmatrix}m\\ j\end{bmatrix}i^j\\  &=\frac{(n+1)^{\underline{m+1}}}{m+1}-\sum_{j=0}^{m-1}(-1)^{m-j}\begin{bmatrix}m\\ j\end{bmatrix}S_j(n) \end{aligned}</script><ul><li>伯努利数以及伯努利多项式</li></ul><p><code>I don&#39;t know, fuck you.</code></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="ARC102E-Stop-Otherwise…"><a href="#ARC102E-Stop-Otherwise…" class="headerlink" title="ARC102E Stop. Otherwise…"></a>ARC102E Stop. Otherwise…</h3><p>有$N$个不可区分的$K$面骰子，对于每个$i=2,3,⋯2K$，求有多少种方案使得：任意两个骰子朝上的面要么相同，要么和不为$i$。答案对$998244353$取模。</p><script type="math/tex; mode=display">2\leq N\leq 2000,1\leq K\leq 2000</script><p>假设固定了$i$，那么限制就相当于：出现第$1$面的骰子与出现第$i−1$面的骰子不能同时出现；出现第$2$面的骰子与出现第$i−2$面的骰子不能同时出现……，我们将这样不能同时出现的面归为一组</p><p>显然，一共有$l=\lfloor\frac i2\rfloor$组限制</p><p>我们枚举在最终的方案中，这些限制所影响的组中一共有多少组至少出现了一个骰子，假设有$i$个，那么方案数为${l\choose i}2^i$，即从$l$组中选出$i$组，每一组有两种选法</p><p>对于选出的$i$组，每一组至少要选一个，因此我们可以将$n$减去$i$，即预先给每一组都塞上一个</p><p>接下来问题等价于将$n−i$个骰子分配给$i+k−2l$种面的方案数，可空，使用插板法即可</p><p>那么答案为</p><script type="math/tex; mode=display">\sum_{i=0}^l{l\choose i}2^i{n+k-2l-1\choose i+k-2l-1}</script><h3 id="ARC101E-Ribbons-on-Tree"><a href="#ARC101E-Ribbons-on-Tree" class="headerlink" title="ARC101E Ribbons on Tree"></a>ARC101E Ribbons on Tree</h3><p>给出一棵n个点的树，你要统计将所有点匹配的方案数，使得每一条边都至少被一对匹配点的最短路径覆盖，答案$\mod 10^9+7$，保证$n$是偶数</p><p>$n≤5000$</p><p>先考虑暴力容斥</p><p>枚举哪些边不满足条件，假设边集为$S$，那么方案数就是原树将$S$集合中的边抠掉之后的匹配数，即每一个连通块的匹配数之积</p><p>一个连通块的匹配数显然只与这个连通块的大小有关，那么我们可以将这个容斥写成$dp$的形式，即$dp[u][i]$表示考虑$u$以及$u$的子树，当前连通块大小为$i$时的贡献之和</p><p>当我们考虑了$u$的所有子树之和，我们尝试割去$u$与其父亲的连边，注意此时贡献要取反，因为容斥系数是$(−1)^{|S|}$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N][N], g[N], sz[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>, f[u][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != fa) &#123;</span><br><span class="line">            dfs(e[i].to, u);</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">int</span> tmp[N];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sz[e[i].to] + sz[u]; j++) tmp[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= sz[e[i].to]; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= sz[u]; k++)</span><br><span class="line">                    tmp[j + k] = (tmp[j + k] + (LL)f[e[i].to][j] * f[u][k]) % mod;</span><br><span class="line">            sz[u] += sz[e[i].to];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sz[u]; j++) f[u][j] = tmp[j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sz[u]; j++)    </span><br><span class="line">        f[u][<span class="number">0</span>] = (f[u][<span class="number">0</span>] - (LL)f[u][j] * g[j] % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>) g[i] = (LL)g[i - <span class="number">2</span>] * (i - <span class="number">1</span>) % mod;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mod - f[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ARC096E-Everything-on-it"><a href="#ARC096E-Everything-on-it" class="headerlink" title="ARC096E Everything on it"></a>ARC096E Everything on it</h3><p>求有多少个子集的集合，满足</p><ul><li>其中任意一个子集都是$\{1,2,\cdots n\}$的子集</li><li>任意两个子集不能相同</li><li>$1,2,\cdots n$每个数都至少出现了两次</li></ul><p>答案对质数$M$取模</p><script type="math/tex; mode=display">2\leq n\leq 3000,10^8\leq M\leq 10^9+9</script><p>考虑枚举有多少个数至多出现了一次，假设有$i$个</p><p>再假设这些数分到了$j$个集合中，由于每个数可能出现，也可能没有出现，因此我们可以添加一个数$0$，然后再将这些数划分为$j+1$个集合，与$0$在同一个集合的那些数表示没有出现</p><p>因此这一步的方案数为$\begin{Bmatrix}i+1\\ j+1\end{Bmatrix}$</p><p>其余的数可以出现，也可以不出现。受影响的集合一共有$j$个，方案数为$(2^{n-i})^j$</p><p>对于其余的集合，当前选出的i个数一定没有出现过，对应出来的每一种集合也可以选择出现或者不出现，因此方案数为$2^{2^{n-i}}$</p><p>因此答案为</p><script type="math/tex; mode=display">\sum_{i=0}^n(-1)^i{n\choose i}\begin{Bmatrix}i+1\\ j+1\end{Bmatrix}(2^{n-i})^j2^{2^{n-i}}</script><p>注意指数上是模$M−1$而不是$M$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3010</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> mod;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> mod = mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> S[N][N], C[N][N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    S[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) </span><br><span class="line">            C[i][j] = (C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        S[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            S[i][j] = (S[i - <span class="number">1</span>][j - <span class="number">1</span>] + (LL)S[i - <span class="number">1</span>][j] * j) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, res = <span class="number">0</span>; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; mod, init(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> other = Pow(<span class="number">2</span>, Pow(<span class="number">2</span>, n - i, mod - <span class="number">1</span>)), tmp = (LL)C[n][i] * other % mod, base = Pow(<span class="number">2</span>, n - i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, t = base; j &lt;= i; j++) &#123;</span><br><span class="line">            tmp = (tmp + (LL)C[n][i] * t % mod * other % mod * S[i + <span class="number">1</span>][j + <span class="number">1</span>]) % mod;</span><br><span class="line">            t = (LL)t * base % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>) res = (res - tmp + mod) % mod;</span><br><span class="line">        <span class="keyword">else</span> res = (res + tmp) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ARC093F-Dark-Horse"><a href="#ARC093F-Dark-Horse" class="headerlink" title="ARC093F Dark Horse"></a>ARC093F Dark Horse</h3><p>有$2^n$名选手，编号为$1$至$2^n$，现在这$2^n$名选手将进行$n$轮淘汰赛，决出胜者。若$x&lt;y$，则当$x$与$y$对决时，$x$能获胜。但是有$m$个例外，$1$号选手在与这$m$个人对决的时候会输。问有多少种排列方式使得最终$1$号选手能取得胜利，答案对$10^9+7$取模</p><p>对决的方式是每轮选择排列中的第$2i−1$与第$2i$名选手对决</p><script type="math/tex; mode=display">1\leq n\leq 16, 0\leq m\leq 16</script><p>首先我们钦定$1$在排列的第一个位置，由于对决是一棵二叉树的形式，因此$1$实际上放哪里都无所谓</p><p>接下来，$1$会分别与$p_2,\min\{p_3,p_4\},\min\{p_5,p_6,p_7,p_8\},\cdots$对决，那么限制就等价于：$p_2,\min\{p_3,p_4\},\min\{p_5,p_6,p_7,p_8\},\cdots$中都不能出现给定的$m$个数</p><p>考虑容斥，枚举有哪些集合的最小值是给出的$m$个数之一</p><p>将给定的$m$个数排序，记$dp[i][S]$表示以及考虑了$m$个数中的前$i$个数，这$i$个数占据了$S$集合的方案数</p><p>注意这里我们只给确定的集合分配其它数，即只有$S$集合内的数在此时的$dp$中是被考虑了的</p><p>假设我们现在要将第$k$大的限制加入某个集合，此时可以很方便地得到当前可以用的，并且比这个第$k$大的限制还要大的数的个数，将约束排序的作用就体现在这里</p><p>转移就是</p><script type="math/tex; mode=display">dp[i+1][S|2^j]=dp[i+1][S|2^j]+dp[i][S]\times{2^n-i-A_i\choose 2^j-1}\times2^j!</script><p>即从剩下的数中选择$2^j−1$个数填入当前集合，这$2^j−1$个数以及当前的限制$A_i$可以在集合内随便排列</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = (<span class="number">1</span> &lt;&lt; N) + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[M], inv[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fucked[<span class="number">17</span>], dp[<span class="number">17</span>][<span class="number">1</span> &lt;&lt; N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1</span> &lt;&lt; n; i++) </span><br><span class="line">        frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;fucked[i]);</span><br><span class="line">    sort(fucked + <span class="number">1</span>, fucked + m + <span class="number">1</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a &gt; b;&#125;), dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">                dp[i][j] = (dp[i][j] + dp[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">                <span class="keyword">int</span> upper = (<span class="number">1</span> &lt;&lt; n) - fucked[i] - j;</span><br><span class="line">                <span class="keyword">if</span> (upper &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">                    <span class="keyword">if</span> (!(j &amp; (<span class="number">1</span> &lt;&lt; k - <span class="number">1</span>))) </span><br><span class="line">                        dp[i][j | (<span class="number">1</span> &lt;&lt; k - <span class="number">1</span>)] = (dp[i][j | (<span class="number">1</span> &lt;&lt; k - <span class="number">1</span>)] + (LL)dp[i - <span class="number">1</span>][j] * C(upper, (<span class="number">1</span> &lt;&lt; k - <span class="number">1</span>) - <span class="number">1</span>)</span><br><span class="line">                            % mod * frac[<span class="number">1</span> &lt;&lt; k - <span class="number">1</span>]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">1</span> &lt;&lt; n; s++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = (LL)dp[m][s] * frac[(<span class="number">1</span> &lt;&lt; n) - s - <span class="number">1</span>] % mod;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_popcount(s) &amp; <span class="number">1</span>) res = (res - tmp + mod) % mod;</span><br><span class="line">        <span class="keyword">else</span> res = (res + tmp) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL)res * (<span class="number">1</span> &lt;&lt; n) % mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UOJ422-【集训队作业-2018】小Z的礼物"><a href="#UOJ422-【集训队作业-2018】小Z的礼物" class="headerlink" title="UOJ422 【集训队作业 2018】小Z的礼物"></a>UOJ422 【集训队作业 2018】小Z的礼物</h3><p>给定$n\times m$的方格，每个格子中都有一个礼物，其中有些礼物是小Z喜欢的</p><p>每次小Z会等概率地随机选取某两个相邻格子中的礼物（得到过的礼物可能会再次得到），求得到所有小Z喜欢的礼物的时间的期望</p><script type="math/tex; mode=display">n\leq 6,m\leq 100</script><p>格子对一共有$t=2(n−1)(m−1)+n+m−2$个</p><p>首先<code>min-max</code>容斥一下，考虑暴力容斥：枚举喜欢的礼物的子集，然后统计出与这些位置有关的“格子对”的数量，假设是$k$</p><p>那么，这种情况的<code>min</code>，即选出的格子至少有一个被选中的概率是$\frac{k}{t}$，期望次数就是$\frac{t}{k}$</p><p>因此我们轮廓线$dp$一下，记录$dp[i][s][j]$表示当前位置为$i$，最后$n$个格子状态为$s$，此时选出的格子与$j$个“格子对”有关时的贡献</p><p>注意新选一个格子的时候贡献要取反</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][<span class="number">1</span> &lt;&lt; N][<span class="number">1200</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> G[N + <span class="number">1</span>][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, G[i] + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = mod - <span class="number">1</span>; <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> all = <span class="number">2</span> * (n - <span class="number">1</span>) * (m - <span class="number">1</span>) + n - <span class="number">1</span> + m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            cur ^= <span class="number">1</span>, <span class="built_in">memset</span>(dp[cur], <span class="number">0</span>, <span class="keyword">sizeof</span>(dp[cur]));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">1</span> &lt;&lt; n; s++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> ls = <span class="number">0</span>; ls &lt;= all; ls++) <span class="keyword">if</span> (dp[cur ^ <span class="number">1</span>][s][ls]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> turn = (s &lt;&lt; <span class="number">1</span>) &amp; ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>), t = ((s &amp; <span class="number">1</span>) &amp;&amp; (j != <span class="number">1</span>)) + ((s &amp; <span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>) &amp;&amp; (i != <span class="number">1</span>))), t2 = (i != <span class="number">1</span>) + (j != <span class="number">1</span>);</span><br><span class="line">                    dp[cur][turn][ls + t] = (dp[cur][turn][ls + t] + dp[cur ^ <span class="number">1</span>][s][ls]) % mod;</span><br><span class="line">                    <span class="keyword">if</span> (G[j][i] == <span class="string">'*'</span>) dp[cur][turn | <span class="number">1</span>][ls + t2] = (dp[cur][turn | <span class="number">1</span>][ls + t2] - dp[cur ^ <span class="number">1</span>][s][ls] + mod) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">1</span> &lt;&lt; n; s++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ls = <span class="number">1</span>; ls &lt;= all; ls++) <span class="keyword">if</span> (dp[cur][s][ls]) </span><br><span class="line">            res = (res + (LL)dp[cur][s][ls] * all % mod * Pow(ls, mod - <span class="number">2</span>)) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="斯特林反演"><a href="#斯特林反演" class="headerlink" title="斯特林反演"></a>斯特林反演</h1><h2 id="几个引理以及推论"><a href="#几个引理以及推论" class="headerlink" title="几个引理以及推论"></a>几个引理以及推论</h2><script type="math/tex; mode=display">\begin{gathered}n^m=\sum_{i=0}^m\begin{Bmatrix}m\\ i\end{Bmatrix}n^{\underline i}\\  n^{\overline m}=\sum_{i=0}^m\begin{bmatrix}m\\ i\end{bmatrix}n^i\\  f(n)=\sum_{k=0}^m\begin{Bmatrix}n\\ k\end{Bmatrix}g(k)\Leftrightarrow g(n)=\sum_{k=0}^n(-1)^{n-k}\begin{bmatrix}n\\ k\end{bmatrix}f(k)\\  \sum_{k=m}^n(-1)^{n-k}\begin{bmatrix}n\\ k\end{bmatrix}\begin{Bmatrix}k\\ m\end{Bmatrix}=[m=n]\\  \sum_{k=m}^n(-1)^{n-k}\begin{Bmatrix}n\\ k\end{Bmatrix}\begin{bmatrix}k\\ m\end{bmatrix}=[m=n]\\  x^{\underline n}=(-1)^n(-x)^{\overline n},x^{\overline n}=(-1)^n(-x)^{\underline n}\end{gathered}</script><p>第一个式子我们之前证明过</p><p>接下来我们一个一个来</p><script type="math/tex; mode=display">n^{\overline m}=\sum_{i=0}^m\begin{bmatrix}m\\ i\end{bmatrix}n^i</script><p>采用数学归纳法证明</p><script type="math/tex; mode=display">\begin{aligned} n^{\overline m}&=(n+m-1)n^{\overline{m-1}}\\  &=(n+m-1)\sum_i\begin{bmatrix}m-1\\ i\end{bmatrix}n^i\\  &=\sum_i\begin{bmatrix}m-1\\ i\end{bmatrix}n^{i+1}+\sum_i\begin{bmatrix}m-1\\ i\end{bmatrix}n^i(m-1)\\  &=\sum_i\begin{bmatrix}m-1\\ i-1\end{bmatrix}n^i+\sum_i\begin{bmatrix}m-1\\ i\end{bmatrix}n^i(m-1)\\  &=\sum_i(\begin{bmatrix}m-1\\ i-1\end{bmatrix}+(m-1)\begin{bmatrix}m-1\\ i\end{bmatrix})n^i\\  &=\sum_{i=0}^m\begin{bmatrix}m\\ i\end{bmatrix}n^i \end{aligned}</script><p>反转公式</p><script type="math/tex; mode=display">\sum_{k=m}^n(-1)^{n-k}\begin{bmatrix}n\\ k\end{bmatrix}\begin{Bmatrix}k\\ m\end{Bmatrix}=[m=n]\\  \sum_{k=m}^n(-1)^{n-k}\begin{Bmatrix}n\\ k\end{Bmatrix}\begin{bmatrix}k\\ m\end{bmatrix}=[m=n]</script><p>需要用到上面列出的式子中的最后一个，就是那个上升下降幂互换的</p><script type="math/tex; mode=display">\begin{aligned} n^m&=\sum_{i=0}^m\begin{Bmatrix}m\\ i\end{Bmatrix}n^{\underline i}\\  &=\sum_{i=0}^m\begin{Bmatrix}m\\ i\end{Bmatrix}(-1)^i(-n)^{\overline i}\\  &=\sum_{i=0}^m\begin{Bmatrix}m\\ i\end{Bmatrix}(-1)^i\sum_{j=0}^i\begin{bmatrix}i\\ j\end{bmatrix}(-n)^j\\  &=\sum_{j=0}^mn^j\sum_{i=j}^m\begin{Bmatrix}m\\ i\end{Bmatrix}\begin{bmatrix}i\\ j\end{bmatrix}(-1)^{i-j} \end{aligned}</script><p>注意到第二个求和符号后面的式子是与n无关的。要保证上面的式子成立，必须满足</p><script type="math/tex; mode=display">\sum_{i=j}^m\begin{Bmatrix}m\\ i\end{Bmatrix}\begin{bmatrix}i\\ j\end{bmatrix}(-1)^{i-j}=[j=m]</script><p>就是第二个反转公式</p><p>第一个公式的证明同理</p><p>斯特林反演：</p><script type="math/tex; mode=display">f(n)=\sum_{k=0}^m\begin{Bmatrix}n\\ k\end{Bmatrix}g(k)\Leftrightarrow g(n)=\sum_{k=0}^n(-1)^{n-k}\begin{bmatrix}n\\ k\end{bmatrix}f(k)</script><p>我们假设有</p><script type="math/tex; mode=display">g(n)=\sum_{k=0}^n(-1)^{n-k}\begin{bmatrix}n\\ k\end{bmatrix}f(k)</script><p>那么</p><script type="math/tex; mode=display">\begin{aligned} f(n)&=\sum_{i=0}^n[i=n]f(i)\\  &=\sum_{i=0}^n\sum_{j=i}^n\begin{Bmatrix}n\\ j\end{Bmatrix}\begin{bmatrix}j\\ i\end{bmatrix}(-1)^{j-i}f(i)\\  &=\sum_{j=0}^n\begin{Bmatrix}n\\ j\end{Bmatrix}\sum_{i=0}^j\begin{bmatrix}j\\ i\end{bmatrix}(-1)^{j-i}f(i)\\  &=\sum_{j=0}^n\begin{Bmatrix}n\\ j\end{Bmatrix}g(j) \end{aligned}</script><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><h3 id="【2018-雅礼集训】方阵"><a href="#【2018-雅礼集训】方阵" class="headerlink" title="【2018 雅礼集训】方阵"></a>【2018 雅礼集训】方阵</h3><p>有一个$n\times m$的网格，每个格子要填上一个$[1,c]$的数，问任意两行或任意两列均不同的方案数</p><script type="math/tex; mode=display">n,m\leq 5000</script><p>行、列同时有限制，我们先只考虑行的限制</p><p>一行有$c^m$种填法，要求每行都不相同，因此n行就有$g(m)=(c^m)^{\underline n}$种填法</p><p>现在考虑列的限制，设$f(m)$表示$n\times m$的矩阵，行、列均满足条件的方案数</p><p>将相同的列缩在一起，枚举缩完之和的列的数量，那么有</p><script type="math/tex; mode=display">g(m)=\sum_{i=0}^m\begin{Bmatrix}m\\ i\end{Bmatrix}f(i)</script><p>根据斯特林反演，可以得到</p><script type="math/tex; mode=display">f(m)=\sum_{i=0}^m(-1)^{m-i}\begin{bmatrix}m\\ i\end{bmatrix}g(i)</script><p>时间复杂度$n^2$</p><h3 id="一道例题"><a href="#一道例题" class="headerlink" title="一道例题"></a>一道例题</h3><p>给出一棵$n$个点的树，从某个点出发开始随机游走：在点$u$时，有$p_u$的概率留在原地，否则等概率向相邻的节点移动，直到移动到$1$号节点</p><p>求从每个点出发直至停下所花费的时间的$k$次方的期望</p><script type="math/tex; mode=display">n\leq 10^5,k\leq 10^5,nk\leq 10^6</script><p>我们设$t_u$表示在某次随机中，节点$u$到达$1$号节点<strong>实际</strong>需要的时间</p><p>那么我们需要求的就等价于</p><script type="math/tex; mode=display">\begin{aligned} E(t_u^k)&=E[\sum_{i=0}^k\begin{Bmatrix}k\\ i\end{Bmatrix}{t_u\choose i}i!]\\  &=\sum_{i=0}^k\begin{Bmatrix}k\\ i\end{Bmatrix}i!E[{t_u\choose i}] \end{aligned}</script><p>因此问题的关键在于求出$E({t_u\choose i})$</p><p>我们考虑如下转移</p><script type="math/tex; mode=display">E[{t_u\choose i}]=P_uE[{t_u+1\choose i}]+\frac{1-P_u}{|v|}\sum_vE[{t_v+1\choose i}]</script><p>将组合数拆开</p><script type="math/tex; mode=display">E[{t_u\choose i}]=P_u(E[{t_u\choose i}]+E[{t_u\choose i-1}])+\frac{1-P_u}{|v|}\sum_vE[{t_v\choose i}]+E[{t_v\choose i-1}]</script><p>在算出$E[{t_u\choose i}]$之前，$E[{t_u\choose i-1}]$已经被算出了，我们设$dp_u=E[{t_u\choose i}],a_u=E[{t_u\choose i-1}]$</p><p>那么有</p><script type="math/tex; mode=display">dp_u=P_udp_u+P_ua_u+\frac{1-P_u}{|v|}\sum_vdp_v+a_v</script><p>注意到$v$可以取到$u$的父亲，我们将这种情况单独拿出来</p><p>根据套路，$dp_u$一定可以表示为$A_udp_f+B_u$</p><p>后面我就不推了，根据这个式子可以分别得出$A_u,B_u$</p><p>时间复杂度$O(nk)$</p><h3 id="另一道例题"><a href="#另一道例题" class="headerlink" title="另一道例题"></a>另一道例题</h3><p>求$n$个点的带标号无向图的联通块数$k$次方幂之和</p><script type="math/tex; mode=display">n\leq 10^5,k\leq 15</script><p>$n$个点带标号连通无向图的数量很好求</p><p>我们假设一张图有$m$个联通块，那么它对答案的贡献就是</p><script type="math/tex; mode=display">m^k=\sum_{i=0}^k\begin{Bmatrix}k\\ i\end{Bmatrix}i!{m\choose i}</script><p>因此我们需要计算的是从这$m$个联通块中选出$i$个联通块的方案数</p><p>构造$k$个生成函数</p><p>我们设$G(x)$为带标号连通无向图的EGF，$F(x)$为无向图的EGF</p><p>显然有</p><script type="math/tex; mode=display">F(x)=\sum_{i\geq 0}\frac{G(x)^i}{i!}=\exp G(x)\\ G(x)=\ln F(x)</script><p>那么设</p><script type="math/tex; mode=display">\begin{aligned} H_k(x)&=\sum_{i\geq 0}\frac{G(x)^i}{i!}{i\choose k}\\  &=\sum_{i\geq 0}\frac{G(x)^i}{i!}\frac{i!}{k!(i-k)!}\\  &=\frac{1}{k!}\sum_{i\geq 0}\frac{G(x)^i}{(i-k)!}\\  &=\frac{G(x)^k}{k!}\sum_{i\geq 0}\frac{G(x)^{i-k}}{(i-k)!}\\  &=\frac{G(x)^k}{k!}\exp G(x)\\  &=\frac{G(x)^k}{k!}F(x) \end{aligned}</script><p>递推即可</p><h3 id="【清华集训-2017】生成树计数"><a href="#【清华集训-2017】生成树计数" class="headerlink" title="【清华集训 2017】生成树计数"></a>【清华集训 2017】生成树计数</h3><p>在一个$s$个点的图中，存在$s−n$条边，使图中形成了$n$个连通块，第$i$个连通块中有$a_i$个点</p><p>现在我们需要再连接$n−1$条边，使该图变成一棵树。对于一种连边方案，设原图中第$i$个连通块连出了$d_i$条边，那么这棵树$T$的价值为</p><script type="math/tex; mode=display">\text{val}(T)=\left(\prod_{i=1}^nd_i^m\right)\left(\sum_{i=1}^nd_i^m\right)</script><p>求出所有可能的生成树的价值之和，对$998244353$取模</p><script type="math/tex; mode=display">n\leq 3\times 10^4,m\leq 30</script><p>首先我们知道</p><script type="math/tex; mode=display">ans=\sum_T\sum_{i=1}^nd_i^m\prod_{j=1}^nd_j^ma_j^{d_j}</script><p>乘这个$a_i^{d_i}$是因为每个连通块连出的边都可以从这个连通块内部的任意一个点连出去，因此一条边有$a_i$种选择端点的方案</p><p>将累乘中$i=j$的项提到前面来</p><script type="math/tex; mode=display">ans=\sum_T\sum_{i=1}^nd_i^{2m}a_i^{d_i}\prod_{i\neq j}d_j^ma_j^{d_j}</script><p>考虑将$T$去掉，改写成<code>prufer</code>序，我们枚举每个点在序列中的出现次数$c_i$，显然有$d_i=c_i+1$</p><p>对于一个确定的长度为$n−2$的prufer序，我们知道每个数的出现次数，那么对应的序列就有$\frac{(n-2)!}{\prod c_i!}$种</p><p>因此，有</p><script type="math/tex; mode=display">ans=\sum_{i=1}^n\sum_{\sum c_i=n-2}\frac{(n-2)!}{\prod c_i!}(c_i+1)^{2m}a_i^{c_i+1}\prod_{j\neq i}(c_j+1)^ma_j^{c_j+1}</script><p>考虑构造生成函数</p><script type="math/tex; mode=display">\begin{aligned} A_i(x)&=\sum_ka_i^{k+1}\frac{(k+1)^{2m}}{k!}x^k\\  B_i(x)&=\sum_ka_i^{k+1}\frac{(k+1)^m}{k!}x^k \end{aligned}</script><p>这样的好处是，我们现在可以通过$x$的指数控制$\sum c_i$</p><p>那么有</p><script type="math/tex; mode=display">ans=(n-2)![x^{n-2}]\sum_{i=1}^nA_i(x)\prod_{j\neq i}B_i(x)</script><p>考虑将$A_i(x),B_i(x)$化简</p><p>这里的做法是：先积分再求导<del>我也不知道怎么想到的</del></p><p>考虑设出$T(x)$表示$A_i(x)$的不定积分</p><script type="math/tex; mode=display">\begin{aligned} T(x)&=\int A_i(x)\text{ d}x=\sum_{k}a_i^{k+1}\frac{(k+1)^{2m}}{(k+1)!}x^{k+1}\\  &=\sum_{k}a_i^k\frac{k^{2m}}{k!}x^k\\  &=\sum_{k}a_i^k\sum_{j=0}^{2m}\begin{Bmatrix}2m\\ j\end{Bmatrix}\frac{k!}{(k-j)!}\times\frac{1}{k!}x^k\\  &=\sum_{j=0}^{2m}\begin{Bmatrix}2m\\ j\end{Bmatrix}a_i^jx^j\sum_k\frac{(a_ix)^{k-j}}{(k-j)!}\\  &=\sum_{j=0}^{2m}\begin{Bmatrix}2m\\ j\end{Bmatrix}a_i^jx^je^{a_ix} \end{aligned}</script><p>然后我们再求导回去</p><script type="math/tex; mode=display">\begin{aligned} A_i(x)&=T'(x)=\left[e^{a_ix}\left(\sum_{j=0}^{2m}\begin{Bmatrix}2m\\ j\end{Bmatrix}a_i^jx^j\right)\right]'\\  &=e^{a_ix}\sum_{j=0}^{2m}\begin{Bmatrix}2m\\ j+1\end{Bmatrix}a_i^{j+1}(j+1)x^j+a_i\sum_{j=0}^{2m}\begin{Bmatrix}2m\\ j\end{Bmatrix}a_i^jx^je^{a_ix}\\  &=e^{a_ix}\sum_{j=0}^{2m}a_i^{j+1}x^j\left(\begin{Bmatrix}2m\\ j+1\end{Bmatrix}(j+1)+\begin{Bmatrix}2m\\ j\end{Bmatrix}\right)\\  &=e^{a_ix}\sum_{j=0}^{2m}a_i^{j+1}x^j\begin{Bmatrix}2m+1\\ j+1\end{Bmatrix} \end{aligned}</script><p>这是一个只有$2m$项的多项式</p><p>同理，我们可以求出$B_i(x)$</p><script type="math/tex; mode=display">B_i(x)=e^{a_ix}\sum_{j=0}^{m}a_i^{j+1}x^j\begin{Bmatrix}m+1\\ j+1\end{Bmatrix}</script><p>再根据式子</p><script type="math/tex; mode=display">ans=\sum_{i=1}^nA_i(x)\prod_{j\neq i}B_i(x)</script><p>分治NTT解决即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> FFT </tag>
            
            <tag> 状态压缩 </tag>
            
            <tag> 容斥 </tag>
            
            <tag> 生成函数 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
