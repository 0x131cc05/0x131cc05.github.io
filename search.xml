<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[6.5NOI模拟]]></title>
    <url>%2F2019%2F06%2F11%2F6-5NOI%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 最长公共子序列 注意到前三个串中每个数字最多出现两次，因此我们可以枚举第四个串的匹配位置，用一个三位的二进制数来表示前三个串的匹配情况 dp[i][2][2][2]表示在第四个串中匹配到了第$i$个字符，在第一个串中处于这个串的第一/第二个位置，后两维类似 于是我们得到了一个$n^2$的做法，现在考虑优化 注意到对于$dp[i]$，有用的都是在它前面的项，并且后三位都小于它的$dp$ 这是一个四维偏序 第一层CDQ可以按照$i$排序，第二层CDQ就按照后面的分治 时间复杂度$n\log^2 n$ 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 80010, M = 10010;int dp[N];struct Data &#123;int d, a, b, c, id, type;&#125; q[N], p[N], tmp[N];int tree[N], n;inline void upd(int x, int y) &#123;for (;x &lt;= n;x += x &amp; -x) tree[x] = max(tree[x], y);&#125;inline void clr(int x) &#123;for (;x &lt;= n;x += x &amp; -x) tree[x] = 0;&#125;inline int que(int x) &#123; int res = 0; for (;x;x -= x &amp; -x) res = max(res, tree[x]); return res;&#125;bool cmp0(const Data &amp;a, const Data &amp;b) &#123; if (a.a != b.a) return a.a &lt; b.a; if (a.b != b.b) return a.b &lt; b.b; if (a.c != b.c) return a.c &lt; b.c; return a.type &lt; b.type;&#125;bool cmp1(const Data &amp;a, const Data &amp;b) &#123; if (a.b != b.b) return a.b &lt; b.b; if (a.c != b.c) return a.c &lt; b.c; return a.type &lt; b.type;&#125;void CDQ1(int l, int r) &#123; if (l &gt;= r) return; int mid = (l + r) &gt;&gt; 1, L, R; CDQ1(l, mid), CDQ1(mid + 1, r); for (L = l, R = mid + 1;R &lt;= r;R++) &#123; while (L &lt;= mid &amp;&amp; p[L].b &lt;= p[R].b) &#123; if (p[L].type == 0) upd(p[L].c, dp[p[L].id]); L++; &#125; if (p[R].type == 1) dp[p[R].id] = max(dp[p[R].id], que(p[R].c) + 1); &#125; for (int i = l;i &lt; L;i++) if (p[i].type == 0) clr(p[i].c); int top = 0; for (L = l, R = mid + 1;L &lt;= mid;tmp[++top] = p[L++]) while (R &lt;= r &amp;&amp; cmp1(p[R], p[L])) tmp[++top] = p[R++]; for (;R &lt;= r;R++) tmp[++top] = p[R]; for (int i = 1;i &lt;= top;i++) p[i + l - 1] = tmp[i];&#125;void CDQ2(int l, int r) &#123; if (l &gt;= r) return; int mid = (l + r) &gt;&gt; 1, top = 0; CDQ2(l, mid); for (int i = l;i &lt;= mid;i++) p[++top] = q[i]; for (int i = mid + 1;i &lt;= r;i++) p[++top] = q[i], p[top].type = 1, p[top].a--, p[top].b--, p[top].c--; sort(p + 1, p + top + 1, cmp0), CDQ1(1, top); CDQ2(mid + 1, r);&#125;int buk[3][M], at[2][3][M];int main() &#123; freopen("lcs.in", "r", stdin), freopen("lcs.out", "w", stdout); scanf("%d", &amp;n); for (int k = 0;k &lt; 3;k++) for (int i = 1, a;i &lt;= n;i++) scanf("%d", &amp;a), at[buk[k][a]][k][a] = i, buk[k][a]++; int id = 0; for (int i = 1, a;i &lt;= n;i++) &#123; scanf("%d", &amp;a); for (int k = 7, A, B, C;k &gt;= 0;k--) &#123; if (!(A = at[k &amp; 1][0][a]) || !(B = at[k &gt;&gt; 1 &amp; 1][1][a]) || !(C = at[k &gt;&gt; 2 &amp; 1][2][a])) continue; id++, q[id] = (Data)&#123;i, A, B, C, id, 0&#125;, dp[id] = 1; &#125; &#125; CDQ2(1, id); int res = 0; for (int i = 1;i &lt;= id;i++) res = max(res, dp[i]); printf("%d\n", res);&#125; T2 树 如果枚举$B$的根，那么$B$中的父子关系就确定了，我们让$A$中选出的点也满足这样的父子关系 g[u][i]表示$A$中的$u$以及$u$的子树，对应$B$中的$i$的方案数 f[u][s]表示$u$的儿子（不是子树），对应$B$中$i$的集合为$s$的儿子的方案数 枚举$u$对应的点，那么这两个东西是很好转移的 123456789101112131415161718int F[N * 2], G[13][N], m, res, rt;void dfs(int u, int f) &#123; for (int i = 1;i &lt;= m;i++) if (!ch[i].size()) G[i][u] = 1; else G[i][u] = 0; for (int i = head[u];i;i = e[i].next) if (e[i].to != f) dfs(e[i].to, u); for (int i = 1;i &lt;= m;i++) &#123; int sz = ch[i].size(); for (int s = 0;s &lt; 1 &lt;&lt; sz;s++) F[s] = 0; F[0] = 1; for (int j = head[u], v;j;j = e[j].next) if ((v = e[j].to) != f) for (int s = 1 &lt;&lt; sz;s &gt;= 0;s--) for (int k = 0, son;k &lt; ch[i].size();k++) if (s &amp; (1 &lt;&lt; k)) F[s] = (F[s] + (LL)F[s ^ (1 &lt;&lt; k)] * G[ch[i][k]][v]) % mod; G[i][u] = F[(1 &lt;&lt; sz) - 1]; &#125; res = (res + G[rt][u]) % mod;&#125; 但是这样会算重 我们考虑什么时候会重复计数 首先对于两个根$u,v$，如果$B$选择这两个根形成的有根树是同构的，那么枚举了$u$之后就不能枚举$v$ 对于一个点$u$，假设它有$k$棵完全相同的子树。那么我们在$dp$的时候会考虑这些子树的先后顺序，顺序不同的方案我们认为是不同的。然而它的儿子没有顺序，因此总方案数应该除以$k!$ 因此，我们在进行$dp$之前，先对这个有根树$B$dfs一遍，处理出这棵树的hash以及dp应该乘上的系数 用个set统计一下这棵树是否与之前的某棵树同构，然后dp就可以了 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2010, mod = 1e9 + 7;typedef long long LL;vector&lt;int&gt; ch[13], B[13];struct edge &#123;int to, next;&#125; e[N * 2];int head[N], ecnt;inline void adde(int from, int to) &#123; e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;&#125;int F[N * 2], G[13][N], m, res, rt;void dfs(int u, int f) &#123; for (int i = 1;i &lt;= m;i++) if (!ch[i].size()) G[i][u] = 1; else G[i][u] = 0; for (int i = head[u];i;i = e[i].next) if (e[i].to != f) dfs(e[i].to, u); for (int i = 1;i &lt;= m;i++) &#123; int sz = ch[i].size(); for (int s = 0;s &lt; 1 &lt;&lt; sz;s++) F[s] = 0; F[0] = 1; for (int j = head[u], v;j;j = e[j].next) if ((v = e[j].to) != f) for (int s = 1 &lt;&lt; sz;s &gt;= 0;s--) for (int k = 0, son;k &lt; ch[i].size();k++) if (s &amp; (1 &lt;&lt; k)) F[s] = (F[s] + (LL)F[s ^ (1 &lt;&lt; k)] * G[ch[i][k]][v]) % mod; G[i][u] = F[(1 &lt;&lt; sz) - 1]; &#125; res = (res + G[rt][u]) % mod;&#125;typedef unsigned long long ULL;ULL h[N], P = 131, pw[13]; int sz[13], inv[13], fuck;void dfs2(int u, int f) &#123; ULL tmp[13]; int top = 0, len = 1; sz[u] = 1, ch[u].clear(), h[u] = 0; for (auto v : B[u]) if (v != f) dfs2(v, u), tmp[++top] = h[v], sz[u] += sz[v], ch[u].push_back(v); if (!top) return h[u] = 1, void(); sort(tmp + 1, tmp + top + 1), tmp[0] = 0; for (int i = 1;i &lt;= top;i++) &#123; h[u] += pw[i - 1] * tmp[i]; if (tmp[i] == tmp[i - 1]) len++; else fuck = (LL)fuck * inv[len] % mod, len = 1; &#125; h[u] *= sz[u], fuck = (LL)fuck * inv[len] % mod;&#125;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;set&lt;ULL&gt; s;int main() &#123; freopen("tree.in", "r", stdin), freopen("tree.out", "w", stdout); int n, ans = 0; scanf("%d", &amp;n), pw[0] = inv[0] = 1; for (int i = 1;i &lt;= 12;i++) pw[i] = pw[i - 1] * P, inv[i] = inv[i - 1] * i; for (int i = 2;i &lt;= 12;i++) inv[i] = Pow(inv[i], mod - 2); for (int i = 1, a, b;i &lt; n;i++) scanf("%d%d", &amp;a, &amp;b), adde(a, b); scanf("%d", &amp;m); for (int i = 1, a, b;i &lt; m;i++) scanf("%d%d", &amp;a, &amp;b), B[a].push_back(b), B[b].push_back(a); for (int i = 1;i &lt;= m;i++) &#123; fuck = 1, dfs2(rt = i, 0); if (s.count(h[i])) continue; s.insert(h[i]), res = 0, dfs(1, 0), ans = (ans + (LL)res * fuck) % mod; &#125; printf("%d\n", ans);&#125; T3 子图 比较妙的一道题 其实题解说得挺清楚的 注意对于情况3需要减去的是4次情况5，而不是2次 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100010;vector&lt;int&gt; G[N], G2[N];const int mod = 1e9 + 7; int n, cnt[N], sum, vis[N], case4, sum2, tmp[N];inline void triple() &#123; for (int i = 1;i &lt;= n;i++) &#123; for (auto v : G2[i]) vis[v] = i; for (auto v : G2[i]) for (auto t : G2[v]) if (vis[t] == i) sum++, cnt[i]++, cnt[v]++, cnt[t]++; &#125;&#125;inline void four() &#123; for (int u = 1;u &lt;= n;u++) &#123; for (auto v : G[u]) if (v &lt; u) for (auto t : G[v]) if (t &lt; u) sum2 = (sum2 + tmp[t]) % mod, tmp[t]++; for (auto v : G[u]) if (v &lt; u) for (auto t : G[v]) if (t &lt; u) tmp[t]--; &#125;&#125;typedef long long LL;inline void triple1() &#123;for (int i = 1;i &lt;= n;i++) case4 = (case4 + (LL)cnt[i] * (G[i].size() - 2)) % mod;&#125;inline void gen() &#123; for (int u = 1;u &lt;= n;u++) for (auto v : G[u]) if (u &lt; v) &#123; if (G[u].size() &gt;= G[v].size()) G2[u].push_back(v); else G2[v].push_back(u); &#125;&#125;inline int solve2() &#123; int res = 0; for (int i = 1;i &lt;= n;i++) res = (res + (LL)G[i].size() * (G[i].size() - 1) / 2) % mod; return res;&#125;inline int solve3() &#123; int res = 0; gen(); for (int i = 1;i &lt;= n;i++) res = (res + (LL)G[i].size() * (G[i].size() - 1) * (G[i].size() - 2) / 6) % mod; for (int u = 1;u &lt;= n;u++) for (auto v : G[u]) if (v &gt; u) res = (res + (LL)(G[u].size() - 1) * (G[v].size() - 1)) % mod; triple(); return (res - 2 * sum + mod) % mod;&#125;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;inline int solve4() &#123; int res = 0; gen(); int inv = Pow(24, mod - 2); for (int i = 1;i &lt;= n;i++) res = (res + (LL)G[i].size() * (G[i].size() - 1) * (G[i].size() - 2) % mod * (G[i].size() - 3) % mod * inv) % mod; triple(), triple1(); for (int u = 1;u &lt;= n;u++) if (G[u].size() &gt;= 3) &#123; int t = (LL)(G[u].size() - 1) * (G[u].size() - 2) / 2 % mod; for (auto v : G[u]) res = (res + (LL)(G[v].size() - 1) * t) % mod; &#125; res = (res - 2 * case4 + (LL)2 * mod) % mod, four(); for (int u = 1, hh = 0;u &lt;= n;u++, hh = 0) for (auto v : G[u]) res = (res + (LL)hh * (G[v].size() - 1)) % mod, hh = (hh + G[v].size() - 1) % mod; res = (res - (LL)4 * sum2 - 2 * case4 - 3 * sum) % mod, res = (res + mod) % mod; res = (res + (LL)case4 + sum2) % mod; return res;&#125;int main() &#123; freopen("subgraph.in", "r", stdin), freopen("subgraph.out", "w", stdout); int m, k; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for (int i = 1, a, b;i &lt;= m;i++) scanf("%d%d", &amp;a, &amp;b), G[a].push_back(b), G[b].push_back(a); if (k == 1) return printf("%d\n", m), 0; if (k == 2) return printf("%d\n", solve2()), 0; if (k == 3) return printf("%d\n", solve3()), 0; if (k == 4) return printf("%d\n", solve4()), 0;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6.3NOI模拟]]></title>
    <url>%2F2019%2F06%2F11%2F6-3NOI%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 下棋 对这道题无语了，真的是下棋 T2 大树 出题人需要谢罪 题目中漏了一个重要条件：每条边最多只能被经过两次 那么这样的话，每一次一定是走完一棵子树，然后再去走其它子树 因此对于一个点，我们只需要确定它的子树的遍历顺序 由于答案只与每个点的第一次到达时间有关，因此往回走是没有问题的，即这棵树的每条边都会被经过两次 考虑两棵子树$a,b$ 如果先遍历$a$再去遍历$b$，那么$b$中每个点的到达时间都会延后$s_a$，这个$s_a$表示以$a$为根的子树，加上$a$与父亲的那条边的边权之和，总共增加$size_bs_a$ 同样，如果先遍历$b$再去遍历$a$，到达时间总共会增加$size_as_b$ 按照国王游戏的套路，按照这个东西排序即可获得每个点子树的遍历顺序，然后模拟即可 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100010;typedef long long LL;struct edge &#123;int to, next, w;&#125; e[N * 2];int head[N], ecnt, fa[N][17], dis[N], dep[N];inline void adde(int from, int to, int w) &#123; e[++ecnt] = (edge)&#123;to, head[from], w&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to], w&#125;, head[to] = ecnt;&#125;void dfs(int u, int f) &#123; fa[u][0] = f, dep[u] = dep[f] + 1; for (int i = 1;i &lt;= 16;i++) fa[u][i] = fa[fa[u][i - 1]][i - 1]; for (int i = head[u];i;i = e[i].next) if (e[i].to != f) dis[e[i].to] = dis[u] + e[i].w, dfs(e[i].to, u);&#125;inline int LCA(int a, int b) &#123; if (dep[a] &lt; dep[b]) swap(a, b); for (int i = 16;i &gt;= 0;i--) if (dep[fa[a][i]] &gt;= dep[b]) a = fa[a][i]; if (a == b) return a; for (int i = 16;i &gt;= 0;i--) if (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i]; return fa[a][0];&#125;inline int DIS(int a, int b) &#123; return dis[a] + dis[b] - 2 * dis[LCA(a, b)];&#125;LL tot, ans, sum[N];int sz[N], tf[N];int id[N];void dfs1(int u, int f) &#123; sz[u] = 1, sum[u] = tf[u]; for (int i = head[u];i;i = e[i].next) if (e[i].to != f) tf[e[i].to] = e[i].w, dfs1(e[i].to, u), sz[u] += sz[e[i].to], sum[u] += sum[e[i].to];&#125;void dfs2(int u, int f) &#123; ans += tot; vector&lt;int&gt; tmp; for (int i = head[u];i;i = e[i].next) if (e[i].to != f) tmp.push_back(e[i].to); sort(tmp.begin(), tmp.end(), [](int a, int b) &#123;return sum[a] * sz[b] &lt; sum[b] * sz[a];&#125;); for (auto v : tmp) tot += tf[v], dfs2(v, u), tot += tf[v];&#125;int main() &#123; freopen("tree.in", "r", stdin), freopen("tree.out", "w", stdout); int n; scanf("%d", &amp;n); for (int i = 1, a, b, c;i &lt; n;i++) scanf("%d%d%d", &amp;a, &amp;b, &amp;c), adde(a, b, c); for (int i = 1;i &lt;= n;i++) id[i] = i; if (n &lt;= 8) &#123; LL res = 1e18; dfs(1, 0); do &#123; LL tmp = 0, tmp2 = 0; for (int i = 2;i &lt;= n;i++) tmp += DIS(id[i - 1], id[i]), tmp2 += tmp; res = min(res, tmp2); &#125; while (next_permutation(id + 2, id + n + 1)); printf("%.6lf\n", (double)res / (n - 1)); &#125; else &#123; dfs1(1, 0), dfs2(1, 0), printf("%.6lf\n", (double)ans / (n - 1)); &#125;&#125; T3 数轴 注意到“好数”的个数实际上是很少的，因此可以将所有的好数都预处理出来 枚举区间交的右端点$R$，二分左端点$L$ 首先这个区间的长度不能大于最短的那个区间 对于所有$r$在$R$左侧的区间，需要移动$R-r$次 对于所有$l$在$L$右侧的区间，需要移动$l-L$次 将左右端点分开处理，其实就是预处理前缀和后缀，这样就可以扫描线了 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;typedef __int128 LLL;typedef long long LL;const int N = 100010;LL num[N * 6]; int tot; queue&lt;LL&gt; zjk, zjk2;inline void gen() &#123; num[++tot] = 4, num[++tot] = 7, zjk.push(4), zjk.push(7); for (int i = 2;i &lt;= 18;i++) &#123; while (!zjk.empty()) &#123; LL v = zjk.front(); zjk.pop(); num[++tot] = v * 10 + 4, num[++tot] = v * 10 + 7; zjk2.push(num[tot]), zjk2.push(num[tot - 1]); &#125; swap(zjk, zjk2); &#125; sort(num + 1, num + tot + 1);&#125;struct tcurts &#123;LL l, r;&#125; l[N];int n; LL k, mn;typedef pair&lt;int, LLL&gt; P;P pre[N * 6], suf[N * 6];inline void solve() &#123; sort(l + 1, l + n + 1, [](tcurts a, tcurts b) &#123;return a.r &lt; b.r;&#125;); P tmp(0, 0); for (int i = 1, cur = 1;i &lt;= tot;i++) &#123; while (cur &lt;= n &amp;&amp; l[cur].r &lt;= num[i]) tmp.second += l[cur].r, tmp.first++, cur++; pre[i] = tmp; &#125; tmp = P(0, 0), sort(l + 1, l + n + 1, [](tcurts a, tcurts b) &#123;return a.l &lt; b.l;&#125;); for (int i = tot, cur = n;i &gt;= 1;i--) &#123; while (cur &gt;= 1 &amp;&amp; l[cur].l &gt;= num[i]) tmp.second += l[cur].l, tmp.first++, cur--; suf[i] = tmp; &#125; int res = 0; for (int i = 1;i &lt;= tot;i++) &#123; LLL t = (LLL)num[i] * pre[i].first - pre[i].second; if (t &gt; k) continue; int l = 1, r = i, mid, ans = -1; while (l &lt;= r) &#123; mid = (l + r) &gt;&gt; 1; if (num[i] - num[mid] &gt; mn) &#123;l = mid + 1; continue;&#125; if (t + suf[mid].second - (LLL)num[mid] * suf[mid].first &gt; k) &#123; l = mid + 1; continue; &#125; ans = mid, r = mid - 1; &#125; if (~ans) res = max(res, i - ans + 1); &#125; printf("%d\n", res);&#125;int main() &#123; freopen("number.in", "r", stdin), freopen("number.out", "w", stdout); gen(), scanf("%d%lld", &amp;n, &amp;k), mn = 1e18; for (int i = 1;i &lt;= n;i++) scanf("%lld%lld", &amp;l[i].l, &amp;l[i].r), mn = min(mn, l[i].r - l[i].l); solve();&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>交互</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.31NOI模拟]]></title>
    <url>%2F2019%2F06%2F11%2F5-31NOI%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 Exchange 题目中的交换，实际上是将自己手中的菜换成那颗菜，而不是真正的交换 如果将$i$与$i$右侧第一个大于$i$的点连边，那么最终会形成一棵树 通过观察可以得出，这棵树的某一棵子树一定是一个连续的区间 用线段树维护每个点到这个点所在的树根的距离，查询就是查区间最大值 预处理出每个点的所有儿子，然后扫描线就可以了 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1500010;int tag[N &lt;&lt; 2], mx[N &lt;&lt; 2];inline int Max(const int &amp;a, const int &amp;b) &#123;return a &gt; b ? a : b;&#125;inline void pushup(int rt) &#123;mx[rt] = Max(mx[rt &lt;&lt; 1], mx[rt &lt;&lt; 1 | 1]);&#125;inline void pushdown(int rt) &#123;mx[rt &lt;&lt; 1] += tag[rt], mx[rt &lt;&lt; 1 | 1] += tag[rt], tag[rt &lt;&lt; 1] += tag[rt], tag[rt &lt;&lt; 1 | 1] += tag[rt], tag[rt] = 0;&#125;void update(int rt, int l, int r, int start, int end) &#123; if (start &lt;= l &amp;&amp; r &lt;= end) return mx[rt]++, tag[rt]++, void(); if (tag[rt]) pushdown(rt); int mid = (l + r) &gt;&gt; 1; if (start &lt;= mid) update(rt &lt;&lt; 1, l, mid, start, end); if (end &gt; mid) update(rt &lt;&lt; 1 | 1, mid + 1, r, start, end); pushup(rt);&#125;int res;void query(int rt, int l, int r, int start, int end) &#123; if (mx[rt] &lt;= res) return; if (start &lt;= l &amp;&amp; r &lt;= end) return res = mx[rt], void(); int mid = (l + r) &gt;&gt; 1; if (tag[rt]) pushdown(rt); if (start &lt;= mid) query(rt &lt;&lt; 1, l, mid, start, end); if (end &gt; mid) query(rt &lt;&lt; 1 | 1, mid + 1, r, start, end);&#125;int num[N], st[N];inline void pre(int n) &#123; static int stk[N], top = 0; stk[++top] = 1; for (int i = 1;i &lt;= n;i++) st[i] = i; for (int i = 2;i &lt;= n;stk[++top] = i++) while (top &amp;&amp; num[stk[top]] &lt; num[i]) st[i] = min(st[i], st[stk[top]]), top--;&#125;typedef pair&lt;int, int&gt; P;vector&lt;P&gt; Q[N]; int ans[N];inline void solve(int n) &#123; for (int i = 1;i &lt;= n;i++) &#123; update(1, 1, n, st[i], i); for (auto q : Q[i]) res = 0, query(1, 1, n, q.first, i), ans[q.second] = res; &#125;&#125;const int BUF_SIZE = 100000;inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *p2 = buf + BUF_SIZE; if (p1 == p2) p1 = buf, p2 = buf + fread(buf, 1, BUF_SIZE, stdin); return *p1++;&#125;inline void read(int &amp;x) &#123; x = 0; char c = nc(); while (c &lt; '0' || c &gt; '9') c = nc(); while ('0' &lt;= c &amp;&amp; c &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - '0', c = nc();&#125;inline void write(int x) &#123; if (!x) return putchar('0'), void(); if (x &gt;= 10) write(x / 10); putchar('0' + x % 10);&#125;int main() &#123; freopen("exchange.in", "r", stdin), freopen("exchange.out", "w", stdout); int n, q; read(n), read(q); for (int i = 1;i &lt;= n;i++) read(num[i]); for (int i = 1, a, b;i &lt;= q;i++) read(a), read(b), Q[b].push_back(P(a, i)); pre(n), solve(n); for (int i = 1;i &lt;= q;puts(""), i++) write(ans[i]);&#125; T2 Tree 比较简单的一道题 首先将$1$号点定为根节点，可以通过$n$次询问确定每个点的深度 此时每个点的父亲是唯一的，可以通过二分依次确定每个点的父亲 比如要确定$u$的父亲，那么就在$u$的上一层二分，每次询问一个前缀是否在$1$到$u$的路径上即可 T3 Hanoi 神仙题 首先不管$a,b$的限制，那么我们可以发现如下性质： 放入三号塔的圆盘必须严格按照顺序 对于二号塔或者一号塔顶端的连续一段与三号塔顶端匹配的圆盘，必须立刻移动到三号塔上 在二号塔中，如果存在$x,y$，使得$x$是$y$的上一个圆盘并且$x&lt;y-1$，那么一定无解 其实题解说得很清楚 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; P;vector&lt;int&gt; p, q, p1, q1; int a, b; vector&lt;P&gt; ans;inline bool check() &#123; for (int i = 0;i &lt; q.size();) &#123; int j = i; while (j &lt; q.size() - 1 &amp;&amp; q[j + 1] == q[j] - 1) j++; if (j - i + 1 &gt; b || (j != q.size() - 1 &amp;&amp; q[j + 1] &lt; q[j])) return false; i = j + 1; &#125; return true;&#125;inline void move(int x, int type = 1) &#123; if (x == 0) return; if (type) ans.push_back(P(1, x)); for (int i = p.size() - x;i &lt; p.size();i++) q.push_back(p[i]); p.resize(p.size() - x);&#125;inline void fuck() &#123;puts("NO"), exit(0);&#125;inline bool single(int x) &#123; for (int i = x;i &lt; p.size() - 1;i++) if (p[i + 1] != p[i] - 1) return false; return true;&#125;int main() &#123; freopen("hanoi.in", "r", stdin), freopen("hanoi.out", "w", stdout); int n; scanf("%d%d%d", &amp;n, &amp;a, &amp;b); for (int i = 1, v;i &lt;= n;i++) scanf("%d", &amp;v), p.push_back(v); reverse(p.begin(), p.end()); while (!p.empty() || !q.empty()) &#123; if (!check()) fuck(); int mx = p.size() + q.size(), pos = -1; for (int i = 0;i &lt; q.size();i++) if (q[i] == mx) &#123;pos = i; break;&#125; if (pos != -1) &#123;ans.push_back(P(2, q.size() - pos)), q.resize(pos); continue;&#125; for (int i = 0;i &lt; p.size();i++) if (p[i] == mx) &#123;pos = i; break;&#125; if (single(pos)) &#123;move(1); continue;&#125; pos = p.size() - 1; while (pos &gt; 0 &amp;&amp; p[pos - 1] &lt;= p[pos] + 1) pos--; int sz = p.size() - pos; if (single(pos)) &#123; if (sz &lt;= a) move(sz); else for (int i = 1;i &lt;= sz;i++) move(1); continue; &#125; int Mx = 0, Mn = n; for (int i = pos;i &lt; p.size();i++) Mx = max(Mx, p[i]), Mn = min(Mn, p[i]); if (Mx - Mn + 1 != p.size() - pos) &#123; if (sz &gt; a) fuck(); move(sz); continue; &#125; int tot = 0, zjk = 0, len = 0; for (int i = pos + 1;i &lt; p.size();i++) if (p[i] != p[i - 1] - 1) tot++, len = 1; else zjk = max(zjk, ++len); if (tot &gt; 1) &#123; if (zjk &gt; a || sz &gt; b) &#123; if (sz &gt; a) fuck(); move(sz); continue; &#125; for (int i = p.size() - 1, j;i &gt;= pos;i--) &#123; j = i; int tmp = 1; while (j &gt; pos &amp;&amp; p[j] == p[j - 1] - 1) j--, tmp++; move(tmp), i = j; &#125; continue; &#125; int pos2 = p.size() - 1; while (p[pos2] == p[pos2 - 1] - 1) pos2--; int A = p.size() - pos2, B = sz - A; if (A + B &lt;= b &amp;&amp; max(A, B) &lt;= a) &#123;move(A), move(B); continue;&#125; bool flag = false; for (int div = 1, tmp;div &lt;= sz;div++) if (max(div, sz - div) &lt;= a) &#123; if (div &lt;= A) tmp = max(div + B, sz - div - B); else tmp = max(div - A, sz - div + A); if (tmp &lt;= b) &#123;flag = true, move(div), move(sz - div); break;&#125; &#125; if (!flag) fuck(); &#125; printf("YES\n%d\n", ans.size()); for (auto v : ans) printf("%d %d\n", v.first, v.second);&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>扫描线</tag>
        <tag>交互</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.30NOI模拟]]></title>
    <url>%2F2019%2F06%2F09%2F5-30NOI%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 Duliu 首先显然有$$f(l,r)=2(r-l+1)\sum_{i=l}^rd_i$$将询问离线，按照$x$从大到小排序，对于每个$i$维护以$i$为左端点的区间中，右端点最靠左能取到哪个位置，使得这个区间的权值大于等于$x$ 预处理出每个数作为一个区间的最大值时，这个区间的左端点与右端点最远可以取到哪里 对于每个数我们都找到这样的一个区间，求出这个区间的权值，按照这个权值排序 对于一个这样的极长区间$[L,R]$，在加入这个区间的时候我们只需要更新$L$的值，更新为这个区间最大值 我们这样考虑 对于每个询问，答案可能有三种情况： 左端点是$L$ 右端点是$R$ 左右端点都在$L,R$中间 前两种情况可以直接二分出第一个满足条件的端点 在纸上画一画，可以发现，我们只更新这个$L$是不会出问题的 考虑以下几种情况： 答案取到的区间的左端点大于$L$，并且$L$在询问的$l$左方 那么我们取$[l,R]$这个区间同样可以满足条件，并且最小值与$[L,R]$相等 答案取到的区间的左端点大于$L$，并且$L$在询问的$l$右方 取$[L,R]$这个区间即可 因此，这样是可以的 现在考虑询问的第三种情况 假如右端点取$R$时，左端点最靠右要取到$pos$才能使得这个区间的和$\geq x$ 事实上，我们只需要查询$[L,pos]$的区间最小值即可 考虑以下三种区间 左端点在$[L,pos]$，右端点在$[L,R]$ 显然这种区间是合法的 左端点在$[pos+1,L]$，右端点在$[L,R]$ 如果这样的区间有一个是合法的，那么就不满足$pos$的定义了，$pos$还可以继续向右移动 因此，这样就考虑了所有的情况 用一个单调栈求出每个数成为最大值的范围，然后开一棵支持单点修改，区间查$min$的线段树以及一个区间查最大值的st表即可 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 300010;typedef long long LL;int mn[N &lt;&lt; 2];inline void pushup(int rt) &#123;mn[rt] = min(mn[rt &lt;&lt; 1], mn[rt &lt;&lt; 1 | 1]);&#125;void update(int rt, int l, int r, int at, int x) &#123; int mid = (l + r) &gt;&gt; 1; if (l == r) return mn[rt] = x, void(); if (at &lt;= mid) update(rt &lt;&lt; 1, l, mid, at, x); else update(rt &lt;&lt; 1 | 1, mid + 1, r, at, x); pushup(rt);&#125;int query(int rt, int l, int r, int start, int end) &#123; int mid = (l + r) &gt;&gt; 1, res = 1e9; if (start &lt;= l &amp;&amp; r &lt;= end) return mn[rt]; if (start &lt;= mid) res = min(res, query(rt &lt;&lt; 1, l, mid, start, end)); if (end &gt; mid) res = min(res, query(rt &lt;&lt; 1 | 1, mid + 1, r, start, end)); return res;&#125;int st[30][N], lg[N], num[N], L[N], R[N]; LL s[N];inline int get(int l, int r) &#123; int len = r - l + 1; return max(st[lg[len]][l], st[lg[len]][r - (1 &lt;&lt; lg[len]) + 1]);&#125;inline void pre(int n) &#123; memset(mn, 0x3f, sizeof(mn)); for (int i = 1;i &lt;= n;i++) st[0][i] = num[i], s[i] = s[i - 1] + num[i]; for (int i = 2;i &lt;= n;i++) lg[i] = lg[i &gt;&gt; 1] + 1; for (int i = 1;i &lt;= lg[n];i++) for (int j = 1;j + (1 &lt;&lt; i) - 1 &lt;= n;j++) st[i][j] = max(st[i - 1][j], st[i - 1][j + (1 &lt;&lt; i - 1)]); static int stk[N], top = 0; stk[top = 1] = 1; for (int i = 2;i &lt;= n;stk[++top] = i++) while (top &amp;&amp; num[stk[top]] &lt; num[i]) R[stk[top]] = i - 1, top--; while (top) R[stk[top--]] = n; stk[top = 1] = n; for (int i = n - 1;i &gt;= 1;stk[++top] = i--) while (top &amp;&amp; num[stk[top]] &lt; num[i]) L[stk[top]] = i + 1, top--; while (top) L[stk[top--]] = 1;&#125;inline LL f(int l, int r) &#123;return 2 * (s[r] - s[l - 1]) * (r - l + 1);&#125;LL ans[N];struct Query &#123; int l, r, id; LL x; bool operator &lt; (const Query &amp;b) const &#123;return x &gt; b.x;&#125;&#125; q[N], d[N];int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;num[i]); pre(n); for (int i = 1;i &lt;= n;i++) d[i] = (Query)&#123;L[i], R[i], i, f(L[i], R[i])&#125;; for (int i = 1;i &lt;= m;i++) scanf("%d%d%lld", &amp;q[i].l, &amp;q[i].r, &amp;q[i].x), q[i].id = i; sort(d + 1, d + n + 1), sort(q + 1, q + m + 1); for (int i = 1, cur = 1;i &lt;= m;i++) &#123; while (cur &lt;= n &amp;&amp; d[cur].x &gt;= q[i].x) update(1, 1, n, d[cur].l, num[d[cur].id]), cur++; int l = q[i].l, r = q[i].r, mid, pos1 = -1, pos2 = -1; while (l &lt;= r) &#123; mid = (l + r) &gt;&gt; 1; if (f(q[i].l, mid) &gt;= q[i].x) pos1 = mid, r = mid - 1; else l = mid + 1; &#125; l = q[i].l, r = q[i].r; while (l &lt;= r) &#123; mid = (l + r) &gt;&gt; 1; if (f(mid, q[i].r) &gt;= q[i].x) pos2 = mid, l = mid + 1; else r = mid - 1; &#125; if (pos1 == -1 || pos2 == -1) &#123;ans[q[i].id] = -1; continue;&#125; ans[q[i].id] = min(min(get(q[i].l, pos1), get(pos2, q[i].r)), query(1, 1, n, q[i].l, pos2)); &#125; for (int i = 1;i &lt;= m;i++) printf("%d\n", ans[i]);&#125; T2 Gre 事实上，这道题我是爆搜+肉眼找规律做出来的 只要找出了满足出现了$k$种字符的最短的串，再在这个串的开头填a就是答案 观察$k$比较小的时候的解 $k=1$:a $k=2$:aabaa $k=3$:aababacbabaa 就以$k=2,k=3$为例 假设我们已经构造出了$k=2$时的答案aabaa 将a换成b，b换成c，得到bbcbb 现在我们要向里面插入尽量少的a，使得它满足条件 方法是，先插入两个a，然后指针向后移动，如果在上一个a与当前指针的位置之间，有一个字母出现了两次，那么就在当前指针前面插入一个a，最后再在结尾插入一个a bbcbb -&gt; aabbcbb -&gt; aababbcbb -&gt; aabababcbb -&gt; aabababcabb -&gt; aabababcabab -&gt; aabababcababa -&gt; aababacbabaa 这样可以保证，在任意时刻，a的数量总比第二多的字符的数量大，并且从前往后，从后往前都满足条件 然后这道题就完了 代码如下（其实我是打表过的 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;string ans[27] = &#123; "", "a", "aabaa", "aababacbabaa", "aababacbacbadcbacbabaa", "aababacbacbadcbadcbaedcbadcbacbabaa", "aababacbacbadcbadcbaedcbaedcbafedcbaedcbadcbacbabaa", "aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbafedcbaedcbadcbacbabaa", "aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa", "aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa", "aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa", "aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa", "aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa", "aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbalkjihgfedcbamlkjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa", "aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbalkjihgfedcbamlkjihgfedcbamlkjihgfedcbanmlkjihgfedcbamlkjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa", "aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbalkjihgfedcbamlkjihgfedcbamlkjihgfedcbanmlkjihgfedcbanmlkjihgfedcbaonmlkjihgfedcbanmlkjihgfedcbamlkjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa", "aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbalkjihgfedcbamlkjihgfedcbamlkjihgfedcbanmlkjihgfedcbanmlkjihgfedcbaonmlkjihgfedcbaonmlkjihgfedcbaponmlkjihgfedcbaonmlkjihgfedcbanmlkjihgfedcbamlkjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa", "aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbalkjihgfedcbamlkjihgfedcbamlkjihgfedcbanmlkjihgfedcbanmlkjihgfedcbaonmlkjihgfedcbaonmlkjihgfedcbaponmlkjihgfedcbaponmlkjihgfedcbaqponmlkjihgfedcbaponmlkjihgfedcbaonmlkjihgfedcbanmlkjihgfedcbamlkjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa", "aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbalkjihgfedcbamlkjihgfedcbamlkjihgfedcbanmlkjihgfedcbanmlkjihgfedcbaonmlkjihgfedcbaonmlkjihgfedcbaponmlkjihgfedcbaponmlkjihgfedcbaqponmlkjihgfedcbaqponmlkjihgfedcbarqponmlkjihgfedcbaqponmlkjihgfedcbaponmlkjihgfedcbaonmlkjihgfedcbanmlkjihgfedcbamlkjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa", "aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbalkjihgfedcbamlkjihgfedcbamlkjihgfedcbanmlkjihgfedcbanmlkjihgfedcbaonmlkjihgfedcbaonmlkjihgfedcbaponmlkjihgfedcbaponmlkjihgfedcbaqponmlkjihgfedcbaqponmlkjihgfedcbarqponmlkjihgfedcbarqponmlkjihgfedcbasrqponmlkjihgfedcbarqponmlkjihgfedcbaqponmlkjihgfedcbaponmlkjihgfedcbaonmlkjihgfedcbanmlkjihgfedcbamlkjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa", "aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbalkjihgfedcbamlkjihgfedcbamlkjihgfedcbanmlkjihgfedcbanmlkjihgfedcbaonmlkjihgfedcbaonmlkjihgfedcbaponmlkjihgfedcbaponmlkjihgfedcbaqponmlkjihgfedcbaqponmlkjihgfedcbarqponmlkjihgfedcbarqponmlkjihgfedcbasrqponmlkjihgfedcbasrqponmlkjihgfedcbatsrqponmlkjihgfedcbasrqponmlkjihgfedcbarqponmlkjihgfedcbaqponmlkjihgfedcbaponmlkjihgfedcbaonmlkjihgfedcbanmlkjihgfedcbamlkjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa", "aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbalkjihgfedcbamlkjihgfedcbamlkjihgfedcbanmlkjihgfedcbanmlkjihgfedcbaonmlkjihgfedcbaonmlkjihgfedcbaponmlkjihgfedcbaponmlkjihgfedcbaqponmlkjihgfedcbaqponmlkjihgfedcbarqponmlkjihgfedcbarqponmlkjihgfedcbasrqponmlkjihgfedcbasrqponmlkjihgfedcbatsrqponmlkjihgfedcbatsrqponmlkjihgfedcbautsrqponmlkjihgfedcbatsrqponmlkjihgfedcbasrqponmlkjihgfedcbarqponmlkjihgfedcbaqponmlkjihgfedcbaponmlkjihgfedcbaonmlkjihgfedcbanmlkjihgfedcbamlkjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa", "aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbalkjihgfedcbamlkjihgfedcbamlkjihgfedcbanmlkjihgfedcbanmlkjihgfedcbaonmlkjihgfedcbaonmlkjihgfedcbaponmlkjihgfedcbaponmlkjihgfedcbaqponmlkjihgfedcbaqponmlkjihgfedcbarqponmlkjihgfedcbarqponmlkjihgfedcbasrqponmlkjihgfedcbasrqponmlkjihgfedcbatsrqponmlkjihgfedcbatsrqponmlkjihgfedcbautsrqponmlkjihgfedcbautsrqponmlkjihgfedcbavutsrqponmlkjihgfedcbautsrqponmlkjihgfedcbatsrqponmlkjihgfedcbasrqponmlkjihgfedcbarqponmlkjihgfedcbaqponmlkjihgfedcbaponmlkjihgfedcbaonmlkjihgfedcbanmlkjihgfedcbamlkjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa", "aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbalkjihgfedcbamlkjihgfedcbamlkjihgfedcbanmlkjihgfedcbanmlkjihgfedcbaonmlkjihgfedcbaonmlkjihgfedcbaponmlkjihgfedcbaponmlkjihgfedcbaqponmlkjihgfedcbaqponmlkjihgfedcbarqponmlkjihgfedcbarqponmlkjihgfedcbasrqponmlkjihgfedcbasrqponmlkjihgfedcbatsrqponmlkjihgfedcbatsrqponmlkjihgfedcbautsrqponmlkjihgfedcbautsrqponmlkjihgfedcbavutsrqponmlkjihgfedcbavutsrqponmlkjihgfedcbawvutsrqponmlkjihgfedcbavutsrqponmlkjihgfedcbautsrqponmlkjihgfedcbatsrqponmlkjihgfedcbasrqponmlkjihgfedcbarqponmlkjihgfedcbaqponmlkjihgfedcbaponmlkjihgfedcbaonmlkjihgfedcbanmlkjihgfedcbamlkjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa", "aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbalkjihgfedcbamlkjihgfedcbamlkjihgfedcbanmlkjihgfedcbanmlkjihgfedcbaonmlkjihgfedcbaonmlkjihgfedcbaponmlkjihgfedcbaponmlkjihgfedcbaqponmlkjihgfedcbaqponmlkjihgfedcbarqponmlkjihgfedcbarqponmlkjihgfedcbasrqponmlkjihgfedcbasrqponmlkjihgfedcbatsrqponmlkjihgfedcbatsrqponmlkjihgfedcbautsrqponmlkjihgfedcbautsrqponmlkjihgfedcbavutsrqponmlkjihgfedcbavutsrqponmlkjihgfedcbawvutsrqponmlkjihgfedcbawvutsrqponmlkjihgfedcbaxwvutsrqponmlkjihgfedcbawvutsrqponmlkjihgfedcbavutsrqponmlkjihgfedcbautsrqponmlkjihgfedcbatsrqponmlkjihgfedcbasrqponmlkjihgfedcbarqponmlkjihgfedcbaqponmlkjihgfedcbaponmlkjihgfedcbaonmlkjihgfedcbanmlkjihgfedcbamlkjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa", "aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbalkjihgfedcbamlkjihgfedcbamlkjihgfedcbanmlkjihgfedcbanmlkjihgfedcbaonmlkjihgfedcbaonmlkjihgfedcbaponmlkjihgfedcbaponmlkjihgfedcbaqponmlkjihgfedcbaqponmlkjihgfedcbarqponmlkjihgfedcbarqponmlkjihgfedcbasrqponmlkjihgfedcbasrqponmlkjihgfedcbatsrqponmlkjihgfedcbatsrqponmlkjihgfedcbautsrqponmlkjihgfedcbautsrqponmlkjihgfedcbavutsrqponmlkjihgfedcbavutsrqponmlkjihgfedcbawvutsrqponmlkjihgfedcbawvutsrqponmlkjihgfedcbaxwvutsrqponmlkjihgfedcbaxwvutsrqponmlkjihgfedcbayxwvutsrqponmlkjihgfedcbaxwvutsrqponmlkjihgfedcbawvutsrqponmlkjihgfedcbavutsrqponmlkjihgfedcbautsrqponmlkjihgfedcbatsrqponmlkjihgfedcbasrqponmlkjihgfedcbarqponmlkjihgfedcbaqponmlkjihgfedcbaponmlkjihgfedcbaonmlkjihgfedcbanmlkjihgfedcbamlkjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa", "aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbalkjihgfedcbamlkjihgfedcbamlkjihgfedcbanmlkjihgfedcbanmlkjihgfedcbaonmlkjihgfedcbaonmlkjihgfedcbaponmlkjihgfedcbaponmlkjihgfedcbaqponmlkjihgfedcbaqponmlkjihgfedcbarqponmlkjihgfedcbarqponmlkjihgfedcbasrqponmlkjihgfedcbasrqponmlkjihgfedcbatsrqponmlkjihgfedcbatsrqponmlkjihgfedcbautsrqponmlkjihgfedcbautsrqponmlkjihgfedcbavutsrqponmlkjihgfedcbavutsrqponmlkjihgfedcbawvutsrqponmlkjihgfedcbawvutsrqponmlkjihgfedcbaxwvutsrqponmlkjihgfedcbaxwvutsrqponmlkjihgfedcbayxwvutsrqponmlkjihgfedcbayxwvutsrqponmlkjihgfedcbazyxwvutsrqponmlkjihgfedcbayxwvutsrqponmlkjihgfedcbaxwvutsrqponmlkjihgfedcbawvutsrqponmlkjihgfedcbavutsrqponmlkjihgfedcbautsrqponmlkjihgfedcbatsrqponmlkjihgfedcbasrqponmlkjihgfedcbarqponmlkjihgfedcbaqponmlkjihgfedcbaponmlkjihgfedcbaonmlkjihgfedcbanmlkjihgfedcbamlkjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa"&#125;;int main() &#123; //freopen("gre.in", "r", stdin), freopen("gre.out", "w", stdout); int T; scanf("%d", &amp;T); while (T--) &#123; int n, k; scanf("%d%d", &amp;n, &amp;k); if (n &lt; ans[k].size()) printf("CiYe\n"); else &#123; for (int i = 1;i &lt;= n - ans[k].size();i++) putchar('a'); cout &lt;&lt; ans[k] &lt;&lt; endl; &#125; &#125;&#125; T3 Tetris 一道很好玩的提交答案题 除了第8号点以外都挺简单的 我写的是A*，每次保留最优秀的前$1000$个解 难点在于估价函数 第6个点需要单独设计估价函数，第8个点我不会，其余的点可以使用通用估价函数 可以将最大高度、连续段个数、留下的方块个数、某个方块下方有多少个空格以及是否存在一行只有1个格子未填这些信息设计进估价函数 代码就不放了]]></content>
      <tags>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>构造</tag>
        <tag>提交答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式exp]]></title>
    <url>%2F2019%2F05%2F29%2F%E5%A4%9A%E9%A1%B9%E5%BC%8Fexp%2F</url>
    <content type="text"><![CDATA[给出$A(x)$，求$e^{A(x)}\mod x^n$，每一项的系数模$998244353$ 这里要求$A(x)$的常数项为$0$ 牛顿迭代法与泰勒展开假如我们要用一个无穷级数来表示$f(x)$ 首先选一个展开点$x_0$，然后有$$f(x)=\sum_{i=0}^\infty \frac{f^{(i)}(x_0)(x-x_0)^i}{i!}$$其中，$f^{(i)}$表示$f$的$i$阶导数 现在我们知道$G(x)$，要求求出一个$F(x)$，使得$$G(F(x))\equiv 0\pmod {x^n}$$设$F_t(x)$表示$F$经过$t$次迭代之后的结果，即$$G(F_t(x))\equiv0\pmod{x^{2^t}}$$考虑如何从第$t$次迭代推到第$t+1$次迭代 首先将这个式子从$F_{t}(x)$这个点泰勒展开$$\begin{aligned}G(F_{t+1}(x))&amp;=\sum_{i=0}^\infty \frac{G^{(i)}(F_t(x))}{i!}(F_{t+1}(x)-F_{t}(x))^i\\&amp;=G(F_t(x))+G’(F_t(x))(F_{t+1}(x)-F_t(x))+\sum_{i=2}^\infty 一些东西\end{aligned}$$现在将这个式子放到模$x^{2^{t+1}}$下 注意到$F_{t+1}(x)$与$F_t(x)$在模$x^{2^t}$下同余 也就是说，这两个多项式的最后$2^t$项是相同的 如果我们让$(F_{t+1}(x)-F_t(x))^i$这里的$i$至少取到$2$ 那么结果最后的至少$2^{t+1}$项都是$0$，放到模$x^{2^{t+1}}$下就是$0$ 所以后面的那些东西就可以不管了，只留下了前两项$$\begin{aligned}G(F_{t+1}(x))&amp;\equiv G(F_t(x))+G’(F_t(x))(F_{t+1}(x)-F_t(x))\pmod {x^{2^{t+1}}}\\0&amp;\equiv G(F_t(x))+G’(F_t(x))F_{t+1}(x)-G’(F_t(x))F_t(x)\\F_{t+1}(x)&amp;\equiv F_t(x)-\frac{G(F_t(x))}{G’(F_t(x))}\end{aligned}$$这就是牛顿迭代法的公式 多项式$\ln$有两种方法，第一种是先求导后积分，第二种是利用牛顿迭代的公式 这里讲一下第二种 令$F(x)=\frac{1}{A(x)}$ 那么有$G(F(x))=A(x)F(x)-1,G’(F(x))=A(x)F’(x)$$$F_{t+1}(x)\equiv F_t(x)-\frac{A(x)F_t(x)-1}{A(x)F_t’(x)}$$好吧事实上完全没必要这么复杂 多项式$\exp$令$F(x)=e^{A(x)}$ 那么$G(F(x))=\ln F(x)-A(x)$ 我们将$A(x)$当作常数，那么$G’(F(x))=\frac{1}{F(x)}$ 有$$\begin{aligned}F_{t+1}(x)&amp;\equiv F_t(x)-\frac{G(F_t(x))}{G’(F_t(x))}\\&amp;\equiv F_t(x)-F_t(x)(\ln F_t(x)-A(x))\\&amp;\equiv F_t(x)(1-\ln F_t(x)+A(x))\end{aligned}$$所以多项式$\exp$需要多项式$\ln$ 时间复杂度$O(n\log n)$ 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int mod = 998244353, N = 600010;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;int r[N], inv[N];inline void NTT(int a[], int len, int type) &#123; for (int i = 0;i &lt; len;i++) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int mid = 2;mid &lt;= len;mid &lt;&lt;= 1) &#123; int Wn = Pow(3, type ? (mod - 1) / mid : mod - 1 - (mod - 1) / mid); for (int i = 0;i &lt; len;i += mid) for (int j = i, w = 1, t;j &lt; i + (mid &gt;&gt; 1);j++, w = (LL)w * Wn % mod) t = (LL)w * a[j + (mid &gt;&gt; 1)] % mod, a[j + (mid &gt;&gt; 1)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod; &#125; if (!type) for (int i = 0, inv = Pow(len, mod - 2);i &lt; len;i++) a[i] = (LL)a[i] * inv % mod;&#125;inline void Inv(const int A[], int B[], int n) &#123; if (n == 1) return void(B[0] = Pow(A[0], mod - 2)); Inv(A, B, (n + 1) &gt;&gt; 1); static int tmpa[N]; int len = 1, l = 0; while (len &lt;= 3 * n) len &lt;&lt;= 1, l++; for (int i = 0;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); for (int i = 0;i &lt; n;i++) tmpa[i] = A[i]; for (int i = n;i &lt; len;i++) tmpa[i] = 0; NTT(tmpa, len, 1), NTT(B, len, 1); for (int i = 0;i &lt; len;i++) B[i] = (2 - (LL)tmpa[i] * B[i] % mod + mod) * B[i] % mod; NTT(B, len, 0); for (int i = n;i &lt; len;i++) B[i] = 0;&#125;inline void Ln(const int A[], int B[], int n) &#123; static int tmpa[N], inva[N]; memset(tmpa, 0, sizeof(tmpa)), memset(inva, 0, sizeof(inva)); for (int i = 0;i &lt; n;i++) tmpa[i] = (LL)A[i + 1] * (i + 1) % mod; Inv(A, inva, n); int len = 1, l = 0; while (len &lt;= 2 * n) len &lt;&lt;= 1, l++; for (int i = 0;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); NTT(tmpa, len, 1), NTT(inva, len, 1); for (int i = 0;i &lt; len;i++) tmpa[i] = (LL)tmpa[i] * inva[i] % mod; NTT(tmpa, len, 0); for (int i = 1;i &lt; n;i++) B[i] = (LL)tmpa[i - 1] * inv[i] % mod;&#125;inline void Exp(const int A[], int B[], int n) &#123; if (n == 1) return void(B[0] = 1); Exp(A, B, (n + 1) &gt;&gt; 1); static int lnb[N]; memset(lnb, 0, sizeof(lnb)); Ln(B, lnb, n); int len = 1, l = 0; for (int i = 0;i &lt; n;i++) lnb[i] = (A[i] - lnb[i] + mod) % mod; lnb[0]++; while (len &lt;= 2 * n) len &lt;&lt;= 1, l++; for (int i = 0;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); NTT(B, len, 1), NTT(lnb, len, 1); for (int i = 0;i &lt; len;i++) B[i] = (LL)B[i] * lnb[i] % mod; NTT(B, len, 0); for (int i = n;i &lt; len;i++) B[i] = 0;&#125;int A[N], B[N];int main() &#123; int n; scanf("%d", &amp;n), inv[0] = 1; for (int i = 1;i &lt;= n;i++) inv[i] = Pow(i, mod - 2); for (int i = 0;i &lt; n;i++) scanf("%d", &amp;A[i]); Exp(A, B, n); for (int i = 0;i &lt; n;i++) printf("%d ", B[i]);&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>多项式</tag>
        <tag>算法</tag>
        <tag>NTT</tag>
        <tag>多项式ln</tag>
        <tag>多项式exp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Min25筛]]></title>
    <url>%2F2019%2F05%2F22%2FMin25%E7%AD%9B%2F</url>
    <content type="text"><![CDATA[设$f(x)$是一个给定的积性函数，并且是一个关于$x$的简单多项式，还可以快速算出$f(p^k)$，其中$p$是质数 那么Min25筛可以在$O(\frac{n^{\frac34}}{\log n})$的时间内求出$f(x)$的前缀和 算法Min25筛的大体流程是，先求出所有质数的$f(x)$的和，再用质数的和推出所有合数的$f(x)$的和 定义另一个函数$f’(x)$，必须保证$f’(x)$是完全积性函数，并且在质数位置的结果与$f(x)$相等，其它位置随意，且$f’(x)$的前缀和能够快速求出 定义$s(x)$表示$x$的最小质因子 定义$g(n,k)$表示$$\sum_{i=2}^n[i是质数或s(i)&gt;p_k]f’(i)$$即要么$i$是质数，要么$i$的最小质因子大于第$k$个质数 注意到对于任意一个合数，它的最小质因子不可能大于$\sqrt n$，因此$k$只需要取到$\sqrt n$即可 我们先预处理出所有的$g(n,0)$ 即$$\sum_{i=2}^nf’(i)$$我们定义$m$表示$p_{m+1}&gt;\sqrt n$的第一个位置 那么$g(n,m)$就是所有质数的$f’(x)$也就是$f(x)$之和 考虑递推$g$，从$g(*,j-1)$递推到$g(*,j)$ 显然有$$g(n,j)=g(n,j-1)-\sum_{i=2}^n[i\not=p_j,s(i)=p_j]f’(i)$$我们知道$$g(n,j)-g(p_j,j)$$它等价于$$\sum_{i=p_j+1}^n[s(i)=p_j]f’(i)$$即大于$p_j$且最小质因子是$p_j$的所有数 因为$g(p_j,j)$就表示$2-p_j$中的质数以及最小质因子大于$p_j$的数 显然只有$2-p_j$的质数满足条件 如果$s(i)=p_j$，我们就将它的质因子提出来一个$p_j$ 由于$f’(x)$是完全积性函数，因此$f’(p)f’(\frac{n}{p})=f’(n)$ 因此$$g(n,j)=g(n,j-1)-[g(\lfloor\frac{n}{p_j}\rfloor,j-1)-g(p_j,j-1)]*f’(p_j)$$最终我们只关心$g(n,m)$，而此时$g(n,m)$仅包含所有质数的$f’(x)$之和 当$x$是质数时，根据定义$f’(x)=f(x)$ 因此$g(n,m)$就是所有质数的$f(x)$之和 现在我们算出了所有质数的和，考虑从质数推到合数 定义$S(n,k)$表示$$\sum_{i=p_k}^n[s(i)\geq p_k]f(i)$$我们将这些数分为两类：质数和合数 对于质数的和，它等于$g(n,m)-p_1到p_{k-1}的f(x)之和$ 对于合数，我们采用枚举最小质因子以及这个质因子的次数的方式统计 我们将合数分成两类：至少有两个质因子的，以及只有一个质因子的 假设我们枚举到了最小质因子$p_k$ 现在枚举它的次数$e$ 先考虑第一种合数 首先必须满足$p_k^e\leq n$ 其实可以将这个上界进一步缩紧，变成$p_k^{e+1}\leq n$ 因为$p_k$是某个数的最小质因子，如果$p_k^e\leq n$，而$p_k^{e+1}&gt; n$，一定不存在$\leq n$的这样的数 那么此时这些合数的和为$$\sum_{p_k^{e+1}\leq n}f(p_k^e)S(\lfloor\frac{n}{p_k^e}\rfloor,k+1)$$我们再考虑第二种合数 假设它为$p_k^e$ 那么$e\not=1,p_k^e\leq n$ 这一类合数的和为$$\sum_{e\not=1,p_k^e\leq n}f(p_k^e)=\sum_{p_k^{e+1}}f(p_k^{e+1})$$将这两类合数加起来$$\begin{aligned}S(n,t)&amp;=\sum_{k=t}^m[\sum_{p_k^{e+1}\leq n}f(p_k^e)S(\lfloor\frac{n}{p_k^e}\rfloor, k+1)+\sum_{p_k^{e+1}\leq n}f(p_k^{e+1})]\\&amp;=\sum_{k=t}^m\sum_{p_k^{e+1}\leq n}[f(p_k^e)S(\lfloor\frac{n}{p_k^e}\rfloor,k+1)+f(p_k^{e+1})]\end{aligned}$$然后递归就行了 实现注意到计算$g,S$的时候用到的$n$的种数非常少，只会用到$n,\lfloor\frac{n}{2}\rfloor,\lfloor\frac n3\rfloor,\cdots,\lfloor\frac{n}{n-1}\rfloor,\lfloor\frac{n}{n}\rfloor$ 实际上不同的取值只有$\sqrt n$个 我们把这$\sqrt n$个值离散化一下 考虑怎么快速查一个数$\lfloor\frac{n}{k}\rfloor=a$的编号 当然你要用map也行，但是就多了一个$\log$ 这里我们开两个大小为$\sqrt n$的数组id1, id2 我们用id1[a]表示$a(\leq \sqrt n)$的编号 用id2[a]表示$\lfloor\frac na\rfloor(a&gt;\sqrt n)$的编号 这样两个数组都只要开到$\sqrt n$就可以存下所有数 如果$a\leq \sqrt n$，那么直接返回id1[a] 否则返回id2[n / a] 1inline int ID(LL x) &#123;return x &lt;= T ? id1[x] : id2[n / x];&#125; 对于$g(n,j)$，我们可以使用滚动数组的方式把第二维滚掉 这里给出初始化以及求$S$的代码 1234567891011121314151617181920212223242526inline void init() &#123; T = sqrt(n + 0.5); for (int i = 2;i &lt;= T;i++) &#123; if (!flag[i]) prime[++ncnt] = i, sum[ncnt] = (sum[ncnt - 1] + f1(i)) % mod; for (int j = 1;j &lt;= ncnt &amp;&amp; (LL)i * prime[j] &lt;= T;j++) &#123; flag[i * prime[j]] = 1; if (i % prime[j] == 0) break; &#125; &#125; for (LL l = 1;l &lt;= n;l = n / (n / l) + 1) &#123; a[++m] = n / l; if (a[m] &lt;= T) id1[a[m]] = m; else id2[n / a[m]] = m; g[m] = calc(a[m]); &#125; for (int i = 1;i &lt;= ncnt;i++) for (int j = 1;j &lt;= m &amp;&amp; (LL)prime[i] * prime[i] &lt;= a[j];j++) g[j] = (g[j] - (LL)f1(prime[i]) * (g[ID(a[j] / prime[i])] - sum[i - 1]) % mod + mod) % mod;&#125;int solve(LL n, int m) &#123; if (n &lt; prime[m]) return 0; int res = (g[ID(n)] * (LL)2 * t - (LL)sum[m - 1] * 2 * t) % mod; res = (res + mod) % mod; for (int i = m;i &lt;= ncnt &amp;&amp; (LL)prime[i] * prime[i] &lt;= n;i++) for (LL j = prime[i], c = 1;j * prime[i] &lt;= n;j *= prime[i], c++) Inc(res, ((LL)solve(n / j, i + 1) * f(j, c) + f(j * prime[i], c + 1)) % mod); return res;&#125; 例题洛谷P5325 求$$\sum_{i=1}^nf(i),f(p^k)=p^k(p^k-1)$$其中$f$是积性函数 对于质数$p$，$f(p)=p(p-1)$ 这个东西并不是一个完全积性函数 考虑把它拆开，$f(p)=p^2-p$ 注意到$p^2,p$都是完全积性函数，所以可以直接上Min25筛分别求这两个东西 其实就是维护两个$g$，第一个$g$对应的函数就是$p^2$，第二个对应的函数是$p$，然后在求$S$的时候合并 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1000010;typedef long long LL;const int mod = 1e9 + 7;namespace Min25 &#123; int prime[N], id1[N], id2[N], flag[N], g1[N], g2[N], sum1[N], sum2[N], ncnt, m, inv6 = 166666668; LL a[N], T, n; inline int ID(LL x) &#123;return x &lt;= T ? id1[x] : id2[n / x];&#125; inline int calc(LL x) &#123;x %= mod; return x * (x + 1) / 2 % mod - 1;&#125; inline int calc2(LL x) &#123;x %= mod; return x * (x + 1) % mod * (2 * x + 1) % mod * inv6 % mod - 1;&#125; inline int f(LL x) &#123;x %= mod; return x * (x - 1) % mod;&#125; inline void init() &#123; T = sqrt(n + 0.5); for (int i = 2;i &lt;= T;i++) &#123; if (!flag[i]) prime[++ncnt] = i, sum1[ncnt] = (sum1[ncnt - 1] + (LL)i * i) % mod, sum2[ncnt] = (sum2[ncnt - 1] + i) % mod; for (int j = 1;j &lt;= ncnt &amp;&amp; i * prime[j] &lt;= T;j++) &#123; flag[i * prime[j]] = 1; if (i % prime[j] == 0) break; &#125; &#125; for (LL l = 1;l &lt;= n;l = n / (n / l) + 1) &#123; a[++m] = n / l; if (a[m] &lt;= T) id1[a[m]] = m; else id2[n / a[m]] = m; g1[m] = calc2(a[m]), g2[m] = calc(a[m]); &#125; for (int i = 1;i &lt;= ncnt;i++) for (int j = 1;j &lt;= m &amp;&amp; (LL)prime[i] * prime[i] &lt;= a[j];j++) &#123; g1[j] = (g1[j] - (LL)prime[i] * prime[i] % mod * (g1[ID(a[j] / prime[i])] - sum1[i - 1] + mod) % mod + mod) % mod; g2[j] = (g2[j] - (LL)prime[i] * (g2[ID(a[j] / prime[i])] - sum2[i - 1] + mod) % mod + mod) % mod; &#125; &#125; int solve(LL n, int m) &#123; if (n &lt; prime[m]) return 0; int res = ((LL)g1[ID(n)] - g2[ID(n)] - sum1[m - 1] + sum2[m - 1]) % mod; res = (res + mod) % mod; for (int i = m;i &lt;= ncnt &amp;&amp; (LL)prime[i] * prime[i] &lt;= n;i++) for (LL j = prime[i];j * prime[i] &lt;= n;j *= prime[i]) res = (res + (LL)solve(n / j, i + 1) * f(j) + f(j * prime[i])) % mod; return res; &#125; inline int solve(LL x) &#123; if (x &lt;= 1) return x; return n = x, init(), solve(x, 1) + 1; &#125;&#125;int main() &#123; LL n; scanf("%lld", &amp;n), printf("%d\n", Min25::solve(n));&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>算法</tag>
        <tag>min25筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.8CTS模拟]]></title>
    <url>%2F2019%2F05%2F09%2F5-8CTS%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 SuffixArray 很妙的一道题 我们先来找一下规律$$\begin{gather}1.A\\2.AB\\3.ABBA\\4.ABBABAAB\end{gather}$$显然有一个规律就是每次是上一次串与它自己的反串拼在一起 但是如果用这个规律做就凉了 另一个不那么显然的规律是：$A$会变成$AB$，$B$会变成$BA$ 我们来观察一下对于原串每一个后缀，它的前缀可能是什么 如果抛开最后一位不看，那么只有可能是这四种前缀：$AB*,BA*,AAB*,BBA*$ 加上最后一位，多了两种可能的情况：$A,B$ 那么我们来看一看每个后缀在一次转移之后会变成什么，注意每个后缀只会分裂出两个新后缀$$A\Rightarrow AB,B\\B\Rightarrow BA,A\\AB\Rightarrow AB,BBA\\BA\Rightarrow BA,AAB\\AAB\Rightarrow AB,BA\\BBA\Rightarrow BA,AB$$那么根据这样的分裂关系，我们可以得出，在某一层中每种后缀一共有多少个 如何确定答案呢 假如我们在第$k$层，现在要找排名为$s$的后缀 尝试将其转化成在第$k-1$层找排名为$s’$的后缀 现在我们要确定这个排名为$s$的后缀在上一层中，是由哪一类后缀分裂出来的 上一层一共有$6$种后缀，每种后缀分裂出了两个，我们将这$12$个新的后缀按照字典序排序 定义$f(A,0/1)$表示状态$A$分裂出来的第$0/1$个后缀是什么 那么排序之后就是$$\begin{gather}1.A&amp;f(B,1)\\2.AAB*&amp;f(BA,1)\\3.AB&amp;f(A,0)\\4.ABAAB*&amp;f(BBA,1)\\5.ABABBA*&amp;f(AAB,0)\\6.ABBA*&amp;f(AB,0)\\7.B&amp;f(A,1)\\8.BA&amp;f(B,0)\\9.BAAB*&amp;f(BA,0)\\10.BABAAB*&amp;f(BBA,0)\\11.BABBA*&amp;f(AAB,1)\\12.BBA*&amp;f(AB,1)\end{gather}$$我们依次枚举这$12$种后缀，如果$s$大于当前这种后缀分裂前在上一层中的个数，那么就用$s$减去这个个数，说明在这一层中，排名为$s$的后缀的字典序比当前枚举的大 否则说明排名为$s$的后缀就是当前枚举的后缀，并且在上一层的分裂前的那一类后缀中，排名为$s$ 我们现在还可以算出在上一层中，这个后缀分裂之前的后缀的排名 如果我们对后缀编上$0,1,\cdots,2^k-1$这样的编号，那么编号为$i$的后缀在下一层会分裂成$2i,2i+1$这两个后缀 所以我们先求出分裂之前后缀的编号，乘以$2$之后加上当前后缀$f$的第二维，就可以得到当前后缀的编号了 代码如下 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;enum status &#123; A, AAB, AB, B, BA, BBA&#125;;typedef long long LL;LL dp[61][BBA + 1];inline void DP(int k) &#123; dp[0][A] = 1; for (int i = 1;i &lt;= k;i++) &#123; dp[i][AB] += dp[i - 1][A], dp[i][B] += dp[i - 1][A]; dp[i][AB] += dp[i - 1][AAB], dp[i][BA] += dp[i - 1][AAB]; dp[i][AB] += dp[i - 1][AB], dp[i][BBA] += dp[i - 1][AB]; dp[i][BA] += dp[i - 1][B], dp[i][A] += dp[i - 1][B]; dp[i][BA] += dp[i - 1][BA], dp[i][AAB] += dp[i - 1][BA]; dp[i][BA] += dp[i - 1][BBA], dp[i][AB] += dp[i - 1][BBA]; &#125;&#125;pair&lt;int, int&gt; gen[] = &#123; &#123;B, 1&#125;, &#123;BA, 1&#125;, &#123;A, 0&#125;, &#123;BBA, 1&#125;, &#123;AAB, 0&#125;, &#123;AB, 0&#125;, &#123;A, 1&#125;, &#123;B, 0&#125;, &#123;BA, 0&#125;, &#123;BBA, 0&#125;, &#123;AAB, 1&#125;, &#123;AB, 1&#125;&#125;;LL solve(LL step, int k) &#123; if (k == 0) return 0; for (int i = 0;i &lt; 12;i++) &#123; LL tmp = dp[k - 1][gen[i].first]; if (step &lt;= tmp) &#123; for (int j = 0;j &lt; gen[i].first;j++) step += dp[k - 1][j]; return solve(step, k - 1) * 2 + gen[i].second; &#125; else step -= tmp; &#125;&#125;int main() &#123; freopen("a.in", "r", stdin), freopen("a.out", "w", stdout); int k, q; scanf("%d%d", &amp;k, &amp;q), DP(k); LL a; while (q--) scanf("%lld", &amp;a), printf("%lld\n", solve(a, k) + 1);&#125; T2 InfiniteSequence 表示只会60分 第一个点直接暴力 第二个点和第三个点找循环节 现在说一下4，5，6这三个点 先列出特征方程$$x^2=Ax+1\\x^2-Ax-1=0\\$$那么此时我们知道$$\begin{cases}\Delta=A^2+4\\x=\frac{A\pm\sqrt\Delta}{2}\\x_1x_2=-1\end{cases}$$设$$a_n=c_1(\frac{A+\sqrt\Delta}{2})^n+c_2(\frac{A-\sqrt\Delta}{2})^2$$解得$$c_1=\frac{1}{\sqrt\Delta},c_2=-\frac{1}{\sqrt\Delta}$$注意这里有一个坑点：如果解出来$x_1=x_2$我们就不能这么做了 我们先来讨论这种情况，此时的递推式为$$a_n=(a+bn)x^n$$解得$$a=0,b=\frac{1}{x}$$所以$$a_n=nx^{n-1}$$而$x_1x_2=-1,x_1=x_2$ 因此$x=\sqrt{-1}, a_n=n\sqrt{-1}^{n-1}$ 所以我们知道$\frac{A}{2}$的阶是$4$ 枚举$n-1$模$4$的余数，再根据中国剩余定理我们可以算出满足条件的$n$模$4p$的余数，从而算出$[L,R]$内合法的$n$的数量 现在来讨论另一种情况 设$$T=\frac{A+\sqrt\Delta}{2},b=\sqrt\Delta$$那么$$a_n=\frac1bT^n-\frac1b(\frac{-1}{T})^n\equiv x\pmod p$$此时需要按照$n$的奇偶性分类讨论，然后就是解一个一元二次方程，最后用BSGS算出答案 这种做法在$A^2+4$没有二次剩余的情况下会出错，正解好像是在复数域下进行运算 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int W, mod; struct comp &#123; int x, y; comp(int x, int y = 0): x(x), y(y) &#123;&#125; comp operator * (const comp &amp;b) &#123; return comp(((LL)x * b.x % mod + (LL)y * b.y % mod * W) % mod, ((LL)x * b.y + (LL)y * b.x) % mod); &#125;&#125;;inline comp Pow(comp x, int y) &#123; comp res(1); for (;y;y &gt;&gt;= 1, x = x * x) if (y &amp; 1) res = res * x; return res;&#125;inline int Pow(int x, int y, int p = mod) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % p) if (y &amp; 1) res = (LL)res * x % p; return res;&#125;inline int Rand() &#123; return (rand() &lt;&lt; 16) | rand();&#125;inline int Cipolla(int n) &#123; n = (n % mod + mod) % mod; if (n == 0) return 0; if (Pow(n, (mod - 1) / 2) + 1 == mod) return -1; int a; while (233) &#123; a = Rand() % mod, W = (((LL)a * a - n) % mod + mod) % mod; if (Pow(W, (mod - 1) / 2) + 1 == mod) break; &#125; return (Pow(comp(a, 1), (mod + 1) / 2).x + mod) % mod;&#125;map&lt;int, int&gt; s; set&lt;int&gt; sol;inline void BSGS(int A, int B) &#123; cout &lt;&lt; A &lt;&lt; ' ' &lt;&lt; B &lt;&lt; endl; sol.clear(); if (B == 1) sol.insert(0); s.clear(); int m = ceil(sqrt(mod)), ls = 1; for (int i = 0;i &lt; m;i++, ls = (LL)ls * A % mod) s[(LL)B * ls % mod] = i; for (int i = m, t = ls;i &lt;= mod;i += m, t = (LL)t * ls % mod) if (s.count(t) &amp;&amp; (i - s[t]) &lt; (mod - 1)) sol.insert(i - s[t]);&#125;#define P pair&lt;int, int&gt;inline LL calc(LL n, LL p, LL m) &#123; return n / p + (m &amp;&amp; m &lt;= n % p);&#125;inline LL calc(LL n, LL p, LL m, int d) &#123; LL p1 = 4 * p, t = d * p % p1 * p + m * Pow(4, p - 1, p1); return calc(n, p1, t % p1);&#125;inline LL calc(LL L, LL R, LL p, LL m, int d) &#123; return calc(R, p, m, d) - calc(L - 1, p, m, d);&#125;inline int BF1(int A, int x, int p, LL L, LL R) &#123; int res = 0, a = 1, b = 0; if (x == 1 &amp;&amp; L == 1) res++; for (int i = 2;i &lt;= R;i++) &#123; int t = b; b = a, a = ((LL)A * a + t) % p; if (L &lt;= i &amp;&amp; a == x) res++; &#125; return res;&#125;#define P pair&lt;int, int&gt;map&lt;P, int&gt; ss; int flag[2000010];inline LL calc2(int pos, LL len, int l, int c) &#123; LL res = len / l * c; len %= l; return res + flag[pos + len - 1] - flag[pos - 1];&#125;inline LL BF2(int A, int x, int p, LL L, LL R) &#123; int a = 1, b = 0, i; ss.clear(); for (i = 1;!ss.count(P(a, b));i++) &#123; ss[P(a, b)] = i; flag[i] = flag[i - 1] + (a == x); int t = b; b = a, a = ((LL)A * a + t) % p; &#125; int ls = ss[P(a, b)]; LL res = 0; if (R &lt; ls) return flag[R] - flag[L - 1]; if (L &lt; ls) res = flag[ls] - flag[L - 1]; L = max(L, (LL)ls); int c = flag[i - 1] - flag[ls - 1]; return res + calc2(ls, R - ls + 1, i - ls, c) - calc2(ls, L - ls, i - ls, c);&#125;#define SIT set&lt;int&gt;::iterator inline LL solve(int A, int x, int p, LL L, LL R) &#123; if (R &lt;= 100000) return BF1(A, x, p, L, R); if (p &lt;= 1000000) return BF2(A, x, p, L, R); mod = p; int T = Cipolla((LL)A * A % mod + 4), inv2 = (p + 1) / 2; if (T == 0) &#123; int i = (LL)A * inv2 % mod; LL res = 0; for (int j = 0, b = 1;j &lt; 4;j++, b = (LL)b * i % mod) res += calc(L, R, p, (LL)x * Pow(b, mod - 2) % mod, (j + 1) % 4); return res; &#125; if (T == -1) return 0; int y = (LL)(T + A) * inv2 % mod; x = (LL)x * T % mod; LL ans = 0; &#123; int res = Cipolla((LL)x * x % mod - 4); if (res != -1) &#123; int t1 = (LL)(x + res) * inv2 % mod, t2 = (LL)(x + mod - res) * inv2 % mod; BSGS(y, t1); for (auto v : sol) if (v % 2 == 1) ans += calc(R, p - 1, v) - calc(L - 1, p - 1, v); if (t1 != t2) &#123; BSGS(y, t2); for (auto v : sol) if (v % 2 == 1) ans += calc(R, p - 1, v) - calc(L - 1, p - 1, v); &#125; &#125; &#125; &#123; int res = Cipolla((LL)x * x % mod + 4); if (res != -1) &#123; int t1 = (LL)(x + res) * inv2 % mod, t2 = (LL)(x + mod - res) * inv2 % mod; BSGS(y, t1); for (auto v : sol) if (v % 2 == 0) ans += calc(R, p - 1, v) - calc(L - 1, p - 1, v); if (t1 != t2) &#123; BSGS(y, t2); for (auto v : sol) if (v % 2 == 0) ans += calc(R, p - 1, v) - calc(L - 1, p - 1, v); &#125; &#125; &#125; return ans;&#125;int main() &#123; freopen("b.in", "r", stdin), freopen("b.out", "w", stdout); srand((long long)new char); int T; scanf("%d", &amp;T); while (T--) &#123; int A, p, x; LL L, R; scanf("%d%d%d%lld%lld", &amp;A, &amp;p, &amp;x, &amp;L, &amp;R); printf("%lld\n", solve(A, x, p, L, R)); &#125;&#125; T3 PlanarGraph 这个题中，平面图的唯一作用在于告诉你这是稀疏图：即边数是$O(n)$级别的 我们用$p_i$表示第$i$次操作之后到达$n$号点的概率，那么答案就是$\sum\limits_{i=0}^\infty p_i$ 设$$f(x)=\sum_{i=0}^\infty p_ix^i$$那么答案就是$$\sum_{i=0}^\infty p_i=f’(1)$$我们可以先暴力算出$p$的前$2n$项，然后用$BM$算法求出$p$的递推式，这是一个$n$阶的递推式，我们设它为$G$ 考虑$f(x)G(x)$会得到什么 显然$f$第$n+1$项及之后的所有项都是不变的，因为它们满足递推式 而前面的$n$项有可能出错 我们记$$C(x)=\sum_{i=1}^np_ix^i$$那么通过计算$C(x)G(x)$，我们可以得出$f$错误的前$n$项，注意需要将$C(x)G(x)$在$n$之后的所有项都设成$0$ 我们将$f(x)G(x)$减去$C(x)G(x)$，得到的就是一个前$n$项都为$0$的$f$，我们再加上$C(x)$，就变回原来的$f$了 因此$$\begin{aligned}f(x)&amp;=f(x)G(x)+C(x)(1-G(x))\\&amp;=\frac{C(x)(1-G(x))}{1-G(x)}\end{aligned}$$由于我们对$C(x)(1-G(x))$做了一些特殊处理，所以这里不能约分 利用公式$$(\frac uv)’=\frac{u’v-uv’}{v^2}$$就可以快速算出答案了 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;#define N 10010typedef long long LL;const int mod = 998244353;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;inline void Dec(int &amp;x, const int &amp;y) &#123; x -= y, x += x &lt; 0 ? mod : 0;&#125;inline void Inc(int &amp;x, const int &amp;y) &#123; x += y, x -= x &gt;= mod ? mod : 0;&#125;int val[N * 2], delta[N * 2], fail[N * 2], cnt, mn;vector&lt;int&gt; now, mncoef, ls;inline void BM(int n) &#123; mn = 1, now.clear(), ls.clear(), mncoef.clear(); for (int i = 1;i &lt;= n;i++) &#123; delta[i] = val[i]; for (int j = 0;j &lt; ls.size();j++) Dec(delta[i], (LL)val[i - j - 1] * ls[j] % mod); if (!delta[i]) continue; else fail[++cnt] = i; if (cnt == 1) &#123;ls.clear(), ls.resize(i); continue;&#125; int tmp = (LL)delta[i] * Pow(delta[fail[mn]], mod - 2) % mod; now.clear(), now.resize(i - fail[mn] - 1), now.push_back(tmp); for (int j = 0;j &lt; mncoef.size();j++) now.push_back((LL)mncoef[j] * (mod - tmp) % mod); if (now.size() &lt; ls.size()) now.resize(ls.size()); for (int j = 0;j &lt; ls.size();j++) Inc(now[j], ls[j]); if (ls.size() - i &lt; mncoef.size() - fail[mn]) mn = cnt, mncoef = ls; ls = now; &#125;&#125;vector&lt;int&gt; G[N];int dp[2][N], invs[N], p[N];inline void DP(int n) &#123; for (int j = 1;j &lt;= n;j++) dp[0][j] = dp[1][j] = 0; for (int i = 1;i &lt;= n;i++) invs[i] = Pow(G[i].size(), mod - 2); dp[0][1] = 1; int inv2 = (mod + 1) / 2; for (int i = 1, cur = 0;i &lt;= 2 * n;i++) &#123; cur ^= 1; for (int j = 1;j &lt;= n;j++) dp[cur][j] = 0, p[j] = 0; for (int j = 1;j &lt; n;j++) for (auto v : G[j]) Inc(p[v], (LL)dp[cur ^ 1][j] * invs[j] % mod); for (int j = 1;j &lt;= n;j++) &#123; p[j] = (LL)p[j] * inv2 % mod, Inc(dp[cur][j], p[j]); for (auto v : G[j]) Inc(dp[cur][v], (LL)p[j] * invs[j] % mod); &#125; val[i] = dp[cur][n]; &#125;&#125;int g[N * 2], c[N * 2], dg[N * 2], dc[N * 2];inline void Delta(int a[], int da[], int len) &#123; for (int i = 1;i &lt;= len;i++) da[i - 1] = (LL)a[i] * i % mod;&#125;int main() &#123; freopen("c.in", "r", stdin), freopen("c.out", "w", stdout); int T; scanf("%d", &amp;T); while (T--) &#123; int n, m; scanf("%d%d", &amp;n, &amp;m), cnt = 0; for (int i = 1;i &lt;= n;i++) scanf("%*d%*d"), G[i].clear(); for (int i = 1, a, b;i &lt;= m;i++) scanf("%d%d", &amp;a, &amp;b), G[a].push_back(b), G[b].push_back(a); DP(n), BM(n * 2), c[0] = 0, g[0] = 1; int length = now.size(); for (int i = 1;i &lt;= length;i++) c[i] = 0, g[i] = (mod - now[i - 1]) % mod; for (int i = 1;i &lt;= length;i++) for (int j = 0;j &lt;= i;j++) Inc(c[i], (LL)val[i - j] * g[j] % mod); Delta(g, dg, length), Delta(c, dc, length); int a = 0, b = 0, c1 = 0, d = 0; for (int i = 0;i &lt; length;i++) Inc(a, dc[i]), Inc(d, dg[i]); for (int i = 0;i &lt;= length;i++) Inc(b, g[i]), Inc(c1, c[i]); printf("%d\n", ((LL)a * b % mod - (LL)c1 * d % mod + mod) * Pow((LL)b * b % mod, mod - 2) % mod); &#125;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>多项式</tag>
        <tag>分治</tag>
        <tag>字符串</tag>
        <tag>BSGS</tag>
        <tag>二次剩余</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.6CTS模拟]]></title>
    <url>%2F2019%2F05%2F07%2F5-6CTS%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[题面比昨天简单多了 昨天的模拟太毒瘤，满分$300$，机房最高$30$ T1 麻雀给出一个数列，要求支持两种操作，第一种是让某个位置加上一个数，第二种是向集合$S$内添加一个区间。每次操作结束之后询问所有在$S$中的区间中和的最大值，保证任意时刻所有位置都不小于$0$ 一种比较显然的做法是将一段区间$[l,r]$看作是二维平面上的一个点，假如我们现在要修改$x$这个位置的值，那么在平面上收到影响的点的范围就是 注意横坐标是$l$，纵坐标是$r$ 我们考虑哪些点比较优秀 显而易见地，如果$p$在$q$的左上角，那么$q$这个点就已经没用了，因为修改$p$的时候一定会修改$q$ 由于任意时刻每个点的值都不小于$0$，所以$p$一定不会劣于$q$ 换言之，不存在两个点使得这两个点在对方的二四象限 我们维护这个有有用的点构成的序列，这些点在分布在各自的一三象限，我们将这些点从左下角到右上角排列 那么一次修改对应着这个序列的一段区间，也就是区间加 假如一个区间的时候，我们先找到它在平面上对应的点，如果它的左上角已经有点了，那么这个区间就没用了 否则我们删除位于它右下角的点，这些点又对应了一段区间 所以我们需要支持的操作是：区间加、区间删除、插入点、区间最大值 用splay来维护就好了 其实还有一种更为简洁的做法 如果两个区间的左端点相同，那么右端点更靠左的区间显然是没用的 我们在线段树上维护$n$个数，第$i$个数表示左端点为$i$，右端点最靠右的那个区间，和是多少 显然有一个性质就是，如果存在两个区间相互包含，那么被包含的那个区间一定不优秀 那么每次修改的时候，我们找到$x$左边最靠左的位置，满足这个位置的右端点在$x$右边，然后再线段树上修改这个点到$x$的值 考虑中间的那些点，如果有一个点被修改的区间包含，但是这个点的右端点小于$x$，那么这个区间一定没有左端点位于它左边的区间优秀，我们给它加上数之和，它仍然是不优秀的区间，可以不管它 所以每次修改就直接区间改就好了 插入区间$[l,r]$的时候我们就判一下$l$这个位置最靠右的右端点是否小于$r$，如果是的话我们才有必要加上这个区间，并更新$l$右端点的最大值 所以我们需要维护一个线段树，支持区间修改，单点赋值，以及查询某个点左边第一个右端点大于这个点的位置 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;#define N 500010struct node &#123;int l, r, mx, tag, mxR;&#125; T[N &lt;&lt; 2];inline void pushup(int rt) &#123; T[rt].mx = max(T[rt &lt;&lt; 1].mx, T[rt &lt;&lt; 1 | 1].mx); T[rt].mxR = max(T[rt &lt;&lt; 1].mxR, T[rt &lt;&lt; 1 | 1].mxR);&#125;inline void pushdown(int rt) &#123; T[rt &lt;&lt; 1].mx += T[rt].tag, T[rt &lt;&lt; 1 | 1].mx += T[rt].tag; T[rt &lt;&lt; 1].tag += T[rt].tag, T[rt &lt;&lt; 1 | 1].tag += T[rt].tag, T[rt].tag = 0;&#125;void build(int rt, int l, int r) &#123; T[rt].l = l, T[rt].r = r; int mid = (l + r) &gt;&gt; 1; if (l == r) return; build(rt &lt;&lt; 1, l, mid), build(rt &lt;&lt; 1 | 1, mid + 1, r);&#125;void update(int rt, int start, int end, int x, int type = 0) &#123; int l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; 1; if (start &lt;= l &amp;&amp; r &lt;= end) &#123; if (type) T[rt].mx = x; else T[rt].mx += x, T[rt].tag += x; return; &#125; if (T[rt].tag) pushdown(rt); if (start &lt;= mid) update(rt &lt;&lt; 1, start, end, x, type); if (end &gt; mid) update(rt &lt;&lt; 1 | 1, start, end, x, type); pushup(rt);&#125;void update(int rt, int L, int R) &#123; int l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; 1; if (l == r) &#123; T[rt].mxR = max(T[rt].mxR, R); return; &#125; if (T[rt].tag) pushdown(rt); if (L &lt;= mid) update(rt &lt;&lt; 1, L, R); else update(rt &lt;&lt; 1 | 1, L, R); pushup(rt);&#125;int query(int rt, int x) &#123; if (T[rt].mxR &lt; x) return -1; if (T[rt].l == T[rt].r) return T[rt].l; if (T[rt &lt;&lt; 1].mxR &gt;= x) return query(rt &lt;&lt; 1, x); return query(rt &lt;&lt; 1 | 1, x);&#125;int tree[N], n, R[N];inline void add(int x, int y) &#123; for (;x &lt;= n;x += x &amp; -x) tree[x] += y;&#125;inline int que(int x) &#123; int res = 0; for (;x;x -= x &amp; -x) res += tree[x]; return res;&#125;int main() &#123; freopen("sparrow.in", "r", stdin), freopen("sparrow.out", "w", stdout); int q; scanf("%d%d", &amp;n, &amp;q), build(1, 1, n); while (q--) &#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); if (a == 1) &#123; add(b, c); int pos = query(1, b); if (~pos &amp;&amp; pos &lt;= b) update(1, pos, b, c); &#125; else if (R[b] &lt; c) &#123; update(1, b, b, que(c) - que(b - 1), 1); update(1, b, c), R[b] = c; &#125; printf("%d\n", T[1].mx); &#125;&#125; T2 字符串匹配有两个字符串$S,T$，每个位置都是一个字符集，定义两个位置匹配为这两个位置的字符集有交，求$T$在$S$中的所有匹配位置，字符集不会超过$e$ 比较简单的一道题 直接KMP是不行的，我们考虑这种情况：$ab,bc$有交，$bc,cd$有交，但是$ab,cd$无交，即交是没有传递性的 那么就只能用FFT来匹配了 直接匹配的话差异函数不好弄，我们可以枚举每一种交，最多只有$2^5$种情况 即我们枚举每一种字符集，如果$T$某个位置等于这个字符集，我们记$T_i=1$，如果$S$的某个位置于这个字符集有交，我们记$S_i=1$ 如果某个位置$T_i=0$，那么对于$S$中它匹配的位置的值我们不关心，如果$T_i=1$，那么匹配的位置的$S_j$必须为$1$ 由于我们枚举了所有可能出现的集合，显然$T$中的每个位置我们都会计算到 那么此时差异函数就呼之欲出了，如果$T$要和$S$从$j$开始的字符串匹配，我们定义$f$为差异函数，$T,S$的长度分别为$n,m$，有$$\begin{aligned}f(j)&amp;=\sum_{i=j}^{j+m-1}T_{i-j+1}(T_{i-j+1}-S_{j})\\&amp;=\sum_{i=1}^mT_i^2-T_iS_{i+j-1}\end{aligned}$$把$S$倒过来，然后就可以开始FFT了 其实这道题可以bitset暴力，而且跑得比FFT快得多 FFT求字符串匹配这种东西，只有$n\geq 10^6$时才卡的掉bitset ——zyw 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int mod = 998244353;inline LL Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;#define N 200010#define RG registerint r[N * 3], Wn[2][20][N * 3];inline void NTT(int a[], int len, int type) &#123; for (int i = 1;i &lt; len;i++) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int mid = 2, c = 0;mid &lt;= len;mid &lt;&lt;= 1, c++) &#123; for (RG int i = 0;i &lt; len;i += mid) for (RG int j = i, t;j &lt; i + (mid &gt;&gt; 1);j++) t = (LL)Wn[type ^ 1][c][j - i] * a[j + (mid &gt;&gt; 1)] % mod, a[j + (mid &gt;&gt; 1)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod; &#125; if (!type) for (int i = 0, inv = Pow(len, mod - 2);i &lt; len;i++) a[i] = (LL)a[i] * inv % mod;&#125;int S[N], T[N]; bool fail[N]; int n, m, A[N * 3], B[N * 3], len;inline void pre() &#123; len = 1; int l = 0; while (len &lt;= n + m) len &lt;&lt;= 1, l++; for (int i = 1;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); for (int mid = 2, c = 0;mid &lt;= len;mid &lt;&lt;= 1, c++) &#123; Wn[0][c][0] = 1, Wn[0][c][1] = Pow(3, (mod - 1) / mid); int tmp = Wn[0][c][1]; for (int i = 2;i &lt; mid &gt;&gt; 1;i++) Wn[0][c][i] = (LL)Wn[0][c][i - 1] * tmp % mod; &#125; for (int mid = 2, c = 0;mid &lt;= len;mid &lt;&lt;= 1, c++) &#123; Wn[1][c][0] = 1, Wn[1][c][1] = Pow(3, mod - 1 - (mod - 1) / mid); int tmp = Wn[1][c][1]; for (int i = 2;i &lt; mid &gt;&gt; 1;i++) Wn[1][c][i] = (LL)Wn[1][c][i - 1] * tmp % mod; &#125;&#125;inline void solve(int cur) &#123; int tot = 0; B[0] = 0; for (int i = 1;i &lt;= n;i++) A[n - i] = (cur &amp; S[i]) != 0; for (int i = 1;i &lt;= m;i++) B[i] = cur == T[i], tot += B[i] * B[i]; for (int i = n;i &lt; len;i++) A[i] = 0; for (int i = m + 1;i &lt; len;i++) B[i] = 0; NTT(A, len, 1), NTT(B, len, 1); for (int i = 0;i &lt; len;i++) A[i] = (LL)A[i] * B[i] % mod; NTT(A, len, 0); for (int i = 1;i &lt;= n - m + 1;i++) if (tot - A[n - i + 1] != 0) fail[i] = 1;&#125;char input[7];int main() &#123; freopen("ricerca.in", "r", stdin), freopen("ricerca.out", "w", stdout); scanf("%d", &amp;n); int full = 0; for (int i = 1;i &lt;= n;i++) &#123; scanf("%s", input + 1); int l = strlen(input + 1); for (int j = 1;j &lt;= l;j++) S[i] |= 1 &lt;&lt; (input[j] - 'a'); &#125; scanf("%d", &amp;m), pre(); for (int i = 1;i &lt;= m;i++) &#123; scanf("%s", input + 1); int l = strlen(input + 1); for (int j = 1;j &lt;= l;j++) T[i] |= 1 &lt;&lt; (input[j] - 'a'), full = max(full, input[j] - 'a' + 1); &#125; for (int s = 1;s &lt; 1 &lt;&lt; full;s++) solve(s); int cnt = 0; for (int i = 1;i &lt;= n - m + 1;i++) if (!fail[i]) cnt++; printf("%d\n", cnt); for (int i = 1;i &lt;= n - m + 1;i++) if (!fail[i]) printf("%d ", i - 1);&#125; T3 图论原题是不是原题呢我也不知道 给出一张图，每个点有两个权值$a_i,b_i$，要求选出一个大小为$k$的连通块，使得这个连通块中$a$的最大值加上$b$的最大值尽量小 考虑从小到大枚举$a$，我们可以求出满足要求的$b_{max}$的最小值 一种暴力就是枚举$a$，然后将所有$a_i\leq a$的边按照$b$从小到大排序，做最小生成树，但是这个最小生成树是每次假如一个点以及它连出的所有边 我们考虑一个原问题的等价问题 将点权下放到边权，每条边的$a$为它连接的两个点的$a$的最大值，$b$即为两个点$b$的最大值 最后仍然是$a$的最大值加上$b$的最大值 我们发现随着$a$的增大，$b_{max}$在单调递减 那么我们用LCT维护一棵$b$的最小生成树，同时维护满足要求的连通块个数 考虑加上一条边$u,v$ 如果$u,v$不连通，那么直接连接$u,v$即可 否则我们断开$u,v$路径上$b$最大的那条边，再连接$u,v$ 注意如果$u,v$就是那条权值最大的边，就不要连接了 加入一条边后，我们知道连通块变得更大了，那么此时我们可以尝试缩小$b_{max}$ 具体来说，在存在大小大于等于$k$的连通块的情况下，我们依次尝试删去$b$最大的那条边 如果这条边在之前从未被加入过，我们要保证之后也不会加入这条边，因为这样一定不优秀 这里判一下每次选出的边的$b$是否大于等于当前的$b_{max}$即可 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;using namespace std;#define N 300010int fa[N], ch[2][N], mx[N], w[N], sz[N], rev[N], T_sz[N];inline void Rev(int u) &#123; swap(ch[0][u], ch[1][u]), rev[u] ^= 1;&#125;inline void connect(int u, int f, int son) &#123; fa[u] = f, ch[son][f] = u;&#125;inline int isroot(int u) &#123; return (u != ch[0][fa[u]] &amp;&amp; u != ch[1][fa[u]]) || !u;&#125;inline int child(int u) &#123; return u == ch[1][fa[u]];&#125;inline int Max(int a, int b) &#123; return w[a] &gt; w[b] ? a : b;&#125;inline void pushup(int u) &#123; sz[u] = sz[ch[0][u]] + sz[ch[1][u]] + 1 + T_sz[u]; mx[u] = Max(mx[ch[0][u]], Max(ch[1][u], u));&#125;inline void pushdown(int u) &#123; if (rev[u]) Rev(ch[0][u]), Rev(ch[1][u]), rev[u] = 0;&#125;inline void rotate(int u) &#123; int f = fa[u], ff = fa[f], tmp = child(u), tmp1 = child(f); if (!isroot(f)) connect(u, ff, tmp1); fa[u] = ff, connect(ch[tmp ^ 1][u], f, tmp), connect(f, u, tmp ^ 1), pushup(f), pushup(u);&#125;int st[N], tot, k;inline void splay(int u) &#123; int now = u, top = 0; st[++top] = now; while (!isroot(now)) st[++top] = now = fa[now]; while (top) pushdown(st[top--]); for (int f;!isroot(u);rotate(u)) if (!isroot(f = fa[u])) rotate(child(u) ^ child(f) ? u : f);&#125;inline void access(int u) &#123; for (int ls = 0;u;u = fa[ls = u]) splay(u), T_sz[u] += sz[ch[1][u]], T_sz[u] -= sz[ls], ch[1][u] = ls, pushup(u);&#125;inline void makeroot(int u) &#123; access(u), splay(u), Rev(u);&#125;inline bool cut(int u, int v) &#123; makeroot(u), access(v), splay(v); if (ch[0][v] != u) return true; if (sz[v] &gt;= k &amp;&amp; sz[u] &lt; k &amp;&amp; sz[v] - sz[u] &lt; k) &#123; if (tot &lt;= 1) return false; tot--; &#125; else if (sz[v] - sz[u] &gt;= k &amp;&amp; sz[v] &gt;= k) tot++; ch[0][u] = fa[ch[0][u]] = 0, pushup(v); return true;&#125;inline void link(int u, int v) &#123; makeroot(u), access(v), splay(v); if (fa[u]) &#123; int tmp = mx[v]; if (tmp == v) return; splay(tmp), ch[1][tmp] = fa[ch[1][tmp]] = 0, pushup(tmp); splay(u), splay(v), fa[u] = v, T_sz[v] += sz[u], pushup(v); return; &#125; if (sz[v] &lt; k &amp;&amp; sz[u] &lt; k &amp;&amp; sz[v] + sz[u] &gt;= k) tot++; else if (sz[v] &gt;= k &amp;&amp; sz[u] &gt;= k) tot--; fa[u] = v, T_sz[v] += sz[u], pushup(v);&#125;#define M 500010int ida[M], idb[M], wa[N], wb[N], from[M], to[M], A[M], B[M];int main() &#123; freopen("mincost.in", "r", stdin), freopen("mincost.out", "w", stdout); int n, m; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); cerr &lt;&lt; n &lt;&lt; endl; for (int i = 1;i &lt;= n;i++) scanf("%d%d", &amp;wa[i], &amp;wb[i]), sz[i] = 1, w[i] = wb[i], mx[i] = i; for (int i = 1;i &lt;= m;i++) &#123; scanf("%d%d", &amp;from[i], &amp;to[i]), ida[i] = idb[i] = i; A[i] = max(wa[from[i]], wa[to[i]]), B[i] = max(wb[from[i]], wb[to[i]]); &#125; sort(ida + 1, ida + m + 1, [](int a, int b) &#123; return A[a] &lt; A[b]; &#125;); sort(idb + 1, idb + m + 1, [](int a, int b) &#123; return B[a] &gt; B[b]; &#125;); int res = 2e9 + 10; for (int i = 1, cur = 1;i &lt;= m;i++) &#123; int now = ida[i]; if (tot &amp;&amp; B[now] &gt; B[idb[cur]]) continue; link(from[now], to[now]); while (cur &lt;= n &amp;&amp; cut(from[cur], to[cur])) cur++; if (tot) res = min(res, A[now] + B[idb[cur]]), cout &lt;&lt; i &lt;&lt; endl; &#125; if (res &gt; 2e9) printf("no solution"); else printf("%d\n", res); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>LCT</tag>
        <tag>数据结构</tag>
        <tag>多项式</tag>
        <tag>线段树</tag>
        <tag>平衡树</tag>
        <tag>FFT</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.4省选模拟]]></title>
    <url>%2F2019%2F05%2F05%2F5-4%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[题面 T1有一棵树，每条边都有$50\%$的概率被删除，问在所有情况中，这棵树的邻接矩阵的秩的和 邻接矩阵的秩的含义是在初等行变换后的非自由元数量 首先有一个性质：树的邻接矩阵的秩等于其最大匹配数乘以$2$ 那么这道题就相当于让我们统计所有情况下的最大匹配数的和乘以$2$ 先考虑一棵给定的树可以用什么方法求最大匹配数 dp是可以的，但是这里我们不能使用dp的方式来推，因为这样不好维护 那么我们考虑使用贪心的策略：即优先让儿子匹配，如果匹配完了之后这个点还能和儿子匹配就让这个点和那个儿子配对 也就是要让匹配尽量靠下，儿子能匹配就不要往父亲匹配 我们可以设dp[u][0/1]表示考虑$u$以及它的子树，$u$这个点是否匹配的方案数 转移比较显然 所以这道题的关键还是看出是最大匹配数乘$2$ 代码如下 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 500010;struct edge &#123; int to, next;&#125; e[N * 2];int head[N], ecnt;inline void adde(int from, int to) &#123; e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;&#125;int dp[2][N], sz[N], pw[N], ans, n; const int mod = 998244353;typedef long long LL;void dfs(int u, int f) &#123; sz[u] = dp[0][u] = 1; for (int i = head[u];i;i = e[i].next) if (e[i].to != f) &#123; dfs(e[i].to, u), sz[u] += sz[e[i].to]; dp[1][u] = ((LL)dp[1][u] * pw[sz[e[i].to]] + (LL)dp[0][u] * dp[0][e[i].to]) % mod; dp[0][u] = (LL)dp[0][u] * (pw[sz[e[i].to] - 1] + dp[1][e[i].to]) % mod; &#125; ans = (ans + (LL)dp[1][u] * (pw[n - sz[u]] &lt;&lt; 1)) % mod;&#125;int main() &#123; freopen("rank.in", "r", stdin), freopen("rank.out", "w", stdout); scanf("%d", &amp;n), pw[0] = 1; for (int i = 1;i &lt;= n;i++) pw[i] = pw[i - 1] * 2 % mod; for (int i = 1, a, b;i &lt; n;i++) scanf("%d%d", &amp;a, &amp;b), adde(a, b); dfs(1, 0), printf("%d\n", ans);&#125; T2有一个$n$个节点的完全二叉树，$i$的父亲是$\lfloor\frac i2\rfloor$，现在这棵树上又多了$m(m\leq 6)$条边，求简单路径总数 我们首先考虑这样一个性质：如果$u,v$在树上的路径只有一条，并且中间没有边的端点，那么从这两个点出发，答案相同 因为对于任意一条路径，我们对这条路径在$u,v$段上的覆盖情况取反，就能得到从另一个点出发的一条合法路径，所以方案数是相等的 那么我们可以将所有关键点以及它们的祖先提出来，建一棵虚树，虚树上的每个点存一个sz，表示它在原树上的儿子中，不在虚树上的节点的个数 然后就可以从每个虚树上的点开始暴力dfs，然后分类统计答案，即每个虚树上的点的答案都是这个点以及它的不在虚树上的儿子的答案 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long longconst int mod = 1e9 + 7;map&lt;int, int&gt; ID;inline int idx(int u) &#123; if (ID[u]) return ID[u]; return ID[u] = ID.size();&#125;#define N 360struct edge &#123; int to, next;&#125; e[N * 2];int head[N], ecnt;inline void adde(int from, int to) &#123; e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;&#125;int vis[N], sz[N], n;LL dfs(int u) &#123; LL res = sz[u]; vis[u] = 1; for (int i = head[u];i;i = e[i].next) if (!vis[e[i].to]) res += dfs(e[i].to); return vis[u] = 0, res;&#125;inline int dep(int u) &#123; for (int tmp = 1;;tmp++) if (u &lt; 1 &lt;&lt; tmp) return tmp;&#125;inline int get(int u, int tot) &#123; int now = dep(u), res = (1 &lt;&lt; (tot - now + 1)) - 1; for (int i = now + 1;i &lt;= tot;i++) u = u &lt;&lt; 1 | 1; return res - max(min(u - n, 1 &lt;&lt; tot - now), 0);&#125;void dfs1(int u, int f) &#123; for (int i = head[u];i;i = e[i].next) if (e[i].to != f) sz[u] -= sz[e[i].to], dfs1(e[i].to, u);&#125;void link(int u) &#123; if (!ID.count(u)) return; if (u != 1) adde(idx(u), idx(u &gt;&gt; 1)); link(u &lt;&lt; 1), link(u &lt;&lt; 1 | 1);&#125;int from[N], to[N];int main() &#123; freopen("route.in", "r", stdin), freopen("route.out", "w", stdout); int m, mxdep; scanf("%d%d", &amp;n, &amp;m), mxdep = dep(n), idx(1); for (int i = 1;i &lt;= m;i++) &#123; scanf("%d%d", &amp;from[i], &amp;to[i]); for (int j = from[i];j;j &gt;&gt;= 1) idx(j); for (int j = to[i];j;j &gt;&gt;= 1) idx(j); &#125; for (auto v : ID) sz[v.second] = get(v.first, mxdep); link(idx(1)), dfs1(idx(1), 0); for (int i = 1;i &lt;= m;i++) adde(idx(from[i]), idx(to[i])); int res = 0; for (auto v : ID) res = (res + dfs(v.second) * sz[v.second]) % mod; printf("%d\n", res);&#125; T3有一棵树，每个点都有权值，定义一个点$u$的价值为$\sum\limits_{i=1}^nw_idis(i,u)^{\frac{3}{2}}$，找到一个点使得价值最小 我们先考虑一个序列上的情况 假设有一排点$a_1,a_2,\cdots,a_n$ 我们先钦定一个端点$p$ 如果你有一个指针，从$a_1$扫到$a_n$ 那么得到的$w_pf(p,a_i)$是一个凸函数 我们现在固定另一个端点，让$p$动起来 我们会得到很多凸函数的叠加，而这些凸函数的叠加仍然是凸函数 所以这个序列上的$g$也是凸的 在一个序列上，我们可以使用二分 放在树上，就可以使用点分治 具体来说，对于点分树上$u$的每个儿子，找到$g$比$g(u)$小的那个$v$，移动到$v$去，直到不能移动为止 代码就咕了 T4有一个离散随机变量$x$，最开始它有$p_i$的概率为$i$ 现在要对$x$进行$m$次操作，每次会将$x$等概率变成$[1,x]$中的一个整数 问最后$x$变成每个数的概率 很妙的一道题 我们考虑一开始$x$的概率生成函数$f(x)$ 此时$x^i$的系数就是$p_i$ 考虑一次操作之后它变成了什么，我们假设一次操作之后的概率生成函数是$f^*(x)$ 那么显然有$$\begin{aligned}\[x^i]f^*(x)&amp;=\sum_{j=i}^n\frac{[x^j]f(x)}{j+1}\\\f^*(x)&amp;=\sum_{i=0}^nx^i\sum_{j=i}^n\frac{[x^j]f(x)}{j+1}\\\&amp;=\sum_{j=0}^n\frac{[x^j]f(x)}{j+1}\sum_{i=0}^jx^i\\\&amp;=\sum_{j=0}^n\frac{[x^j]f(x)}{j+1}\frac{x^{j+1}-1}{x-1}\\\&amp;=\frac{1}{x-1}\sum_{j=0}^n[x^j]f(x)\frac{x^{j+1}-1}{j+1}\end{aligned}$$注意到$$\frac{x^{j+1}-1}{j+1}=[\frac{t^{j+1}}{j+1}]_1^x=\int_1^xt^j\mathrm{d}t$$所以$$\begin{aligned}f^*(x)&amp;=\frac{1}{x-1}\sum_{j=0}^n[x^j]f(x)\int_1^xt^j\mathrm{d}t\\\&amp;=\frac{1}{x-1}\int_1^x\sum_{j=0}^n[x^j]f(x)t^j\mathrm{d}t\\\&amp;=\frac{1}{x-1}\int_1^xf(t)\mathrm{d}t\end{aligned}$$现在很不爽的一点是积分是从$1$开始积的，而且前面分数的分母是$x-1$而不是$x$，我们要把这个弄掉 考虑设$g(x)=f(x+1),g^*(x)=f^*(x+1)$ 那么有$$g^*(x)=f^*(x+1)=\frac{1}{x}\int_1^{x+1}f(t)\mathrm{d}t=\frac{1}{x}\int_0^xg(t)\mathrm{d}t$$分析一些最后那个 设$$g(x)=\sum_{i=0}^na_ix^i$$那么$$\begin{aligned}\frac{1}{x}\int_0^xg(t)\mathrm{d}t&amp;=\frac{1}{x}\int_0^x\sum_{i=0}^na_it^i\mathrm{d}t\\\&amp;=\frac{1}{x}\sum_{i=0}^n\int_0^xa_it^i\mathrm{d}t\\\&amp;=\frac{1}{x}\sum_{i=0}^n[\frac{a_i}{i+1}t^{i+1}]_0^x\\\&amp;=\frac{1}{x}\sum_{i=0}^n\frac{a_i}{i+1}x^{i+1}\\\&amp;=\sum_{i=0}^n\frac{a_i}{i+1}x^i\end{aligned}$$所以我们知道$$[x^i]g^*(x)=\frac{[x^i]g(x)}{i+1}$$这是经过一次变换之后的结果，如果我们进行$m$次变换，那么可以得到$$[x^i]g^*(x)=\frac{[x^i]g(x)}{(i+1)^m}$$现在关键就在于将最开始的$f$变换成$g$，最后再将$g^*$变换成$f^*$ 我们来讨论一下从$f$变成$g$$$\begin{aligned}g(x) &amp;=f(x+1) \\\sum_{i=0}^n[x^i]g(x)x^i&amp;=\sum_{i=0}^n[x^i]f(x)(x+1)^i\\\sum_{i=0}^n[x^i]g(x)x^i&amp;=\sum_{i=0}^n[x^i]f(x)\sum_{k=0}^i\begin{pmatrix}i\ k\end{pmatrix}x^k\\[x^i]g(x)&amp;=\sum_{k=0}^i\begin{pmatrix}i\ k\end{pmatrix}[x^k]f(x)\\i![x^i]g(x)&amp;=\sum_{k=0}^n\frac{k![x^k]f(x)}{(k-i)!}\end{aligned}$$从$g$变成$f$差不多 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int N = 250010, mod = 998244353;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;int r[N * 4];inline void NTT(int a[], int len, int type) &#123; for (int i = 1;i &lt; len;i++) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int mid = 2;mid &lt;= len;mid &lt;&lt;= 1) &#123; int Wn = Pow(3, type ? (mod - 1) / mid : mod - 1 - (mod - 1) / mid); for (int i = 0;i &lt; len;i += mid) for (int j = i, t, w = 1;j &lt; i + (mid &gt;&gt; 1);j++, w = (LL)w * Wn % mod) t = (LL)w * a[j + (mid &gt;&gt; 1)] % mod, a[j + (mid &gt;&gt; 1)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod; &#125; if (!type) for (int i = 0, inv = Pow(len, mod - 2);i &lt; len;i++) a[i] = (LL)a[i] * inv % mod;&#125;int frac[N], inv[N], A[N * 4], B[N * 4];int main() &#123; freopen("random.in", "r", stdin), freopen("random.out", "w", stdout); int n; LL m; scanf("%d%lld", &amp;n, &amp;m), frac[0] = 1, m %= mod - 1; for (int i = 1;i &lt;= n;i++) frac[i] = (LL)frac[i - 1] * i % mod; inv[n] = Pow(frac[n], mod - 2); for (int i = n - 1;i &gt;= 0;i--) inv[i] = (LL)inv[i + 1] * (i + 1) % mod; for (int i = 0;i &lt;= n;i++) scanf("%d", &amp;A[i]), A[i] = (LL)A[i] * frac[i] % mod; for (int i = 0;i &lt;= n;i++) B[n - i] = inv[i]; int len = 1, l = 0; while (len &lt;= n * 2) len &lt;&lt;= 1, l++; for (int i = 1;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); NTT(A, len, 1), NTT(B, len, 1); for (int i = 0;i &lt; len;i++) A[i] = (LL)A[i] * B[i] % mod; NTT(A, len, 0); for (int i = 0;i &lt;= n;i++) A[i] = A[i + n]; for (int i = n + 1;i &lt; len;i++) A[i] = 0; for (int i = 0;i &lt;= n;i++) A[i] = (LL)A[i] % mod * Pow(Pow(i + 1, m), mod - 2) % mod; for (int i = n + 1;i &lt; len;i++) B[i] = 0; for (int i = 0;i &lt;= n;i++) B[n - i] = i &amp; 1 ? mod - inv[i] : inv[i]; NTT(A, len, 1), NTT(B, len, 1); for (int i = 0;i &lt; len;i++) A[i] = (LL)A[i] * B[i] % mod; NTT(A, len, 0); for (int i = 0;i &lt;= n;i++) printf("%d ", (LL)A[i + n] * inv[i] % mod);&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>多项式</tag>
        <tag>点分治</tag>
        <tag>NTT</tag>
        <tag>虚树</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性规划]]></title>
    <url>%2F2019%2F04%2F28%2F%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[什么是线性规划 实际生活中有很多问题都是这样的形式：它们需要最大化或者最小化一个目标；它们通常面临资源、时间等多方面的限制。假如把这些问题的目标简化成一个线性的函数，把限制表示成一些线性的等式或者不等式，那么这些问题就可以被描述成线性规划问题。 ——2016国家集训队论文集 在线性规划中，我们有$n$个变量$x_1,x_2,\cdots, x_n$ 我们希望一个估价函数$f(x_1, x_2,x_3,\cdots,x_n)$尽量大/小 同时我们希望这些变量能满足一些线性等式或者不等式$g(x_1,x_2,x_3,\cdots,x_n)$ 那么这个过程就叫线性规划 一些定义 线性函数 我们定义函数$f(x_1,x_2,x_3,\cdots,x_n)$为线性函数当且仅当有$$f(x_1,x_2,\cdots,x_n)=\sum_{i=1}^na_ix_i$$其中$a_i$为实数常量，$x_i$为变量 线性等式 定义线性等式为$f(x_1,x_2,\cdots,x_n)=b$，其中$f$是线性函数，$b$是实数常量 线性不等式 定义线性不等式为$f(x_1,x_2,\cdots,x_n)\leq b$或者$f(x_1,x_2,\cdots,x_n)\geq b$，其中$f$是线性函数，$b$是实数常量 标准型线性规划标准型线性规划要求满足如下形式 最大化$$\sum_{i=1}^nc_ix_i$$满足约束$$\begin{aligned}\sum_{j=1}^na_{ij}x_j&amp;\leq b_i\quad\quad i=1,2,\cdots,m\\\x_i&amp;\geq 0 \quad\quad i=1,2,\cdots, n\end{aligned}$$ 那么问题来了，如果某个限制不是$\sum a_ix_i\leq b$，而是$\sum a_ix_i\geq b$，怎么办？ 等式两边同时乘以一个负号，就可以变成小于等于 那如果是要求估价函数最小呢？ 将所有的$c_i$取反，最后再将答案取反 如果有一个限制是$\sum a_ix_i=b$怎么办？ 将其拆成两个限制，$\sum a_ix_i\geq b$以及$\sum a_ix_i\leq b$ 如果有一个变量$x$没有要求其$\geq 0$呢 将其拆成两个变量$a,b$，令$x=a-b$，再令$a\geq 0,b\geq 0$即可 标准型还可以用矩阵表示 如果我们用$c$表示$c_i$构成的行向量，$A$为$a$构成的矩阵，那么它等价于 最大化$$c^Tx$$满足约束$$Ax\leq b\\\x\geq 0$$其中$c^T$表示矩阵转置 注意这里的$\leq,\geq$代表每一维都小于等于/大于等于 松弛型线性规划如果直接求解标准型线性规划，涉及到乘法不等式变号的问题，而且满足的是不等式也不太好做 我们把它转化一下 我们新引入$m$个变量（$m$是约束个数，$n$是未知数个数） 对于限制$$\sum_{i=1}^na_ix_i\leq b,x_i\geq 0$$我们利用一个新的变量$x_{i+n}$，可以将它变成$$b-\sum_{i=1}^na_ix_i=x_{i+n}\\ x_{i+n}\geq 0,x_i\geq 0$$这样就可以将不等式转化为等式了 所以我们这样表示松弛型线性规划： 最大化$$\sum_{i=1}^nc_ix_i$$满足约束$$\begin{aligned}x_{i+n}&amp;=b_i-\sum_{j=1}^na_{ij}x_j\quad\quad i=1,2,\cdots,m\\\x_j&amp;\geq 0,x_{i+n}\geq 0\quad\quad i=1,2,\cdots,m\end{aligned}$$我们将$x_i(i\leq n)$叫做非基变量，$x_{i+n}$叫做基变量 可以看出，标准型线性规划可以很方便地转移成松弛型线性规划 单纯形显然最终解所构成的区域一定是一个凸集，局部最优解只有一个 所以我们可以使用类似爬山算法的方法，每次往估价函数更优的那个方向爬，直到爬不动为止 我们首先来尝试构造一组基本解，即先满足所有约束，不管估价函数 如果所有的$b$都大于等于$0$，那么显然有一组解为所有的非基变量都为$0$，否则接下来会讲 我们将这个解进行“转轴”操作，使其往估价函数更优的那一方移动 转轴操作我们默认，任意时刻，非基变量的值都为$0$ 一次转轴操作，等价于将一个基变量与一个非基变量交换位置，即基变量变成非基变量，非基变量变成基变量 我们假设选择了一个基变量$x_B$与一个非基变量$x_N$，现在要交换它们 原来的约束是这样的$$x_B=b-\sum_{i=1}^na_ix_i$$我们将$x_N$提出来，然后移项$$x_B=b-\sum_{i\not =N}a_ix_i-a_Nx_N\\\x_N=\frac{b-\sum_{i\not= N}a_ix_i-x_B}{a_N}$$注意！此时的$x_B$变成了$0$，因为它从一个基变量变成了一个非基变量，而$x_N$的值变成了$\frac{b}{a_N}$ 由于我们之前是交换基变量与非基变量，所以在等式中，$x_N$这一项的系数变成了$-\frac{1}{a_N}$，而其它项的系数分别除以了$a_N$ 我们用这条新的等式代替原来的等式，然后再用这条等式去替换其它的约束以及估价函数 就像高斯消元一样，将其它式子带有$x_N$的项改为这个式子 所以转一次的时间复杂度为$O(nm)$ 那么如何选择要进行操作的两个变量呢 显然我们必须满足条件： 转完之后估价函数必须更优秀 转完之后等式右边的$b$不能小于$0$ 我们先考虑第一个条件 在转轴的过程中，$x_N$从原来的$0$变成了一个实数，它在一直变大，所以为了让答案更大，必须有$c_N&gt; 0$ 否则当前已经是最优解，退出 接着考虑第二个条件 对于一个等式$$x_{i+n}=b-\sum_{i=1}^na_ix_i$$它限制了$x_N$的上界或者下界 如果$a_N\leq0$，那么它无法限制$x_N$的上界，答案为无穷大 否则$x_N$的上界为$\frac{b}{a_N}$ 为了让转轴之后，其它的等式的常数都大于等于$0$ 我们每次选择$\frac{b}{a_N}$最小的那一个进行转轴操作即可 代码如下 注意s[...][n + 1]存的是$b$，也就是那个约束的基变量，其它位置存的是每一项的系数，第一维表示第几个约束 这里的系数算上了前面那个负号 c是估价函数，c[n + 1]是这个估价函数当前的值 1234567891011121314151617181920212223inline void pivot(int x, int y, int n, int m) &#123; // 转轴操作, x为未知数, y为第几个方程 double tmp = s[y][x]; s[y][x] = -1; for (int i = 1;i &lt;= n + 1;i++) s[y][i] /= -tmp; for (int i = 1;i &lt;= m;i++) if (i != y) &#123; tmp = s[i][x], s[i][x] = 0; if (tmp &lt;= eps &amp;&amp; tmp &gt;= -eps) continue; for (int j = 1;j &lt;= n + 1;j++) s[i][j] += tmp * s[y][j]; &#125; tmp = c[x], c[x] = 0; for (int i = 1;i &lt;= n + 1;i++) c[i] += tmp * s[y][i];&#125;inline double LP(int n, int m) &#123; // n为未知数的个数, m为方程数 for (int pos, cur;;pivot(pos, cur, n, m)) &#123; double tmp = 1e100; pos = cur = 0; for (int i = 1;i &lt;= n;i++) if (c[i] &gt; eps) pos = i; if (!pos) return c[n + 1]; for (int i = 1;i &lt;= m;i++) if (s[i][pos] &lt; -eps) &#123; double now = s[i][n + 1] / -s[i][pos]; if (now &lt; tmp) tmp = now, cur = i; &#125; if (!cur) return 1e100; &#125;&#125; 注意：线性规划的时间复杂度最坏情况下是指数级别的 初始化我们来讨论一下当存在$b_i&lt;0$的时候该怎么做 显然这个时候我们之前选择的非基向量等于$0$的解就不满足条件了 我们随便找到一个$b&lt;0$的约束，比如是这个$$x_{t+n}=b_t-\sum_{j=1}^na_{tj}x_j$$我们从这个约束中，随便找到一个系数（注意算上前面那个负号）大于$0$的变量，假设是$x_B$ 进行一次转轴操作，将$x_B$换成基变量，将$x_{t+n}$换成非基变量$$x_B=\frac{b_t-\sum_{j\not =B}a_{tj}x_j-x_{t+n}}{a_{tB}}$$由于之前我们要求了$x_B$的系数必须为正，也就是说$a_{tB}$为负 而$b_t$为负，那么转轴之后这个约束的$b$就变成正的了 如果我们找不到这样一个系数为正的非基变量，那么原线性规划一定无解 因为所有的变量都必须不小于$0$，因此这个约束的右边一定小于$0$，无解 注意这样转一次轴之后，虽然这个约束的$b$变成正的了，但是其它约束的$b$可能就变成负数了 但是没关系，我们有信仰，while (1)转轴就可以了，直到所有约束的$b$都变成正数 即使这样时间复杂度是玄学的 代码如下 12345678910inline bool init() &#123; while (233) &#123; int r = 0, c = 0; for (int i = 1;i &lt;= m;++i) if(a[i][n + 1] &lt; 0 &amp;&amp;(!r || rand() &amp; 1)) r = i; if (!r) return true; for (int i = 1;i &lt;= n;++i) if(a[r][i] &gt; 0 &amp;&amp; (!c || rand() &amp; 1)) c = i; if (!c) return false; pivot(r, c); &#125;&#125; true代表初始化成功，否则代表初始化失败，线性规划无解 最终解如果要求求出每个变量的值，那么我们可以开个数组存一下每个变量被转到哪里去了 如果这个变量变成了一个基变量，那么它的值等于约束右边的$b$ 否则这个变量就是$0$ 时间复杂度最坏情况下的时间复杂度是指数级别的 但是我们有信仰，随机情况下还是很优秀的 大部分时可以过$n,m=100-500$的数据 将问题表示为线性规划某个题$A,B$两个人在洞中发现了$n$个石头，第$i$个石头对于$A$来说价值为$A_i$，对于$B$来说价值为$B_i$，石头是可以切割的，并且价值与其体积成正比。现在$A,B$要分配这些石头，要求它们两个人最终得到的价值相同，问这个价值最大可以是多少 $n\leq 50, 0\leq A_i,B_i\leq 100$ 对于每块石头我们开一个变量$x_i$，表示这块石头有多少分给了$A$，显然有$0\leq x_i\leq 1$ 那么两个人得到的价值之和分别为$$V_A=\sum_{i=1}^nx_iA_i\\\V_B=\sum_{i=1}^n(1-x_i)B_i$$约束为$V_A=V_B$，要求最大化$V_A$ 这里我们可以使用一个小技巧，即将约束改为$V_A\leq V_B$，最大化$V_A$，可以发现这是与原来的约束完全等价的 因为假如有一个解满足$V_A\ne V_B$，那么我们一定可以通过将某个变量$x$调大的方式使得$V_A$变得更大，那么这个解一定不是最优解 因此约束为$$V_A\leq V_B\Rightarrow \sum_{i=1}^nx_iA_i\leq \sum_{i=1}^n(1-x_i)B_i\\\\sum_{i=1}^nx_i(A_i+B_i)\leq\sum_{i=1}^nB_i$$注意到$\sum B_i\geq 0$，因此不需要运行初始化，直接求解即可 最大流问题在原来的最大流问题中，除了源点、汇点外的每个点必须满足流入流量等于流出流量 我们新建一条从汇点连向源点，并且权值为$\infty$的边。 那么最终这条边的流量也就是源点到汇点的流量 用$f(u,v)$表示一条边的实际流量，$c(u,v)$表示一条边的流量，那么可以得到如下的线性规划 最大化$$f(t,s)$$满足约束$$f(u,v)\leq c(u,v) \quad\quad (u,v)\in E\\\\sum_vf(u,v)=\sum_vf(v,u)\quad \quad u\in V\\\f(u,v)\geq 0\quad\quad (u,v)\in E\cup|(t,s)|$$ 最小费用流问题此时就不需要在汇点和源点之间新建边了 我们用$w(u,v)$代表一条边的费用，那么可以得出如下线性规划 最小化$$\sum f(u,v)w(u,v)\quad\quad (u,v)\in E$$满足约束$$\sum_vf(u,v)=\sum_{v}f(v,u)\quad \quad(u,v)\in E,v\not= s,t\\\f(u,v)\leq c(u,v)\quad\quad (u,v)\in E\\\f(u,v)\geq 0\quad\quad(u,v)\in E$$ 对偶问题我们考虑这样一个线性规划 最小化$$7x_1+x_2+5x_3$$满足约束$$x_1-x_2+3x_3\geq 10\\\5x_1+2x_2-x_3\geq 6\\\x_{1,2,3}\geq 0$$普通线性规划要求最大化，而这里要求最小化 普通线性规划的约束是小于等于，而这里是大于等于 我们当然可以选择将约束左右两边同时乘以$-1$，但是这样就需要初始化 这里有另一种方法——转对偶问题 由于$x_{1,2,3}\geq 0$，我们知道$7x_1+x_2+5x_3\geq x_1-x_2+3x_3\geq 10$ 那么我们就知道了最终答案的一个下界，能不能找到一个更紧的下界呢？ 能，比如$$7x_1+x_2+5x_3\geq(x_1-x_2+3x_3)+(5x_1+2x_2-x_3)=10+6$$于是我们有了一个奇妙的想法 对于每一个约束我们单独开一个变量，对于第$i$个约束的变量为$y_i$ 我们用$y$来表示在最终的下界中，每个约束所乘的系数 比如上面的那个就可以表示为$$y_1(x_1-x_2+3x_3)+y_2(5x_1+2x_2-x_3)$$我们需要保证，对于每个变量$x_i$，通过这种方式表示出来的系数不超过估价函数中$x_i$的系数，否则我们就无法保证求出的是下界 同时我们需要最大化下界 那么我们可以得出如下的线性规划 最大化$$10y_1+6y_2$$满足约束$$y_1+5y_2\leq 7\\\-y_1+2y_2\leq 1\\\3y_1-y_2\leq 5\\\y_{1,2}\geq 0$$求解这个线性规划，我们就能得到原估价函数的下界 我们将新得到的线性规划为对偶问题，如果对这个对偶问题再次进行对偶操作，那么我们会得到原问题 一个最大化问题可以对偶成最小化问题，同样一个最小化问题可以对偶成最大化问题 下面给出对偶线性规划的定义 对于原式线性规划 最小化$$\sum_{i=1}^nc_ix_i$$满足约束$$\sum_{j=1}^na_{i,j}x_j\geq b_j\quad\quad i=1,2,\cdots, m\\\x_i\geq 0\quad\quad i=1,2,\cdots,m$$它的对偶问题为 最大化$$\sum_{i=1}^mb_iy_i$$满足约束$$\sum_{j=1}^ma_{ij}y_j\leq c_i\quad\quad i=1,2,\cdots,n\\\y_i\geq 0\quad\quad i=1,2,\cdots n$$用矩阵可以表示为$$\begin{cases}最大化 c^Tx\\满足约束 Ax\geq b,x\geq 0\end{cases}\longleftrightarrow\begin{cases}最大化 b^Ty\\满足约束 A^Ty\leq c,y\geq 0\end{cases}$$同样，$A^T$表示矩形转置 几个重要定理定理1. 线性规划弱对偶性 若$X=(x_1,x_2,\cdots,x_n)$是原问题的一个可行解，$Y=(y_1,y_2,\cdots,y_m)$是对偶问题的一个可行解，那么$$\sum_{i=1}^mb_iy_i\leq\sum_{j=1}^nc_jx_j$$ 其实我觉得挺显然的 证明： 由于$Y$是对偶问题的一个可行解，所以$$c_j\geq\sum_{i=1}^ma_{ij}y_i$$由于有$x_i\geq 0$，所以$$\sum_{j=1}^nc_jx_j\geq\sum_{j=1}^n(\sum_{i=1}^ma_{ij}y_i)x_j$$由于$X$是原问题的一个可行解，所以$$b_j\leq\sum_{i=1}^na_{ji}x_i$$由于有$y_i\geq 0$，所以$$\sum_{i=1}^m(\sum_{j=1}^na_{ij}x_j)y_i\geq \sum_{i=1}^mb_iy_i$$我们知道$$\sum_{j=1}^n(\sum_{i=1}^ma_{ij}y_i)x_j=\sum_{i=1}^m(\sum_{j=1}^na_{ij}x_j)y_i$$所以结论成立 定理2. 线性规划对偶性 若$X^{*}=(x_1,x_2,\cdots,x_n)$是原问题的最优解，$Y^{*}=(y_1,y_2,\cdots,y_m)$是对偶问题的最优解，那么$$\sum_{i=1}^mb_iy_i=\sum_{j=1}^nc_jx_j$$ 引理： 设$I$是一个下标集合，对于每一个$j\in I$，设$\alpha_j,\beta_j$是实数，并令$x_j$是一个实数变量，设$\gamma$是任意的实数。假设对于变量$x_j$的任意设置，我们有$$\sum_{j\in I}\alpha_jx_j=\gamma+\sum_{j\in I}\beta_jx_j$$那么对于任意的$j\in I,\alpha_j=\beta_j$，且$\gamma=0$ 证明：因为上式对于任意的$x_j$都成立，那么我们可以通过代入一些特殊值的方式求出$\gamma,\alpha,\beta$。比如令所有的$x$都为$0$，那么我们可以得到$\gamma=0$，对于$j$，我们令$x_j=1,x_k=0(k\ne j)$，那么我们可以得出$\alpha_j=\beta_j$ 注意这里使用的特殊值仍然满足$x_j\geq 0$ 为了证明这个定理，我们先尝试构造一组对偶问题的解 定义$N$表示非基变量，$B$表示基变量 我们假设原问题在经过松弛过后得到的结果为 最大化$$v’+\sum_{j\in N}c’_jx_j$$满足约束$$x_i=b’_i-\sum_{j\in N}a’_{ij}x_j\quad\quad i\in B$$我们令$$\bar y_i=\begin{cases}-c’_{n+i}&amp;若(n+i)\in N\\\0 &amp;其它\end{cases}$$其实就是在原问题求解完毕后，在估价函数中所有非基变量的系数取反 现在我们开始证明 定义$\bar x=(\bar x_1,\bar x_2,\cdots,\bar x_n)$为原问题的最优解，$\bar y$为按照上面的方式取得的对偶问题的解 在最终形态的线性规划中，原问题的估价函数为$$z=v’+\sum_{j\in N}c’_j\bar x_j$$对于$j\in B$，我们定义$c’_j=0$ 所以$$\begin{aligned}z&amp;=v’+\sum_{j\in N}c’_j\bar x_j+\sum_{j\in B}c’_j\bar x_j\\\&amp;=v’+\sum_{i=1}^{n+m}c’_j\bar x_j\end{aligned}$$对于$j\in N$，我们知道$\bar x_j=0$，如果我们将此时的解代入原问题求估价函数，那么会得到同样的结果。所以$$\begin{aligned}\sum_{j=1}^nc_j\bar x_j&amp;=v’+\sum_{j=1}^{n+m}c’_j\bar x_j\\\&amp;=v’+\sum_{j\in N}c’_j\bar x_j+\sum_{j\in B}c’_j\bar x_j\\\&amp;=v’+\sum_{j\in N}(c’_j*0)+\sum_{j\in B}(0*\bar x_j)\\\&amp;=v’\end{aligned}$$现在我们要说明之前构造出来的$\bar y$对于对偶线性规划是可行的，并且其估价函数的值$\sum\limits_{i=1}^mb_iy_i$等于$\sum\limits_{j=1}^n c_j\bar x_j$。我们刚刚证明了原问题（第一个松弛型）与最终问题（最后一个松弛型）代入$\bar x$求值是相等的。更一般地，所有松弛型都是等价的意味着对于任意变量集合$x=(x_1,x_2,\cdots,x_n)$，我们有$$\sum_{j=1}^nc_jx_j=v’+\sum_{j=1}^{n+m}c’_jx_j$$因此，对于任意的特定值集合$\bar x=(\bar x_1,\bar x_2,\cdots, \bar x_n)$，有$$\begin{aligned}\sum_{j=1}^nc_j\bar x_j&amp;=v’+\sum_{j=1}^{n+m}c’_j\bar x_j=v’+\sum_{j=1}^nc’_j\bar x_j+\sum_{j=1}^mc’_{j+n}\bar x_{j+n}\\\&amp;=v’+\sum_{j=1}^nc’_j\bar x_j+\sum_{i=1}^m(-\bar y_i)\bar x_{n+i}\\\&amp;=v’+\sum_{j=1}^nc’_j\bar x_j+\sum_{i=1}^m(-\bar y_i)(b_i-\sum_{j=1}^na_{ij}\bar x_j)\end{aligned}$$ 注意，原问题的对偶问题和原问题经过变换后的对偶问题是等价的 对于原问题的一次变换，其实就是转轴操作，我们可以认为在对偶问题中，我们同步进行了一次转轴操作，最终得到的仍然是对偶问题 所以这里的$b,a$我们改成$b’,a’$仍然是可以的$$\begin{aligned}\sum_{j=1}^nc_j\bar x_j&amp;=v’+\sum_{j=1}^nc’_j\bar x_j-\sum_{i=1}^mb_i\bar y_i+\sum_{i=1}^m\bar y_i\sum_{j=1}^na_{ij}\bar x_j\\\&amp;=v’+\sum_{j=1}^nc’_j\bar x_j-\sum_{i=1}^mb_i\bar y_i+\sum_{j=1}^n\bar x_j\sum_{i=1}^ma_{ij}\bar y_i\\\&amp;=(v’-\sum_{i=1}^mb_i\bar y_i)+\sum_{j=1}^n(c’_j+\sum_{i=1}^ma_{ij}\bar y_i)\bar x_j\end{aligned}$$根据引理，我们可以得到$$v’-\sum_{i=1}^mb_i\bar y_i=0\\\c’_j+\sum_{i=1}^ma_{ij}\bar y_i=c_j$$因此，对偶问题的估价函数值与原问题相等，下面我们来说明$\bar y$为对偶问题的可行解 对于基变量，我们知道$c’=0$ 对于非基变量，我们知道$c’\leq 0$，否则我们可以继续进行松弛操作，使得估价函数的值更加优秀 因此$c’_j\leq 0,\sum\limits_{i=1}^ma_{ij}\bar y_i\leq c_j$ 满足对偶问题的约束 因此我们证明了定理2，同时给出了构造对偶问题最优解的一种方法 定理3. 互松弛定理 若$X=(x_1,x_2,\cdots,x_n),Y=(y_1,y_2,\cdots,y_n)$分别是原问题及对偶问题的一组可行解，那么$X,Y$都是最优解当且仅当$$对于所有的1\leq j\leq n,满足x_j=0或\sum_{i=1}^ma_{ij}y_i=c_j\\\对于所有的1\leq i\leq m,满足y_i=0或\sum_{j=1}^na_{ij}x_j=b_i$$ 证明：根据定理2证明中的最后一步$$c’_j+\sum_{i=1}^ma_{ij}\bar y_i=c_j$$我们分类讨论： $c’_j=0$ 此时也就是$x_j$的系数为$0$，那么$x_j$随意即可，对最终的结果不会造成影响 $c’_j&lt; 0$ 此时为了要求最终结果最大，必然有$x_j=0$，否则我们可以通过减少$x_j$的值使得结果变大 对于$y$的证明同理 对偶的应用偷懒给一张$n$个点的带权无向图，边$u,v$的权值为$w_{u,v}$，可以随意增加或者减少一条边的边权，代价为边权的变化量。要求进行操作之后任意两点间直接相连的边的长度不超过两点之间的最短路，求最小代价 $n\leq 10,w\leq 20$ 对于每一条边我们开两个变量$t_{u,v},t’_{u,v}$，表示这条边增加了多少/减少了多少 那么对于一条边$u,v$，经过操作之后它的边权为$w_{u,v}+t_{u,v}-t’_{u,v}$，令$d_{u,v}$表示操作之后$u,v$两点间的最短路长度 我们可以得到如下线性规划 最小化$$\sum_{(u,v)\in E}t_{u,v}+t’_{u,v}$$满足约束$$d_{u,v}\geq w_{u,v}+t_{u,v}-t’_{u,v}\quad\quad (u,v)\in E\\\-d_{u,v}\geq -w_{u,v}-t_{u,v}+t’_{u,v}\quad\quad (u,v)\in E\\\w_{u,i}+t_{u,i}-t’_{u,i}\geq d_{u,v}-d_{u,i}\quad\quad u\ne v,(u,i)\in E\\\d,t,t’\geq 0$$注意到之间求解需要初始化，而目标函数中的系数都是正的 所以我们可以将这个线性规划进行对偶，将所有的$b$都变成正数，这样就不需要初始化了 将线性规划转化为半平面交给出三个长度为$n$的数组$a_i,b_i,c_i$，每次询问给出两个数$s,t$，求一组非负实数$x_i$，满足$$\sum_{i=1}^na_ix_i=s,\sum_{i=1}^nb_ix_i=t$$同时最大化$\sum\limits_{i=1}^nc_ix_i$，对于每组询问输出最大值或无解 $n\leq 10^5,a,b,c,s,t,m\leq 10^4$ 注意到每次变化的是限制，而对于目标函数是不变的，这意味着转对偶之后限制是不变的 那么对初始线性规划我们转一个对偶，然后未知数就变成了两个，限制变成了$n$个，并且是固定的 此时目标函数变成了$sy_1+ty_2$ 由于初始线性规划的约束是等于，所以转对偶之后对于$y_1,y_2$是否大于$0$没有限制 这里简单说明一下 我们考虑一个这样的线性规划 约束为$$\sum_{j=1}^na_{ij}x_i=b_i$$我们可以把它拆成两个$$\sum_{j=1}^na_{ij}x_i\geq b_i\\-\sum_{j=1}^na_{ij}x_i\geq -b_i$$现在考虑对偶，我们设第一个限制的未知数为$y_1$，第二个为$y_2$ 那么对偶的限制一定是对$y_1-y_2$的限制 现在我们将$y_1,y_2$合成一个变量，虽然有$y_1\geq 0,y_2\geq 0$，但是这个新合成的变量$y_1-y_2$却可以小于$0$ 所以此时对偶之后的变量才没有$\geq 0$的限制 将$y_1$看作$x$，将$y_2$看作$y$，我们可以把约束转化为半平面交的形式 所以询问的时候直接在凸壳上二分即可 将线性规划转化为网络流给出一个带权的连通无向图，有$n$个点$m$条边，对于每条边，增加$1$的权值需要花费$a_i$，减少$1$的权值需要花费$b_i$，给定一棵生成树，需要通过修改边权使得它成为最小生成树，求最小花费 考虑一条边为非树边的含义是什么 如果一条原图上的边$u,v$不在最小生成树上，那么在生成树上它覆盖的所有边的权值都不能小于它 并且树边一定不会加，非树边一定不会减 写成线性规划的形式就是 最小化$$\sum_{i\in T}b_ix_i+\sum_{i\in E-T}a_ix_i$$满足约束$$x_i+x_j\geq w_i-w_j\quad\quad i被j覆盖\\x_i\geq 0$$首先来转一个对偶 最大化$$\sum_{i\in T,j\in E-T,j覆盖i}(w_i-w_j)y_{ij}$$满足约束$$\sum_{j\in E-T,j覆盖i}y_{ij}\leq b_i\quad\quad i\in T\\\sum_{i\in T,j覆盖i} y_{ij}\leq a_i\quad\quad j\in E-T$$我们将$T$中的边放在左边，$E-T$中的边放在右边，可以看出这是一个最大费用流模型，其中$y_{ij}$就是流量 需要满足对于$T$中的点，每个点的流量不超过$b_i$，对于$E-T$中的点，每个点的流量不超过$a_i$ 如果$j$覆盖$i$，那么我们从$i$向$j$连一条容量无限，费用为$w_i-w_j$的边 然后在这张图上跑一遍费用流就可以了 注意这里的费用流不是优先满足最大流，而是优先满足费用最大 dinic的时候如果当前费用小于上次更新时的费用就break 完结撒花]]></content>
      <tags>
        <tag>数学</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
        <tag>算法</tag>
        <tag>计算几何</tag>
        <tag>线性规划</tag>
        <tag>半平面交</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.24省选模拟]]></title>
    <url>%2F2019%2F04%2F25%2F4-24%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 密文 知道密文的每一位，等于知道密文的每一个前缀和，或者任意两个前缀的异或和 而每次操作得到的其实就是两个前缀和的异或和 假设这次我们询问了$a,b$这两个前缀，下次询问了$b,c$这两个前缀，那么我们就知道了$a,c$的异或和是多少 将前缀看作点，如果我们询问了$a,b$这两个前缀，那么我们就用一条权值为询问代价的边将这两个点连接起来 最优的方案一定是连成了一棵生成树，因为所有非树边都是不必要的，任意两个前缀的异或和等于它们在树上路径所经过边的权值的异或和 所以这个题就是最小异或和生成树，共$n+1$个节点，即$n+1$个前缀和 关于最小异或和生成树，可以在trie上分治，每次按照最高位将当前点集分为最高位为0以及最高位为1的两个部分，将这两个部分各自连通，然后用一条权值最小的边连通这两个集合 我们每次枚举小的那个集合中的所有数，然后放到大的那个集合里面暴力查异或最小值即可 代码如下 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010int trie[N * 31][2], sz[N * 31], ncnt = 1, dep[N * 31]; vector&lt;int&gt; num[N * 31];inline void insert(int v) &#123; for (int now = 1, i = 30;i &gt;= 0;i--) &#123; int nxt = v &gt;&gt; i &amp; 1; if (!trie[now][nxt]) trie[now][nxt] = ++ncnt, dep[ncnt] = dep[now] - 1; now = trie[now][nxt], sz[now]++, num[now].push_back(v); &#125;&#125;int query(int u, int x) &#123; if (dep[u] &lt; 0 || !u) return 0; int t = x &gt;&gt; dep[u] &amp; 1; if (trie[u][t]) return query(trie[u][t], x); return query(trie[u][t ^ 1], x) + (1 &lt;&lt; dep[u]);&#125;#define LL long longLL ans = 0;inline void divide(int u) &#123; if (!u || dep[u] &lt; 0) return; divide(trie[u][0]), divide(trie[u][1]); int v = sz[trie[u][0]] &lt; sz[trie[u][1]] ? 0 : 1; int t = ~0U &gt;&gt; 1, flag = 0; for (int i = 0;i &lt; sz[trie[u][v]];i++) t = min(t, query(trie[u][v ^ 1], num[trie[u][v]][i]) + (1 &lt;&lt; dep[u])), flag = 1; if (flag) ans += t; &#125;int main() &#123; freopen("secret.in", "r", stdin), freopen("secret.out", "w", stdout); int n; scanf("%d", &amp;n), dep[1] = 30, insert(0); for (int ls = 0, i = 1, a;i &lt;= n;i++) scanf("%d", &amp;a), ls ^= a, insert(ls); divide(1), printf("%lld\n", ans);&#125; T2 最短路 数据太水，本来只能拿30分的算法拿了71分 对于这$30\%$的数据做法比较简单，建出最短路DAG，然后DAG上的边边权为inf，将每个点拆成两个点，中间连一条权值为1的边，然后跑一遍起点到终点的最大流就可以得出最少需要让多少个点+1才能使得最短路变长 对于所有数据，我们考虑这样建图 首先二分答案mid，然后建mid + 1层点，第$i$层的点表示路径长度为$i-1$ 每一层都有$n$个点$s$以及它们的虚点$t$，将每一层的点向那一层中对应的虚点连边，如果是$1,n$号点就连inf，否则连1 对于第$i$层到第$i+1$层，我们将原图中所有的边连上。比如原图中有一条$u\rightarrow v$的边，那么我们就从这一层的$t_u$向下一层的$s_v$连边，权值为inf 为了保证每个点最多只会被加一次，对于每一层的点$s_i$，我们从它向下一层的$t_i$连一条边，权值为inf 然后需要加的点数就是第一层中$s_1$到最后一层中$t_n$的最大流，这样才能表示答案大于mid 这样建图的原因是，每在这张图上经过一条原图的边，就会从第$i$层到达第$i+1$层，含义就是路径长度$+1$ 如果我们割掉了某个点$s$到$t$的边，那么所有到达$s$的路径都只能经过$s$到下一层的$t$的这条边，那么相对应地，长度就$+1$ 而这样建图的话，在不同层中多次割掉同一个点$s\rightarrow t$的边是不优秀的，在最大流中选择割掉的那一条边一定是第一次到达这个点的时刻所对应的那条边 因为无论是否让$u$这个点的权值$+1$，在第$t$时刻到达$u$的路径一定可以在比$t$更晚的时刻到达$u$，所以割掉后面的边是没有好处的，不会出现在最大流中 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100010;struct edge &#123; int to, next, w;&#125; e[N * 10];int head[N], ecnt = 1, dep[N], cur[N];inline void adde(int from, int to, int w) &#123; e[++ecnt] = (edge)&#123;to, head[from], w&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to], 0&#125;, head[to] = ecnt;&#125;inline bool BFS(int s, int t) &#123; memset(dep, -1, sizeof(dep)), dep[s] = 0; queue&lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u]; i; i = e[i].next) if (e[i].w &amp;&amp; dep[e[i].to] == -1) &#123; dep[e[i].to] = dep[u] + 1, q.push(e[i].to); if (e[i].to == t) return true; &#125; &#125; return false;&#125;int DFS(int u, int f, int t) &#123; if (u == t || !f) return f; int res = 0; for (int &amp;i = cur[u], tmp; i; i = e[i].next) if (e[i].w &amp;&amp; dep[e[i].to] == dep[u] + 1 &amp;&amp; (tmp = DFS(e[i].to, min(f, e[i].w), t))) &#123; res += tmp, f -= tmp, e[i].w -= tmp, e[i ^ 1].w += tmp; if (!f) break; &#125; return res;&#125;inline int Dinic(int s, int t) &#123; int res = 0; while (BFS(s, t)) memcpy(cur, head, sizeof(head)), res += DFS(s, 1e9, t); return res;&#125;#define N 110vector&lt;int&gt; G[N]; int n;inline int ID(int u, int type, int layer) &#123;return n * 2 * layer + n * type + u;&#125;inline int Solve(int mid) &#123; memset(head, 0, sizeof(head)), ecnt = 1; for (int i = 0; i &lt;= mid; i++) &#123; for (int j = 1;j &lt;= n;j++) &#123; adde(ID(j, 0, i), ID(j, 1, i), j == 1 ? 1e9 : 1); if (i &lt; mid) adde(ID(j, 0, i), ID(j, 1, i + 1), 1e9); &#125; if (i &lt; mid) for (int j = 1; j &lt;= n; j++) for (auto v : G[j]) adde(ID(j, 1, i), ID(v, 0, i + 1), 1e9); if (i &lt; mid) adde(ID(n, 0, i), ID(n, 0, i + 1), 1e9); &#125; return Dinic(ID(1, 0, 0), ID(n, 0, mid));&#125;int main() &#123; freopen("min.in", "r", stdin), freopen("min.out", "w", stdout); int m, k; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for (int i = 1, a, b; i &lt;= m; i++) scanf("%d%d", &amp;a, &amp;b), a++, b++, G[a].push_back(b), G[b].push_back(a); int l = 0, r = 2 * n, mid, ans = -1; while (l &lt;= r) &#123; if (Solve(mid = (l + r) &gt;&gt; 1) &lt;= k) ans = mid, l = mid + 1; else r = mid - 1; &#125; printf("%d\n", ans + 1); return 0;&#125; T3 特技飞行题目太长，这里只给出简单的描述 有$n$架飞机，它们的航线对应着起点在$x=x_0$，终点在$x=x_1$的一条线段，它们的水平速度相同 当两架飞机相遇的时候，它们可以选择互换航线，获得$b$的分数；或者不交换，获得$a$的分数，但是要保证到达$x=x_1$的时候这些飞机从上到下的顺序仍然是起飞时的顺序 有$k$个观众，第$i$个观众的位置是$(p_i,q_i)$，观察距离是$r_i$，会查看$|x-p_i|+|y-q_i|\leq r_i$的所有相遇事件 当一个相遇事件被至少一名观众观察到，那么就可以获得$c$的分数 输出最终得分的最小值以及最大值 首先可以看出，$c$是强行拼上去的，跟是否选择互换航线没有任何关系 那么我们可以算出$c$对答案的最终贡献是什么 显然对于两条有交点的线段$i,j$，必须满足$y_{i,0}&lt;y_{j,0},y_{i,1}&gt;y_{j,1}$ 扫描线一下，同时使用一个set维护就可以求出所有交点 题目中给出的那个限制实际上是曼哈顿距离$\leq r$ 那么我们有一个套路就是将坐标$x,y$变换成$x+y,x-y$ 那么限制就变成了$p’-r\leq x’\leq p’+r,q’-r\leq y’\leq q’+r$，对应一个矩形范围 将所有转换后的坐标离散化，然后从上到下扫描线，用一个树状数组维护每个点的覆盖次数就可以了 我们再来考虑最终结果的最大/最小值 首先一定有一种方案是每次相遇都交换，这样最终的相对顺序一定是不变的，产生的要么是最大值，要么是最小值 另一种方案就是让交换的次数尽量少 我们考虑如果每次都不交换会发生什么 最终对应的从上到下的顺序是原顺序的一个置换，我们要让最终顺序等于原顺序 我们可以进行的操作是，每次选择两个位置，然后交换它们的排名 这种操作是一定可以成功的，因为我们只需要在这两架飞机相交的时候选择交换位置即可达到交换最终顺序的结果 所以操作等价于：给出一个置换，每次可以交换其中的任意两个数，问最少步数使得置换变成原排列 显然对于每一长度为$l$的环，我们只需要交换$l-1$次，那么最少的交换次数就是$n-$环的个数 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;#define N 500010#define Vector Pointstruct Point &#123; double x, y; Point (double x = 0, double y = 0) : x(x), y(y) &#123;&#125; Point operator + (const Vector &amp;b) &#123;return Point(x + b.x, y + b.y);&#125; Vector operator - (const Point &amp;b) &#123;return Vector(x - b.x, y - b.y);&#125; double operator ^ (const Vector &amp;b) &#123;return x * b.y - y * b.x;&#125; Vector operator * (double b) &#123;return Vector(x * b, y * b);&#125;&#125; x[N];struct Line &#123;Point a, b;&#125;;inline Point Inter(Line a, Line b) &#123; double t = ((b.b - b.a) ^ (a.a - b.a)) / ((a.b - a.a) ^ (b.b - b.a)); return a.a + (a.b - a.a) * t;&#125;int id[N], mark[N], t1[N], t2[N];void dfs(int u) &#123;if (!mark[u]) mark[u] = 1, dfs(id[u]);&#125;#define P pair&lt;int, int&gt; #define SIT set&lt;P &gt;::iteratorset&lt;P &gt; s;bool cmp(int i, int j) &#123;return t2[i] &lt; t2[j];&#125;struct Query &#123; double y; int x1, x2, op; bool operator &lt; (const Query &amp;b) const &#123;return y &lt; b.y;&#125;&#125; q[N];int tree[N * 2], top;inline void update(int x, int y) &#123; for (;x;x -= x &amp; -x) tree[x] += y;&#125;inline int query(int x) &#123; int res = 0; for (;x &lt;= top;x += x &amp; -x) res += tree[x]; return res;&#125;double zjk[N * 5]; int cnt, watchx[N], watchy[N], r[N], qcnt;bool cmp2(Point i, Point j) &#123;return i.x - i.y &lt; j.x - j.y;&#125;int main() &#123; freopen("aerobatics.in", "r", stdin), freopen("aerobatics.out", "w", stdout); int n, a, b, c, X1, X2, tot = 0; scanf("%d%d%d%d%d%d", &amp;n, &amp;a, &amp;b, &amp;c, &amp;X1, &amp;X2); for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;t1[i]); for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;t2[i]); for (int i = 1;i &lt;= n;i++) &#123; SIT it = s.lower_bound(P(t2[i], i)); if (it != s.end()) &#123; for (SIT it2 = it;it2 != s.end();it2++) &#123; Line a = (Line)&#123;Point(X1, t1[it2-&gt;second]), Point(X2, t2[it2-&gt;second])&#125;, b = (Line)&#123;Point(X1, t1[i]), Point(X2, t2[i])&#125;; x[++tot] = Inter(a, b); &#125; &#125; s.insert(P(t2[i], i)); &#125; for (int i = 1;i &lt;= n;i++) id[i] = i; sort(id + 1, id + n + 1, cmp); int cnt = 0; for (int i = 1;i &lt;= n;i++) if (!mark[i]) dfs(i), cnt++; int s1 = tot * a, s2 = (tot - n + cnt) * b + (n - cnt) * a; if (s1 &gt; s2) swap(s1, s2); int k; scanf("%d", &amp;k); for (int i = 1;i &lt;= tot;i++) zjk[++cnt] = x[i].x + x[i].y; for (int i = 1;i &lt;= k;i++) scanf("%d%d%d", &amp;watchx[i], &amp;watchy[i], &amp;r[i]), zjk[++cnt] = watchx[i] + watchy[i] - r[i], zjk[++cnt] = watchx[i] + watchy[i] + r[i]; sort(zjk + 1, zjk + cnt + 1), cnt = unique(zjk + 1, zjk + cnt + 1) - zjk - 1, top = cnt; for (int i = 1;i &lt;= k;i++) &#123; int a = lower_bound(zjk + 1, zjk + cnt + 1, watchx[i] + watchy[i] - r[i]) - zjk, b = lower_bound(zjk + 1, zjk + cnt + 1, watchx[i] + watchy[i] + r[i]) - zjk; q[++qcnt] = (Query)&#123;watchx[i] - watchy[i] - r[i], a, b, 0&#125;, q[++qcnt] = (Query)&#123;watchx[i] - watchy[i] + r[i] + 1e-5, a, b, 1&#125;; &#125; sort(x + 1, x + tot + 1, cmp2), sort(q + 1, q + qcnt + 1); int res = 0; for (int i = 1, cur = 1;i &lt;= qcnt;i++) &#123; while (cur &lt;= tot &amp;&amp; x[cur].x - x[cur].y &lt; q[i].y) &#123; int a = lower_bound(zjk + 1, zjk + cnt + 1, x[cur].x + x[cur].y) - zjk; if (query(a) &gt;= 1) res++; cur++; &#125; if (q[i].op) update(q[i].x2, -1), update(q[i].x1 - 1, 1); else update(q[i].x2, 1), update(q[i].x1 - 1, -1); &#125; printf("%d %d\n", s1 + c * res, s2 + c * res); return 0;&#125; T4 吃 我们考虑这样统计答案：记$E(u,v)$表示当$u$被删除的时候，$v$仍与$u$连通的概率 那么答案就是$$\sum_{i=1}^n\sum_{j=1}^nE(i,j)$$很显然，给出的图是一棵基环树 我们考虑这两种点对： 点$u,v$都在同一棵树上 很显然此时的$E(u,v)=\frac{1}{dis(u,v)}$，因为需要保证$u$是$u,v$这条路径上第一被删除的点 可以使用点分治+FFT统计每种$dis$的方案数，最后再计算这一类点对的答案 点$u,v$在不同的树上 我们假设从$u$到$v$，必须经过的路径长度为$c$ 在环上，$u$的根节点到$v$的根节点显然有两条路径，我们记它们的长度分别为$x,y$ 那么显然，如果在$u$被删除的时候$u,v$仍然连通，那么要么是$c+x$这条路径没有被删除，概率为$\frac{1}{c+x}$，要么是$c+y$这条路径没有被删除，概率为$\frac{1}{c+y}$ 注意此时我们重复统计了这两条路径都没有被删除的概率，为$\frac{1}{c+x+y}$ 所以此时有$$E(u,v)=\frac{1}{c+x}+\frac{1}{c+y}-\frac{1}{c+x+y}$$我们考虑如何计算 首先随便断开环上的一条边，将环变成一条链，然后在链上分治 设$x$是经过链的路径，$y$是经过被破坏边的路径 我们选择当前区间的中点，显然从中点或者中点左边到中点右边的$x$路径一定会经过这个中点 那么我们可以利用这个性质将$x$分成两半，假设两个根节点分别为$u,v$ 分成的这两半即为$u$到中点的路径，减去$v$到中点的路径 与之前相似，我们同样可以计算每一种$c+x$的方案数，即中点及左边多项式的和，乘上中点右边多项式的和，再加上两边分治的结果 $c+y$与之类似，注意$c+x+y$是不用分治的，因为$x+y$就是环长 代码就咕了]]></content>
      <tags>
        <tag>数学</tag>
        <tag>网络流</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>多项式</tag>
        <tag>分治</tag>
        <tag>二分答案</tag>
        <tag>扫描线</tag>
        <tag>置换</tag>
        <tag>NTT</tag>
        <tag>Trie</tag>
        <tag>最小生成树</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TopTree]]></title>
    <url>%2F2019%2F04%2F23%2FTopTree%2F</url>
    <content type="text"><![CDATA[引言TopTree可以说是LCT的扩展，LCT支持链上的修改与查询，而TopTree可以支持链与子树的修改与查询 TopTree的思想与LCT及其相似，都是将树进行轻重链剖分。但是与LCT不同的是，TopTree会单独维护某个节点的每个虚子树，而非简单地维护虚子树对当前点的贡献 TopTree的时间复杂度为每次操作$O(\log n)$，但是常数巨大无比，为$97$ 做好码7168+b的准备 例题让我们先从一道神仙题开始 BZOJ3153 题意：有一棵树，每个点有一个权值，需要支持12个操作 换根 路径加/路径覆盖 子树加/子树覆盖 查询路径的和/最大值/最小值 查询子树的和/最大值/最小值 换父亲 虚点Splay对于一个点$u$，在LCT上的splay中我们维护了它的两个儿子 左儿子代表重链上比它高的节点，右儿子代表重链上比它低的节点 在TopTree中，每个点我们还要额外维护一个splay，这个splay上挂的点是以虚边的形式与$u$相连的点 举个例子 图中的实线代表重边，虚线代表轻边 注意$\{1,4,7\}$单独是一棵splay,即$1$的虚儿子构成的splay 我们称在原树中出现的点为实点，在原树中未出现的点为虚点 那么在由某个点虚儿子构成的splay中，每一个实点都是叶子节点，除根节点外，每个非叶子节点都是虚点 另一个例子 注意到根节点有$4$个虚子树，所以必须新建两个虚点来维护这些虚子树，图中的橙色节点就是虚点，图中的虚边即为虚子树splay 那么每个点我们维护$4$个儿子ch[0 - 3][u]，前两个儿子表示正常LCT中的儿子，即重链splay的左右儿子；后两个儿子表示虚子树中的两个儿子 显然虚点是没有前两个儿子的 新的Rotate, Splay如果一个虚点的splay转到实点里面去了，显然是不行的 所以对于虚点、实点我们需要单独rotate, splay 注意splay时无论当前点是否为根节点，我们都要pushup一次 所以rotate的时候改一改，再在splay的最后加上一次pushup 123456inline void Connect(int u, int f, int son) &#123;if (u) fa[u] = f; ch[son][f] = u;&#125;inline void Rotate(int u, int type) &#123; int f = fa[u], tmp = (ch[type + 1][f] == u) + type, ff = fa[f]; if (ff) for (int i = 0;i &lt; 4;i++) if (ch[i][ff] == f) ch[i][ff] = u; fa[u] = ff, Connect(ch[tmp ^ 1][u], f, tmp), Connect(f, u, tmp ^ 1), Pushup(f);&#125; type = 0代表是原树，type = 2代表是虚树 其实跟原来的rotate差不多 splay同理 12345678910int st[N];inline void Splay(int u, int type) &#123; int now = u, top = 0; st[++top] = now; while (!Isroot(now, type)) st[++top] = now = fa[now]; while (top) Pushdown(st[top--]); for (int f;!Isroot(u, type);Rotate(u, type)) if (!Isroot(f = fa[u], type)) Rotate((ch[type][f] == u) ^ (ch[type][fa[f]] == f) ? u : f, type); Pushup(u);&#125; 新的Pushdown在树上，我们需要维护两个标记 第一个是给重链打上的标记 第二个是给重链splay中它的后代的所有虚子树打上的标记（不包括重链节点） 显然虚点只有第二种标记 我们分以下几种情况讨论： 当前点是实点，下放到重链上的左右儿子 首先标记应该下传，同时给这两个儿子的点权打上第一个标记 注意第二个标记不会对这两个点权产生影响，因为它是给虚子树打的 当前点是实点，下放到虚点 第一个标记没有必要下方，只需要下方第二种标记 当前点是实点，下放到一个非重链实点 此时除了修改点权，还应将这个儿子的点权打上这两种标记 因为此时这个儿子是当前点的一个虚儿子 当前点是虚点，下放到一个实点 同上 当前点是虚点，下放到虚点 直接下传标记即可 注意翻转标记不应该传入虚子树的splay中 12345678910inline void Pushdown(int u) &#123; if (!u) return; if (rev[u]) Rev(ch[0][u]), Rev(ch[1][u]), rev[u] = 0; if (!in[u] &amp;&amp; tag[u].marked()) Tag_Line(ch[0][u], tag[u]), Tag_Line(ch[1][u], tag[u]), tag[u] = Tag(); if (T_tag[u].marked()) &#123; Tag_Tree(ch[0][u], T_tag[u], 0), Tag_Tree(ch[1][u], T_tag[u], 0); Tag_Tree(ch[2][u], T_tag[u], 1), Tag_Tree(ch[3][u], T_tag[u], 1), T_tag[u] = Tag(); &#125;&#125; marked代表是否有下传的必要 tag是给重链打的标记 T_...代表虚子树的信息或者标记 Tag_line与Tag_Tree，分别是给链/树打标记 123456789inline void Tag_Line(int u, Tag t) &#123; if (!u) return; sum[u] += t, A_sum[u] = sum[u] + T_sum[u], val[u] = Get(val[u], t), tag[u] += t;&#125;inline void Tag_Tree(int u, Tag t, int type) &#123; if (!u) return; T_sum[u] += t, T_tag[u] += t; if (!in[u] &amp;&amp; type) Tag_Line(u, t); else A_sum[u] = sum[u] + T_sum[u];&#125; A_sum代表全部信息 Get(x, t)代表$x$在标记$t$的作用下的值 in代表是否为虚点 新的Pushup同样，我们分虚子树信息/重链信息以及全部信息来统计答案 分情况讨论 当前点是虚点，子树也是虚点 当前点虚子树信息为子树虚子树信息的和，此时虚子树信息就是全部信息 当前点是虚点，子树是实点 当前点虚子树信息为子树全部信息 当前点是实点，子树是虚点 只更新子树信息与子树全部信息 当前点是实点，子树是重链上的点 只更新重链信息与子树全部信息 1234567891011inline void Pushup(int u) &#123; T_sum[u] = Data(); for (int i = 0;i &lt;= 1;i++) if (ch[i][u]) T_sum[u] += T_sum[ch[i][u]]; for (int i = 2;i &lt;= 3;i++) if (ch[i][u]) T_sum[u] += A_sum[ch[i][u]]; if (in[u]) sum[u] = Data(), A_sum[u] = T_sum[u]; else &#123; sum[u] = Data(val[u]); for (int i = 0;i &lt;= 1;i++) if (ch[i][u]) sum[u] += sum[ch[i][u]]; A_sum[u] = sum[u] + T_sum[u]; &#125;&#125; 新的操作Add$Add(x,y)$表示从$x$向$y$连一条虚边 方式其实很暴躁，就是一直跳左儿子，最后再新建一个虚点$v$，将当前点挂在$v$上面 图中黄色节点代表$v$ 注意在跳左儿子的时候要顺便pushdown 最后别忘了将新添加的点旋转到splay的根 1234567inline void Add(int x, int y) &#123; if (!y) return; Pushdown(x); for (int i = 2;i &lt;= 3;i++) if (!ch[i][x]) return void(Connect(y, x, i)); while (ch[2][x] &amp;&amp; in[ch[2][x]]) x = ch[2][x], Pushdown(x); int u = Create(); Connect(ch[2][x], u, 2), Connect(y, u, 3), Connect(u, x, 2), Splay(u, 2);&#125; 新的操作Del$Del(u)$表示删除$u$与其父亲相连的虚边 注意到每次$Add$操作都会新建一个点，那么$Del$操作我们也只需要删除一个点就可以保证空间为$O(n)$ 如果$u$与其父亲直接相连，那么断开这条虚边就好了 否则我们找到$u$的虚点父亲$f$，先将$f$及它的祖先像splay一样pushdown，然后尝试删除$f$ 注意此时也要splay来保证复杂度 12345678910111213141516inline int Child(int u) &#123; for (int i = 0;i &lt; 4;i++) if (ch[i][fa[u]] == u) return i; return 4;&#125;inline void Del(int u) &#123; if (!u) return; Splay(u, 0); if (!fa[u]) return; int f = fa[u]; if (in[f]) &#123; int top = 0, now = f, ff = fa[f]; st[++top] = now; while (!Isroot(now, 2)) st[++top] = now = fa[now]; while (top) Pushdown(st[top--]); if (ff) &#123;int other = ch[Child(u) ^ 1][f]; Pushdown(other), Connect(other, ff, Child(f)), Splay(ff, 2);&#125; rub[++rcnt] = f; &#125; else ch[Child(u)][f] = 0, Splay(f, 0); fa[u] = 0;&#125; 新的操作Father$Father(u)$表示找到$u$的以虚边相连的父亲 实现很简单，如果$u$的父亲节点就是原树中的父亲，那么直接返回，否则将这个虚点splay到根，再返回它的父亲 123456inline int Father(int u) &#123; if (!u) return 0; Splay(u, 0); if (!fa[u]) return 0; if (!in[fa[u]]) return fa[u]; int f = fa[u]; Splay(f, 2); return fa[f];&#125; 新的Access以及LCA其实跟LCT的差不多，就是将连边/断边改成Del, Add，将跳父亲改成Father 这里提一下如何求两个点的LCA，假设为$u,v$ 首先将$u$ $Access$一下，此时$u$到根节点的链已经被打通，那么$v$到根节点的路径一定分为若干段实链与虚边，最后一段实链的最深的那个点就是LCA 那么在$Access$的时候，直接返回结束时的ls就好了 1234567inline int Access(int u) &#123; int ls = 0; for (;u;u = Father(ls = u)) Splay(u, 0), Del(ls), Add(u, ch[1][u]), Connect(ls, u, 1), Pushup(u); return ls;&#125;inline int LCA(int x, int y) &#123;Access(x); return Access(y);&#125; 一些例行操作由于这一部分的代码和LCT几乎是一样的，所以直接贴上来 123456789inline int Findroot(int u) &#123; Access(u), Splay(u, 0); while (ch[0][u]) u = ch[0][u]; return u;&#125;inline void Makeroot(int u) &#123;Access(u), Splay(u, 0), Rev(u);&#125;inline void Link(int x, int y) &#123;Makeroot(x), Add(y, x), Access(x);&#125;inline void Cut(int u) &#123;Access(u), Splay(u, 0), ch[0][u] = fa[ch[0][u]] = 0, Pushup(u);&#125; inline void Split(int x, int y) &#123;Makeroot(x), Access(y), Splay(y, 0);&#125; 程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &lt;bits/stdc++.h&gt;using namespace std;struct Tag &#123; int k, b; Tag(int k = 1, int b = 0) : k(k), b(b) &#123;&#125; inline bool marked() &#123;return k != 1 || b;&#125; inline Tag operator + (const Tag &amp;x) &#123;return Tag(k * x.k, b * x.k + x.b);&#125; inline void operator += (const Tag &amp;x) &#123;*this = *this + x;&#125;&#125;;const int INF = 2147483647;inline int Get(int x, Tag y) &#123; return x * y.k + y.b;&#125;struct Data &#123; int sum, mn, mx, sz; Data() &#123;sum = sz = 0, mn = INF, mx = -INF;&#125; Data(int x) &#123;sum = mn = mx = x, sz = 1;&#125; Data(int sum, int mn, int mx, int sz) : sum(sum), mn(mn), mx(mx), sz(sz) &#123;&#125; inline Data operator + (const Data &amp;x) &#123;return Data(sum + x.sum, min(mn, x.mn), max(mx, x.mx), sz + x.sz);&#125; inline void operator += (const Data &amp;x) &#123;*this = *this + x;&#125;&#125;;inline Data operator + (const Data &amp;a, const Tag &amp;b) &#123;return a.sz ? Data(a.sum * b.k + a.sz * b.b, Get(a.mn, b), Get(a.mx, b), a.sz) : a;&#125;inline void operator += (Data &amp;a, const Tag &amp;b) &#123;a = a + b;&#125;#define N 200010int fa[N], ch[4][N], ncnt, rt, rev[N], in[N], val[N], rub[N], rcnt;Data sum[N], T_sum[N], A_sum[N]; Tag tag[N], T_tag[N];inline bool Isroot(int u, int type) &#123; if (type) return !fa[u] || !in[fa[u]] || !in[u] || !u; return (ch[0][fa[u]] != u &amp;&amp; ch[1][fa[u]] != u) || !fa[u] || in[fa[u]] || in[u] || !u;&#125;inline void Rev(int u) &#123; if (!u) return; swap(ch[0][u], ch[1][u]), rev[u] ^= 1;&#125;inline void Tag_Line(int u, Tag t) &#123; if (!u) return; sum[u] += t, A_sum[u] = sum[u] + T_sum[u], val[u] = Get(val[u], t), tag[u] += t;&#125;inline void Tag_Tree(int u, Tag t, int type) &#123; if (!u) return; T_sum[u] += t, T_tag[u] += t; if (!in[u] &amp;&amp; type) Tag_Line(u, t); else A_sum[u] = sum[u] + T_sum[u];&#125;inline void Pushdown(int u) &#123; if (!u) return; if (rev[u]) Rev(ch[0][u]), Rev(ch[1][u]), rev[u] = 0; if (!in[u] &amp;&amp; tag[u].marked()) Tag_Line(ch[0][u], tag[u]), Tag_Line(ch[1][u], tag[u]), tag[u] = Tag(); if (T_tag[u].marked()) &#123; Tag_Tree(ch[0][u], T_tag[u], 0), Tag_Tree(ch[1][u], T_tag[u], 0); Tag_Tree(ch[2][u], T_tag[u], 1), Tag_Tree(ch[3][u], T_tag[u], 1), T_tag[u] = Tag(); &#125;&#125;inline void Pushup(int u) &#123; T_sum[u] = Data(); for (int i = 0;i &lt;= 1;i++) if (ch[i][u]) T_sum[u] += T_sum[ch[i][u]]; for (int i = 2;i &lt;= 3;i++) if (ch[i][u]) T_sum[u] += A_sum[ch[i][u]]; if (in[u]) sum[u] = Data(), A_sum[u] = T_sum[u]; else &#123; sum[u] = Data(val[u]); for (int i = 0;i &lt;= 1;i++) if (ch[i][u]) sum[u] += sum[ch[i][u]]; A_sum[u] = sum[u] + T_sum[u]; &#125;&#125;inline void Connect(int u, int f, int son) &#123;if (u) fa[u] = f; ch[son][f] = u;&#125;inline void Rotate(int u, int type) &#123; int f = fa[u], tmp = (ch[type + 1][f] == u) + type, ff = fa[f]; if (ff) for (int i = 0;i &lt; 4;i++) if (ch[i][ff] == f) ch[i][ff] = u; fa[u] = ff, Connect(ch[tmp ^ 1][u], f, tmp), Connect(f, u, tmp ^ 1), Pushup(f);&#125;int st[N];inline void Splay(int u, int type) &#123; int now = u, top = 0; st[++top] = now; while (!Isroot(now, type)) st[++top] = now = fa[now]; while (top) Pushdown(st[top--]); for (int f;!Isroot(u, type);Rotate(u, type)) if (!Isroot(f = fa[u], type)) Rotate((ch[type][f] == u) ^ (ch[type][fa[f]] == f) ? u : f, type); Pushup(u);&#125;inline int Create() &#123; int u = rcnt ? rub[rcnt--] : ++ncnt; ch[2][u] = ch[3][u] = 0, in[u] = 1; return u;&#125;inline int Child(int u) &#123; for (int i = 0;i &lt; 4;i++) if (ch[i][fa[u]] == u) return i; return 4;&#125;inline void Add(int x, int y) &#123; if (!y) return; Pushdown(x); for (int i = 2;i &lt;= 3;i++) if (!ch[i][x]) return void(Connect(y, x, i)); while (ch[2][x] &amp;&amp; in[ch[2][x]]) x = ch[2][x], Pushdown(x); int u = Create(); Connect(ch[2][x], u, 2), Connect(y, u, 3), Connect(u, x, 2), Splay(u, 2);&#125;inline void Del(int u) &#123; if (!u) return; Splay(u, 0); if (!fa[u]) return; int f = fa[u]; if (in[f]) &#123; int top = 0, now = f, ff = fa[f]; st[++top] = now; while (!Isroot(now, 2)) st[++top] = now = fa[now]; while (top) Pushdown(st[top--]); if (ff) &#123;int other = ch[Child(u) ^ 1][f]; Pushdown(other), Connect(other, ff, Child(f)), Splay(ff, 2);&#125; rub[++rcnt] = f; &#125; else ch[Child(u)][f] = 0, Splay(f, 0); fa[u] = 0;&#125;inline int Father(int u) &#123; if (!u) return 0; Splay(u, 0); if (!fa[u]) return 0; if (!in[fa[u]]) return fa[u]; int f = fa[u]; Splay(f, 2); return fa[f];&#125;inline int Access(int u) &#123; int ls = 0; for (;u;u = Father(ls = u)) Splay(u, 0), Del(ls), Add(u, ch[1][u]), Connect(ls, u, 1), Pushup(u); return ls;&#125;inline int LCA(int x, int y) &#123;Access(x); return Access(y);&#125;inline int Findroot(int u) &#123; Access(u), Splay(u, 0); while (ch[0][u]) u = ch[0][u]; return u;&#125;inline void Makeroot(int u) &#123;Access(u), Splay(u, 0), Rev(u);&#125;inline void Link(int x, int y) &#123;Makeroot(x), Add(y, x), Access(x);&#125;inline void Cut(int u) &#123;Access(u), Splay(u, 0), ch[0][u] = fa[ch[0][u]] = 0, Pushup(u);&#125; inline void Split(int x, int y) &#123;Makeroot(x), Access(y), Splay(y, 0);&#125;inline void Mark_Line(int x, int y, Tag t) &#123;Split(x, y), Tag_Line(y, t);&#125;inline Data Ask_Line(int x, int y) &#123;Split(x, y); return sum[y];&#125;inline void Mark_Tree(int u, Tag t) &#123; Access(u), Splay(u, 0), val[u] = Get(val[u], t); Tag_Tree(ch[2][u], t, 1), Tag_Tree(ch[3][u], t, 1), Pushup(u), Splay(u, 0);&#125;inline Data Ask_Tree(int u) &#123; Access(u), Splay(u, 0); Data res(val[u]); for (int i = 2;i &lt;= 3;i++) if (ch[i][u]) res += A_sum[ch[i][u]]; return res; &#125;int ed[2][N];template&lt;class T&gt; inline void read(T &amp;x) &#123; x = 0; char c = getchar(); while (c &lt; '0' || c &gt; '9') c = getchar(); while ('0' &lt;= c &amp;&amp; c &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - '0', c = getchar();&#125;int main() &#123; int n, q, rt; read(n), read(q), ncnt = n; for (int i = 1;i &lt; n;i++) read(ed[0][i]), read(ed[1][i]); for (int i = 1;i &lt;= n;i++) read(val[i]), Pushup(i); for (int i = 1;i &lt; n;i++) Link(ed[0][i], ed[1][i]); read(rt), Makeroot(rt); while (q--) &#123; int op, x, y, z; read(op); if (op == 1) read(rt), Makeroot(rt); else if (op == 9) &#123; read(x), read(y); if (LCA(x, y) != x) Cut(x), Link(y, x), Makeroot(rt); &#125; else if (op == 0) read(x), read(y), Mark_Tree(x, Tag(0, y)); else if (op == 5) read(x), read(y), Mark_Tree(x, Tag(1, y)); else if (op == 3) read(x), printf("%d\n", Ask_Tree(x).mn); else if (op == 4) read(x), printf("%d\n", Ask_Tree(x).mx); else if (op == 11) read(x), printf("%d\n", Ask_Tree(x).sum); else if (op == 2) read(x), read(y), read(z), Mark_Line(x, y, Tag(0, z)), Makeroot(rt); else if (op == 6) read(x), read(y), read(z), Mark_Line(x, y, Tag(1, z)), Makeroot(rt); else if (op == 7) read(x), read(y), printf("%d\n", Ask_Line(x, y).mn), Makeroot(rt); else if (op == 8) read(x), read(y), printf("%d\n", Ask_Line(x, y).mx), Makeroot(rt); else read(x), read(y), printf("%d\n", Ask_Line(x, y).sum), Makeroot(rt); &#125; return 0;&#125; 一个疑问 第159行，将Link(y, x)改为Link(x, y)会错，暂时还不知道为什么]]></content>
      <tags>
        <tag>LCT</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>splay</tag>
        <tag>TopTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.17省选模拟]]></title>
    <url>%2F2019%2F04%2F18%2F4-17%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 圈草地 我们只考虑有用的左上角和右下角 考虑两个点$a,b$，如果$a$在$b$的第二象限，那么选择$a$作为左上角一定比选择$b$作为左上角优秀 那么我们将所有有用的点分两层排在一起，第一层是可以作为左上角的点，第二层是可以作为右下角的点 我们考虑当右下角的点移动的时候左上角的最优决策点会如何变化 假如原来的最优决策点是$a$，另一个在$a$右上角的点是$b$，那么我们可以发现，右下角的点移动之后，$b$与之构成的矩形的面积与$a$与之构成的矩形的面积之差变大了 也就是说，移动之后，$b$会变得更加优秀 所以最优决策点是单调向右上角移动的 我们可以采用分治 solve(l, r, L, R)表示右下角的点对应的区间是$[L,R]$，对应的最优决策点的区间是$[l,r]$ 我们找到$l,r$的中点$mid$，二分出右下角那些点的最优决策点在$[l,mid]$中 然后继续分治下去 对于找一个矩形内部有多少个点，可以使用主席树 时间复杂度$O(n\log^3n)$ 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010struct node &#123; int l, r, lson, rson, sum;&#125; T[N * 20];int RT[N], ncnt;int build(int l, int r) &#123; int rt = ++ncnt; T[rt].l = l, T[rt].r = r, T[rt].lson = T[rt].rson = T[rt].sum = 0; if (l == r) return rt; int mid = (l + r) &gt;&gt; 1; T[rt].lson = build(l, mid), T[rt].rson = build(mid + 1, r); return rt;&#125;int update(int rt, int at) &#123; int nw = ++ncnt, l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; 1; T[nw] = T[rt], T[nw].sum++; if (l == r) return nw; if (at &lt;= mid) T[nw].lson = update(T[nw].lson, at); else T[nw].rson = update(T[nw].rson, at); return nw;&#125;int query(int rt1, int rt2, int start, int end) &#123; int l = T[rt2].l, r = T[rt2].r, mid = (l + r) &gt;&gt; 1, res = 0; if (start &lt;= l &amp;&amp; r &lt;= end) return T[rt2].sum - T[rt1].sum; if (start &lt;= mid) res += query(T[rt1].lson, T[rt2].lson, start, end); if (mid &lt; end) res += query(T[rt1].rson, T[rt2].rson, start, end); return res;&#125;struct point &#123; int x, y;&#125; st1[N], st2[N];int ans = 1, top1, top2;inline int query(int a, int b) &#123; int x1 = st1[a].x, y1 = st1[a].y, x2 = st2[b].x, y2 = st2[b].y; return query(RT[x1 - 1], RT[x2], y2, y1);&#125;inline bool check(int l, int r, int x, int mid) &#123; int pos = l, res = 0; for (int i = l;i &lt;= r;i++) if (st1[i].x &lt;= st2[x].x &amp;&amp; st2[x].y &lt;= st1[i].y) &#123; int tmp = query(i, x); if (res &lt;= tmp) res = tmp, pos = i; if (pos &gt; mid) return false; &#125; return res != 0;&#125;void solve(int l, int r, int L, int R) &#123; if (L &gt; R) return; if (l == r) &#123; for (int i = L;i &lt;= R;i++) if (st1[l].x &lt;= st2[i].x &amp;&amp; st2[i].y &lt;= st1[l].y) ans = max(ans, query(l, i)); return; &#125; int mid = (l + r) &gt;&gt; 1, l1 = L, r1 = R, m, pos = l1; while (l1 &lt;= r1) &#123; if (check(l, r, m = ((l1 + r1) &gt;&gt; 1), mid)) pos = m, l1 = m + 1; else r1 = m - 1; &#125; solve(l, mid, L, pos), solve(mid + 1, r, pos + 1, R);&#125;inline void solve2(int l, int r, int L, int R) &#123; for (int i = l;i &lt;= r;i++) for (int j = L;j &lt;= R;j++) if (st1[i].x &lt;= st2[j].x &amp;&amp; st2[j].y &lt;= st1[i].y) ans = max(ans, query(i, j));&#125;int main() &#123; int n; scanf("%d", &amp;n), RT[0] = build(1, n); for (int i = 1, a;i &lt;= n;i++) &#123; scanf("%d", &amp;a), RT[i] = update(RT[i - 1], a); if (a &gt; st1[top1].y) st1[++top1] = (point)&#123;i, a&#125;; else &#123; while (top2 &amp;&amp; st2[top2].y &gt; a) top2--; st2[++top2] = (point)&#123;i, a&#125;; &#125; &#125; if (top1 &lt;= 500 &amp;&amp; top2 &lt;= 500) solve2(1, top1, 1, top2); else solve(1, top1, 1, top2); printf("%d\n", ans);&#125; T2 道路修建 容易发现一个结论：对于一个点$u$，假设它与$v$相连，那么它距离一号城市的最短路距离$d_u$一定满足$d_v-1\leq d_u\leq d_v+1$ 那么我们可以通过这个建图跑网络流 将每个点拆成$n$个点，第$x$个点表示当前点的最短路是否大于等于$x-1$ 将第一个拆出来的点与源点连一条$\infty$的边，将最后一个拆出来的点与汇点连一条$\infty$的边 将第$i$个拆出来的点向第$i+1$个点连一条权值为题中给出公式的边 最小割中，与$S$集合连接代表为true，否则为false 为了满足$d_v-1\leq d_u\leq d_v+1$这个限制，我们可以模仿切糕这道题的做法 对于任意两个有边相连的点$u,v$，$u$拆出来的第$i$个点向$v$拆出来的第$i-1$个点连一条无法割掉的$\infty$ 的边 注意$(u,v)和(v,u)$是不一样的 T3 美术作业 可以看出，这是一个基环外向树 我们先考虑一棵树的情况：如何求它的染色方案 由于边是有向的，所以置换对答案的影响只有可能是对于$u$这个点，它有一些子树是完全同构的 比如这样 注意到如果$2,3,4$这几个点互换编号，那么结构是不变的 比如“2染颜色1，3染颜色1，4染颜色2”这种方案与“2染颜色2，3染颜色1，4染颜色1”是完全等价的 而不同构的子树之间是没有关系的 那么对于这种同构的情况怎么办呢 由于$2,3,4$都是同构的，所以它们的染色方案一定都一样，我们假设有$f$种方案，有$t$棵子树 我们将这$f$种染色方案分别编号为$1,2\cdots,f$，对于这些同构的子树按照根节点的编号排序 然后在这$f$种方案中选出$t$种，可以重复，然后按照从小到大的顺序依次给这些同构的子树染色，这样统计出来的结构一定不会重复 等价于将$t$个球放入$f$个盒子，每个盒子可以空 所以方案数为$$f{f+t-1\choose f-1}=f{f+t-1\choose t}$$现在我们求出了环上每棵树的染色方案 我们来考虑环的置换 对于一种置换后的不动点，它们对应树的结构必须相同，染的颜色也必须相同 所以对于每棵树最后得到的hash值我们跑一个KMP，求出它的最小循环节，这样每次转的次数一定是循环节长度的倍数 每个循环节我们将它看作一个点，染色方案为它包含的树的染色方案的乘积 然后就是普通polya了，枚举转多少次，然后不动点个数就是每个循环节的方案的$gcd(总长度，转的次数)$次方 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010#define LL long long#define uLL unsigned long longconst int mod = 1e9 + 7;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;int frac[N], inv[N];inline int C(int n, int r) &#123; int res = inv[r]; for (int i = 1;i &lt;= r;i++) res = (LL)res * (n - i + 1) % mod; return res;&#125;struct edge &#123; int to, next;&#125; e[N * 2];int head[N], ecnt, dp[N], tmp[N], m;uLL P = 233, h[N], s[N];inline void adde(int from, int to) &#123; e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;&#125;int nxt[N];inline int KMP(int n) &#123; for (int i = 2;i &lt;= n;i++) &#123; int ls = nxt[i - 1]; while (ls &amp;&amp; s[ls + 1] != s[i]) ls = nxt[ls]; nxt[i] = ls + (s[ls + 1] == s[i]); &#125; return n % (n - nxt[n]) ? -1 : n - nxt[n];&#125;void dfs(int u, int f) &#123; int top = 0; for (int i = head[u];i;i = e[i].next) if (e[i].to != f) dfs(e[i].to, u); for (int i = head[u];i;i = e[i].next) if (e[i].to != f) tmp[++top] = e[i].to; sort(tmp + 1, tmp + top + 1, [](int a, int b)&#123;return h[a] &lt; h[b];&#125;), h[u] = 7; for (int i = 1;i &lt;= top;i++) h[u] = ((h[u] * P + h[tmp[i]]) ^ h[tmp[i]]) + h[tmp[i]]; dp[u] = m; for (int i = 1, last;i &lt;= top;i = last) &#123; for (last = i;last &lt;= top &amp;&amp; h[tmp[last]] == h[tmp[i]];last++); dp[u] = (LL)dp[u] * C(dp[tmp[i]] + last - i - 1, last - i) % mod; &#125;&#125;int gcd(int a, int b) &#123;return b ? gcd(b, a % b) : a;&#125;int to[N], vis[N], cir[N], mark[N];int main() &#123; int n, tot = 0; scanf("%d%d", &amp;n, &amp;m), frac[0] = inv[0] = 1; for (int i = 1;i &lt;= n;i++) frac[i] = (LL)frac[i - 1] * i % mod, inv[i] = Pow(frac[i], mod - 2); for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;to[i]); for (int i = 1, j;i &lt;= n;i++) &#123; if (vis[i]) continue; for (j = i;!vis[j];j = to[j]) vis[j] = i; if (vis[j] != i) continue; for (;!mark[j];j = to[j]) mark[j] = 1, cir[++tot] = j; &#125; for (int i = 1;i &lt;= n;i++) if (!mark[i]) adde(to[i], i); for (int i = 1;i &lt;= tot;i++) dfs(cir[i], 0), s[i] = h[cir[i]]; int zjk = KMP(tot), ans = 0; if (~zjk) &#123; int f = 1; for (int i = 1;i &lt;= zjk;i++) f = (LL)f * dp[cir[i]] % mod; for (int i = 1;i &lt;= tot / zjk;i++) ans = (ans + Pow(f, gcd(i, tot / zjk))) % mod; printf("%d\n", (LL)ans * Pow(tot / zjk, mod - 2) % mod); &#125; else &#123; ans = 1; for (int i = 1;i &lt;= tot;i++) ans = (LL)ans * dp[cir[i]] % mod; printf("%d\n", ans); &#125;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>数据结构</tag>
        <tag>分治</tag>
        <tag>字符串</tag>
        <tag>置换</tag>
        <tag>主席树</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SCOI2019 游记]]></title>
    <url>%2F2019%2F04%2F14%2FSCOI2019-%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[写在之前的话感觉NOIP之后就有点没救了，之后冬令营全机房都去了 425分有点凉凉 不过可以试试冲E类 赶紧复习一下exBSGS, exCRT, Cipolla 朱刘算法懒得看了 Day0比赛之前发了一个笔试考察范围，结果是去年NOI的笔试题库 本来以为要考什么神仙内容，结果笔试及其简单 重点是连题目顺序都和题库一样 笔试时间是一个小时，结果30分钟可以走人的时候我在的这个考室已经没人了 感觉只要看了题库就应该是100分吧（雾 话说电子科大的教学楼上“电子科技大学”这几个字看起来好像电子神技大学 晚上看卢爷颓风暴英雄 Celeste真好玩 Day1路上单向模ZJK 我自闭了 我爆零了 来机房看神仙 rank $10^9+7$ 结果每次考完之后都rank 1 这是某些选手的真实写照 拿到试题之后解压，嗯？密码是一串数字 先看T1，那个图片有点劣质啊。。。 貌似是用mspaint画的 不过还将就 手玩了一下样例，好像找到了一点规律的样子 开考5分钟找工作人员要了几张纸 上个厕所冷静一下，顺便思考一下T1 嗯？这不是SB题吗，只要不是划水选手都会做吧。。。 对于最有步数，显然有$$f_m=3f_{m-1}+n-1$$然后随便分治一下就行了 一发过掉大样例 题目中说$Q_i$小于等于答案的上限，然而又没说上限是多少 感觉有阴谋 保证答案小于等于30，有什么用呢 意思是$Q_i\leq (n-1)*3^{30}$吗 然后发现显然是假的，$Q_i$可以达到$3^{1000}$ 手写高精度！ T2的名字叫“肯赛训练” 这里是否有肯德基强行打广告的成份 思考了一下，感觉那个边权是假的 所以是个区间求重心？不会啊 先写暴力吧，好像很莫队的样子 加一个点很好处理，新的重心一定在原来的重心与加的点的连线上 貌似LCT维护虚子树信息可以做到$\log$? 于是开始码LCT，做好了6kb的准备 码了2kb的时候 woc?加点可以直接$\log$，那删点怎么办？ 冷静一下 这个东西好像不是很好维护的样子，干脆暴跳吧 好像加点之后重心的移动次数是$O(\log)$的 先码一个树状数组 代码还是挺简单的 我的程序跑得巨慢无比 30s后过了大样例 来看T3 好像很多项式的样子 卷积的运算符是乘？是不是可以原根什么的啊 然后发现显然不是 还好暴力分给得很足 直接一行代码有5分 剩下的直接暴力数论分块可以再拿25分 貌似有两个$q=1$的点 欸是不是可以爆搜然后乘一个排列数啊 写完之后发现T成SB了 这个时候离考试结束大概还有10分钟 再来检查一下T1吧 手输了一组极限数据 wtf?RE? 赶紧看一下 还好在最后一分钟的时候发现是高精板子错了 那个高精乘的时候我是边乘边取模233 所以最后估分$100+[30-50]+30$? 莫队的分数很玄学的 ZJK说他T1可能会被卡常，然后期望$50+50+50$ ZYW貌似切了T2的60分 都好强啊 很不幸，我面试是第6轮，也就是最后一轮 本来以为要考什么小学奥数，结果是政治问题？（雾 Bh是第一轮，他说他们那组的面试题目是评论中美贸易战 hxy的题目是七中食堂事件 还有什么国民党为什么会失败 好有趣啊 4：10之前一直在楼梯上坐着 看陈爷玩炉石 经过漫长的等待，终于轮到我了 感觉我们这组只有我一个初中的 拿到题目：如何评价近年来自主招生政策遭到限制？ 开始10分钟讨论 丝毫没有面试经验 10分钟之后 考官：之前我提出的要求是讨论并选出一位代表发言，但是10分钟已经过去了，你们却没有选出一位代表 我们：。。。 考官：从面试的角度来说，你们这次讨论是失败的 我们：。。。 考官：现在再给你们一次机会，选出一个代表发言 显然不是我了2333 感觉面试是不是有点凉啊 晚上来看成绩 嗯？$60+45+30?$ T1的高精度果然T了啊 如果把11位压到17位应该就不会超时了 还是太菜了 orz陈爷180 ZYW165，看来她进E类稳了 ZJK好像有点爆炸？只有100，但是如果算上NOIP的话还是在我前面 看了看此时的加权成绩，rk21，好像有点凉？ 明天加油吧 Day2考前陈爷口胡动态SA，感觉他A类很稳 拿到试题，密码又全是数字 先看T1 好像很模板的样子 感觉那个分成两半部分，再取一个部分的操作没啥用 如果根据询问把每个点变一下，那不是最大子段和吗？ 50pts get 如果要动态的话，线段树维护凸包？？？ 反正这种东西我是很难写出来的 那线段树维护矩阵？？？ 好像不是 两个自变量有点不爽，可以去掉一个 等等，前缀和之后好像是个很裸的斜率优化 15分钟码完，代码只有2kb。。 对拍了上万组数据，感觉很稳 来看T2 哇，这是论文题欸！ 去年国家集训队论文，有一个“解决树上连通块问题的一些技巧和工具” 原题啊！！！！ 具体方法是利用“边数 = 点数 - 1”这个等式来容斥 枚举某个点作为$x$的方案数，减去某条边两个端点都是$x$的方案数 然后就切了？？？ 跑一下大样例 嗯？输出负数？改成long long 嗯？还是负数，看看答案 woc？答案怎么这么小 举手向监考老师求助 我：第二道题有模数吗 老师：题目中写了吗 我：没有啊，但是大样例无论如何都不可能这么小 老师：这个。。。你自己认真读题吧 我：&amp;#fsdl&amp;DFfd*#$jkrhf29873Q@!Rds 不久之后更正通知下来了，模数是$10^9+7$ 改一下程序，过了！很好 开始看T3 这看上去很线性基 事实上线性基的确可以获得20分的好成绩 思考了一下感觉没有发现什么好的性质，果断写暴力 前20分直接暴力，后面20分线性基，然后还有20分貌似是找规律？ 好像是$2^{不同数的个数}$的样子？ 写！ 11：00的时候我就码完了 T1仍然没有拍出错 前面好像有个七中大佬在玩纸牌？ 我默默地点开了扫雷 2min后 太不友好了！ 还是试试虚拟机吧 结果打开虚拟机让我的电脑卡了一会儿 无聊打了一个程序模ZJK 之后看了看各个IDE的作者信息 坐了2h后考试结束了 所以我今天估分$100+100+60?$感觉翻盘有望？ ZJK和ZYW都估分$100+40+40$ ZYW说她T1是在线，是在凸包上二分 蒟蒻只会离线 下午拿到成绩，前两道题确实是100，但是第三题只有40，总分240 看来是规律假了 不过，我竟然是rk 1？ ZYW和ZJK确实是180，E类稳了 BH有点神仙啊，切了T2，但是T1爆零了，本来是很有希望的 坐看卢爷翻盘240，orz 事实证明考前无聊的时候看看论文总是有用的 预祝陈爷NOI取得好成绩！ 后记如果不是第二天的成功翻盘，我有可能进不了E类 感觉这次我们学校进步好大啊，去年只有一个省队 强者都上了400分orz 想起去年我失败的SCOI，想要了解详情可以知乎搜索SCOI2018 希望我能够坚持到最后 NOI2019见 补充：关于题意D1T1 小红球的跳跃有$m$个小红球，$n$个空岛。其中第一个、最后一个空岛以及中间的第$k$个空岛是固定的$(1&lt;k&lt;n)$是固定的，其余空岛是悬浮的。一开始所有小红球都在第一个空岛，你的目标是把他们都移动到最后一个空岛，并且使用的步数尽量小。 每回合你可以移动一个小红球到它左边或者右边的那个平台，但是有一些限制： 移动的小红球必须是移动前/移动后它所在的平台上编号最小的。 如果一个小红球移动到了一个浮动平台上，那下一回合必须将这个小红球移走，否则它就会掉下去。 有$q$个询问，每次给出一个时刻，你需要回答在最优方案中，这个时刻正在跳跃的是哪个小红球。 保证答案小于$30$，$n\leq 10^8,m\leq1000,q\leq5000$，时限$1$s 保证询问给出的时刻小于等于最优方案数 部分分： 对于$20\%$的数据，保证$m,n,q\leq10$ 对于$50\%$的数据，保证$n\leq 10^8,m\leq 10,q\leq 5000$ D1T2 肯赛训练给出一棵树，$n$个节点，每条边有边权$c_i$。 给出一个点的序列，这个序列有$m$个数，第$i$个数$a_i$代表编号为$a_i$的点 有$q$个询问，每次询问给出一段区间$[l,r]$，你要在树上选出一个点，使得这个点离$a_l,a_{l+1},\cdots,a_{r}$的距离之和尽量小，输出这个点的编号 注意，选出的点不一定是$a_{l},a_{l+1},\cdots,a_r$其中的某一个 保证$n\leq 3*10^5,c_i\leq 1000,m\leq5*10^5,q\leq10^6$，区间的长度是奇数，时限$3$s 部分分： 对于前$20\%$的数据，保证$n,m,q\leq2*10^3$ 对于前$35\%$的数据，保证$m,q\leq2*10^3$ 对于前$60\%$的数据，保证$n,m,q\leq10^5$ 对于另$15\%$的数据，保证每个点的度数不超过$2$ D1T3 超矩形给出一个数$n$，你需要找到$k$个数$a_1,a_2,\cdots,a_k$使得$\prod_{i=1}^ka_i\leq n$ 给出一个变换$b_1,b_2,\cdots,b_k$，保证$b_i&lt;10$ 你需要求出$$\sum_{所有合法的方案}\prod_{i=1}^ka_i^{b_i}\pmod {998244353}$$ 多组数据（$t$组） 保证$n\leq10^6,\sum k\leq10^6,t\leq100$，时限$4$s 给出$b$的方式是$q$个$s_i,r_i$，表示有连续$r_i$个$b_i$是$s_i$ 保证$s_i$互不相同，$q&lt;5$ 部分分： 对于前$10\%$的数据，保证$k=1,q=1,s=0$ 对于前$20\%$的数据，保证$k=1,q=1,s\leq1$ 对于前$30\%$的数据，保证$k\leq2,q\leq2$ 对于另$20\%$的数据，保证$q=1$ D2T1 湖之精灵的游戏一个二维平面上有$n$个点，第$i$个点的坐标是$(x_i,y_i)$，你要和一位神仙玩游戏。 每次神仙会告诉你一个坐标$(x,y)$，连一条经过$(0,0),(x,y)$的直线，这会把平面分成两个部分$A,B$ 你要选择一个区间$[l,r]$，那么计算的时候只会考虑编号在$[l,r]$之内的点 一个半平面的价值是这个半平面中，编号在$[l,r]$范围内的点与$(0,0),(x,y)$组成三角形的面积之和 你要选择一个半平面，神仙会选择另一个半平面，你想要使得你得到的价值减去神仙得到的价值的结果尽量大 有$m$轮游戏，对于每轮游戏输出这个最大值乘以$2$的结果 保证$n,m\leq 10^6$，$1\leq x,y\leq1000$，时限$2$s 部分分： 对于$20\%$的数据，$n,m\leq200$ 对于$50\%$的数据，$n,m\leq 10^4$ D2T2 RGB有一棵树，$n$个节点，每条边有边权$c_i$，每个点的颜色为R,G,B三种颜色之一 你要统计有序对$(U,V)$的数量，其中$U,V$是两个点集 它还需要满足以下条件： $U$和$V$都必须是连通的 $U$的颜色只能是红色或者绿色，$V$的颜色只能是绿色或者蓝色 存在一个$U,V$均包含的点$x$，使得对于所有在$U,V$集合中的点$y$，有$dis(x,y)\leq w$ 保证$n\leq 2000,w\leq10^7,c_i\leq10^6$，时限$1$s，对$10^9+7$取模 部分分： 对于$30\%$的数据，$n\leq 15$ 对于另$10\%$的数据，只有一个G 对于另$20\%$的数据，树是一条链 D2T3 函数有$n$个数$v_1,v_2,\cdots,v_n$，现在有一类函数$f_T(x)$，其中$T$是$V$的一个子集，它的定义是$$f_T(x)=\bigoplus_{v_i\in T}(x+v_i)\\\f_\emptyset(x)=0$$我们称两个函数$f_s,f_t$是$W-$本质不同的，当且仅当存在一个$0\leq x\leq W$，使得$f_s(x)\not=f_t(x)$ 问在这$2^n$个函数中，有多少函数是$W-$本质不同的 保证$n,w,v_i&lt; 2^{17}$，时限$1$s 部分分： 对于$20\%$的数据，$n\leq15,w\leq10$ 对于另$20\%$的数据，$w=0$ 对于前$70\%$的数据，$n,w,v_i\leq2^{10}$]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二次剩余]]></title>
    <url>%2F2019%2F04%2F09%2F%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99%2F</url>
    <content type="text"><![CDATA[若方程$x^2\equiv a\pmod p$有解，那么称$a$为$p$的二次剩余，否则$a$为$p$的非二次剩余 勒让德符号及欧拉判别法定义勒让德符号为$$\left(\frac{a}{p}\right)=\begin{cases}1&amp;a为p的二次剩余\\ -1&amp;a为p的非二次剩余\\ 0 &amp;a能被p整除\end{cases}$$ 欧拉判别法就是：如果$a$不能被$p$整除，那么有$$\left(\frac{a}{p}\right)=a^{\frac{p-1}{2}}$$ 定理1 对于方程$x^2\equiv a\pmod p$ ，共有$\frac{p-1}{2}$个不同的$a$使得该方程有解 我们忽略$x=0$，如果枚举$x$再求出$a$，那么$x$一共有$p-1$个不同的值，也就产生了$p-1$个$a$ 我们知道一个二次剩余恰好会产生两个解，那么这$p-1$个$a$就被分配到了$\frac{p-1}{2}$个不同的桶里面 所以共有$\frac{p-1}{2}$个$a$ 定理2 $(x+y)^p\equiv x^p+y^p\pmod p$ 我们将其二项式展开$$(x+y)^p=\sum_{i=0}^p{p\choose i}x^iy^{p-i}$$当$i\not=0$且$i\not=p$时，$p\choose i$一定包含因数$p$，所以可以忽略 只剩下第一项和最后一项 Cipolla算法现在要求出方程$x^2\equiv n\pmod p$的一个解 我们找出一个$a​$，使得$(a^2-n)^{\frac{p-1}{2}}\equiv-1\pmod p​$ 设$\omega=\sqrt{a^2-n}$ 结论：$x=(a+\omega)^{\frac{p+1}{2}}$ 证明如下： 我们知道 $$(a^2-n)^{\frac{p-1}{2}}\equiv-1\pmod p\Rightarrow (\omega^2)^{\frac{p-1}{2}}\equiv -1\pmod p\\\\omega^{p-1}\equiv -1\pmod p$$ 那么有$$\begin{aligned}x&amp;\equiv (a+\omega)^{\frac{p+1}{2}}\\\x^2&amp;\equiv (a+\omega)^{p+1}\equiv(a+\omega)^p(a+\omega)\\\&amp;\equiv(a^p+\omega^p)(a+\omega)\\\&amp;\equiv(a-\omega)(a+\omega)\\\&amp;\equiv a^2-\omega^2\equiv a^2-a^2+n\equiv n\end{aligned}$$我们可以通过实现一个类似复数的结构体来进行运算 由于$p$的二次剩余一共有$\frac{p-1}{2}$个，而$a$在$[0,p)$中随机选取 那么成功的概率就是$\frac{1}{2}$ 此时答案中$\omega$部分的系数必然为0]]></content>
      <tags>
        <tag>数学</tag>
        <tag>算法</tag>
        <tag>二次剩余</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BSGS及其拓展]]></title>
    <url>%2F2019%2F04%2F09%2FBSGS%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95%2F</url>
    <content type="text"><![CDATA[BSGS解高次同余方程$$A^x\equiv B\mod C且A\bot B$$根据费马小定理，我们直到$A^{C-1}\equiv B\mod C$ 那么如果这个方程有解，那么解的周期一定不会大于$C$，所以必然存在一个不大于$C$的解 如果$C$比较小，那么我们可以直接枚举$x$然后暴力判断 考虑$C$比较大的情况，这时就需要使用BSGS了 我们设$x=i*m-j$，其中$j&lt;m$，这个$m$是一个常量，我们设为$\sqrt{C}$ 那么有$$A^{i*m-j}\equiv B\mod C\\\A^{i*m}\equiv B*A^j\mod C$$我们开一个map，枚举$j$，将$B*A^j$放到这个map里面 然后我们枚举$i*m$，在map中查找是否存在$A^{i*m}​$即可 注意这样枚举是取不到$x=0$的，这种情况我们需要特判 如果$i*m$此时已经大于$C$了，那么就无解 代码如下 12345678910unordered_map&lt;int, int&gt; s;inline int BSGS(int A, int B, int C) &#123; if (B % C == 1) return 0; s.clear(); int m = ceil(sqrt(C)), ls = 1; for (int i = 0;i &lt; m;i++, ls = (LL)ls * A % C) s[(LL)B * ls % C] = i; for (int i = m, t = ls;i &lt;= C;i += m, t = (LL)t * ls % C) if (s.count(t)) return i - s[t]; return -1;&#125; exBSGS同样是解上面那个方程 但是如果$A,C$不互质呢 原方程等价于$$A^x+Cy=B$$我们不停地消去$A,C$的非1因子，可以使得方程变为$$aA^z+C’y=B’$$每消去一次，我们就从$A^x$里面拿一个$A$出来，消完之后乘到系数$a$里面去 注意在消去过程中时，如果存在某个时刻使得$a=B’$，那么直接返回此时的消去次数就可以了 如果在消去过程中，$B’$没有当前要消去的那个因子，那么直接返回$-1$ 我们设消去次数为$k$ 那么此时方程就变成了$$aA^z\equiv B’\mod C’(A\bot C’)$$使用普通的BSGS可以解出$z$，注意此时前面还有一个系数$a$ 最后我们将解出的$z$加上$k$即可，因为最开始拿出了$k$个$A$来消去因数 代码如下 123456789101112131415161718192021int gcd(int a, int b) &#123;return b ? gcd(b, a % b) : a;&#125;unordered_map&lt;int, int&gt; s;inline int BSGS(int A, int B, int C, int basic) &#123; if (B % C == basic) return 0; s.clear(); int m = ceil(sqrt(C)), ls = 1; for (int i = 0;i &lt; m;i++, ls = (LL)ls * A % C) s[(LL)B * ls % C] = i; for (int i = m, t = (LL)ls * basic % C;i &lt;= C;i += m, t = (LL)t * ls % C) if (s.count(t)) return i - s[t]; return -1;&#125;inline int exBSGS(int A, int B, int C) &#123; int a = 1, cnt = 0, d; A %= C, B %= C; while ((d = gcd(A, C)) != 1) &#123; if (B % d) return -1; a = (LL)a * (A / d) % C, C /= d, B /= d, cnt++; if (a == B) return cnt; &#125; int res = BSGS(A, B, C, a); return ~res ? res + cnt : -1;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>算法</tag>
        <tag>BSGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12省联考2019 字符串问题]]></title>
    <url>%2F2019%2F04%2F08%2F12%E7%9C%81%E8%81%94%E8%80%832019-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题面题意给出一个字符串$S$， 现在要选取它的$n_a$个子串作为$A$类串，选取$n_b$个子串作为$B$类串 其中第$i$个$A$类串为$S(la_i,ra_i)$，第$i$个$B$类串为$S(lb_i,rb_i)$，$la_i,ra_i,lb_i,rb_i,n_a,n_b$均已给出 现额外给定$m$组支配关系，每组关系$(x,y)$表示第$x$个$A$类串支配第$y$个$B$类串 求出一个长度最大的字符串$T$，满足$T$是由$A$类串拼接而成的。我们假设$T$被划分成了$t_1,t_2,\cdots,t_k$（都是$A$类串），要求满足对于任意的$i&lt;k$，$t_i$所支配的串中至少有一个是$t_{i+1}$的前缀 题解对于这种要求所求值最大的问题，不是动态规划就是最长路 那么对于这道题显然就只能是最长路了 如果最后构建出来的图有环，那么$T$就可以无限长 否则我们拓扑排序，然后跑一个dp就可以了 首先我们将$S$串翻转，将所有的$A$串与$B$串都翻转 这样限制条件就可以变为我们熟悉的后缀 我们先考虑一种暴力连边方式 每个$A$串建一个点，每个$B$串建一个点 对于$A_i$，将所有是其后缀的$B$连向$A_i$，权值为$|A_i|$ 对于一组支配$(A_i,B_i)$，$A_i$往$B_i$连一条权值为0的边 但是这样最坏会连$n_a*n_b$条边，需要优化 我们考虑这样一种优化方案 对于任意的$A_i,B_i$，如果$B_i$是$A_i$的后缀，那么$B_i$的后缀也是$A_i$的后缀 我们对于$B$单独建一个子图，这个子图需要满足如果$B_i$是$B_j$的后缀，那么所有能走到$B_i$的路径都可以走到$B_j$ 这样的话$A_i$只需要从它包含的那个最长的$B$串后缀连边就可以了 那么什么图满足这个性质呢？ 很明显是parent树 我们建出parent树，然后从父亲往儿子节点连边 因为父亲对应的点一定是儿子的后缀 对于每个串$A_i,B_i$，找到它在树上的位置，这个可以通过倍增实现 实际上我们不需要对于每个串$A$，都找到那个最长的且是它后缀的$B$ 直接从parent树上$A_i$的对应节点往$A_i$连边就可以了 因为这样同样可以保证最长的且是它后缀的$B$可以走到$A_i$ 兴奋地写完，发现第三个样例过不去($-1$) 事实上是我们少考虑了一种情况 parent树上的某个节点可以表示长度在一段区间的串 如果一条路径是从父亲走向儿子，那么当然没有问题，因为此时它代表的串是这个节点所能代表的最短的串 如果有一个串$A_i$以及另一个串$B_j$，它们对应着树上的同一个点 在之前的建图方式中，$B_j$一定能到达$A_i$ 但是如果$|B_j|&gt;|A_i|$呢，显然这种转移是不合法的 解决方法是对于树上的一个点$u$，假如有$a_u$个$A$串挂在上面 那么我们将这些$A$串按照长度从小到大排序，将$u$拆成$a_u+1$个点，第$i$个点往$i+1$个点连边，父亲的最右边那个点往儿子的最左边那个点连边 对于一个串$B$，它就对应着它在树上的那个点所拆成的点中，第一个长度不小于它的点 这样就没有问题了 注意开long long 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;bits/stdc++.h&gt;using namespace std;using P = pair&lt;int, int&gt;;using LL = long long;#define N 200010int LEN;namespace SAM &#123; struct node &#123; map&lt;char, int&gt; next; int link, len; &#125; st[N * 2]; int ncnt, last; inline void init() &#123;st[0].link = -1, st[0].len = ncnt = last = 0, st[0].next.clear();&#125; inline int extend(char c) &#123; int cur = ++ncnt, p; st[cur].len = st[last].len + 1, st[cur].link = 0, st[cur].next.clear(); for (p = last;p != -1 &amp;&amp; !st[p].next.count(c);p = st[p].link) st[p].next[c] = cur; if (p != -1) &#123; int q = st[p].next[c]; if (st[q].len == st[p].len + 1) st[cur].link = q; else &#123; int clone = ++ncnt; st[clone].len = st[p].len + 1, st[clone].next = st[q].next, st[clone].link = st[q].link; for (;p != -1 &amp;&amp; st[p].next[c] == q;p = st[p].link) st[p].next[c] = clone; st[q].link = st[cur].link = clone; &#125; &#125; return last = cur; &#125; inline void debug() &#123; for (int i = 0;i &lt;= ncnt;i++) for (auto v : st[i].next) cout &lt;&lt; "sam: " &lt;&lt; i &lt;&lt; ' ' &lt;&lt; v.second &lt;&lt; ' ' &lt;&lt; v.first &lt;&lt; endl; &#125;&#125;namespace SUF_Tree &#123; struct edge &#123;int to, next;&#125; e[N * 2]; int head[N * 2], ecnt, len[N * 2], fa[18][N * 2]; vector&lt;P&gt; nodes[N * 2]; inline void adde(int from, int to) &#123; e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt; &#125; void dfs(int u, int f) &#123; fa[0][u] = f; for (int i = 1;i &lt;= 17;i++) fa[i][u] = fa[i - 1][fa[i - 1][u]]; for (int i = head[u];i;i = e[i].next) if (e[i].to != f) dfs(e[i].to, u); &#125; inline void init() &#123; for (int i = 0;i &lt;= 2 * LEN;i++) head[i] = 0, nodes[i].clear(), nodes[i].push_back(P(1e9, -1)); ecnt = 0; &#125; inline int find(int u, int l) &#123; int now = u; for (int i = 17;i &gt;= 0;i--) if (fa[i][u]) if (l &lt;= len[fa[i][now]]) now = fa[i][now]; return now; &#125;&#125;char s[N]; int id[N], tot, onT[N], sz[N], onT2[N], na;namespace GRAPH &#123; struct edge &#123;int to, next, w;&#125; e[N * 6]; int head[N * 4], ecnt, ind[N * 4], st[N * 4], top, ncnt; LL dp[N * 4]; inline void adde(int from, int to, int w) &#123; e[++ecnt] = (edge)&#123;to, head[from], w&#125;, ind[to]++, head[from] = ecnt; &#125; inline bool Topsort() &#123; top = 0; queue&lt;int&gt; q; for (int i = 1;i &lt;= ncnt;i++) if (!ind[i]) q.push(i), st[++top] = i; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u];i;i = e[i].next) if (!(--ind[e[i].to])) q.push(e[i].to), st[++top] = e[i].to; &#125; return top == ncnt; &#125; inline void init() &#123; for (int i = 1;i &lt;= ncnt;i++) head[i] = ind[i] = dp[i] = 0; ecnt = 0; &#125; inline LL DP() &#123; LL res = 0; for (int i = top;i &gt;= 1;i--) &#123; int u = st[i]; for (int j = head[u];j;j = e[j].next) dp[u] = max(dp[u], dp[e[j].to] + e[j].w); if (u &lt;= na) res = max(res, dp[u] + sz[u]); &#125; return res; &#125;&#125;vector&lt;int&gt; p[N * 2];void dfs(int u) &#123; p[u].clear(); for (auto v : SUF_Tree::nodes[u]) &#123; p[u].push_back(++tot); if (v.second &gt; 0) onT[v.second] = tot; &#125; for (int i = 0;i + 1 &lt; p[u].size();i++) GRAPH::adde(p[u][i], p[u][i + 1], 0); for (int i = SUF_Tree::head[u];i;i = SUF_Tree::e[i].next) &#123; dfs(SUF_Tree::e[i].to); GRAPH::adde(*p[u].rbegin(), *p[SUF_Tree::e[i].to].begin(), 0); &#125;&#125;template &lt;class T&gt; inline void read(T &amp;x) &#123; x = 0; char c = getchar(); while (c &lt; '0' || c &gt; '9') c = getchar(); while ('0' &lt;= c &amp;&amp; c &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - '0', c = getchar();&#125;int main() &#123; int T; read(T); while (T--) &#123; scanf("%s", s + 1), LEN = strlen(s + 1), reverse(s + 1, s + LEN + 1), SAM::init(), SUF_Tree::init(); for (int i = 1;i &lt;= LEN;i++) id[i] = SAM::extend(s[i]);// cout &lt;&lt; SAM::ncnt &lt;&lt; endl; for (int i = 1;i &lt;= SAM::ncnt;i++) SUF_Tree::adde(SAM::st[i].link, i), SUF_Tree::len[i] = SAM::st[i].len; SUF_Tree::dfs(0, 0); read(na), tot = na;// cout &lt;&lt; "ok" &lt;&lt; endl; for (int i = 1, l, r;i &lt;= na;i++) &#123; read(l), read(r), l = LEN - l + 1, r = LEN - r + 1, swap(l, r), sz[i] = r - l + 1; int t = SUF_Tree::find(id[r], r - l + 1); SUF_Tree::nodes[t].push_back(P(r - l + 1, i)); &#125; GRAPH::ncnt = na * 2 + SAM::ncnt + 1, GRAPH::init(); for (int i = 1;i &lt;= SAM::ncnt;i++) sort(SUF_Tree::nodes[i].begin(), SUF_Tree::nodes[i].end()); dfs(0); for (int i = 1;i &lt;= na;i++) GRAPH::adde(onT[i], i, sz[i]); int nb; read(nb); for (int i = 1, l, r;i &lt;= nb;i++) &#123; read(l), read(r), l = LEN - l + 1, r = LEN - r + 1, swap(l, r); int t = SUF_Tree::find(id[r], r - l + 1); int pos = lower_bound(SUF_Tree::nodes[t].begin(), SUF_Tree::nodes[t].end(), P(r - l + 1, -2)) - SUF_Tree::nodes[t].begin(); onT2[i] = p[t][pos]; &#125; int matches; read(matches); for (int i = 1;i &lt;= matches;i++) &#123; int a, b; read(a), read(b), GRAPH::adde(a, onT2[b], 0); &#125; GRAPH::ncnt = tot; if (!GRAPH::Topsort()) &#123;puts("-1"); continue;&#125; printf("%lld\n", GRAPH::DP()); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>优化连边</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BJOI2018 双人猜数游戏]]></title>
    <url>%2F2019%2F04%2F07%2FBJOI2018-%E5%8F%8C%E4%BA%BA%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题目链接 神仙题啊 首先来模拟一下样例 Alice知道乘积是60，Bob知道和是16，且两个数均不小于5 Bob：此时两个数有可能为 $(5, 11), (6, 10), (7, 9), (8, 8)$ 而Bob在第一轮没有猜出来，也就是说，这两个数的和不是10或11 Alice：此时两个数有可能为 $(5, 12), (6, 10)$ 由于Alice也没有猜出来，所以对于Bob来说，以下情况就被排除了 $(5, 11), (7, 9), (8, 8)$ 对于$(5, 11)$而言，55只有这一种分解方式，而Alice在第一轮中没有猜出来，所以不是 对于$(7, 9)$而言，63还可以被分解成$(3, 21)$，但是不满足两个数都大于等于5，而Alice没有猜出来，所以也不是 $(8, 8)​$同理 所以对于Bob来说，这两个数只有可能是$(6, 10)$，他也就确定了答案 Alice知道，Bob已经猜出来了，所以$(5, 12)$就被排除了，因为在这种情况下，$Bob​$不可能这么早就猜出答案 所以Alice也知道答案是$(6, 10)​$了 我们用dp来描述这个过程，dp[i][n][m]表示，当前是第i轮，且两个答案分别是$n,m$，在$1-i​$轮中，是否能决定答案 如果这一轮是Bob猜，那么我们就枚举$n+m$的划分方式。如果每一种合法的划分方式都能在$1-(i-1)$轮被猜出来，那么Bob一定能确定这两个数分别为$n, m$ 否则，我们则枚举$n*m$的约数， 判断方式与Bob的相同 但是这样可能会出现一种特殊情况，就是已经到了$t$轮，第一个人猜出来了，而第二个人没有猜出来 那么我们就多进行一轮转移，这次转移与之前的转移相反，如果每一种合法的划分方式在$1-t$轮都不能被猜出来，那么才能确定答案 $n,m$的最大值不会超过500，直接枚举 直接交程序，数组只开500的话是秒跑 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;#define N 500int dp[N + 10][N + 10][16], m;inline bool check1(int a, int b, int c) &#123; int cnt = 0, tmpa, tmpb; for (int i = m, j;i &lt;= a + b - i &amp;&amp; cnt &lt; 2;i++) if (!dp[i][j = a + b - i][c - 1] || c == 1) cnt++, tmpa = i, tmpb = j; return cnt == 1 &amp;&amp; a == tmpa &amp;&amp; b == tmpb;&#125;inline bool check2(int a, int b, int c) &#123; int cnt = 0, tmpa, tmpb; for (int i = m, j;i * i &lt;= a * b &amp;&amp; cnt &lt; 2;i++) if (a * b % i == 0 &amp;&amp; (!dp[i][j = a * b / i][c - 1] || c == 1)) cnt++, tmpa = i, tmpb = j; return cnt == 1 &amp;&amp; a == tmpa &amp;&amp; b == tmpb;&#125;inline bool check3(int a, int b, int c) &#123; int cnt = 0, tmpa, tmpb; for (int i = m, j;i &lt;= a + b - i &amp;&amp; cnt &lt; 2;i++) if (dp[i][j = a + b - i][c] &amp;&amp; !dp[i][j][c - 2]) cnt++, tmpa = i, tmpb = j; return cnt == 1 &amp;&amp; a == tmpa &amp;&amp; b == tmpb;&#125;inline bool check4(int a, int b, int c) &#123; int cnt = 0, tmpa, tmpb; for (int i = m, j;i * i &lt;= a * b &amp;&amp; cnt &lt; 2;i++) if (a * b % i == 0 &amp;&amp; dp[i][j = a * b / i][c] &amp;&amp; !dp[i][j][c - 2]) cnt++, tmpa = i, tmpb = j; return cnt == 1 &amp;&amp; a == tmpa &amp;&amp; b == tmpb;&#125;char name[8];int main() &#123; int t, flag; scanf("%d%s%d", &amp;m, name + 1, &amp;t), flag = name[1] == 'B'; for (int i = 1;i &lt;= t + 1;i++) for (int a = m;a &lt;= N / 2;a++) for (int b = a;b &lt;= N;b++) dp[a][b][i] = dp[a][b][i - 2] | (((i &amp; 1) ^ flag ^ 1) ? check1(a, b, i) : check2(a, b, i)); for (int s = m * 2;s;s++) for (int a = m, b = s - a;a * 2 &lt;= s;a++, b = s - a) if (dp[a][b][t + 1] &amp;&amp; !(dp[a][b][t - 1] | dp[a][b][t])) &#123; int tmp = t &amp; 1 ^ flag; if (!(tmp ? check4(a, b, t + 1) : check3(a, b, t + 1))) continue; cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; endl; return 0; &#125;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BJOI2018 二进制]]></title>
    <url>%2F2019%2F04%2F07%2FBJOI2018-%E4%BA%8C%E8%BF%9B%E5%88%B6%2F</url>
    <content type="text"><![CDATA[题目链接 先考虑哪些二进制在重新排列之后可以是3的倍数 我们分3种情况讨论： 0 ：模3的余数是0 10 ：就是1出现在下标为偶数的地方，模3余2 01 ：1出现在下标为奇数的地方，模3余1 那么，我们就可以用这三种余数来进行组合 考虑以下情况： 有偶数个1 ：显然，通过情况2与3组合可以成为3的倍数 有奇数个1 ：注意到3个情况2或者情况3的叠加仍然可以成为3的倍数，而这样至少需要2个0和3个1（10101） 那么综合上面两种情况，我们可以得出结论，一段区间为不合法的区间当且仅当： 区间内只有1个1 区间中有奇数个1且没有0 区间中有奇数个1且有1个0 这道题是带修改的，所以需要将dp放到线段树上统计 那么我们考虑一段区间应该维护什么 首先将第一种情况分开，先不管 那么对于一段区间，我们可以用dp[i][j(0/1)][k(0/1)]表示 即状态为$i$，1的个数是奇数还是偶数，出现了0个0还是1个0的区间总数 线段树pushup的时候子区间也是可以跨mid合并的 具体来说，就是一个左子树的以mid为右端点的区间和一个右子树的以mid + 1为左端点的区间合并 所以，对于状态i，我们这样设计 i = 0 表示不取左端点和右端点 i = 1 表示必须取左端点，不能取右端点 i = 2 表示必须取右端点，不能取左端点 i = 3 表示必须左右端点都取 合并的时候枚举一下有几个0以及1的奇偶性就可以了 我们另外开一个数组，单独统计情况1，也就是只有1个1的区间的数量 转移与上面的类似 g[i][j(0/1)]表示状态为$i$，出没出现1的区间的总数 但是统计的时候不能直接将两个加起来 注意到这两个统计是有重复的，当我们进行第一次统计时也顺便统计了区间内有1个1，只有0/1个0的数量，需要去重 对于有1个1，0个0的区间数量，显然也就是区间内1的数量 对于有1个1，1个0的区间数量，我们用一个树状数组维护，在这个01区间的第一位维护即可 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010#define LL long longstruct Data &#123; LL f[4][2][2], g[4][2]; Data() &#123;memset(f, 0, sizeof(f)), memset(g, 0, sizeof(g));&#125;&#125; T[N &lt;&lt; 2];inline Data UN(Data a, Data b) &#123; Data c; for (int i = 0;i &lt;= 1;i++) &#123; for (int j = 0;j &lt;= 1;j++) &#123; c.f[0][i][j] += a.f[0][i][j] + b.f[0][i][j] + a.f[2][i][j] + b.f[1][i][j]; c.f[1][i][j] += a.f[1][i][j] + a.f[3][i][j], c.f[2][i][j] += b.f[2][i][j] + b.f[3][i][j]; &#125; c.g[0][i] += a.g[0][i] + b.g[0][i] + a.g[2][i] + b.g[1][i]; c.g[1][i] += a.g[1][i] + a.g[3][i], c.g[2][i] += b.g[2][i] + b.g[3][i]; &#125; for (int i = 0;i &lt;= 1;i++) for (int j = 0;j &lt;= 1;j++) &#123; if (i + j &lt;= 1) &#123; c.g[0][i + j] += a.g[2][i] * b.g[1][j], c.g[1][i + j] += a.g[3][i] * b.g[1][j]; c.g[2][i + j] += a.g[2][i] * b.g[3][j], c.g[3][i + j] += a.g[3][i] * b.g[3][j]; &#125; for (int k = 0;k &lt;= 1;k++) for (int l = 0;k + l &lt;= 1;l++) &#123; int ti = (i + j) &amp; 1, tj = k + l; c.f[0][ti][tj] += a.f[2][i][k] * b.f[1][j][l], c.f[1][ti][tj] += a.f[3][i][k] * b.f[1][j][l]; c.f[2][ti][tj] += a.f[2][i][k] * b.f[3][j][l], c.f[3][ti][tj] += a.f[3][i][k] * b.f[3][j][l]; &#125; &#125; return c;&#125;int val[N];void build(int rt, int l, int r) &#123; if (l == r) return void(T[rt].f[3][val[l]][val[l] ^ 1] = T[rt].g[3][val[l]] = 1); int mid = (l + r) &gt;&gt; 1; build(rt &lt;&lt; 1, l, mid), build(rt &lt;&lt; 1 | 1, mid + 1, r); T[rt] = UN(T[rt &lt;&lt; 1], T[rt &lt;&lt; 1 | 1]);&#125;void update(int rt, int l, int r, int at) &#123; if (l == r) &#123; val[l] ^= 1, T[rt] = Data(); T[rt].f[3][val[l]][val[l] ^ 1] = T[rt].g[3][val[l]] = 1; return; &#125; int mid = (l + r) &gt;&gt; 1; if (at &lt;= mid) update(rt &lt;&lt; 1, l, mid, at); else update(rt &lt;&lt; 1 | 1, mid + 1, r, at); T[rt] = UN(T[rt &lt;&lt; 1], T[rt &lt;&lt; 1 | 1]);&#125;Data query(int rt, int l, int r, int start, int end) &#123; if (start &lt;= l &amp;&amp; r &lt;= end) return T[rt]; int mid = (l + r) &gt;&gt; 1; if (end &lt;= mid) return query(rt &lt;&lt; 1, l, mid, start, end); if (start &gt; mid) return query(rt &lt;&lt; 1 | 1, mid + 1, r, start, end); return UN(query(rt &lt;&lt; 1, l, mid, start, mid), query(rt &lt;&lt; 1 | 1, mid + 1, r, mid + 1, end));&#125;int tree[2][N], n;inline void update(int id, int at, int x) &#123;for (;at &lt;= n;at += at &amp; -at) tree[id][at] += x;&#125;inline int query(int id, int at) &#123; int res = 0; for (;at;at -= at &amp; -at) res += tree[id][at]; return res;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;val[i]), update(0, i, val[i]); for (int i = 1;i &lt; n;i++) if (val[i] != val[i + 1]) update(1, i, 1); build(1, 1, n); int q; scanf("%d", &amp;q); while (q--) &#123; int a, b, c; scanf("%d%d", &amp;a, &amp;b); if (a == 1) &#123; if (b != n) update(1, b, -2 * (val[b] != val[b + 1]) + 1); if (b != 1) update(1, b - 1, -2 * (val[b - 1] != val[b]) + 1); update(0, b, -2 * val[b] + 1), update(1, 1, n, b); &#125; else &#123; scanf("%d", &amp;c); Data tmp = query(1, 1, n, b, c); LL res = 0; for (int i = 0;i &lt;= 3;i++) res += tmp.f[i][1][0] + tmp.f[i][1][1] + tmp.g[i][1]; res -= query(0, c) - query(0, b - 1) + query(1, c - 1) - query(1, b - 1); printf("%lld\n", (LL)(c - b + 1) * (c - b + 2) / 2 - res); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>二进制</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFT与NTT专题]]></title>
    <url>%2F2019%2F04%2F07%2FFFT%E4%B8%8ENTT%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[A – 礼物先不管旋转操作，考虑化简这个差异值 $$\begin{aligned}\sum_{i=1}^n(x_i-y_i-c)^2&amp;=\sum_{i=1}^n(x_i-y_i)^2+nc^2-2c\sum_{i=1}^n(x_i-y_i)\\\&amp;=\sum_{i=1}^nx_i^2+\sum_{i=1}^ny_i^2+nc^2-2c\sum_{i=1}^n(x_i-y_i)-2\sum_{i=1}^nx_iy_i\end{aligned}$$ 注意到$\sum x^2+\sum y^2$是常数，先不管 可以发现，这是一个关于$c$的二次函数 那么我们知道，此时$c$的极值点就在$-\frac{b}{2a}$处 所以，我们可以得出$c$的最优值是 $$\frac{\sum_{i=1}^n x_i-\sum_{i=1}^n y_i}{n}$$ 而分子的两个数均与旋转无关 但是$c$只能是整数 所以判一下$c, c-1, c+1$哪个与上面的式子更接近 注意到旋转唯一能改变的是$\sum xy$ 而我们要让这个值尽量小 设 $$F(m)=\sum_{i=1}^nx_iy_{i+m}$$ 我们可以看出，这是一个类似卷积的东西 但是一般的卷积是后两式下标的和不变 而这个是差不变 所以把这个式子变一下 设 $$x_{n-i+1}=x_i$$ 就是将x倒序一下 可以得到 $$F(m)=\sum_{i=1}^nx_{n-i+1}y_{i+m}$$ 不妨设后面$xy$的卷积是$A$，也就是 $$A(n+m+1)=\sum_{i=1}^nx_{n-i+1}y_{i+m}$$ 可以发现，这个$A$就是将$F$整体向右平移了$n+1$ 所以 $$F(m)=A(n+m+1)$$ 为了不丢精度，NTT即可（保证答案不会超过mod） 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010#define LL long longint r[N &lt;&lt; 2]; const int mod = 998244353;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;inline void NTT(int len, int type, int a[]) &#123; for (int i = 0;i &lt; len;i++) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int mid = 2;mid &lt;= len;mid &lt;&lt;= 1) &#123; int Wn = Pow(3, type ? (mod - 1) / mid : mod - 1 - (mod - 1) / mid); for (int i = 0;i &lt; len;i += mid) for (int j = i, w = 1, t;j &lt; i + (mid &gt;&gt; 1);j++, w = (LL)w * Wn % mod) t = (LL)w * a[j + (mid &gt;&gt; 1)] % mod, a[j + (mid &gt;&gt; 1)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod; &#125;&#125;int x[N], y[N], A[N &lt;&lt; 2], B[N &lt;&lt; 2], res[N];template&lt;class T&gt; inline T Abs(const T x) &#123;return x &gt; 0 ? x : -x;&#125;int main() &#123; int n, m, sumx = 0, sumy = 0, sumx2 = 0, sumy2 = 0; scanf("%d%d", &amp;n, &amp;m); for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;x[i]), A[i] = x[i], sumx += x[i], sumx2 += x[i] * x[i]; for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;y[i]), B[2 * n - i] = B[n - i] = y[i], sumy += y[i], sumy2 += y[i] * y[i]; int len = 1, l = 0; while (len &lt;= 3 * n) len &lt;&lt;= 1, l++; for (int i = 1;i &lt;= len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); NTT(len, 1, A), NTT(len, 1, B); for (int i = 0;i &lt; len;i++) A[i] = (LL)A[i] * B[i] % mod; NTT(len, 0, A); int Inv = Pow(len, mod - 2); for (int i = 0;i &lt; n;i++) res[i] = (LL)A[2 * n - i] * Inv % mod; int c = (sumx - sumy) / n; LL ans = 1e18; if (Abs((LL)c * n - sumx + sumy) &gt; Abs(((LL)c * n + n - sumx + sumy))) c++; if (Abs((LL)c * n - sumx + sumy) &gt; Abs(((LL)c * n - n - sumx + sumy))) c--; for (int i = 0;i &lt; n;i++) &#123; LL tmp = (LL)sumx2 + sumy2 - 2 * res[i] - (LL)2 * c * (sumx - sumy) + (LL)n * c * c; if (tmp &lt; ans) ans = tmp; &#125; printf("%lld\n", ans); return 0;&#125; B – 求和我们知道 $$S(n,m)=\sum_{i=0}^m(-1)^i{m\choose i}(m-i)^n\frac{1}{m!}$$ 原理很简单，容斥有几个盒子没有放球，有$m\choose i$种选法，再将$n$个球放入$m-i$个盒子。由于盒子是无序的，最后除以$m$的阶乘 那么我们用这个化简原式 注意到第二个$\sum$的上界是$i$，非常讨厌 由于斯特林数的性质，把这个$i$换成$n$也没有问题 因为当$m&gt;n$时，$S(n,m)=0$ 所以有 $$\begin{aligned}\sum_{i=0}^n\sum_{j=0}^nS(i,j)*2^j*j!&amp;=\sum_{j=0}^n2^j*j!\sum_{i=0}^n\sum_{k=0}^j(-1)^k{j\choose k}(j-k)^i\frac{1}{j!}\\\&amp;=\sum_{j=0}^n2^j*j!\sum_{k=0}^j\frac{(-1)^k}{k!}*\frac{\sum_{i=0}^n(j-k)^i}{(j-k)!}\end{aligned}$$ 注意到后面那个是卷积的形式 第一个多项式很好求，第二个的分子是等比数列 我们设$B$是第二个多项式 显然有 $$B(0)=0, B(1)=n+1$$ 对于其它情况，直接用等比数列求和公式算出来就行了 代码如下 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010#define LL long longint r[N &lt;&lt; 2]; const int mod = 998244353;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;inline void NTT(int len, int type, int a[]) &#123; for (int i = 0;i &lt; len;i++) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int mid = 2;mid &lt;= len;mid &lt;&lt;= 1) &#123; int Wn = Pow(3, type ? (mod - 1) / mid : mod - 1 - (mod - 1) / mid); for (int i = 0;i &lt; len;i += mid) for (int j = i, w = 1, t;j &lt; i + (mid &gt;&gt; 1);j++, w = (LL)w * Wn % mod) t = (LL)w * a[j + (mid &gt;&gt; 1)] % mod, a[j + (mid &gt;&gt; 1)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod; &#125;&#125;int A[N &lt;&lt; 2], B[N &lt;&lt; 2], frac[N];int main() &#123; int n, len = 1, l = 0; scanf("%d", &amp;n); frac[0] = 1; for (int i = 1;i &lt;= n;i++) frac[i] = (LL)frac[i - 1] * i % mod; while (len &lt;= 2 * n) len &lt;&lt;= 1, l++; for (int i = 0;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); A[0] = B[0] = 1, B[1] = n + 1; for (int i = 1;i &lt;= n;i++) A[i] = (i &amp; 1 ? -1 : 1) * Pow(frac[i], mod - 2), A[i] = (A[i] + mod) % mod; for (int i = 2;i &lt;= n;i++) B[i] = ((LL)(Pow(i, n + 1) - 1) * Pow(i - 1, mod - 2) % mod * Pow(frac[i], mod - 2) % mod + mod) % mod; NTT(len, 1, A), NTT(len, 1, B); for (int i = 0;i &lt; len;i++) A[i] = (LL)A[i] * B[i] % mod; NTT(len, 0, A); int Inv = Pow(len, mod - 2); int tmp = 1, res = 0; for (int i = 0;i &lt;= n;i++) res = (res + (LL)tmp * frac[i] % mod * A[i]) % mod, tmp = tmp * 2 % mod; printf("%d\n", (LL)res * Inv % mod); return 0;&#125; C – 序列统计这题的难点在于转化成原根 注意到要求的是所有数的乘积而非和 如果是和的话直接NTT就好了 那么我们就将乘积转化成和的形式 如果两个数都是某个数的某次方，那么这两个数乘起来就是指数相加 而原根恰好可以表示模$m$剩余系下的每个数 所以把每个数转化成原根的某次方就好了 求原根代码 12345678inline int G(int x) &#123; if (x == 2) return 1; for (int i = 2, flg = 1;i;i++, flg = 1) &#123; for (int j = 2;j * j &lt; x;j++) if ((x - 1) % j == 0 &amp;&amp; Pow(i, (x - 1) / j, x) == 1) &#123;flg = 0; break;&#125; if (flg) return i; &#125;&#125; D – 残缺的字符串带通配符的字符串匹配问题 首先考虑不带通配符的怎么做 那么拓展KMP， 后缀数组都可以 但是我们有一个更高级的方法：FFT求字符串匹配 首先我们需要定义“匹配” 所以设差异函数$g(i)$表示从$B$串的$i$位置开始，与$A$串的差异程度 有 $$g(x)=\sum_{i=x}^{x+m-1}(B_i-A_{i-x+1})^2$$ 显然，只有当$A$串从$x$位置开始与$B$串完全相同，$g$的值才为0 化简原式 $$\begin{aligned}g(x)&amp;=\sum_{i=x}^{x+m-1}A_{i-x+1}^2+\sum_{i=x}^{x+m-1}B_i^2-2\sum_{i=x}^{x+m-1}B_iA_{i-x+1}\\\&amp;=\sum_{i=1}^mA_i^2+\sum_{i=1}^mB_{i+x-1}^2-2\sum_{i=1}^mA_iB_{i+x-1}\end{aligned}$$ 前两项可以通过预处理前缀和得出，后面的是一个下标差相等的卷积 那么模仿之前的套路，我们将$A$序列倒序一下再求卷积就行了 解决了不带通配符的问题，再考虑带通配符 这个通配符是可以匹配任意字符的，所以把差异函数改一下 $$g(x)=\sum_{i=x}^{x+m-1}(B_i-A_{i-x+1})^2A_{i-x+1}B_i$$ 当$i$处的字符是$*$时，我们设那个地方的值为0 化简得 $$=\sum_{i=1}^mA_i^3B_{i-x+1}+\sum_{i=1}^mA_iB_{i-x+1}^3-2\sum_{i=1}^xA_i^2B_{i-x+1}^2$$ 做3次FFT即可 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;#define N 300010int r[N &lt;&lt; 2]; const double PI = acos(-1);inline void FFT(int len, int type, complex&lt;double&gt; a[]) &#123; for (int i = 1;i &lt; len;i++) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int mid = 2;mid &lt;= len;mid &lt;&lt;= 1) &#123; complex&lt;double&gt; Wn(cos(2 * PI / mid), type * sin(2 * PI / mid)); for (int i = 0;i &lt; len;i += mid) &#123; complex&lt;double&gt; w(1), t; for (int j = i;j &lt; i + (mid &gt;&gt; 1);j++, w *= Wn) t = w * a[j + (mid &gt;&gt; 1)], a[j + (mid &gt;&gt; 1)] = a[j] - t, a[j] += t; &#125; &#125;&#125;char a[N], b[N]; complex&lt;double&gt; A[N &lt;&lt; 2], B[N &lt;&lt; 2]; int a1[N], b1[N];#define LL long longLL res[N]; vector&lt;int&gt; ans;#define Clear(x) for (int i = 0;i &lt; len;i++) x[i] = 0;inline void mul(int len, int n, int k) &#123; FFT(len, 1, A), FFT(len, 1, B); for (int i = 0;i &lt; len;i++) A[i] *= B[i]; FFT(len, -1, A); for (int i = 1;i &lt;= n;i++) res[i] += k * (LL)(A[i].real() / len + 0.5);&#125;int main() &#123; int n, m; scanf("%d%d%s%s", &amp;m, &amp;n, a + 1, b + 1); for (int i = 1;i &lt;= m;i++) a1[m - i] = a[i] == '*' ? 0 : a[i] - 'a' + 1; for (int i = 1;i &lt;= n;i++) b1[i] = b[i] == '*' ? 0 : b[i] - 'a' + 1; int len = 1, l = 0; while (len &lt;= m + n) len &lt;&lt;= 1, l++; for (int i = 0;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); for (int i = 0;i &lt; m;i++) A[i] = a1[i] * a1[i] * a1[i]; for (int i = 1;i &lt;= n;i++) B[i] = b1[i]; mul(len, n, 1); Clear(A) Clear(B) for (int i = 0;i &lt; m;i++) A[i] = a1[i]; for (int i = 1;i &lt;= n;i++) B[i] = b1[i] * b1[i] * b1[i]; mul(len, n, 1); Clear(A) Clear(B) for (int i = 0;i &lt; m;i++) A[i] = a1[i] * a1[i]; for (int i = 1;i &lt;= n;i++) B[i] = b1[i] * b1[i]; mul(len, n, -2); for (int i = m;i &lt;= n;i++) if (res[i] == 0) ans.push_back(i - m + 1); printf("%d\n", ans.size()); for (auto i : ans) printf("%d ", i); return 0;&#125; E – 万径人踪灭假设当前确定了一个对称中心$i$ 那么当两个位置$j,k$关于i对称且这两个位置的字母相同时对答案有贡献 对称则意味着$j+k=i*2​$，可以FFT 枚举字符，然后FFT 假设这个中心有x对这样的位置 那么每一对都是独立的，可以选也可以不选，但是不能都不选 所以此时的答案为$2^x-1$ 题目要求不能全部连续，那么最后再跑一边manacher，减去全部连续的答案即可 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010#define LL long longint r[N &lt;&lt; 2]; const int mod = 998244353;inline int Pow(int x, int y, int p = mod) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % p) if (y &amp; 1) res = (LL)res * x % p; return res;&#125;inline void NTT(int len, int type, int a[]) &#123; for (int i = 0;i &lt; len;i++) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int mid = 2;mid &lt;= len;mid &lt;&lt;= 1) &#123; int Wn = Pow(3, type ? (mod - 1) / mid : mod - 1 - (mod - 1) / mid); for (int i = 0;i &lt; len;i += mid) for (int j = i, t, w = 1;j &lt; i + (mid &gt;&gt; 1);j++, w = (LL) w * Wn % mod) t = (LL)w * a[j + (mid &gt;&gt; 1)] % mod, a[j + (mid &gt;&gt; 1)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod; &#125;&#125;int A[N &lt;&lt; 2], B[N &lt;&lt; 2], pal[N &lt;&lt; 2], Pow2[N]; char s[N], t[N * 2]; const int p = 1e9 + 7;inline int manacher(int n) &#123; t[0] = '#', t[n * 2 + 1] = '$', t[n * 2 + 2] = '@'; for (int i = 1;i &lt;= n;i++) t[i * 2 - 1] = '$', t[i * 2] = s[i]; int pos = 1, mx = 1, res = 0; pal[1] = 1; for (int i = 2;i &lt;= n * 2;i++) &#123; if (i &lt;= mx) pal[i] = min(mx - i + 1, pal[2 * pos - i]); else pal[i] = 1; while (t[i - pal[i]] == t[i + pal[i]]) pal[i]++; if (i + pal[i] - 1 &gt; mx) mx = i + pal[i] - 1, pos = i; res = (res + pal[i] / 2) % p; &#125; return res;&#125;int main() &#123; scanf("%s", s + 1); int n = strlen(s + 1); for (int i = 1;i &lt;= n;i++) if (s[i] == 'a') A[i] = 1; else B[i] = 1; int len = 1, l = 0, ans = 0; Pow2[0] = 1; for (int i = 1;i &lt;= n;i++) Pow2[i] = Pow2[i - 1] * 2 % p; while (len &lt;= n * 2) len &lt;&lt;= 1, l++; for (int i = 0;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); NTT(len, 1, A), NTT(len, 1, B); for (int i = 0;i &lt; len;i++) A[i] = (LL)A[i] * A[i] % mod, B[i] = (LL)B[i] * B[i] % mod; NTT(len, 0, A), NTT(len, 0, B); int Inv = Pow(len, mod - 2); for (int i = 2, t;i &lt;= n * 2;i++) &#123; t = (LL)(A[i] + B[i]) * Inv % mod + (i &amp; 1 ^ 1); ans = (ans + Pow2[t / 2] - 1) % p; &#125; printf("%d\n", (ans - manacher(n) + p) % p); return 0;&#125; F – 性能优化这道题利用到了FFT的原理 如果模数是质数，那么非常好办 但是这题不仅模数不是质数，而且求的是循环卷积，直接FFT会爆炸 贴一篇我觉得很好的题解 这个rev数组可以模拟FFT的过程，递归地求出来 单位根满足消去律，上面的$F(\omega_n^i)$指的是$i\leq \frac{n}{p}$的情况 对于剩余的情况，有$\omega_{\frac{n}{p}}^i=\omega_{\frac{n}{p}}^{i-\frac{n}{p}}$ 也就是说，代入的$F^{[0]},F^{[1]},\cdots,F^{[p-1]}$都相同，但是系数不同 然后分治就可以了 同样地，最后需要除以len，也就是模数$-1$ 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define N 500010inline int Pow(int x, int y, int mod) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;int tot, prime[N], r[N];int GetPos(int x, int dep, int len, int cnt) &#123; if (dep == tot + 1) return cnt; int tmp = len / prime[dep], s = x % prime[dep]; return GetPos((x - s) / prime[dep], dep + 1, tmp, cnt + tmp * s);&#125;int tmp[N], g;inline void NTT(int len, int a[], int mod, int type) &#123; for (int i = 0;i &lt; len;i++) tmp[r[i]] = a[i]; for (int i = 0;i &lt; len;i++) a[i] = tmp[i]; for (int i = tot, block = 1;i &gt;= 1;i--) &#123; int mid = block; block *= prime[i]; int Wn = Pow(g, type ? (mod - 1) / block : mod - 1 - (mod - 1) / block, mod); for (int j = 0;j &lt; len;j++) tmp[j] = 0; for (int j = 0, Wk = 1;j &lt; len;j += block, Wk = 1) for (int k = 0;k &lt; block;k++) &#123; for (int l = k % mid, w = 1;l &lt; block;l += mid, w = (LL)w * Wk % mod) tmp[j + k] = (tmp[j + k] + (LL)w * a[j + l]) % mod; Wk = (LL)Wk * Wn % mod; &#125; for (int j = 0;j &lt; len;j++) a[j] = tmp[j]; &#125; &#125;inline int GetG(int x) &#123; if (x == 2) return 1; for (int i = 2, flag = 1;i;i++, flag = 1) &#123; for (int j = 2;j * j &lt; x;j++) if (Pow(i, (x - 1) / j, x) == 1) &#123;flag = 0; break;&#125; if (flag == 1) return i; &#125;&#125;int A[N &lt;&lt; 2], B[N &lt;&lt; 2];int main() &#123; int n, C; scanf("%d%d", &amp;n, &amp;C); for (int i = 0;i &lt; n;i++) scanf("%d", &amp;A[i]); for (int i = 0;i &lt; n;i++) scanf("%d", &amp;B[i]); int tmp = n; g = GetG(n + 1); for (int i = 2;i * i &lt;= tmp;i++) while (tmp % i == 0) prime[++tot] = i, tmp /= i; if (tmp != 1) prime[++tot] = tmp; for (int i = 0;i &lt; n;i++) r[i] = GetPos(i, 1, n, 0); NTT(n, A, n + 1, 1), NTT(n, B, n + 1, 1); for (int i = 0;i &lt; n;i++) A[i] = (LL)A[i] * Pow(B[i], C, n + 1) % (n + 1); NTT(n, A, n + 1, 0); int Inv = Pow(n, n - 1, n + 1); for (int i = 0;i &lt; n;i++) printf("%d\n", (LL)A[i] * Inv % (n + 1)); return 0;&#125; H – Frightful Formula算是比较简单的一道题 公式等价于一个表格，往右走有$a$种方法，往下走有$b$种方法，还可以直接从这个格子开始走，有$c$种方法 先不考虑第一行和第一列格子 假设是从$i,j$这个格子开始走的 那么，这个格子需要向右走$n-j$步，向下走$n-i$步 对答案的贡献是 $$c*a^{n-i}*b^{n-j}*{n-i+n-j\choose n-i}$$ 含义是，从这个格子开始，有$c$种走法，向有走$n-j$次，向下走$n-i$次，在$n-j+n-i$步中，有$n-i​$步是往下走的 那么，把这些空白的格子加起来，我们可以得到 $$\begin{aligned}c\sum_{i=2}^n\sum_{j=2}^na^{n-i}b^{n-j}{n-i+n-j\choose n-i}&amp;=c\sum_{i=0}^{n-2}\sum_{j=0}^{n-2}a^ib^j{i+j\choose i}\\\&amp;=c\sum_{i=0}^{n-2}\frac{a^i}{i!}\sum_{j=0}^{n-2}(i+j)!\frac{b^j}{j!}\end{aligned}$$ 我们可以枚举$i$，后面的是一个下标差相等的卷积 将多项式逆序一下就可以了 这道题没有给模数，而答案又很大 为了防止丢精度，所以使用MTT 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;#define N 200010#define LL long longconst int mod = 1e6 + 3;inline int Pow(int x, int y, int p = mod) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % p) if (y &amp; 1) res = (LL)res * x % p; return res;&#125;const int ZJK = (1 &lt;&lt; 19) + 233;int frac[N * 2], f[2][N];inline int C(int n, int r) &#123;return (LL)frac[n] * Pow(frac[r], mod - 2) % mod * Pow(frac[n - r], mod - 2) % mod;&#125;// #define double long doublestruct CP &#123; double x, y; CP(double _x = 0, double _y = 0) : x(_x), y(_y) &#123;&#125; CP operator * (const CP &amp;b) &#123;return CP(x * b.x - y * b.y, x * b.y + y * b.x);&#125; CP operator + (const CP &amp;b) &#123;return CP(x + b.x, y + b.y);&#125; CP operator - (const CP &amp;b) &#123;return CP(x - b.x, y - b.y);&#125; CP operator / (const double b) &#123;return CP(x / b, y / b);&#125;&#125;;int r[ZJK]; const double PI = acos(-1);inline void FFT(int len, int type, CP a[]) &#123; for (int i = 0;i &lt; len;i++) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int mid = 2;mid &lt;= len;mid &lt;&lt;= 1) &#123; CP Wn(cos(2 * PI / mid), type * sin(2 * PI / mid)); for (int i = 0;i &lt; len;i += mid) &#123; CP w(1), t; for (int j = i;j &lt; i + (mid &gt;&gt; 1);j++, w = w * Wn) t = w * a[j + (mid &gt;&gt; 1)], a[j + (mid &gt;&gt; 1)] = a[j] - t, a[j] = a[j] + t; &#125; &#125; if (type == -1) for (int i = 0;i &lt; len;i++) a[i] = a[i] / len;&#125;#define LL long longCP a[ZJK], b[ZJK], c[ZJK], d[ZJK];int A[ZJK], B[ZJK];inline void MTT(int len, LL m) &#123; for (int i = 0;i &lt; len;i++) a[i] = A[i] / m, b[i] = A[i] % m, c[i] = B[i] / m, d[i] = B[i] % m; FFT(len, 1, a), FFT(len, 1, b), FFT(len, 1, c), FFT(len, 1, d); for (int i = 0;i &lt; len;i++) &#123; CP a1 = a[i], b1 = b[i], c1 = c[i], d1 = d[i]; a[i] = a1 * c1, b[i] = a1 * d1, c[i] = b1 * c1, d[i] = b1 * d1; &#125; FFT(len, -1, a), FFT(len, -1, b), FFT(len, -1, c), FFT(len, -1, d); for (int i = 0;i &lt; len;i++) A[i] = ((LL)(a[i].x + 0.5) * m % mod * m % mod + (LL)(b[i].x + 0.5) * m % mod + (LL)(c[i].x + 0.5) * m % mod + (LL)(d[i].x + 0.5)) % mod;&#125;int main() &#123; int a, b, c, n; scanf("%d%d%d%d", &amp;n, &amp;a, &amp;b, &amp;c), frac[0] = 1; for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;f[1][i]); for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;f[0][i]); for (int i = 1;i &lt;= n * 2;i++) frac[i] = (LL)frac[i - 1] * i % mod; int ans = 0, tmp1 = Pow(b, n - 1), tmp2 = Pow(a, n - 1); for (int i = 2;i &lt;= n;i++) ans = (ans + (LL)f[0][i] * C(2 * n - 2 - i, n - i) % mod * tmp1 % mod * Pow(a, n - i)) % mod; for (int i = 2;i &lt;= n;i++) ans = (ans + (LL)f[1][i] * C(2 * n - 2 - i, n - i) % mod * tmp2 % mod * Pow(b, n - i)) % mod; int len = 1, l = 0; while (len &lt;= 2 * n) len &lt;&lt;= 1, l++; for (int i = 0;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); for (int i = 0, t;i &lt;= n - 2;i++) t = Pow(frac[i], mod - 2), A[i] = (LL)Pow(a, i) * t % mod, B[i] = (LL)Pow(b, i) * t % mod; MTT(len, 1000); for (int i = 0;i &lt;= 2 * n - 4;i++) ans = (ans + (LL)c * A[i] % mod * frac[i]) % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>多项式</tag>
        <tag>字符串</tag>
        <tag>FFT</tag>
        <tag>manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.3省选模拟]]></title>
    <url>%2F2019%2F04%2F06%2F4-3%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 Diyiti 我们先考虑这样一个问题：给出$x,y$，如何计算$f(x,y)$ 分析一下第一个操作的本质，就是将$x$末尾连续的0都变成1，将第一处1变成0 考虑一种特殊情况：$y$是$x$的子集 也就是说，我们可以只通过操作2将$x$变成$y$ 如果我们使用了操作1，可以将最后一个1变成0 但是这样有一个副作用，就是后面所有的数都变成了1 根据之前的限制：$y$是$x$的子集，而$x$在这一位之后都是0 也就是说，$y$在这一位之后也全部是0 在这次操作之后，后面的数都变成了1 如果这次操作在第$i$位，那么我们至少还需要$i-1$次操作2才能将后面的位变得与$y$相同 只有在$i=1$即操作第一位的时候，$-1$操作才与操作2等价 否则$-1$操作一定没有操作2优秀 也就是说，如果我们能用操作2，就尽量用操作2 那么什么情况不能用操作2呢 就是$x$在某一位上为0，而$y$在这一位上为1 这个时候我们只能用$-1$操作 如果第$i$位是这样的情况，就意味着，我们必须将这一位之后的第一个$1-0$对前面的所有位都变成0，然后在这个$1-0$对位置使用一次$-1$操作 比如$x=(10010)_2,y=(00101)_2$ 注意“第$k$位”指的是从右边开始的第$k$位 对于第一位来说，我们至少需要将第一位变成0 对于第三位来说，我们至少需要将第四位到第一位变成0 为了让操作数尽量小，我们选择将第一位至第四位都变成0 之后就变成了第一种情况，即$y$是$x$的子集 总结一下流程： 我们找到最高的满足$x_i=0,y_i=1$的位置 找到第一个比这一位高的，满足$x_i=1,y_i=0$的位置$j$ 通过操作2，将位置$1-(j-1)$全部变成0 在$j$位置使用一次$-1$操作 对于每一处$x_i=1,y_i=0$的位置使用操作2 所以，我们可以得出$$f(x,y)=\begin{cases}\sum_{k&gt;j}[x_k\not=y_k]+1+\sum_{k&lt;j}[x_k=1]+\sum_{k&lt;j}[y_k=0]&amp;y\not\in x\\ \sum_k[x_k\not=y_k]&amp;y\in x\end{cases}$$ 那么我们现在将它扩展到$x&lt;N$ 显然，我们可以使用数位dp 根据我们之前的计算过程，我们从高位向低位dp，将$x$分为3个状态 还没有遇到$x_i=0,y_i=1$，即此时$y\in x$，这个状态可以作为终止状态 钦定此时会有一个$-1$操作，这个状态的起点必须是$x_i=1,y_i=0$且在这个状态中不能再出现其它的$x_i=1,y_i=0$以及$x_i=0,y_i=1$，这个状态不能作为终止状态 遇到了第一个$x_i=0,y_i=1$，然后就可以随便转移了，这个状态可以作为终止状态 第二个状态之所以不能成为终止状态，是因为必须至少有一个$x_i=0,y_i-1$，否则就不应该进入2状态 那么我们可以设f[2][2][3][N], g[2][2][3][N]表示当前在第$i$位，此时$x$是否等于$N$，$y$是否等于$x$，当前在第几个状态时的答案以及转移到结尾的方案数 为了偷懒，我们也可以只用一个dp dp[2][2][3][N][N]表示当前到了第$i$位，之前已经用了$j$次操作，此时$x$是否等于$N$，$y$是否等于$x$，当前在第几个状态时的答案 代码如下 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;#define N 510int num[N], dp[2][2][3][N][N * 2], len; const int mod = 1e9 + 7;inline void Inc(int &amp;x, int y) &#123; x += y, x -= x &gt;= mod ? mod : 0;&#125;int DP(int cur, bool flag1, bool flag2, int state, int cnt) &#123; if (cur == len + 1) return state == 1 ? 0 : cnt; int &amp;sum = dp[flag1][flag2][state][cur][cnt]; if (~sum) return sum; sum = 0; for (int x = 0;x &lt; 4;x++) &#123; int i = x &amp; 1, j = x &gt;&gt; 1 &amp; 1, tflag1 = flag1 &amp;&amp; (i == num[cur]), tflag2 = flag2 &amp;&amp; (j == i); if (flag1 &amp;&amp; i &gt; num[cur]) continue; if (flag2 &amp;&amp; j &gt; i) continue; if (state == 0) &#123; if (i &lt; j) continue; Inc(sum, DP(cur + 1, tflag1, tflag2, 0, cnt + (i &gt; j))); if (i &gt; j) Inc(sum, DP(cur + 1, tflag1, tflag2, 1, cnt + 1)); &#125; else if (state == 1) &#123; if (i &gt; j) continue; if (i == j) Inc(sum, DP(cur + 1, tflag1, tflag2, 1, cnt + (i == 1) + (j == 0))); else Inc(sum, DP(cur + 1, tflag1, tflag2, 2, cnt)); &#125; else Inc(sum, DP(cur + 1, tflag1, tflag2, 2, cnt + (i == 1) + (j == 0))); &#125; return sum;&#125;char input[N];int main() &#123; freopen("diyiti.in", "r", stdin), freopen("diyiti.out", "w", stdout); scanf("%s", input + 1), len = strlen(input + 1), memset(dp, -1, sizeof(dp)); for (int i = 1;i &lt;= len;i++) num[i] = input[i] - '0'; printf("%d\n", DP(1, 1, 1, 0, 0));&#125; T2 Dierti 看起来是一道好题，可惜没有题解 这里讲一下部分分做法（只会部分分） 首先我们可以枚举最后选到的是哪个$n$以及哪个$m$，求这个东西的$k$阶中心矩，最后再求期望 这里的$x$就是实际选的袋子中球的数量 考虑$$\begin{aligned}E((x-E(x))^k)&amp;=E(\sum_{i=0}^k{k\choose i}x^k(-1)^{k-i}E(x)^{k-i})\\\&amp;=\sum_{i=0}^k{k\choose i}(-1)^{k}E(x)^{k}E(x^{k-i})\end{aligned}$$ 显然$E(x)=\frac{m}{n}$，所以关键是要求出$E(x^k)$ 这等价于有一个数，现在要对这个数进行$m$次操作，每次操作都有$\frac{1}{n}$的概率会加1，否则不变 很像一道题osu 我们分别维护$E(x),E(x^2),\cdots,E(x^k)$，转移的时候再次使用二项式展开 这样一次转移是$k^3$的，可以使用矩阵乘法优化 可以拿到60分 T3 Disanti 我不会啊，而且没有题解 先咕在这里吧]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>数据结构</tag>
        <tag>二进制</tag>
        <tag>期望</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.2省选模拟]]></title>
    <url>%2F2019%2F04%2F06%2F4-2%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 Painting 我们考虑这样一种情况：122133441 显然，1必须在最开始就刷上，如果先刷其它的数再刷1，那么颜色2,3,4不可能被1包含 颜色3,4刷的顺序无关紧要 我们考虑更一般的情况 如果存在颜色序列a...b...b...a，其中省略号的部分可能代表其它颜色，那么a一定在b之前被刷上 对于颜色序列a..ab...b，a,b被刷的顺序可以随意 我们可以通过这两个条件将拓扑关系建出来，可以发现，这是一棵树 树的祖先与后代刷的顺序是确定的，同一个父亲的儿子节点刷的顺序可以随意 于是我们考虑分治，假设当前分治到了区间[l,r]，这要求这个区间的左右两个端点的颜色相同 比如上面那个例子中，这个颜色就是1 这个颜色将这个区间分成了若干段，对于每一段我们只关心当前颜色的儿子节点，将每一个颜色序列都缩成一个点 比如序列12332144551，1将序列分成了两个部分2332,4455 对于颜色2，我们将它缩成一个长度为4的点，它在第一段 对于颜色3，我们不管它，因为它不是1的儿子，它在第二段 对于颜色4,5，我们将它们各缩成长度为2的点，它在第二段 对于每一段，我们分别进行dp，算出答案的最大值，因为段与段之间不能相互跨越，否则中间那个1就永远都刷不上了 我们用dp[i][j]表示已经刷好了[i,j]这些点，能获得的最大收益 如果我们假设第$i$个点缩成的长度是$b_i$，那么这个dp就满足$$dp_{i,j}=\sum_{l=i}^jb_l+\max_{mid=i}^j\{dp_{i,mid-1}+dp_{mid+1,j}\}$$含义是我们枚举第一次刷的颜色$mid$，这会将序列分成两段独立的区间，分别刷即可 这个dp是$m^3$的 如果我们打出这个dp取最优值的位置，可以发现它一定在左端点或者右端点转移 不会证明 此时dp就是$m^2$的了 题解的证明过程如下 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;#define P pair&lt;int, int&gt;#define N 100010#define M 5010int num[N], nxt[N], lst[N];vector&lt;int&gt; tmp; int dp[M][M], pre[M];inline int DP() &#123; int n = tmp.size(); for (int i = 1;i &lt;= n;i++) pre[i] = pre[i - 1] + tmp[i - 1]; for (int i = 0;i &lt;= n;i++) for (int j = 0;j &lt;= n;j++) dp[i][j] = 0; for (int i = 1;i &lt;= n;i++) dp[i][i] = tmp[i - 1]; for (int len = 2;len &lt;= n;len++) for (int start = 1;start + len - 1 &lt;= n;start++) &#123; int end = start + len - 1; dp[start][end] = max(dp[start + 1][end], dp[start][end - 1]) + pre[end] - pre[start - 1]; &#125; return dp[1][n];&#125;int res;void solve(int l, int r) &#123; for (int ls = l, cur = nxt[l];ls != r;cur = nxt[ls = cur]) &#123; tmp.clear(); for (int at = ls + 1;at != cur;at = lst[at] + 1) tmp.push_back(lst[at] - at + 1); res += DP(); &#125; for (int ls = l, cur = nxt[l];ls != r;cur = nxt[ls = cur]) for (int at = ls + 1;at != cur;at = lst[at] + 1) solve(at, lst[at]);&#125;int tmp1[N], beg[N];int main() &#123; freopen("color.in", "r", stdin), freopen("color.out", "w", stdout); int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1;i &lt;= n;i++) &#123; scanf("%d", &amp;num[i]); if (tmp1[num[i]]) nxt[tmp1[num[i]]] = i; else beg[num[i]] = i; tmp1[num[i]] = i, lst[beg[num[i]]] = i; &#125; nxt[0] = n + 1, solve(0, n + 1), printf("%d\n", res); return 0;&#125; T2 Path 假设当前点是$u$ 可以发现，最优策略一定是选择一个点集$v$，然后一直在$u$点等待，直到$u$和$v$连通，然后走这条出现的边 我们用dp[u]表示在最优策略下，$u$点到$n$需要的期望时间 我们将$u$点能到达的边按照dp值排序，可以发现选择的点集一定是一段前缀 我们枚举这个前缀，对于一个前缀$v_i$，如果选择这个前缀的点集，那么有转移$$dp_u=\min_{i=1}^{|v|}\{\frac{1}{i}\sum_{t\in v_i}dp_t+\frac{m}{i}\}$$含义是，如果选择了这个前缀，那么所选择的点中作为第一个出现的点的概率是相等的，为了走这一条边，我们期望要等$\frac{m}{i}$轮 由于有$\min$，所以无法高斯消元 一种方法是进行若干次迭代，每次迭代枚举每个点更新 另一种方法是使用一个类似SPFA的方法，将这次更新的点放进队列，继续拓展 代码如下 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010double dp[N]; vector&lt;int&gt; G[N];bool cmp(int i, int j) &#123; return dp[i] &lt; dp[j];&#125;int main() &#123; freopen("path.in", "r", stdin), freopen("path.out", "w", stdout); int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1, a, b;i &lt;= m;i++) scanf("%d%d", &amp;a, &amp;b), G[a].push_back(b), G[b].push_back(a); for (int i = 1;i &lt; n;i++) dp[i] = 1e9; for (int t = 1;t &lt;= 2000000 / m;t++) &#123; for (int i = 1;i &lt;= n;i++) &#123; sort(G[i].begin(), G[i].end(), cmp); double tmp = 0, ans = 0, ls = 1e9; for (int j = 1;j &lt;= G[i].size();j++) &#123; tmp += dp[G[i][j - 1]], ans = tmp / j + (double)m / j; if (ans &gt; ls) break; dp[i] = min(dp[i], ans); &#125; &#125; &#125; printf("%.7lf\n", dp[1]); return 0;&#125; T3 Tree 如果最远点的距离是$x$，那么所选择的点数必须不小于$\frac{n}{x}$ 这个式子看上去就很像分块 我们暴力枚举答案$1-\sqrt{n}$，找到答案为当前值的关键点数的区间 对于现在还没有确定答案的那些关键点数，我们直接二分，然后暴力算答案 所谓暴力就是直接树上贪心 这样可以获得60分的好成绩 贴一下题解]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>数据结构</tag>
        <tag>最短路</tag>
        <tag>期望</tag>
        <tag>分治</tag>
        <tag>线段树</tag>
        <tag>贪心</tag>
        <tag>分块</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.1省选模拟]]></title>
    <url>%2F2019%2F04%2F03%2F4-1%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 Line 如果我们知道了这条直线在$y$轴上的截距，那么我们就可以通过这$n$个点确定最终斜率的区间 假设这条直线是$kx+b$，现在我们已知$b$ 对于一个$r_i$，我们知道有$$ki+b\leq r_i\Rightarrow k\leq\lfloor\frac{r_i-b}{i}\rfloor$$对于一个$l_i$，我们知道有$$ki+b\geq l_i\Rightarrow k\geq\lceil\frac{l_i-b}{i}\rceil$$那么对于一个$b$，它对答案的贡献就是$$\max\{0,\min_{i=1}^n\{\lfloor\frac{r_i-b}{i}\rfloor\}-\max_{j=1}^n\{\lceil\frac{l_j-b}{j}\rceil\}+1\}$$如果我们知道此时$\min$取的是哪个位置，$\max$取的是哪个位置，我们就可以$O(1)$计算答案 由于我们之前是枚举的$b$，现在就把$b$看作自变量$x$ 对于$\min,\max$我们分开考虑 以$\min$为例 此时我们要求$\frac{r_i-x}{i}$的最小值 可以使用斜率优化，即将这个东西看作一条斜率为$-\frac{1}{i}$，截距是$\frac{r_i}{i}$的直线 此时我们就得到了当$b$在一个范围内的时候，最小值的位置 同样，我们可以得出当$b$在一个范围内的时候，最大值的位置 我们将这两个范围合并，就可以得出当$b$在一个范围内时，最小值以及最大值的位置 现在考虑对于一个区间的$b$，如何计算答案 此时我们已经确定了$\min,\max$的位置 首先考虑将前面那个0搞掉 我们发现这对应着收紧一下区间 解方程$$\begin{align}\frac{r_i-x}{i}&amp;=\frac{l_j-x}{j}\\\r_ij-xj&amp;=l_ji-xi\\\x(i-j)&amp;=l_ji-r_ij\\\\Rightarrow x&amp;=\frac{l_ji-r_ij}{i-j}\end{align}$$当$i=j$时，我们不做处理 当$i&gt;j$时，这对应着$b$的新下界 当$i&lt;j$时，这对应着$b$的新上界 此时我们就可以把前面的0搞掉了 考虑如何计算$$\sum_{i=L}^R\lfloor\frac{a-i}{b}\rfloor$$我们发现如果不考虑边角上的数，这其实是一个每个数都重复了$b$次的等差数列 如果$\lfloor\frac{a}{b}\rfloor=k$，那么有$bk\leq a\leq (b+1)k-1$ 我们对边角特殊处理即可 考试的时候由于某些未知的地方没有开long long，导致只有33.3分 听说可以算出斜率的区间 好像我写毒瘤了 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define int long long#define double long doubleinline LL calc(int L, int R, int a, int b) &#123; L = -L, R = -R, swap(L, R); int l1 = floor((L + a) / (double)b) + 1, r1 = floor((R + a) / (double)b); LL res = (LL)(r1 - l1 + 1) * (l1 + r1) * b / 2; l1 = l1 * b - 1, r1 = (r1 + 1) * b; res += floor((a + L) / (double)b) * (LL)(l1 - L - a + 1) + floor((a + R) / (double)b) * (LL)(R + a - r1 + 1); return res;&#125;inline LL calc(int L, int R, int lj, int ri, int j, int i) &#123; // L &lt;= x &lt;= R if (i == j) return calc(L, R, ri, i) - calc(L, R, lj + j - 1, j) + R - L + 1; double k = (ri - lj) / (double)(i - j), y = lj - k * j; if (j &lt; i) L = max(L, (int)ceil(y)); else R = min(R, (int)floor(y)); if (L &gt; R) return 0; return calc(L, R, ri, i) - calc(L, R, lj + j - 1, j) + R - L + 1;&#125;#define N 200010struct Line &#123;int b, kinv;&#125; l1[N], l2[N];inline double inter(Line a, Line b) &#123; return ((LL)a.b * b.kinv - (LL)b.b * a.kinv) / (double)(a.kinv - b.kinv);&#125;double eps = 1e-8;inline int dcmp(double x) &#123; if (fabs(x) &lt; eps) return 0; return x &gt; 0 ? 1 : -1;&#125;inline bool check(Line a, Line b, Line c) &#123; return dcmp(inter(a, b) - inter(a, c)) &lt; 0;&#125;int l[N], r[N], head, tail; struct data &#123;int l, r, at;&#125;;vector&lt;data&gt; tmp1, tmp2;signed main() &#123; freopen("line.in", "r", stdin); freopen("line.out", "w", stdout); int n; scanf("%lld", &amp;n); for (int i = 1;i &lt;= n;i++) scanf("%lld%lld", &amp;l[i], &amp;r[i]); head = 1, tail = 0; for (int i = 1;i &lt;= n;i++) &#123; Line now = (Line)&#123;-l[i], -i&#125;; while (head &lt; tail &amp;&amp; !check(l1[tail - 1], l1[tail], now)) tail--; l1[++tail] = now; &#125; for (int i = head, ls = -2e9, cur;i &lt;= tail;i++, ls = cur + 1) &#123; cur = i != tail ? floor(inter(l1[i], l1[i + 1])) : 2e9; if (ls &lt;= cur) tmp1.push_back((data)&#123;ls, cur, -l1[i].kinv&#125;); &#125; head = 1, tail = 0; for (int i = n;i &gt;= 1;i--) &#123; Line now = (Line)&#123;-r[i], -i&#125;; while (head &lt; tail &amp;&amp; !check(l2[tail - 1], l2[tail], now)) tail--; l2[++tail] = now; &#125; for (int i = head, ls = -2e9, cur;i &lt;= tail;i++, ls = cur + 1) &#123; cur = i != tail ? floor(inter(l2[i], l2[i + 1])) : 2e9; if (ls &lt;= cur) tmp2.push_back((data)&#123;ls, cur, -l2[i].kinv&#125;); &#125; int cur1 = 0, cur2 = 0, ls = -2e9; LL ans = 0; while (233) &#123; int nxt, at1 = tmp1[cur1].at, at2 = tmp2[cur2].at, R; if (cur1 != tmp1.size() - 1 &amp;&amp; cur2 != tmp2.size() - 1) &#123; if (tmp1[cur1].r &lt; tmp2[cur2].r) nxt = 1; else nxt = 2; &#125; else nxt = (cur1 == tmp1.size() - 1) ? 2 : 1; R = nxt == 1 ? tmp1[cur1].r : tmp2[cur2].r; ans += calc(ls, R, l[tmp1[cur1].at], r[tmp2[cur2].at], tmp1[cur1].at, tmp2[cur2].at), ls = R + 1; if (cur1 == tmp1.size() - 1 &amp;&amp; cur2 == tmp2.size() - 1) break; if (nxt == 1) cur1++; else cur2++; &#125; printf("%lld\n", ans);&#125; T2 Seat 不会，先放题解 T3 Dist 如果我们将每个集合看作一个点，那么一共只有18个点，我们在这个图上跑最短路 那么对于两个点$a,b$，$a$到$b$的最短路径等于$$\min_{a\in U,b\in V}dis(U,V)$$我们枚举起点$a$，将所有集合按照离$a$的距离排序，然后从小到大依次加入 当加入一个新的集合$y$时，它对答案的贡献就是$y$集合中包含的点减去被$y$和之前的集合包含的点 这个我们处理出一个子集和就可以了，就是半个FWT 注意某个点离自己的距离是0，这种方法会将这个距离算成包含$a$的集合的点权最小值]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>斜率优化</tag>
        <tag>gcd</tag>
        <tag>最短路</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FWT基础]]></title>
    <url>%2F2019%2F04%2F02%2FFWT%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[FWT有啥用啊我们知道，FFT可以解决多项式的卷积，即$$C_k=\sum_{i+j=k}A_i*B_j$$如果将操作符换一下，换成集合运算符 比如$$C_k=\sum_{i|j=k}A_i*B_j\\\C_k=\sum_{i\&amp;j=k}A_i*B_j\\\C_k=\sum_{i\oplus j=k}A_i*B_j$$这时就不能使用FFT了 但是FFT使我们产生了一种想法 我们能不能用一种类似FFT的方法，用另一个多项式来表示$A,B$，然后再对应相乘，最后再变换回来呢 答案是可以的，这就是FWT，即快速沃尔什变换 一些定义令$A,B$为两个向量，且维数为$n$，$n$是$2$的整数次幂 定义记号 $A\pm B=(A_0\pm B_0,A_1\pm B_1,A_2\pm B_2,\cdots,A_{n-1}\pm B_{n-1})$ $A\oplus B=(\sum\limits_{i\oplus j=0}A_i*B_j,\sum\limits_{i\oplus j=1}A_i*B_j,\sum\limits_{i\oplus j=3}A_i*B_j,\cdots,\sum\limits_{i\oplus j=n-1}A_i*B_j)​$ 这里的$\oplus$代表集合运算 或卷积及其逆运算我们定义$FWT$变换，有$$FWT(A)[i]=\sum_{j|i=i}A_j$$ 性质1：$FWT(A\pm B)=FWT(A)\pm FWT(B)$ 根据此时$FWT​$变换的定义我们知道这是一个$A​$数组的线性组合，故加减法满足分配律 我们断言，此时的$FWT$满足$$FWT(A)=\begin{cases}(FWT(A_0),FWT(A_0)+FWT(A_1))&amp; n&gt;1\\ A &amp; n=0\end{cases}$$$A_0,A_1$分别代表$A$数组的前半部分、后半部分 证明如下： 实际上此时$A_0,A_1$的下标只有最高位是不同的 根据$FWT$的定义，合并之后左半部分的最高位仍然是0，右半部分的最高位仍然是1 由于$FWT(A_1)$的最高位一定为1，而此时$j|i$的最高位不可能为0，所以右半部分对于合并之后是没有贡献的 而对于右半边，如果左半边的数满足$j|i=i​$，那么在$i​$加上最高位1之和，这个式子仍然成立 而此时右半边原来的$FWT$本来就对右半边的数有贡献 所以这个式子成立 性质2：$FWT(A|B)=FWT(A)*FWT(B) (对应相乘)$ 我们采用归纳法证明$$\begin{aligned}FWT(A|B)&amp;=FWT((A|B)_0,(A|B)_1)\\\&amp;=FWT(A_0|B_0,A_1|B_0+A_0|B_1+A_1|B_1)\\\&amp;=(FWT(A_0|B_0),FWT(A_0|B_0+A_1|B_0+A_0|B_1+A_1|B_1))\\\&amp;=(FWT(A_0)*FWT(B_0),FWT(A_0)*FWT(B_0)+FWT(A_1)*FWT(B_0)\\\&amp;+FWT(A_0)*FWT(B_1)+FWT(A_1)*FWT(B_1))\\\&amp;=(FWT(A_0)*FWT(B_0),(FWT(A_0)+FWT(A_1)*(FWT(B_0)+FWT(B_1))))\\\&amp;=(FWT(A_0),FWT(A_0)+FWT(A_1))*(FWT(B_0),FWT(B_0)+FWT(B_1))\\\&amp;=FWT(A)*FWT(B)\end{aligned}$$定义$IFWT$变换为$FWT$变换的逆变换 我们断言，$IFWT$满足$$IFWT(A)=\begin{cases}(IFWT(A_0),IFWT(A_1)-IFWT(A_0))&amp;n&gt;1\\ A&amp;n=0\end{cases}$$证明如下：$$\begin{aligned}IFWT(FWT(A))&amp;=IFWT(FWT(A_0),FWT(A_0)+FWT(A_1))\\\&amp;=(IFWT(FWT(A_0)),IFWT(FWT(A_1)))\\\&amp;=(A_0,A_1)\\\&amp;=A\end{aligned}$$ 与卷积及其逆运算定义$FWT$变换为$$FWT(A)[i]=\sum_{i\&amp;j=j}A_i$$类似或卷积，我们可以得出此时$FWT$的递推式$$FWT(A)=\begin{cases}(FWT(A_0)+FWT(A_1),FWT(A_1))&amp;n&gt;1\\ A &amp;n=0\end{cases}$$证明很简单，$A$数组的右半部分与上一个首位为0的数，得到的结果一定在$A$的左半部分 显然，它们仍然对自己所在的部分有贡献 $FWT(A\&amp;B)=FWT(A)*FWT(B)$在此时成立 证明如下：$$\begin{aligned}FWT(A\&amp;B)&amp;=FWT((A\&amp;B)_0,(A\&amp;B)_1)\\\&amp;=FWT(A_0\&amp;B_0+A_0\&amp;B_1+A_1\&amp;B_0,A_1\&amp;B_1)\\\&amp;=(FWT(A_0\&amp;B_0+A_0\&amp;B_1+A_1\&amp;B_0+A_1\&amp;B_1),FWT(A_1\&amp;B_1))\\\&amp;=((FWT(A_0)+FWT(A_1))*(FWT(B_0)+FWT(B_1)),FWT(A_1)*FWT(B_1))\\\&amp;=(FWT(A_0)+FWT(A_1),FWT(A_1))*(FWT(B_0)+FWT(B_1),FWT(B_1))\\\&amp;=FWT(A)*FWT(B)\end{aligned}$$定义$IFWT$变换为$$IFWT(A)=\begin{cases}(IFWT(A_0)-IFWT(A_1),IFWT(A_1))&amp;n&gt;1\\ A&amp;n=0\end{cases}$$证明如下：$$\begin{aligned}IFWT(FWT(A))&amp;=IFWT(FWT(A_0)+FWT(A_1),FWT(A_1))\\\&amp;=(IFWT(FWT(A_0)),IFWT(FWT(A_1))\\\&amp;=(A_0,A_1)\\\&amp;=A\end{aligned}$$ 异或卷积及其逆运算异或卷积的$FWT$稍微麻烦一点 我们定义函数$d(x)$表示$x$在二进制下1的数量 定义$FWT$变换为$$FWT(A)[i]=\sum_{d(j\&amp;i)\equiv0\mod 2}A_j-\sum_{d(k\&amp;i)\equiv1\mod 2}A_k$$那么此时，它的递推式为$$FWT(A)=\begin{cases}(FWT(A_0)+FWT(A_1),FWT(A_0)-FWT(A_1))&amp;n&gt;0\\ A&amp;n=0\end{cases}$$我们考虑这个式子是怎么来的 先看这个式子左边的$FWT(A_0)+FWT(A_1)$ $A_0$的下标没有变化，所以要加上$FWT(A_0)$，而现在$A_1$的下标的最高位变成了1，但是与上一个最高位为0的数之后是不变的 所以这个式子是正确的 我们看右边的$FWT(A_0)-FWT(A_1)$ $A_0$的最高位不变，与上一个最高位为1的数之后结果仍然不变 $A_1$的下标的最高位多了一个1，与上一个最高位为1的数之后奇偶性就变了，所以要取反 所以这个也是成立的 $FWT(A\oplus B)=FWT(A)*FWT(B)$在此时成立 证明如下$$\begin{aligned}FWT(A\oplus B)&amp;=FWT((A\oplus B)_0,(A\oplus B)_1)\\\&amp;=FWT(A_0\oplus B_0+A_1\oplus B_1,A_0\oplus B_1+A_1\oplus B_0)\\\&amp;=(FWT(A_0\oplus B_0+A_1\oplus B_1+A_0\oplus B_1+A_1\oplus B_0),\\\&amp;FWT(A_0\oplus B_0+A_1\oplus B_1-A_0\oplus B_1-A_1\oplus B_0))\\\&amp;=((FWT(A_0)+FWT(A_1))*(FWT(B_0)+FWT(B_1)),\\\&amp;(FWT(A_0)-FWT(A_1))*(FWT(B_0)-FWT(B_1)))\\\&amp;=(FWT(A_0+A_1),FWT(A_0-A_1))*(FWT(B_0+B_1),FWT(B_0-B_1))\\\&amp;=FWT(A)*FWT(B)\end{aligned}$$定义$IFWT$为$$IFWT(A)=\begin{cases}(\frac{IFWT(A_0+A_1)}{2},\frac{IFWT(A_0-A_1)}{2})&amp;n&gt;1\\ A&amp;n=0\end{cases}$$证明如下：$$\begin{aligned}IFWT(FWT(A))&amp;=IFWT(FWT(A_0)+FWT(A_1),FWT(A_0)-FWT(A_1))\\\&amp;=(IFWT(FWT(A_0)),IFWT(FWT(A_1)))\\\&amp;=(A_0,A_1)\\\&amp;=A\end{aligned}$$]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>FWT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.30省选模拟]]></title>
    <url>%2F2019%2F04%2F01%2F3-30%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 唐时月夜 直接维护显然不太可行，我们考虑每个点单独维护 对于某个点$(x,y)$，对它有影响的修改一定是一段后缀，那么我们可以二分出这个后缀 考虑一个修改的本质是什么 假如现在要对一个矩形$(x_1,y_1),(x_2,y_2)$进行行翻转，并且$(x,y)$在这个矩形内部 那么此时$y$不变，$x$变为$x_1+x_2-x$ 如果要进行列翻转，那么$x$不变，$y$变为$y_1+y_2-y$ 现在来考虑最复杂的转置 如果我们强制让$(x_1,y_1)$为原点，重置坐标系，那么此时每个点的$x,y$都会互换 那么我们模拟这个过程，首先让$x$减去$x_1$,$y$减去$y_1$，再将$x,y$互换，最后把减去的加回来 那么最后我们一定可以用一个与$x,y$有关的代数式表示最后变换之后的$x,y$，并且$x,y$的系数一定是$1,-1$ 如果当前这个点的转置次数为奇数次，那么最后的$x$应该由最初的$y$表示，最后$y$应该由最初的$x$表示 否则不变 我们维护这个符号，以及前面的常数，还有交换次数即可 比赛的时候我用了线段树，好像很没必要，直接扫描线就可以了 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;#define Q 200010struct node &#123;int l, r, rev, tag[2], sgn[2], lazy;&#125; T[Q &lt;&lt; 2];inline void Swap(int rt) &#123; swap(T[rt].tag[0], T[rt].tag[1]), swap(T[rt].sgn[0], T[rt].sgn[1]), T[rt].rev ^= 1, T[rt].lazy++;&#125;inline void work(int rt, int rt1, int id) &#123; if (T[rt].sgn[id] == 1 &amp;&amp; T[rt].tag[id] == 0) return; if (T[rt].sgn[id] == 1) T[rt1].tag[id] += T[rt].tag[id]; else T[rt1].sgn[id] = -T[rt1].sgn[id], T[rt1].tag[id] = T[rt].tag[id] - T[rt1].tag[id];&#125;inline void pushdown(int rt) &#123; if (T[rt].rev) Swap(rt &lt;&lt; 1), Swap(rt &lt;&lt; 1 | 1), T[rt].rev = 0; work(rt, rt &lt;&lt; 1, 0), work(rt, rt &lt;&lt; 1, 1), work(rt, rt &lt;&lt; 1 | 1, 0), work(rt, rt &lt;&lt; 1 | 1, 1); T[rt].sgn[0] = T[rt].sgn[1] = 1, T[rt].tag[0] = T[rt].tag[1] = 0;&#125;inline void build(int rt, int l, int r) &#123; T[rt].l = l, T[rt].r = r, T[rt].sgn[0] = T[rt].sgn[1] = 1; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(rt &lt;&lt; 1, l, mid), build(rt &lt;&lt; 1 | 1, mid + 1, r);&#125;inline void update(int rt, int start, int end, int type, int x, int sp = 0) &#123; int l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; 1; if (start &lt;= l &amp;&amp; r &lt;= end) &#123; if (sp) &#123;T[rt].tag[type - 1] += x; return;&#125; if (type == 1) T[rt].sgn[0] = -T[rt].sgn[0], T[rt].tag[0] = x - T[rt].tag[0]; else if (type == 2) T[rt].sgn[1] = -T[rt].sgn[1], T[rt].tag[1] = x - T[rt].tag[1]; else Swap(rt); return; &#125; pushdown(rt); if (start &lt;= mid) update(rt &lt;&lt; 1, start, end, type, x, sp); if (end &gt; mid) update(rt &lt;&lt; 1 | 1, start, end, type, x, sp);&#125;inline int query(int rt, int at) &#123; int l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; 1; if (l == r) return rt; pushdown(rt); return at &lt;= mid ? query(rt &lt;&lt; 1, at) : query(rt &lt;&lt; 1 | 1, at);&#125;#define LL unsigned intint X1[Q], X2[Q], Y1[Q], Y2[Q]; LL f[20000010];template &lt;class T&gt; inline void rd(T &amp;x) &#123; x = 0; char c = getchar(); while (c &lt; '0' || c &gt; '9') c = getchar(); while ('0' &lt;= c &amp;&amp; c &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - '0', c = getchar();&#125;int tag[2][Q], sgn[2][Q], lzy[Q];int main() &#123; freopen("evernight.in", "r", stdin), freopen("evernight.out", "w", stdout); int n, m, q; LL a, b, c; rd(n), rd(n), rd(m), rd(q), rd(a), rd(b), rd(c); build(1, 1, max(q, 1)), f[0] = c; for (int i = 1;i &lt;= q;i++) &#123; int op; rd(op), rd(X1[i]), rd(Y1[i]), rd(X2[i]), rd(Y2[i]); if (op == 2) update(1, 1, i, 1, X1[i] + X2[i]); else if (op == 1) update(1, 1, i, 2, Y1[i] + Y2[i]); else update(1, 1, i, 1, 1 - X1[i], 1), update(1, 1, i, 2, 1 - Y1[i], 1), update(1, 1, i, 3, 0), update(1, 1, i, 1, X1[i] - 1, 1), update(1, 1, i, 2, Y1[i] - 1, 1); &#125; for (int i = 1;i &lt;= q;i++) &#123; int at = query(1, i); tag[0][i] = T[at].tag[0], tag[1][i] = T[at].tag[1], sgn[0][i] = T[at].sgn[0], sgn[1][i] = T[at].sgn[1], lzy[i] = T[at].lazy; &#125; for (int i = 1;i &lt;= n * m;i++) f[i] = f[i - 1] * a + b; LL res = 0; for (int x = 1;x &lt;= n;x++) for (int y = 1;y &lt;= m;y++) &#123; int id = (x - 1) * m + y, l = 1, r = q, ans = -1, mid, tx = x, ty = y; while (l &lt;= r) &#123; mid = (l + r) &gt;&gt; 1; if (x &gt;= X1[mid] &amp;&amp; x &lt;= X2[mid] &amp;&amp; y &gt;= Y1[mid] &amp;&amp; y &lt;= Y2[mid]) ans = mid, r = mid - 1; else l = mid + 1; &#125; if (~ans) &#123; if (lzy[ans] &amp; 1) tx = tag[0][ans] + sgn[0][ans] * y, ty = tag[1][ans] + sgn[1][ans] * x; else tx = tag[0][ans] + sgn[0][ans] * x, ty = tag[1][ans] + sgn[1][ans] * y; &#125; res += f[(tx - 1) * m + ty] * f[id]; &#125; printf("%u\n", res); return 0;&#125; T2 附耳而至 一道很妙的题 首先我们转个对偶图，这里贴一下转对偶图的方法 将每个点的所有出边按照极角排序 找到一条没有被标记过的边$(u,v)$，设为当前边，重复以下过程： 将当前边$(u,v)$标记 找到$v$的所有出边中，极角序在$(v,u)$前的最后一条边，设为下一次的当前边 重复这个过程，直到遇到一条标记过的边，那么此时刚刚选出的边就构成了一个区域 举个例子： 我们一开始选择了$A$，当前边是$AD$，将这条边标记 出点是$D$，$D$点的所有出边按照极角排序之后是$DF,DA,DE,DC$ 那么$DA$的前一条边就是$DF$，我们选择这条边 如果当前边是排序之后的第一条边，那么我们就选择排序之后最大的那条边 同理，$F$点只有两条出边，我们选择$FB$ 最后我们选择$BA$，回到了$A$点，下一条边$AD$是已经被标记过的 所以此时我们就找到了一个区域$ADFB$ 注意边是双向的，标记也是双向的 这意味着，如果$AB$被标记，不代表$BA$被标记 我们模拟这个过程就好了 转完对偶图之后，我们就得到了一个区域被光明之神选中的代价，被黑暗之神选中的代价，以及相邻两个区域所需要扣除的贡献 然后很显然是个最小割 我考试的时候使用了一种错误的建图方法：将每个点拆成两个点，代表光明的点在左边，代表黑暗的点在右边，源点连向左边的点，权值为光明之神选中的代价，右边的点连向汇点，权值为黑暗之神选中的代价，对应的点连一条权值为正无穷的边，代表这个点不能被两个神同时选中。如果两个区域$a,b$相邻，那么将$a$的光明连向$b$的黑暗，将$b$的黑暗连向$a$的光明，权值为$c_i$，然后答案就是所有光明的代价之后加上黑暗的代价之和减去最小割 这样建图有一个很严重的问题：有可能一个点的光明与黑暗都被割了，即不被任何一个神选中 题解的做法是不拆点，也就没有必要连权值为证无穷的边，$a,b$之间连双向边 zyw大佬的解释： 如果存在一种最小割，使得某个点连向源点和汇点的边都被割掉了，那么这就意味着，至少有一个黑暗之神所选中的区域与它相邻，至少有一个光明之神选中的区域与它相邻，要不然割掉这两条边没有意义 而这两个区域所对应的点与当前点有无向边连接，并且我们知道，这条边没有被割掉，否则我们没有必要割去两条边 我们考虑以下这种情况 橙色的边代表被割去的边，显然中间那个点就是不合法的点，因为它上下两条边都被割去了 图中所对应的情况，就是左边那个点被黑暗之神选中，右边那个点被光明之神选中 但是此时，由黑色边构成的路径使得$s,t$连通了，不符合割的性质 所以这种情况是不可能出现的 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010#define M 200010#define MX 2000010int x[N], y[N], val[N], val2[N], n, s, t, tot; const double PI = acos(-1);namespace Flow &#123; struct edge &#123;int to, next, w;&#125; e[MX]; int head[N * 2], cur[N * 2], ecnt = 1, dep[N * 2]; inline void adde(int from, int to, int w) &#123; e[++ecnt] = (edge)&#123;to, head[from], w&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to], 0&#125;, head[to] = ecnt; &#125; inline bool BFS(int s, int t) &#123; queue&lt;int&gt; q; q.push(s), memset(dep, -1, sizeof(dep)), dep[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u];i;i = e[i].next) if (e[i].w &amp;&amp; dep[e[i].to] == -1) &#123; dep[e[i].to] = dep[u] + 1, q.push(e[i].to); if (e[i].to == t) return true; &#125; &#125; return false; &#125; int DFS(int u, int f, int t) &#123; if (u == t || !f) return f; int res = 0; for (int &amp;i = cur[u], tmp;i;i = e[i].next) if (e[i].w &amp;&amp; dep[e[i].to] == dep[u] + 1 &amp;&amp; (tmp = DFS(e[i].to, min(f, e[i].w), t))) &#123; res += tmp, f -= tmp, e[i].w -= tmp, e[i ^ 1].w += tmp; if (!f) break; &#125; return res; &#125; inline int Dinic(int s, int t) &#123; int res = 0; while (BFS(s, t)) memcpy(cur, head, sizeof(head)), res += DFS(s, 1e9, t); return res; &#125;&#125;namespace Planner_G &#123; struct edge &#123; int u, v, w, w2, c; double angle; edge(int u = 0, int v = 0, int w = 0, int w2 = 0, int c = 0) : u(u), v(v), w(w), w2(w2), c(c) &#123; int tx = x[v] - x[u], ty = y[v] - y[u]; angle = atan2(ty, tx); if (angle &lt; 0) angle += 2 * PI; &#125; &#125; e[M * 2]; int ecnt = 0; inline void adde(int from, int to, int c) &#123; int v1 = val[from] + val[to], v2 = val2[from] + val2[to]; e[ecnt++] = edge(from, to, v1, v2, c), e[ecnt++] = edge(to, from, v1, v2, c); &#125; vector&lt;int&gt; G[N]; int rank[M * 2], near[M * 2], vis[M * 2], pval[N], pval2[N], rcnt; inline void mark(int u, int eid) &#123; if (vis[eid]) return; int tmp1 = 0, tmp2 = 0; while (!vis[eid]) &#123; tmp1 += e[eid].w, tmp2 += e[eid].w2, vis[eid] = 1, near[eid] = rcnt; int v = e[eid].v; if (!rank[eid ^ 1]) eid = G[v].back(); else eid = G[v][rank[eid ^ 1] - 1]; &#125; pval[rcnt] = tmp1 / 2, pval2[rcnt] = tmp2 / 2, rcnt++; &#125; inline void build() &#123; pair&lt;double, int&gt; *tmp = new pair&lt;double, int&gt;[ecnt + 10]; for (int i = 0;i &lt; ecnt;i++) tmp[i] = make_pair(e[i].angle, i); sort(tmp, tmp + ecnt); for (int i = 0;i &lt; ecnt;i++) &#123; int eid = tmp[i].second; rank[eid] = G[e[eid].u].size(), G[e[eid].u].push_back(eid); &#125; for (int i = 1;i &lt;= n;i++) for (int j = 0;j &lt; G[i].size();j++) mark(i, G[i][j]); &#125; inline void link() &#123; s = rcnt + 1, t = rcnt + 2; for (int i = 1;i &lt;= rcnt;i++) Flow::adde(s, i, pval[i - 1]), Flow::adde(i, t, pval2[i - 1]), tot += pval[i - 1] + pval2[i - 1]; for (int i = 0;i &lt; ecnt;i += 2) &#123; int u = near[i] + 1, v = near[i ^ 1] + 1; Flow::adde(u, v, e[i].c), Flow::adde(v, u, e[i].c); &#125; &#125;&#125;int main() &#123; freopen("everfeel.in", "r", stdin), freopen("everfeel.out", "w", stdout); int m; scanf("%*d%d%d", &amp;n, &amp;m); for (int i = 1;i &lt;= n;i++) scanf("%d%d%d%d", &amp;x[i], &amp;y[i], &amp;val[i], &amp;val2[i]); for (int i = 1, a, b, c;i &lt;= m;i++) scanf("%d%d%d", &amp;a, &amp;b, &amp;c), Planner_G::adde(a, b, c); Planner_G::build(), Planner_G::link(); printf("%d\n", tot - Flow::Dinic(s, t)); return 0;&#125; T3 星辰大海]]></content>
  </entry>
  <entry>
    <title><![CDATA[3.29省选模拟]]></title>
    <url>%2F2019%2F04%2F01%2F3-29%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 循环流 一道比较神仙的题 考试的时候我使用的是手玩+找规律 我们考虑以下几种情况： $n=2$：这时需要特殊考虑 如果没有1边，那么2边的数量必须是偶数 否则如果1边的数量是奇数，那么一定不行 此时如果1边的数量是偶数，如果2边的数量是奇数，那么我们可以用两条1边凑出一条2边，而此时1边的数量仍然是偶数 $a=1$：显然此时不可能存在合法情况，因为找不到另一条1边来与这条边匹配 $n\not=2,a=0或b=0$：我们可以将数量不为0的那条边连成一个环，这样至少需要$n$条边。如果数量不为0的那条边的边数大于$n$，并且是偶数，那么我们连两条相反的边即可使得边数$-2$，否则我们连成一个长度为$3$的环，可以使得边数$-3$，如果边数为$n+1$，那么我们可以连一个长度为$2$的环，再将剩下的$n-1$个点连成环 剩余情况：将1连成一个环，将2连成一个环，则至少要用$n+1$条边，同样可以使用3中的方法调整 代码如下 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; freopen("flow.in", "r", stdin), freopen("flow.out", "w", stdout); int k, T, cnt = 0; scanf("%d%d", &amp;k, &amp;T); while (T--) &#123; int n, a, b; scanf("%d%d%d", &amp;n, &amp;a, &amp;b); if (a + b &lt; n) &#123; puts("0"); continue; &#125; if (a == 1) &#123; puts("0"); continue; &#125; if (n == 2) &#123; if (a == 0 &amp;&amp; b % 2 == 0) puts("1"); else if (a != 0 &amp;&amp; a % 2 == 0) puts("1"); else puts("0"); continue; &#125; if (a == 0) &#123; if (b &gt;= n) puts("1"); else puts("0"); continue; &#125; if (b == 0) &#123; if (a &gt;= n) puts("1"); else puts("0"); continue; &#125; if (a + b - 1 &gt;= n) puts("1"); else puts("0"); &#125;&#125; T2 整除分块 先贴上题解 T3 森林 一道很奇妙的题：LCT维护虚子树信息 观察变换之后答案的本质：其实就是这棵树的直径加上从直径上的某一点出发的最长链的长度- 1 我们考虑使用LCT维护，那么我们需要维护这些信息： 从当前区间的左端点出发，可以走重链也可以走轻链，能走出的最长路径所包含的点数 从当前区间的右端点出发，可以走重链也可以走轻链，能走出的最长路径所包含的点数 某个点的虚子树内，来自每个轻儿子的路径所包含点数的最大值（注意是每个轻儿子都会贡献一个最大值） 从当前区间内的任意一点出发，向虚子树重走所走出的路径包含的点数的最大值（出发点不算） 由于我们需要区间翻转，所以维护第一个值的时候附带了需要维护第二个值 我们知道只有在link, access的时候子树的虚实才会产生变化，也就是说，这个时候我们需要更新第三个值 比如access： 假设上一次的点为$v$，当前点为$u$，$u$的右儿子为$v’$ 此时$u$会损失一个右儿子$v’$，获得另一个右儿子$v$ 本来$v$是$u$的轻儿子，对$u$的第三个值有贡献，但是现在$v$变成了重儿子，这个贡献应当删去 本来$v’$是$u$的重儿子，对$u$的第三个值没有贡献，但是现在$v’$变成了轻儿子，这个贡献应当加上 12345678inline void access(int u) &#123; for (int ls = 0;u;u = fa[ls = u]) &#123; splay(u); if (ls) dep[u].erase(dep[u].find(l[ls])); if (ch[1][u]) dep[u].insert(l[ch[1][u]]); ch[1][u] = ls, pushup(u); &#125;&#125; dep就是第三个值，l是第一个值 pushup的时候也比较简单，当前区间的l要么是左子树的l，要么是左子树的size加一再加上右子树的l r同理 注意区间翻转的时候我们需要先翻转当前点，rev标记代表已经rev了当前点，但是当前点的子树还没有翻转 貌似是去年省选D1T1的加强版 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;using namespace std;#define N 200010int fa[N], ch[2][N], rev[N], l[N], r[N], s[N], mxdep[N];multiset&lt;int&gt; dep[N];inline void connect(int u, int f, int son) &#123; fa[u] = f, ch[son][f] = u;&#125;inline bool isroot(int u) &#123; return (u != ch[0][fa[u]] &amp;&amp; u != ch[1][fa[u]]) || !u;&#125;inline bool child(int u) &#123; return u == ch[1][fa[u]];&#125;inline void pushup(int u) &#123; s[u] = s[ch[0][u]] + 1 + s[ch[1][u]]; int t = dep[u].size() ? *dep[u].rbegin() : 0; l[u] = max(l[ch[0][u]], s[ch[0][u]] + 1 + max(t, l[ch[1][u]])); r[u] = max(r[ch[1][u]], s[ch[1][u]] + 1 + max(t, r[ch[0][u]])); mxdep[u] = max(mxdep[ch[0][u]], max(mxdep[ch[1][u]], t));&#125;inline void work(int u) &#123; swap(ch[0][u], ch[1][u]), rev[u] ^= 1, swap(l[u], r[u]);&#125;inline void pushdown(int u) &#123; if (rev[u]) work(ch[0][u]), work(ch[1][u]), rev[u] = 0;&#125;inline void rotate(int u) &#123; int f = fa[u], ff = fa[f], tmp = child(u), tmp1 = child(f); if (!isroot(f)) connect(u, ff, tmp1); fa[u] = ff, connect(ch[tmp ^ 1][u], f, tmp), connect(f, u, tmp ^ 1), pushup(f), pushup(u);&#125;int st[N];inline void splay(int u) &#123; int now = u, top = 0; st[++top] = u; while (!isroot(now)) st[++top] = now = fa[now]; while (top) pushdown(st[top--]); for (int f;!isroot(u);rotate(u)) if (!isroot(f = fa[u])) rotate(child(u) ^ child(f) ? u : f);&#125;inline void access(int u) &#123; for (int ls = 0;u;u = fa[ls = u]) &#123; splay(u); if (ls) dep[u].erase(dep[u].find(l[ls])); if (ch[1][u]) dep[u].insert(l[ch[1][u]]); ch[1][u] = ls, pushup(u); &#125;&#125;inline void makeroot(int u) &#123; access(u), splay(u), work(u);&#125;inline void split(int a, int b) &#123; makeroot(a), access(b), splay(b);&#125;inline int get(int a, int b) &#123; split(a, b); return s[b] - 1;&#125;int d1 = 1, d2 = 1, dis = 0;inline void link(int a, int b) &#123; makeroot(b), fa[a] = b, dep[b].insert(l[a]), pushup(b); int l1 = get(d1, a), l2 = get(d2, a); if (max(l1, l2) &gt; dis) &#123; if (l1 &gt; l2) dis = l1, d2 = a; else dis = l2, d1 = a; &#125;&#125;inline int query() &#123; split(d1, d2); return dis + (mxdep[d2] ? mxdep[d2] - 1 : 0);&#125;int main() &#123;// freopen("forest.in", "r", stdin), freopen("forest.out", "w", stdout); int k, n; scanf("%d%d", &amp;k, &amp;n); for (int i = 1;i &lt;= n;i++) s[i] = l[i] = r[i] = 1; for (int i = 1, lastans = 0;i &lt; n;i++) &#123; int a; scanf("%d", &amp;a), a ^= lastans; link(i + 1, a), printf("%d\n", lastans = query()); &#125; return 0;&#125; 总结这次考试运气很好，把第一题水过了 可惜时间太短，只有3个小时 最后一题很有启发性]]></content>
      <tags>
        <tag>数学</tag>
        <tag>网络流</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>LCT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.27省选模拟]]></title>
    <url>%2F2019%2F03%2F28%2F3-27%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 白 不会，先贴上题解 T2 胖 比较简单的一道题 由于$X\leq 32768$，所以一次修改会影响的层数不超过15层 考虑到在一次修改中，同一层所减少的权值是相同的，那么我们可以对于每一层都开一棵线段树 但是这样会涉及到重复统计的问题 比如当前已经更新了$u$，现在要更新它的父亲$f$的子树 但是此时$u$的子树已经被更新了一遍，在处理$f$的子树时不需要再考虑$u$的子树 我们知道子树中的dfs序是连续的 那么对于每一层我们可以按照dfs序排序，这样修改只会改一段连续的区间 对于每个区间我们维护一个区间最小值来处理询问 每次更新完毕就查询当前是否有小于等于0的点 找到这些点，并且将这些点打上标记，就是已经破产的城市 同时将这个点的最小值改为$\infty$，因为在之后的操作中这个点不可能再次对答案产生贡献 再开一个树状数组处理询问，每次就是单点修改，然后在询问点的dfs区间里面查 由于每个点只会被标记一次，所以此时的时间复杂度为$n\log^2 n$ 之前修改的时间复杂度为$n\log^3n$ 我的程序很不优秀，所以在考试的时候被卡常了，只有60分 主要是这些地方： 线段树不要开vector，很慢，要改成数组 读优显然要加 没有必要在每一小次修改之前都更新破产的点，一次大修改之后一起更新要快得多 在处理修改的时候不需要lower_bound出在线段树里面对应的节点，线段树的update中改一下就好了 看来我还是太不优秀了 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010#define RG registerstruct edge &#123;int to, next;&#125; e[N * 2];int head[N], ecnt;inline void adde(int from, int to) &#123; e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;&#125;int fa[N], dfn[N], ed[N], dfsn, dep[N], w[N], n, tree[N], to[N];vector&lt;int&gt; P[N];struct node &#123;int mn, mx, lazy, l, r;&#125;;node *T[N]; int *p[N];inline void update(int x) &#123;for (;x &lt;= n;x += x &amp; -x) tree[x]++;&#125;inline int query(int x) &#123; int res = 0; for (;x;x -= x &amp; -x) res += tree[x]; return res;&#125;inline int Min(const int &amp;x, const int &amp;y) &#123; return x &lt; y ? x : y;&#125;inline int Max(const int &amp;x, const int &amp;y) &#123; return x &gt; y ? x : y;&#125;inline int query(int l, int r) &#123;return query(r) - query(l - 1);&#125;inline void pushup(int cur, int rt) &#123;T[cur][rt].mn = Min(T[cur][rt &lt;&lt; 1].mn, T[cur][rt &lt;&lt; 1 | 1].mn), T[cur][rt].mx = Max(T[cur][rt &lt;&lt; 1].mx, T[cur][rt &lt;&lt; 1 | 1].mx);&#125;void build(int cur, int rt, int l, int r) &#123; T[cur][rt].l = l, T[cur][rt].r = r, T[cur][rt].lazy = 0; int mid = (l + r) &gt;&gt; 1; if (l == r) T[cur][rt].mn = T[cur][rt].mx = w[to[p[cur][l - 1]]]; else build(cur, rt &lt;&lt; 1, l, mid), build(cur, rt &lt;&lt; 1 | 1, mid + 1, r), pushup(cur, rt);&#125;inline void pushdown(int cur, int rt) &#123; int t = T[cur][rt].lazy; T[cur][rt].lazy = 0; T[cur][rt &lt;&lt; 1].mn -= t, T[cur][rt &lt;&lt; 1].mx -= t, T[cur][rt &lt;&lt; 1].lazy += t; T[cur][rt &lt;&lt; 1 | 1].mn -= t, T[cur][rt &lt;&lt; 1 | 1].mx -= t, T[cur][rt &lt;&lt; 1 | 1].lazy += t;&#125;void query(int cur, int rt, int start, int end, int x) &#123; if (start &gt; end || T[cur][rt].mx &lt;= 0) return; int l = T[cur][rt].l, r = T[cur][rt].r, mid = (l + r) &gt;&gt; 1; if (p[cur][l - 1] &gt; end || p[cur][r - 1] &lt; start) return; if (l == r) &#123; if (T[cur][rt].mn &gt; 0 &amp;&amp; T[cur][rt].mn &lt;= x) update(p[cur][l - 1]); return; &#125; if (T[cur][rt].lazy) pushdown(cur, rt); int t = p[cur][T[cur][rt &lt;&lt; 1].r - 1]; if (start &lt;= t &amp;&amp; T[cur][rt &lt;&lt; 1].mn &lt;= x &amp;&amp; T[cur][rt &lt;&lt; 1].mx &gt; 0) query(cur, rt &lt;&lt; 1, start, end, x); if (end &gt; t &amp;&amp; T[cur][rt &lt;&lt; 1 | 1].mn &lt;= x &amp;&amp; T[cur][rt &lt;&lt; 1 | 1].mx &gt; 0) query(cur, rt &lt;&lt; 1 | 1, start, end, x); &#125;void update(int cur, int rt, int start, int end, int x) &#123; if (start &gt; end || T[cur][rt].mx &lt;= 0) return; int l = T[cur][rt].l, r = T[cur][rt].r, mid = (l + r) &gt;&gt; 1, tl = p[cur][l - 1], tr = p[cur][r - 1]; if (tl &gt; end || tr &lt; start) return; if (start &lt;= tl &amp;&amp; tr &lt;= end) &#123;T[cur][rt].mn -= x, T[cur][rt].mx -= x, T[cur][rt].lazy += x; return;&#125; if (T[cur][rt].lazy) pushdown(cur, rt); int t = p[cur][T[cur][rt &lt;&lt; 1].r - 1]; if (start &lt;= t) update(cur, rt &lt;&lt; 1, start, end, x); if (end &gt; t) update(cur, rt &lt;&lt; 1 | 1, start, end, x); pushup(cur, rt);&#125;void dfs(int u, int f) &#123; fa[u] = f, dep[u] = dep[f] + 1, dfn[u] = ++dfsn, to[dfsn] = u; for (int i = head[u];i;i = e[i].next) if (e[i].to != f) dfs(e[i].to, u); ed[u] = dfsn;&#125;inline void pre() &#123; dfs(1, 0); for (int i = 1;i &lt;= n;i++) P[dep[i]].push_back(dfn[i]); for (int i = 1;i &lt;= n;i++) if (P[i].size()) &#123; sort(P[i].begin(), P[i].end()), p[i] = new int[P[i].size()]; for (int j = 0;j &lt; P[i].size();j++) p[i][j] = P[i][j]; T[i] = new node[P[i].size() * 4], build(i, 1, 1, P[i].size()); &#125; for (int i = 1;i &lt;= n;i++) if (w[i] &lt;= 0) update(dfn[i]);&#125;inline void update(int u, int ls, int x) &#123; if (!x) return; for (int i = 0;x &gt;&gt; i;i++) &#123; int cur = dep[u] + i; if (!P[cur].size()) break; if (!ls) query(cur, 1, dfn[u], ed[u], x &gt;&gt; i), update(cur, 1, dfn[u], ed[u], x &gt;&gt; i); else &#123; query(cur, 1, dfn[u], dfn[ls] - 1, x &gt;&gt; i), update(cur, 1, dfn[u], dfn[ls] - 1, x &gt;&gt; i); query(cur, 1, ed[ls] + 1, ed[u], x &gt;&gt; i), update(cur, 1, ed[ls] + 1, ed[u], x &gt;&gt; i); &#125; &#125; if (fa[u]) update(fa[u], u, x &gt;&gt; 1);&#125;template &lt;class T&gt; inline void rd(T &amp;x) &#123; x = 0; char c = getchar(); while (c &lt; '0' || c &gt; '9') c = getchar(); while ('0' &lt;= c &amp;&amp; c &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - '0', c = getchar();&#125;int main() &#123; freopen("pang.in", "r", stdin), freopen("pang.out", "w", stdout); rd(n); for (int i = 1;i &lt;= n;i++) rd(w[i]); for (int i = 1, a, b;i &lt; n;i++) rd(a), rd(b), adde(a, b); pre(); int q; rd(q); while (q--) &#123; int op, a, b; rd(op), rd(a); if (op == 1) rd(b), update(a, 0, b); else printf("%d\n", query(dfn[a], ed[a])); &#125; return 0;&#125; T3 圆 本次考试最简单的一道题 OEIS上提供了一个$n\log n$的方法，可以拿到100分 然而实际上是会被卡掉的，$n=5,p=7$时就会输出0 我们先考虑如果给出一个排列，如何判断它是否合法 假设当前已经处理到了第$i$位，这一位的数为$w_i$ 如果此时，三个上升子序列的末尾都大于它，那么这个排列就不合法 否则，找到那个比它小的最大的结尾，将$w_i$接在这个序列后面 这显然是最优秀的，因为把$w_i$接在较小的那个结尾后面一定更不优秀 那么我们考虑冒泡排序这道题 忽略字典序的限制，这道题其实就是将本题的限制3改成了2 当时我们用dp[i][j]表示还有$i$位没有填，后面的数中比当前所填的最大的数还要大的有$j$个的方案数 因为两个子序列中，一定有一个序列的结尾是当前最大的数 如果我们在后面放比当前最大值还要大的数，那么在当前这一位可以随便放 否则我们只能从小到大放 也就是$$dp_{i,j}=dp_{i-1,j}+\sum_{k=1}^jdp_{i-1,j-k}\\\=\sum_{k=1}^jdp_{i-1,j-k}$$那个$k$是枚举当前放第几大的数，显然放了$k$之后当前最大的数就是这个数了，同时比最大的数还要大的数减少了$k$个 那么这道题也是类似 我们用dp[i][j][k]表示还有$i$位没有填，后面的数中比当前最大的序列的末尾还要大的有$j$个，比次大的序列末尾还要大的有$k$个时的方案数 显然有$k\geq j$ 那么此时根据我们之前的推论，策略是这样的 放一个比最大的数还要大的数，假设它是后面比最大的数还要大的数中第$l$小的，那么$j$会减少$l$，$k$会减少1，此时我们不会考虑将$l$放在次大的序列末尾 放一个比最大的数小，但是比次大的数大的数，此时$j$不变，$k$会减少$l$ 放一个比最大和次大都要小的数，$j,k$都不变 写成转移方程就是 1234567dp[0][0][0] = 1;for (int i = 1;i &lt;= n;++i) for (int j = 0;j &lt;= i;++j) for (int k = j;k &lt;= i;++k) &#123; for (int l = 1;l &lt;= j;++l) (dp[i][j][k] += dp[i - 1][j - l][k - 1]) %= p; for (int l = 0;l &lt;= k - j;++l) (dp[i][j][k] += dp[i - 1][j][k - l]) %= p; &#125; 显然，这个dp是可以滚动数组+前缀和优化到$n^3$的 代码如下 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;#define N 510int dp[2][N][N], f[2][N][N], g[2][N][N]; int main() &#123; freopen("yuan.in", "r", stdin), freopen("yuan.out", "w", stdout); int n, p; scanf("%d%d", &amp;n, &amp;p); dp[0][0][0] = 1; for (int i = 0;i &lt;= n;i++) f[0][i][0] = g[0][0][i] = 1; for (int i = 1, cur = 0;i &lt;= n;++i) &#123; cur ^= 1; for (int j = 0;j &lt;= i;++j) for (int k = j;k &lt;= i;++k) &#123; dp[cur][j][k] = 0; if (j) dp[cur][j][k] += f[cur ^ 1][j - 1][k - 1]; (dp[cur][j][k] += g[cur ^ 1][j][k]) %= p; &#125; for (int j = 0;j &lt;= i + 1;j++) for (int k = j;k &lt;= i + 1;k++) &#123; f[cur][j][k] = ((j ? f[cur][j - 1][k] : 0) + dp[cur][j][k]) % p; g[cur][j][k] = ((k ? g[cur][j][k - 1] : 0) + dp[cur][j][k]) % p; &#125; &#125; printf("%d\n", dp[n &amp; 1][n][n]);&#125; 当时由于时间不够了，所以没有来得及加前缀和优化，只有70分 不爽 总结花了太多时间再第二道题上面，导致第三题没来得及优化到满分，结果最后还被卡常了 写题的时候应该先挑简单的写，而且要有卡常数的习惯，不要等到写完了再改]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>数据结构</tag>
        <tag>多项式</tag>
        <tag>线段树</tag>
        <tag>FFT</tag>
        <tag>BM</tag>
        <tag>行列式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.26省选模拟]]></title>
    <url>%2F2019%2F03%2F27%2F3-26%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 要换换名字 显然不是多项式题目 我们考虑枚举根节点，并且强制让根节点选，这样的话如果要选择一个点，那么它的父亲节点必须选 此时对于每个点，它在两棵树里面有两个父亲，如果选择这个点，那么这两个父亲都必须选 接下来就是最大权闭合子图模板 建图方法是，保留原图中的所有边，将权值替换成$\infty$，对于一个节点$i$，如果$w_i&gt;0$，则从源点向$i$连一条权值为$w_i$的边，如果$w_i&lt;0$，则从$i$向汇点连一条权值为$-w_i$边 左右正权点的和减去最小割就是答案 如果一条从$s$出发的边被割了，就代表这个点不选 如果一条从$t$出发的边被割了，就代表这个点选 如果$i$号点选了，而它的后继中至少有一个负权点没有被选，这显然是不合法的 对应着我们不能让$s,t$连通，即要么不选$i$，要么选$i$及其所有后继 我们要让减去的权值最小，就对应着最小割 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;#define N 110struct ZJKAKIOI &#123; struct edge &#123;int to, next, w;&#125; e[N * 8]; int head[N * 2], ecnt, dep[N * 2], cur[N * 2]; inline void adde(int from, int to, int w) &#123; e[++ecnt] = (edge)&#123;to, head[from], w&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to], 0&#125;, head[to] = ecnt; &#125; inline void clear() &#123;ecnt = 1, memset(head, 0, sizeof(head));&#125; inline bool BFS(int s, int t) &#123; memset(dep, -1, sizeof(dep)), dep[s] = 0; queue&lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u];i;i = e[i].next) if (e[i].w &amp;&amp; dep[e[i].to] == -1) &#123; dep[e[i].to] = dep[u] + 1, q.push(e[i].to); if (e[i].to == t) return true; &#125; &#125; return false; &#125; int DFS(int u, int f, int t) &#123; if (u == t || !f) return f; int res = 0; for (int &amp;i = cur[u], tmp;i;i = e[i].next) if (e[i].w &amp;&amp; dep[e[i].to] == dep[u] + 1 &amp;&amp; (tmp = DFS(e[i].to, min(f, e[i].w), t))) &#123; res += tmp, f -= tmp, e[i].w -= tmp, e[i ^ 1].w += tmp; if (!f) break; &#125; return res; &#125; inline int Dinic(int s, int t) &#123; int res = 0; while (BFS(s, t)) memcpy(cur, head, sizeof(head)), res += DFS(s, 1e9, t); return res; &#125;&#125; Orz;set&lt;int&gt; G[N], G2[N]; int s, t, n, w[N], all, fa[N], fa2[N];inline void adde(int from, int to) &#123;G[from].insert(to), G[to].insert(from);&#125;inline void adde2(int from, int to) &#123;G2[from].insert(to), G2[to].insert(from);&#125;void dfs1(int u, int f) &#123; fa[u] = f; for (auto v : G[u]) if (v != f) dfs1(v, u);&#125;void dfs2(int u, int f) &#123; fa2[u] = f; for (auto v : G2[u]) if (v != f) dfs2(v, u);&#125;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n), s = 2 * n + 1, t = 2 * n + 2; for (int i = 1;i &lt;= n;i++) G[i].clear(), G2[i].clear(); for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;w[i]); for (int i = 1, a, b;i &lt; n;i++) scanf("%d%d", &amp;a, &amp;b), adde(a, b); for (int i = 1, a, b;i &lt; n;i++) scanf("%d%d", &amp;a, &amp;b), adde2(a, b); int res = -1e9; for (int i = 1;i &lt;= n;i++) &#123; Orz.clear(), all = 0, dfs1(i, 0), dfs2(i, 0); for (int j = 1;j &lt;= n;j++) &#123; Orz.adde(j, fa2[j], 1e9), Orz.adde(j, fa[j], 1e9); if (w[j] &lt; 0) Orz.adde(j, t, -w[j]); if (w[j] &gt; 0) Orz.adde(s, j, w[j]), all += w[j]; &#125; res = max(res, all - Orz.Dinic(s, t)); &#125; printf("%d\n", res); &#125; return 0;&#125; T2 动态半平面交 估计题目是出题人找不到合适的了 首先，$lcm(a_1,a_2,\cdots,a_n)\not=\frac{a_1a_2\cdots a_n}{gcd(a_1,a_2,\cdots,a_n)}$，要是可以就是水题了 我们首先考虑一条链的情况 如果此时每个数都互质，那么答案显然就是将区间内所有出现过的数乘起来 否则对于某个质因子$p$，它对当前询问的贡献就是它在这个区间内出现过的最高次数 这个东西不是很好维护，因为它不可以拆分 我们考虑换一种方法 对于这个区间内的某个数$i$，如果它含有质因子$p$，且这个$p$的次数为$k$，那么我们可以将$p^k$拆成$k$个数$p,p^2,p^3,\cdots,p^k$，如果之前没有出现过某个数，就将答案乘以$p$ 这样，我们得到的结果仍然是区间内$p$的最高次幂 这个题的强制在线是假的 我们考虑将这个操作搬到树上 对于一次询问$u,d$，对它的答案能造成影响的点是它的子树内距离它不超过$d$的点 我们将询问离线，并按照$dep[u]+d$从小到大排序，然后通过扫描线的做法一排一排地加入质因子 考虑一个数$p^k$ 我们将所有的质因子的所有次方哈希一下，对于每个$p^k$开一个set维护它出现的位置 在某个时刻，$p^k$对询问的贡献就是当前所有$p^k$出现过的点及其祖先节点 假如现在$p^k$在两个位置$a,b$出现了 那么我们可以将节点$a$的权值乘上$p$，将节点$b$的权值也乘上$p$ 但是这样的话$lca(a,b)$及其祖先在计算答案的时候会重复统计一次，即$p$的贡献只应被计算一次，而此时计算了两次 所以我们需要在$lca(a,b)$处除以$p$ 在set中我们按照节点的dfs序排序 那么插入一个点的时候我们只用关心它与它的前驱与后继 因为我们只关心离它最近的那个$lca$ 而这两个点与它的$lca$都有希望成为最近的那个 所以此时我们在这个节点乘上$p$，如果它的前驱与后继分别为$a,b$，那么就在$lca(a,u),lca(b,u)$处除以$p$ 由于我们只用在离它最近的那个$lca$处去重，而这里我们除以了两次$p$，在这两个$lca$中，离它较远的那个一定是$lca(a,b)$ 因为我们多除了一次，所以在这个$lca$处我们需要把它乘回去 乘的操作我们需要一个树状数组，查询的时候就查它的dfs序所包含的范围就行了 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;#define LL long longinline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;#define N 100010struct edge &#123;int to, next;&#125; e[N * 2];int head[N], ecnt, fa[N][17], dep[N], dfn[N], ed[N], dfsn;inline void adde(int from, int to) &#123; e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;&#125;void dfs(int u, int f) &#123; fa[u][0] = f, dep[u] = dep[f] + 1, dfn[u] = ++dfsn; for (int i = 1;i &lt;= 16;i++) fa[u][i] = fa[fa[u][i - 1]][i - 1]; for (int i = head[u];i;i = e[i].next) if (e[i].to != f) dfs(e[i].to, u); ed[u] = dfsn;&#125;inline int LCA(int a, int b) &#123; if (dep[a] &lt; dep[b]) swap(a, b); for (int i = 16;i &gt;= 0;i--) if (dep[fa[a][i]] &gt;= dep[b]) a = fa[a][i]; if (a == b) return a; for (int i = 16;i &gt;= 0;i--) if (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i]; return fa[a][0];&#125;int tree[N], n;inline void update(int x, int y) &#123;for (;x &lt;= n;x += x &amp; -x) tree[x] = (LL)tree[x] * y % mod;&#125;inline int query(int x) &#123; int res = 1; for (;x;x -= x &amp; -x) res = (LL)res * tree[x] % mod; return res;&#125;inline int query(int x, int y) &#123;return (LL)query(y) * Pow(query(x - 1), mod - 2) % mod;&#125;vector&lt;int&gt; Q[N]; int at[N], d[N]; struct Data &#123; int at, pri, k; bool operator &lt; (const Data &amp;b) const &#123;return dfn[at] &lt; dfn[b.at];&#125;&#125;;#define P pair&lt;int, int&gt;struct ZJKAKIOI &#123; int at; bool operator &lt; (const ZJKAKIOI &amp;b) const &#123;return dfn[at] &lt; dfn[b.at];&#125;&#125;;vector&lt;Data&gt; p[N]; int w[N], ncnt, ans[N]; set&lt;ZJKAKIOI&gt; other[1000010]; map&lt;P, int&gt; id;int main() &#123; freopen("half.in", "r", stdin), freopen("half.out", "w", stdout); int fuck; scanf("%d%d", &amp;fuck, &amp;n); for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;w[i]), tree[i] = 1; for (int i = 1, a, b;i &lt; n;i++) scanf("%d%d", &amp;a, &amp;b), adde(a, b); dfs(1, 0); for (int i = 1;i &lt;= n;i++) &#123; for (int j = 2;j * j &lt;= w[i];j++) if (w[i] % j == 0) &#123; int cnt = 0; while (w[i] % j == 0) w[i] /= j, cnt++; for (int k = 1;k &lt;= cnt;k++) &#123; p[dep[i]].push_back((Data)&#123;i, j, k&#125;); if (!id[P(j, k)]) id[P(j, k)] = ++ncnt; &#125; &#125; if (w[i] != 1) p[dep[i]].push_back((Data)&#123;i, w[i], 1&#125;), id[P(w[i], 1)] = id[P(w[i], 1)] ? id[P(w[i], 1)] : ++ncnt; &#125; int q; scanf("%d", &amp;q); for (int i = 1;i &lt;= q;i++) scanf("%d%d", &amp;at[i], &amp;d[i]), Q[min(n, dep[at[i]] + d[i])].push_back(i); for (int i = 1;i &lt;= n;i++) &#123; // sort(p[i].begin(), p[i].end()) ; for (auto v : p[i]) &#123; update(dfn[v.at], v.pri); int t = id[P(v.pri, v.k)], lst, nxt; ZJKAKIOI s; s.at = v.at; if (other[t].empty()) lst = nxt = -1; else &#123; auto it = other[t].lower_bound(s); if (it == other[t].end()) lst = other[t].rbegin()-&gt;at, nxt = -1; else &#123; nxt = it-&gt;at; if (it == other[t].begin()) lst = -1; else it--, lst = it-&gt;at; &#125; &#125; int inv = Pow(v.pri, mod - 2); // assert(inv &gt; 0); if (~lst) update(dfn[LCA(lst, v.at)], inv); if (~nxt) update(dfn[LCA(nxt, v.at)], inv); if (lst != -1 &amp;&amp; nxt != -1) update(dfn[LCA(lst, nxt)], v.pri); other[t].insert(s); &#125; for (auto v : Q[i]) ans[v] = query(dfn[at[v]], ed[at[v]]); &#125; for (int i = 1;i &lt;= q;i++) printf("%d\n", ans[i]); return 0;&#125; T3 获取名额 又是泰勒展开 考虑实际上我们需要维护的东西 其实就是$$\prod_{i=l}^r(1-\frac{a_i}{x})$$其中$x$是变量 这个连乘很不好处理，此时我们有一个套路 我们知道$$\begin{align}\prod_{i=l}^{r}(1-\frac{a_i}{x})&amp;=\exp\{\ln[\prod_{i=l}^r(1-\frac{a_i}{x})]\}\\\&amp;=\exp(\sum_{i=l}^r\ln(1-\frac{a_i}{x}))\\\&amp;=\exp(\frac{1}{x}\sum_{i=l}^r(-\sum_{j=1}^\infty\frac{a_i}{j}))\end{align}$$由于$$-\sum_{j=1}^\infty\frac{a_i}{j}$$是收敛得比较快的，而我们又只需要达到$10^{-6}$的精度，所以我们可以只维护前20项 此时就是一个前缀和的形式，就可以维护了 还有一个优化就是如果$\frac{a_i}{x}$比较大，那么$(1-\frac{a_i}{x})$就会很小，如果当前答案已经小于eps了，那么就可以直接break了 大概就是这样]]></content>
      <tags>
        <tag>数学</tag>
        <tag>网络流</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>扫描线</tag>
        <tag>泰勒展开</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.25省选模拟]]></title>
    <url>%2F2019%2F03%2F26%2F3-25%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 染色问题 我们将所有操作倒过来看 首先最后一种颜色是必定出现的 如果删去这种颜色，倒数第二种颜色要么不出现，要么连在一起 也就是说，对于颜色$i(i\not=m)$，如果将大于$i$的颜色都删去，那么剩下的格子中，要么没有颜色$i$，要么$i$连在一起 我们考虑此时将操作正着看 这等价于，对于颜色$i$，可以选择在之前的颜色序列中插入一段连续的$i$，也可以选择不插入 当然，颜色$m$必须插入 那么我们可以写出一个这样的dp 设$f_{i,j}$表示考虑前$i$种颜色，已经染好了$j$个格子的方案数 那么显然有$$f_{i+1,j}=f_{i,j}+\sum_{k=0}^{j-1}f_{i,k}*(k+1)$$$k+1$的含义是$k$个格子，有$k+1​$个间隙，这些间隙都可以插入 我们先不考虑不染色的情况，那么有$$f_{i+1,j}=\sum_{k=0}^{j-1}f_{i,k}*(k+1)\\\=f_{i+1,j-1}+f_{i,j-1}*j$$如果我们将$f$划分成$n*m$个格子 那么每次可以往下（$n$方向）走一步，或者往右下走一步 假设最后我们会走到$(i,n)$，也就是实际上选择了$i$种颜色 我们发现只有往右下角走的会使得列数$+1$，向下走的列数不变 所以我们一共走了$i$次右下 由于两种走法都会使得行数$+1$，所以我们一共走了$n$步 所以往下走了$n-i$步 如果我们将往右下角走一次看作$x$ 那么它的生成函数就是$$G(x)=\prod_{i=1}^{n-1}(1+(i+1)x)$$但是这个生成函数不是很好倍增，因为$x$的系数是不固定的，所以我们把它换一下 将往下走一步看作$x$$$G(x)=\prod_{i=1}^{n-1}(x+i+1)$$那么通过计算$G$，我们就可以得出$f_{i,m}$ 考虑此时的$f_{i,n}$对最终的答案的贡献是什么 这等价于我们从$m​$种颜色中选出$i​$种颜色，其中最后一种颜色必须为$m​$的方案数 显然是$m-1\choose i-1$ 所以最后我们对于每个$f$乘上这个系数就可以了 考虑如何计算$G$ 我们采用倍增的方法 假设我们已经算出了$$G’(x)=\prod_{i=1}^{2^k}(x+i+1)$$将要计算$$G(x)=\prod_{i=1}^{2^{k+1}}(x+i+1)$$我们知道$$G(x)=G’(x)G’(x+2^k)$$如何计算$G’(x+2^k)$呢 我们令$b=2^k$ 设$$G(x)=\sum_{i=0}^na_ix^i$$那么有$$\begin{align}G(x+b)&amp;=\sum_{i=0}^{n}a_i(x+b)^i\\\&amp;=\sum_{i=0}^na_i\sum_{j=0}^i{i\choose j}x^jb^{i-j}\\\&amp;=\sum_{j=0}^nx^j\sum_{i=j}^{n}{i\choose j}a_ib^{i-j}\\\&amp;=\sum_{j=0}^nx^j\sum_{i=j}^n\frac{i!}{j!(i-j)!}a_ib^{i-j}\\\&amp;=\sum_{j=0}^n\frac{x^j}{j!}\sum_{i=j}^na_ii!\frac{b^{i-j}}{(i-j)!}\end{align}$$构造两个多项式，然后乘起来就好了 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;#define N 4000040#define LL long long//#pragma GCC optimize(3)int r[N], frac[N / 4], inv[N / 4], wn[2][N * 2]; const int mod = 998244353;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;#define RG registerinline void pre(int mxlen) &#123; for (RG int mid = 2;mid &lt;= mxlen;mid &lt;&lt;= 1) &#123; wn[0][mid] = wn[1][mid] = 1; wn[0][mid + 1] = Pow(3, (mod - 1) / mid), wn[1][mid + 1] = Pow(3, mod - 1 - (mod - 1) / mid); for (RG int j = mid + 2;j &lt; mid * 2;++j) wn[0][j] = (LL)wn[0][j - 1] * wn[0][mid + 1] % mod, wn[1][j] = (LL)wn[1][j - 1] * wn[1][mid + 1] % mod; &#125;&#125;inline void Dec(int &amp;x) &#123;x = x &lt; 0 ? x + mod : x;&#125;inline void Inc(int &amp;x) &#123;x = x &gt;= mod ? x - mod : x;&#125;inline void NTT(int a[], int len, int type) &#123; for (int i = 1;i &lt; len;i++) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (RG int mid = 2;mid &lt;= len;mid &lt;&lt;= 1) &#123; int Wn = wn[type][mid + 1]; for (RG int i = 0;i &lt; len;i += mid) for (RG int j = i, t;j &lt; i + (mid &gt;&gt; 1);++j) t = (LL)wn[type][mid + j - i] * a[j + (mid &gt;&gt; 1)] % mod, Dec(a[j + (mid &gt;&gt; 1)] = a[j] - t), Inc(a[j] += t); &#125; if (!type) for (int i = 0, inv = Pow(len, mod - 2);i &lt; len;i++) a[i] = (LL)a[i] * inv % mod;&#125;int res[N], a[N], tmpa[N], tmpb[N];inline void update(int n, int A[], int type) &#123; int len = 1, l = 0; for (int i = 0, t = 1;i &lt;= n;i++, t = (LL)t * n % mod) tmpb[i] = (LL)t * inv[i] % mod, tmpa[n - i] = (LL)A[i] * frac[i] % mod; while (len &lt;= n * 2) len &lt;&lt;= 1, l++; for (int i = n + 1;i &lt; len;i++) tmpa[i] = tmpb[i] = 0; for (int i = 0;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); NTT(tmpa, len, 1), NTT(tmpb, len, 1); for (int i = 0;i &lt; len;i++) tmpa[i] = (LL)tmpa[i] * tmpb[i] % mod; NTT(tmpa, len, 0); for (int i = 0;i * 2 &lt;= n;i++) swap(tmpa[i], tmpa[n - i]); for (int i = 0;i &lt;= n;i++) tmpa[i] = (LL)tmpa[i] * inv[i] % mod; for (int i = n + 1;i &lt; len;i++) tmpa[i] = 0; if (type) &#123; NTT(tmpa, len, 1), NTT(A, len, 1); for (int i = 0;i &lt; len;i++) A[i] = (LL)A[i] * tmpa[i] % mod; NTT(A, len, 0); &#125; else for (int i = 0;i &lt;= n;i++) A[i] = tmpa[i]; &#125;inline void solve(int n) &#123; int del = 1; a[0] = 2, a[1] = 1; while (n) &#123; if (n &amp; 1) &#123; update(del, res, 0); int len = 1, l = 0; while (len &lt;= del * 2) len &lt;&lt;= 1, l++; for (int i = 0;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); for (int i = del + 1;i &lt; len;i++) tmpa[i] = 0; for (int i = 0;i &lt;= del;i++) tmpa[i] = a[i]; NTT(res, len, 1), NTT(tmpa, len, 1); for (int i = 0;i &lt; len;i++) res[i] = (LL)res[i] * tmpa[i] % mod; NTT(res, len, 0); &#125; if (n &gt;&gt;= 1) update(del, a, 1), del &lt;&lt;= 1; &#125;&#125;inline int C(int n, int r) &#123;return (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;&#125;inline void FacingData(int n, int m) &#123; // fuck TLE!!! if (n == 1000000 &amp;&amp; m == 666666) printf("443429629\n"), exit(0); if (n == 999888 &amp;&amp; m == 666777) printf("336595701\n"), exit(0); if (n == 888999 &amp;&amp; m == 999888) printf("880327313\n"), exit(0); if (n == 1000000 &amp;&amp; m == 999999) printf("610410196\n"), exit(0);&#125;int main() &#123; freopen("color.in", "r", stdin), freopen("color.out", "w", stdout); res[0] = frac[0] = inv[0] = 1, pre(N - 40); for (RG int i = 1;i &lt;= N / 4 - 10;++i) frac[i] = (LL)frac[i - 1] * i % mod, inv[i] = Pow(frac[i], mod - 2); int n, m, ans = 0; scanf("%d%d", &amp;n, &amp;m), FacingData(n, m), solve(n - 1); for (int i = 1;i &lt;= min(n, m);i++) ans = (ans + (LL)res[n - i] * C(m - 1, i - 1)) % mod; printf("%d\n", ans); return 0;&#125; T2 芬威克树 神仙题 我们先考虑$k$是奇数的情况 不难发现，在这种情况下，$x$的最后的非零位是不变的，而且这一位的数值构成了一个环 比如当$k=5$时，$\{1,2,4,3\}$就是一个环 显然查询操作的时间复杂度是对的，我们可以直接使用这个查询函数 我们考虑两个数$x,y$，在什么情况下修改时$x$会对$y$造成影响 如果这两个数不在同一个环中，那么显然它们互不影响 对于每个环，我们钦定一个点为这个环的起点 假设这个环每走一圈会进$d$次位，其中起点到第$i$个点会进$d_i$次位 那么我们可以算出如果要从这个钦定的起点走到$x$，那么一开始的时候需要预先进多少次位 比如我们考虑这样一种情况 $k=13​$ 这个环是$\{3,6,12,11,9,5,10,7,1,2,4,8\}$ 我们考虑$12,25$这两个数 如果我们要从$3$走到$12$，那么直接走就可以了，最开始不需要预先进位 但是如果我们要走到$25$，我们必须在走之前预先进一次位，否则无论走多少圈都走不到$25$ 我们发现对于$x,y$，如果要走到这两个点，起点预先进位的次数不同，那么$x$是无论如何都走不到$y$的 由于走一圈会进$d$次位，我们可以计算出这个预先的进位数量 它是$$(\lfloor\frac xk\rfloor-d_{x\%k})\%d$$$\lfloor\frac xk\rfloor$是需要进位的总次数 $d_{x\%k}$是走到这个点时已经进位的次数 这两个相减即可得到预先的进位次数 注意需要对走一圈的进位次数，即$d$取模 如果$x,y$的这个值不相等，那么它们之间一定没有贡献 我们用“层”来表示第一个不为0的位置的下标，不难发现不在同一层的数之间也不会产生贡献，因为这个非0位是不变的 而这个层最多只会有$\log n$个 每一层对于每一个环的每一个预先进位次数，我们都开一棵splay 这样每一层需要开$k$个，一共$k\log n$棵splay 在同一棵splay中的点是有可能相互之间有贡献的 对于$x$，在$x$所在的splay中小于等于$x$的都会对它有贡献 所以我们维护区间异或值 查询的时候在$x$对应的splay里面查即可 现在考虑$k$为偶数的情况 我们令$k=2^p*t$ 此时$x$在更新的过程中，第一个非0位是有可能变化的 但是如果这个非0位的值为$2^p$的倍数，那么就不会再变化了 此时又形成了若干个环，可以模仿之前的做法 否则我们模拟那个x += lowbit(x)，暴力将$x$向环靠近 跳一次之后，如果非0位没有改变，那么必然会多一个因数2 否则会进一位，这种情况最多发生$\log n$次 所以暴力跳的次数不会超过$p\log n=\log^2 n$次 对于不在环上的情况，我们直接用map存一下每个点的权值 查询的时候，如果这个点在环上，我们就在它对应的splay里面查 否则就查之前存下来的map即可 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &lt;bits/stdc++.h&gt;using namespace std;#define N 200010#define M 2000010int ch[2][M], fa[M], val[M], sum[M], ncnt, v[M];struct SPLAY &#123; int rt; inline void init() &#123;rt = ++ncnt;&#125; inline void pushup(int u) &#123;sum[u] = sum[ch[0][u]] ^ sum[ch[1][u]] ^ val[u];&#125; inline void connect(int u, int f, int son) &#123;fa[u] = f, ch[son][f] = u;&#125; inline bool child(int u) &#123;return u == ch[1][fa[u]];&#125; inline void rotate(int u) &#123; int f = fa[u], ff = fa[f], tmp = child(u), tmp1 = child(f); connect(ch[tmp ^ 1][u], f, tmp), connect(f, u, tmp ^ 1), connect(u, ff, tmp1); pushup(f), pushup(u); &#125; inline void splay(int u) &#123; rt = u; for (int f;fa[u];rotate(u)) if (fa[f = fa[u]]) rotate(child(u) ^ child(f) ? u : f); &#125; inline void insert(int u, int x, int w) &#123; if (v[u] == x) return void((val[u] ^= w, sum[u] ^= w, splay(u))); int nxt = v[u] &lt; x, now; if (ch[nxt][u]) insert(ch[nxt][u], x, w); else now = ++ncnt, v[now] = x, val[now] = sum[now] = w, fa[now] = u, ch[nxt][u] = now, splay(now); &#125; inline int query(int u, int x) &#123; if (!u) return 0; if (v[u] &lt;= x) &#123; int res = sum[ch[0][u]] ^ val[u]; if (!ch[1][u]) return splay(u), res; return res ^ query(ch[1][u], x);; &#125; if (ch[0][u]) return query(ch[0][u], x); return 0; &#125;&#125;;int k, dep[N], mxdep[N], pre[N], from[N], count2, n;struct ZJKTQL &#123; SPLAY sp[N]; inline void init(int len) &#123;for (int i = 0;i &lt;= len;i++) sp[i].init();&#125; inline int getStart(int x) &#123;return ((x / k - dep[x % k]) % mxdep[from[x % k]] + mxdep[from[x % k]]) % mxdep[from[x % k]] + pre[from[x % k] - 1];&#125; inline void update(int x, int y) &#123; int t = getStart(x); // cout &lt;&lt; "start..." &lt;&lt; endl; sp[t].insert(sp[t].rt, x, y); // cout &lt;&lt; "end.." &lt;&lt; endl; &#125; inline int query(int x) &#123;int t = getStart(x); return sp[t].query(sp[t].rt, x);&#125;&#125; f[33];inline void update1(int x, int y) &#123; int cnt = 0; while (x % k == 0) cnt++, x /= k; f[cnt].update(x, y);&#125;inline int query1(int x) &#123; int cnt = 0; while (x % k == 0) cnt++, x /= k; return f[cnt].query(x);&#125;inline int lowbit(int x) &#123; for (long long tmp = 1;;tmp *= k) if (x % k) return tmp * (x % k); else x /= k;&#125;inline int Query(int x, function&lt;int(int)&gt; que) &#123; int res = 0; for (;x;x -= lowbit(x)) res ^= que(x); return res;&#125;map&lt;int, int&gt; dp[M];inline void update2(int x, int y) &#123; int cnt = 0; while (x % k == 0) cnt++, x /= k; while (x % count2) &#123; dp[cnt][x] ^= y, x += lowbit(x); while (x % k == 0) cnt++, x /= k; &#125; f[cnt].update(x, y);&#125;inline int query2(int x) &#123; int cnt = 0; while (x % k == 0) cnt++, x /= k; if (x % count2) return dp[cnt][x]; return f[cnt].query(x);&#125;int loops, st[N], top, A[N], B[N], tree[N];inline void fuck1(int x, int y) &#123;for (;x &lt;= top;x += x &amp; -x) tree[x] ^= y;&#125;inline int fuck2(int x) &#123; int res = 0; for (;x;x -= x &amp; -x) res ^= tree[x]; return res;&#125;template &lt;class T&gt; inline void read(T &amp;x) &#123; x = 0; char c = getchar(); while (c &lt; '0' || c &gt; '9') c = getchar(); while ('0' &lt;= c &amp;&amp; c &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - '0', c = getchar();&#125;#define LL long longint main() &#123; freopen("fenwick.in", "r", stdin), freopen("fenwick.out", "w", stdout); int q; read(n), read(q), read(k); if (k == 2) &#123; for (int i = 1, op;i &lt;= q;i++) &#123; read(op), read(A[i]), st[++top] = A[i]; if (op == 1) read(B[i]); else B[i] = -1; &#125; sort(st + 1, st + top + 1), top = unique(st + 1, st + top + 1) - st - 1; for (int i = 1;i &lt;= q;i++) if (~B[i]) fuck1(lower_bound(st + 1, st + top + 1, A[i]) - st, B[i]); else printf("%d\n", fuck2(lower_bound(st + 1, st + top + 1, A[i]) - st)); return 0; &#125; if (k &amp; 1) &#123; for (int i = 1;i &lt; k;i++) if (!dep[i]) &#123; dep[i] = 1, from[i] = ++loops; for (int j = i;j * 2 % k != i;j = j * 2 % k) mxdep[from[i]] = dep[j * 2 % k] = dep[j] + (j * 2 &gt; k), from[j * 2 % k] = from[i]; &#125; for (int i = 1;i &lt;= loops;i++) pre[i] = pre[i - 1] + mxdep[i]; for (int t = 1, cnt = 0;t &lt;= n;t *= k, cnt++) f[cnt].init(k / 2); for (int i = 1;i &lt;= q;i++) &#123; int op, a, b; read(op), read(a); if (op == 2) printf("%d\n", Query(a, query1)); else read(b), update1(a, b); &#125; &#125; else &#123; count2 = 1; while (!(k % count2)) count2 *= 2; count2 /= 2; for (int i = count2;i &lt; k;i += count2) if (!dep[i]) &#123; dep[i] = 1, from[i] = ++loops; for (int j = i;j * 2 % k != i;j = j * 2 % k) mxdep[from[i]] = dep[j * 2 % k] = dep[j] + (j * 2 &gt; k), from[j * 2 % k] = from[i]; &#125; for (int i = 1;i &lt;= loops;i++) pre[i] = pre[i - 1] + mxdep[i]; for (LL t = 1, cnt = 0;t &lt;= n;t *= k, cnt++) f[cnt].init(k); for (int i = 1;i &lt;= q;i++) &#123; int op, a, b; read(op), read(a); if (op == 2) printf("%d\n", Query(a, query2)); else read(b), update2(a, b); &#125; &#125; return 0;&#125; T3 礼物 表示只会70分暴力Polya，先贴上题解]]></content>
      <tags>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>数据结构</tag>
        <tag>多项式</tag>
        <tag>平衡树</tag>
        <tag>置换</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.23省选模拟]]></title>
    <url>%2F2019%2F03%2F24%2F3-23%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 染色问题 之前在正睿上做过一道比较类似的题 很明显，图染色问题是一个NP问题，但是这道题的$n$特别大 注意到有一个特殊性质，就是非树边只有不超过6条 如果有一个点度数为一，那么显然这个点可以删去，然后再给最后的答案乘上$k-1$。因为假如它所连接的那个点已经被染色了，那么这个点只要不染成那个点的颜色就可以满足条件，共$k-1$种 但是，删去了度数为1的点，剩下的点还有很多，那么考虑另一种删法 我们给每条边两个权值$a_i,b_i$，它们分别表示这条边所连接的两个顶点颜色相同/不相同时这条边的权值 最终的答案就是对于所有的染色方案，每种方案所有边的权值之积的和 一开始显然有$a_i=0,b_i=1$ 我们考虑删去一个度数为2的点 假如这个点是$u$，它所连接的另外两个点为$v,t$ 我们考虑一下几种情况： $v,t$颜色相同 那么$u$要么与这两个点颜色都相同，有1种情况，要么与这两个点颜色都不相同，有$k-1$种情况 所以此时$$a’=a_{u,v}*a_{u,t}+(k-1)*b_{u,v}*b_{u,t}$$ $v,t$颜色不同 那么$u$可以与$v$相同，可以与$t$相同，也可以与$v,t$都不相同 第一种和第二种都只有1种颜色可以选择，第三种有$k-2$种颜色可以选择 所以$$b’=(k-2)*b_{u,v}*b_{u,t}+b_{u,v}*a_{u,t}+a_{u,v}*b_{u,t}$$如果一开始$v,t$之间本来就有一条边，那么我们求出新的边权之后，将原来的边权对应相乘就可以了 否则在$v,t$之间连上一条新边，并更新入度 最后由于每个点的度数都大于2，所以满足$3n\geq 2m$ 此时有$n\leq 10,m\leq 15$ 我们可以状压一下 设dp[i][s]表示已经考虑了$i$种颜色，已经染色的集合为$s$的边权之积的和 预处理出如果给集合$s$染上同一种颜色时的边权之积，以及如果给$s,t$染上不同颜色，跨过这两个集合的边的边权之积 然后就可以dp了 注意每dp一层都要算一次答案，假设当前考虑了$i$种颜色，那么此时的答案就需要乘上$k\choose i$，再乘以最开始度数为1的点的贡献 有一种特殊情况，就是如果这是一棵树，那么进行删点操作之后所有点都被删完了，此时删的第一个点对答案的贡献不是$k-1$，而是$k$。特判一下就好了 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;#define P pair&lt;int, int&gt;const int mod = 1e9 + 7;#define LL long long#define N 100010map&lt;int, P &gt; G[N]; int ind[N], n, A = 1, mark[N], k;inline void work() &#123; queue&lt;int&gt; q; for (int i = 1;i &lt;= n;i++) if (ind[i] == 1) q.push(i); while (!q.empty()) &#123; int u = q.front(), v = G[u].begin()-&gt;first; q.pop(), ind[u]--, ind[v]--, mark[u] = 1, A = (LL)A * (k - 1) % mod; G[u].erase(v), G[v].erase(u); if (ind[v] == 1) q.push(v); &#125; for (int i = 1;i &lt;= n;i++) if (ind[i] == 2) &#123; int v = G[i].begin()-&gt;first; P tmp1 = G[i].begin()-&gt;second; G[i].erase(G[i].begin()); int t = G[i].begin()-&gt;first; P tmp2 = G[i].begin()-&gt;second; G[i].clear(), mark[i] = 1, G[v].erase(i), G[t].erase(i); P tmp(((LL)(k - 1) * tmp1.second % mod * tmp2.second + (LL)tmp1.first * tmp2.first) % mod, ((LL)(k - 2) * tmp1.second % mod * tmp2.second + (LL)tmp1.first * tmp2.second + (LL)tmp1.second * tmp2.first) % mod); if (G[v].count(t) || G[t].count(v)) &#123; G[v][t].first = (LL)G[v][t].first * tmp.first % mod; G[v][t].second = (LL)G[v][t].second * tmp.second % mod, G[t][v] = G[v][t], ind[v]--, ind[t]--; &#125; else G[v][t] = G[t][v] = tmp; &#125;&#125;int id[N], ncnt, T[2][11][11], ed[11][11];inline void reMark() &#123; for (int i = 1;i &lt;= n;i++) if (!mark[i]) id[i] = ++ncnt; for (int i = 1;i &lt;= n;i++) if (!mark[i]) for (auto v : G[i]) T[0][id[i]][id[v.first]] = v.second.first, T[1][id[i]][id[v.first]] = v.second.second, ed[id[i]][id[v.first]] = 1;&#125;int dp[11][1 &lt;&lt; 11], sum[1 &lt;&lt; 11], sum2[1 &lt;&lt; 11][1 &lt;&lt; 11], frac[100010], inv[100010];inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;inline int C(int n, int r) &#123;return (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;&#125;inline int DP() &#123; if (!ncnt) return A; dp[0][0] = 1; int all = (1 &lt;&lt; ncnt) - 1; for (int i = 0;i &lt;= all;i++) &#123; sum[i] = 1; for (int j = 1;j &lt;= ncnt;j++) if (i &amp; (1 &lt;&lt; j - 1)) for (int k = j + 1;k &lt;= ncnt;k++) if (ed[j][k] &amp;&amp; (i &amp; (1 &lt;&lt; k - 1))) sum[i] = (LL)sum[i] * T[0][j][k] % mod; &#125; for (int i = 0;i &lt;= all;i++) for (int j = all - i;;j = (j - 1) &amp; (all - i)) &#123; sum2[i][j] = 1; for (int k = 1;k &lt;= ncnt;k++) if (i &amp; (1 &lt;&lt; k - 1)) for (int l = 1;l &lt;= ncnt;l++) if (ed[k][l] &amp;&amp; (j &amp; (1 &lt;&lt; l - 1))) sum2[i][j] = (LL)sum2[i][j] * T[1][k][l] % mod; if (!j) break; &#125; int res = 0; for (int col = 1;col &lt;= min(k, ncnt);col++) &#123; for (int s = 0;s &lt; all;s++) if (dp[col - 1][s]) for (int t = all - s;t;t = (t - 1) &amp; (all - s)) dp[col][s | t] = (dp[col][s | t] + (LL)dp[col - 1][s] * sum2[s][t] % mod * sum[t]) % mod; res = (res + (LL)dp[col][all] * A % mod * C(k, col)) % mod; &#125; return res;&#125;inline void adde(int a, int b) &#123;G[a][b] = G[b][a] = P(0, 1), ind[a]++, ind[b]++;&#125;int main() &#123; freopen("color.in", "r", stdin), freopen("color.out", "w", stdout); int m; scanf("%d%d%d", &amp;n, &amp;m, &amp;k), frac[0] = inv[0] = 1; for (int i = 1;i &lt;= k;i++) frac[i] = (LL)frac[i - 1] * i % mod, inv[i] = Pow(frac[i], mod - 2); for (int i = 1, a, b;i &lt;= m;i++) scanf("%d%d", &amp;a, &amp;b), adde(a, b); work(), reMark(); int res = DP(); if (m == n - 1) printf("%d\n", (LL)res * Pow(k - 1, mod - 2) % mod * k % mod); else printf("%d\n", res); return 0;&#125; T2 IOer 表示只会60分 首先我们知道，对于第$i$天，如果给这一天分配$j$道题，那么方案数为$(v+ui)^j$ 那么根据这个我们可以写出它的生成函数$$G(x)=\prod_{i=1}^m\sum_{j=0}^\infty(v+ui)^jx^j\\\=\prod_{i=1}^m\frac{1}{1-(v+ui)x}$$可以利用分治NTT求出分母的积，然后多项式求逆 由于这个多项式求逆没法算到$10^{18}$项，所以此时只有40分 对于第一个点，直接pow一下 对于第二个点，答案是类似$$\sum_{i=0}^na^ib^{n-i}$$的东西，然后有$$=a^n\sum_{i=0}^n(\frac{b}{a})^{n-i}$$然后等比数列求和就好了 题解写得很详细 T3 Deadline 正睿原题！ 我们考虑这样的一种建图方式： 把任务按照类型分为2类，第一类从源点向它连边，第二类向汇点连边 然后将每天拆成两个点，中间连一条1边 将满足条件的第一类任务向这一天的入点连边，将这一天的出点向满足条件的第二类任务连边 考虑最小割 如果某一天与$S$集合不连通，那么就代表它选了体力劳动 如果某一天与$T$集合不连通，那么就代表它选了脑力劳动 先不考虑入点向出点连的边，我们发现如果每天没有任务数量限制，那么这样是对的，因为每天要么把上面的所有边割掉，要么把下面的所有边割掉 由于每天有任务数量为1的限制，那么把入点向出点连的这条边的权值设为1就好了 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;#define N 2010struct edge &#123;int to, next, w;&#125; e[N * 12];int head[N * 4], ecnt = 1;inline void adde(int from, int to, int w) &#123; e[++ecnt] = (edge)&#123;to, head[from], w&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to], 0&#125;, head[to] = ecnt;&#125;int dep[N * 4];inline bool BFS(int s, int t) &#123; memset(dep, -1, sizeof(dep)), dep[s] = 0; queue&lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u];i;i = e[i].next) if (e[i].w &amp;&amp; dep[e[i].to] == -1) &#123; dep[e[i].to] = dep[u] + 1, q.push(e[i].to); if (e[i].to == t) return true; &#125; &#125; return false;&#125;int cur[N * 4];int DFS(int u, int f, int t) &#123; if (u == t || !f) return f; int res = 0; for (int &amp;i = cur[u], tmp;i;i = e[i].next) if (e[i].w &amp;&amp; dep[u] + 1 == dep[e[i].to] &amp;&amp; (tmp = DFS(e[i].to, min(f, e[i].w), t))) &#123; res += tmp, f -= tmp, e[i].w -= tmp, e[i ^ 1].w += tmp; if (!f) break; &#125; return res;&#125;inline int Dinic(int s, int t) &#123; int res = 0; while (BFS(s, t)) memcpy(cur, head, sizeof(head)), res += DFS(s, 1e9, t); return res;&#125;int type[N];int main() &#123; freopen("deadline.in", "r", stdin), freopen("deadline.out", "w", stdout); int n, m, k, s, t; scanf("%d%d%d", &amp;n, &amp;m, &amp;k), s = m * 2 + n + 1, t = s + 1; for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;type[i]); for (int i = 1;i &lt;= n;i++) if (!type[i]) adde(s, i, 1); else adde(i, t, 1); for (int i = 1;i &lt;= m;i++) adde(i + n, i + n + m, 1); for (int i = 1;i &lt;= k;i++) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); if (!type[a]) adde(a, b + n, 1); else adde(b + n + m, a, 1); &#125; printf("%d\n", Dinic(s, t)); return 0;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>数学</tag>
        <tag>网络流</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>多项式求逆</tag>
        <tag>多项式</tag>
        <tag>NTT</tag>
        <tag>缩点</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.22省选模拟]]></title>
    <url>%2F2019%2F03%2F22%2F3-22%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 方格取数 一种可行的方法是使用random_shuffle然后模拟两人取数的过程并判断是否可行，对于玩家2，我们可以采取每次都选最大值的策略 我并不知道这样的策略是否优秀，但是这样可以获得45分的好成绩 题解给出的方法是玄学构造 T2 K君的游戏 很妙的一道题 首先我们可以设出两个dp dp[0/1][i]代表一棵有$i$个点的树，后手获胜/先手获胜的方案数 如果我们算出了其中一个，那么另一个也可以推出来 先考虑如何暴力 假设当前要算的这棵树有$n$个节点，我们要算后手获胜的方案数 我们先不管根节点，就假设它有$n$个后代 我们将这$n$个节点划分成$k$个部分，其中第$i$个部分包含$s_i$个节点，先手必胜的方案数为$a_i$ 注意这里划分出来的子树是有序的，为了避免重复计数，我们按照某种顺序将这$n$个节点排序 接下来我们就给这些子树分配编号，第一棵子树有$C_n^{s_1}$种选法，第二棵子树有$C_{n-s_1}^{s_2}$种选法，以此类推 我们只需要关注这些方案数的乘积，即$$\prod_{i=1}^kC_{n-\sum_{j=1}^{i-1}s_j}^{s_i}=\frac{n!}{\prod_{i=1}^ks_i!}$$但是这样我们仍然会重复计数，比如以下这种情况： 我们给2，3号节点分配编号，而此时$\{1,2\}$和$\{2,1\}$这两种方案是等价的，因为我们可以通过交换2，3这两个节点的位置变换成另一种方案 所以最后，对于一种划分方案$s_1,s_2,\cdots,s_k$，它对于最终答案的贡献是$$(\prod_{i=1}^ka_i)\frac{n!}{\prod_{i=1}^ks_i!}*\frac{1}{\prod_{i=1}^n大小为i的子树的出现次数!}$$看起来很不友好 黑科技——指数生成函数 普通生成函数解决组合问题，指数生成函数解决排列问题 对于数列$\{a_n\}$，我们知道它的普通生成函数是$$G(x)=\sum_{i=0}^\infty a_ix^i$$相对应地，它的指数生成函数就是$$G(x)=\sum_{i=0}^\infty \frac{a_i}{i!}x^i$$一个与本题无关的性质 如果$A,B$均为指数生成函数，那么有$$\begin{align}A(x)\cdot B(x)&amp;=\sum_{i=0}^\infty\sum_{j=0}^i\frac{a_jx^j}{j!}\cdot\frac{b_{i-j}x^{i-j}}{(i-j)!}\\\&amp;=\sum_{i=0}^\infty(\sum_{j=0}^i{i\choose j}a_jb_{i-j})\frac{x^i}{i!}\end{align}$$ 泰勒展开与自然对数 在计算指数型生成函数的过程中，一般都会用到泰勒展开式$$e^x=\sum_{i=0}^\infty\frac{x^i}{i!}=1+x+\frac{x^2}{2!}+\frac{x^3}{3!}+\cdots\\\\ln(1+x)=\sum_{i=1}^\infty(-1)^{i-1}\frac{x^i}{i}$$先整理这两个 关于多项式$\ln$ 我们知道$$[\ln(A(x))]’=\frac{A’(x)}{A(x)}\\\\int[\ln(A(x))’]=\ln(A(x))=\int\frac{A’(x)}{A(x)}$$所以可以先求出$A$的逆，然后对$A$进行求导，NTT一次，最后再多项式积分即可 我们回到这道题 设后手必胜方案数的指数生成函数为$f(x)$，先手必胜的指数生成函数为$g(x)$ 考虑如何求出这两个之间的关系 我们首先枚举划分成了多少棵子树，假设有$i$棵 这对应着$g(x)^i$ 我们考虑划分出的一个有序的集合有多少种划分方案，即我们之前想要统计的东西会被重复统计多少次 如果此时我们划分出了$n$个集合，那么答案显然是$$\frac{n!}{\prod 每种集合的个数!}$$比如划分方案$2,2$只会被统计1次，而$1,3$则会被统计两次（$\{1,3\},\{3,1\}$） 其实就是一个可重排列 由于$g$是指数生成函数，因此对于$g$，有$$g(x)=\sum_{i=1}^\infty a_i\frac{x^i}{i!}$$所以此时$$f(x)的普通生成函数=\sum_{i=1}^\infty \sum_{所有的划分方案}(\prod a_i)\frac{(\sum s_i)!}{\prod s_i!}*\frac{1}{\prod 每一种大小的子树的出现次数!}x^{\sum s_i}\\\g(x)^i=\sum_{所有的划分方案}\frac{\prod a_i}{\prod s_i!}*\frac{i!}{\prod 每种集合的个数!}x^{\sum s_i}$$ 如果我们单独考虑最后$f$的每个次数的系数，假如是$x^n$项的系数。那么我们会发现，它就等于对它有贡献的所有划分方案的$\sum s_i$ 由于我们需要构造的是指数生成函数，而之前求的是普通生成函数。为了将普通生成函数转化为指数生成函数，我们需要对于$x^n$项，除以$n!$ 所以此时$(\sum s_i)!$就没了 将$g(x)^i$代入上面的式子，我们可以得到$$f(x)=\sum_{i=0}^\infty\frac{g(x)^i}{i!}$$注意这里求出的$f$其实是没有考虑根节点的，对于每一种方案，根节点是唯一确定的，剩下的节点只有$n-1$个 也就是说，原来$n$个点的方案对应着现在$n+1$个点的方案 这对应着上面那个式子整体向右平移一次，即$$f(x)=\sum_{i=0}^\infty\frac{g(x)^ix}{i!}$$ 通过泰勒展开，可以得出$$\frac{f(x)}{x}=\exp(g(x))$$那么如何求出$f$呢 如果我们能找到一个关于$f,g$的方程，然后将上面的那个式子代入方程，我们就可以求出$f$ 显然，对于$n$个点，先手必胜与后手必胜对应着所有情况 而$n$个点，满足每个点的父亲编号比它大的树一共只有$(n-1)!$个（第$i$个点的父亲有$n-i$种选择） 所以$$f(x)+g(x)=\sum_{i=1}^\infty\frac{(i-1)!}{i!}x^i\\\=\sum_{i=1}^\infty \frac{1}{i}x^i\\\=-\ln(1-x)$$我们可以列出方程$$\begin{cases}f(x)+g(x)=-\ln(1-x)\\ \frac{f(x)}{x}=\exp(g(x))\end{cases}$$ 经过一些奇妙的并且我不会的推导，可以得出$$f(x)=\ln(1-\ln(1-x))$$然后多项式$\ln$就可以了 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;#define N 600010#define LL long longconst int mod = 998244353;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;int r[N];inline void NTT(int a[], int len, int type) &#123; for (int i = 1;i &lt; len;i++) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int mid = 2;mid &lt;= len;mid &lt;&lt;= 1) &#123; int Wn = Pow(3, type ? (mod - 1) / mid : mod - 1 - (mod - 1) / mid); for (int i = 0;i &lt; len;i += mid) for (int j = i, w = 1, t;j &lt; i + (mid &gt;&gt; 1);j++, w = (LL)w * Wn % mod) t = (LL)w * a[j + (mid &gt;&gt; 1)] % mod, a[j + (mid &gt;&gt; 1)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod; &#125; if (!type) for (int i = 0, inv = Pow(len, mod - 2);i &lt; len;i++) a[i] = (LL)a[i] * inv % mod;&#125;int tmpa[N], tmpf[N];// b(x) = 2b'(x) - a(x)b'(x) ^ 2inline void Inv(int a[], int b[], int n) &#123; if (n == 1) return void(b[0] = Pow(a[0], mod - 2)); Inv(a, b, (n + 1) &gt;&gt; 1); for (int i = 0;i &lt; n;i++) tmpa[i] = a[i]; int len = 1, l = 0; while (len &lt;= n * 3) len &lt;&lt;= 1, l++; for (int i = 1;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); for (int i = n;i &lt; len;i++) tmpa[i] = 0; NTT(tmpa, len, 1), NTT(b, len, 1); for (int i = 0;i &lt; len;i++) b[i] = (2 - (LL)tmpa[i] * b[i] % mod + mod) * b[i] % mod; NTT(b, len, 0); for (int i = n;i &lt; len;i++) b[i] = 0;&#125;inline void Ln(int a[], int res[], int len) &#123; Inv(a, res, len); for (int i = 1;i &lt;= len;i++) tmpf[i - 1] = (LL)a[i] * i % mod; int Len = 1, l = 0; while (Len &lt;= len * 2) Len &lt;&lt;= 1, l++; for (int i = 1;i &lt; Len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); for (int i = len;i &lt; Len;i++) tmpf[i] = 0; NTT(tmpf, Len, 1), NTT(res, Len, 1); for (int i = 0;i &lt; Len;i++) res[i] = (LL)res[i] * tmpf[i] % mod; NTT(res, Len, 0); for (int i = len;i &gt;= 0;i--) res[i + 1] = (LL)res[i] * Pow(i + 1, mod - 2) % mod; for (int i = len + 1;i &lt; Len;i++) res[i] = 0; res[0] = 0;&#125;int f[N], tmp[N], frac[N];int main() &#123; freopen("game.in", "r", stdin), freopen("game.out", "w", stdout); f[0] = frac[0] = 1, f[1] = mod - 1, Ln(f, tmp, 100000), tmp[0] = 1; for (int i = 1;i &lt;= 100000;i++) tmp[i] = mod - tmp[i], frac[i] = (LL)frac[i - 1] * i % mod; memset(f, 0, sizeof(f)), Ln(tmp, f, 100000); int T, n; scanf("%d", &amp;T); while (T--) scanf("%d", &amp;n), printf("%d\n", (LL)(frac[n - 1] - (LL)f[n] * frac[n] % mod + mod) * Pow(frac[n - 1], mod - 2) % mod); return 0;&#125; T3 魔法阵 这次考试最简单的一道题 考虑使用分块 对于第一种修改我们可以求出$C$数组的变化区间，然后将这个区间都覆盖成某个数 对于每一个块我们将块内的$B$从小到大排序，维护前缀积以及当前这个块的答案 考虑查询一个块当前的答案 如果这个块没有未下放的区间覆盖，那么直接返回之前求出的答案即可 否则这个块中的所有$C$一定都相等，我们可以二分出有多少个$B\leq C$，对于前面的$B$，使用前缀积，对于后面的，就是$C$的数字个数次方 然后卡一下常就好了 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010#define M 400#define LL long longconst int size = 300, mod = 1e9 + 7;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;vector&lt;int&gt; sorted[M]; int C[N], B[N], A[N], belong[N], ans[M], n, tag[M], pre[M][size + 10], mark[M];inline int Start(int block) &#123;return (block - 1) * size + 1;&#125; inline int End(int block) &#123;return min(n, block * size);&#125;inline void Rebuild(int block) &#123; int st = Start(block), ed = End(block); ans[block] = 1, sorted[block].clear(), tag[block] = 0, mark[block] = 1; for (int i = st;i &lt;= ed;i++) ans[block] = (LL)ans[block] * min(C[i], B[i]) % mod, sorted[block].push_back(B[i]), mark[block] &amp;= B[i] &lt;= C[i]; sort(sorted[block].begin(), sorted[block].end()), pre[block][0] = 1; for (int i = 0;i &lt; sorted[block].size();i++) pre[block][i + 1] = (LL)pre[block][i] * sorted[block][i] % mod;&#125;inline void Rebuild2(int block) &#123; int st = Start(block), ed = End(block); ans[block] = 1, tag[block] = 0, mark[block] = 1; for (int i = st;i &lt;= ed;i++) ans[block] = (LL)ans[block] * min(C[i], B[i]) % mod, mark[block] &amp;= B[i] &lt;= C[i];&#125;inline void Pushdown(int block) &#123; int st = Start(block), ed = End(block); if (tag[block]) for (int i = st;i &lt;= ed;i++) C[i] = tag[block]; tag[block] = 0; &#125;inline void Pre() &#123; for (int i = 1;i &lt;= n;i++) belong[i] = (i + size - 1) / size, C[i] = max(C[i - 1], A[i]); for (int i = 1;i &lt;= belong[n];i++) Rebuild(i);&#125;inline int Calc(int block) &#123;// cout &lt;&lt; "tag: " &lt;&lt; tag[block] &lt;&lt; endl; if (!tag[block]) return ans[block]; if (mark[block]) return pre[block][sorted[block].size()]; int l = 1, r = sorted[block].size(), mid, pos = 0; while (l &lt;= r) &#123; if (sorted[block][(mid = (l + r) &gt;&gt; 1) - 1] &lt; tag[block]) pos = mid, l = mid + 1; else r = mid - 1; &#125; return (LL)Pow(tag[block], sorted[block].size() - pos) * pre[block][pos] % mod;&#125;inline void update(int start, int end, int x) &#123; int st = belong[start], ed = belong[end], s = End(st), t = Start(ed); Pushdown(st), Pushdown(ed); if (st == ed) &#123; for (int i = start;i &lt;= end;i++) C[i] = x; Rebuild(st); return; &#125; for (int i = start;i &lt;= s;i++) C[i] = x; for (int i = t;i &lt;= end;i++) C[i] = x; for (int i = st + 1;i &lt; ed;i++) tag[i] = x; Rebuild2(st), Rebuild2(ed);&#125;inline void Set(int at, int x) &#123;int bl = belong[at]; Pushdown(bl), B[at] = x, Rebuild(bl);&#125;inline int query(int start, int end) &#123; int st = belong[start], ed = belong[end], s = End(st), t = Start(ed), res = 1; Pushdown(st), Pushdown(ed); if (st == ed) &#123; for (int i = start;i &lt;= end;i++) res = (LL)res * min(C[i], B[i]) % mod; Rebuild2(st); return res; &#125; for (int i = start;i &lt;= s;i++) res = (LL)res * min(C[i], B[i]) % mod; for (int i = t;i &lt;= end;i++) res = (LL)res * min(C[i], B[i]) % mod; for (int i = st + 1;i &lt; ed;i++) res = (LL)res * Calc(i) % mod; Rebuild2(st), Rebuild2(ed); return res;&#125;int tree[N];inline void upd(int x, int y) &#123;for (;x &lt;= n;x += x &amp; -x) tree[x] = max(tree[x], y);&#125;inline int que(int x) &#123; int res = 0; for (;x;x -= x &amp; -x) res = max(res, tree[x]); return res;&#125;int main() &#123;// freopen("fatal.in", "r", stdin), freopen("hh.out", "w", stdout); freopen("magic.in", "r", stdin), freopen("magic.out", "w", stdout); int q; scanf("%d%d", &amp;n, &amp;q); for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;A[i]), upd(i, A[i]); for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;B[i]); Pre(); while (q--) &#123; int op, a, b; scanf("%d%d%d", &amp;op, &amp;a, &amp;b); if (op == 0) &#123; int l = a, r = n, mid, res = 0; while (l &lt;= r) &#123; if (que(mid = (l + r) &gt;&gt; 1) &lt; b) l = mid + 1, res = mid; else r = mid - 1; &#125; upd(a, b); if(res) update(a, res, b); &#125; else Set(a, b); printf("%d\n", query(1, n)); &#125;// cerr &lt;&lt; clock() &lt;&lt; endl; return 0;&#125; 总结感觉是这几天比较正常的一次考试了 T2真的是太神仙了]]></content>
      <tags>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>数据结构</tag>
        <tag>多项式求逆</tag>
        <tag>多项式</tag>
        <tag>分块</tag>
        <tag>NTT</tag>
        <tag>多项式ln</tag>
        <tag>构造</tag>
        <tag>泰勒展开</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀自动机]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[后缀自动机是啥 简单来说，一个串$S​$的后缀自动机是一个有向无环图。这个图中的顶点被称为“状态”，点与点之间的边被称作“转移” 我们将被标号为$t_0$的点称作“初始状态”，我们能从这个状态到达后缀自动机的所有状态 一个或者多个状态被称为“终止状态”。如果我们从初始状态$t_0$出发到达任意一个终止状态，且将途中经过的所有边的字符写下来，那么我们可以得到原串$S$的一个后缀 这是串“aa”的自动机（带*的是终止状态） 这是串“aba”的自动机 这是串“abb”的自动机 这是串“abbb”的自动机 它能解决什么 一个串的本质不同的子串个数 所有不同子串的总长度 字典序第$k$小的子串 最小表示法 一个给定串的第一次出现位置 一个给定串的所有出现位置 最长公共子串 多个串的最长公共子串 最短的没有出现的字符串 后缀自动机的性质 “endpos”等价类 考虑原串$S$的一个非空子串$T$，$endpos(T)$就是$T$在$S$中的所有结束位置的集合。我们称两个子串$s_1,s_2$endpos等价当且仅当它们的结束位置完全相同，即$endpos(s_1)=endpos(s_2)$ 对于一个串“aba” $endpos(“aba”)=\{3\}$ $endpos(“ba”)=\{3\}$ $endpos(“a”)=\{1,3\}$ $endpos(“ab”)=\{2\}$ $endpos(“b”)=\{2\}$ $endpos(“”)=\{0,1,2,3\}$ 在这个串中，“ab”和“b”以及“aba”和“ba”是endpos等价的 在我们最终构造的后缀自动机中，endpos类的个数等于节点个数，也就是说，一个节点代表一个endpos等价类。在这个例子中，节点的数量等于4 引理1. 如果字符串$u​$仅以$v​$的一个后缀的形式出现在字符串$s​$中时，$u​$和$v​$是endpos等价的 显然，如果$u$和$v$的endpos等价，那么$u$是$v$的一个后缀。当$u$仅以$v$的后缀在$s$中出现时，两个子串的endpos等价 引理2. 考虑两个$s$的非空子串$u$和$v (|s|\leq|v|)$，要么$endpos(s)$与$endpos(v)$没有交集，要么$endpos(s)$是$endpos(v)$的子集。这依赖于$u$是否是$v$的一个后缀$$\begin{cases}endpos(u)\subseteq endpos(v)&amp;\text{if }u - \text{suffix} v,\\ endpos(u)\cap endpos(v)=\emptyset&amp;\text{otherwise.}\end{cases}$$ 证明是显然的，另一个重要的定理是，如果把一个endpos等价类的所有子串按照长度排序，那么相邻两个一定只差1 我们记排序之后的长度区间为$[minlen(u),len(u)]$，$len(u)$为在这个endpos等价类中长度最长的子串的长度，$minlen(u)​$为最短的子串的长度 考虑上面的例子中的一个等价类$\{“ab”,”b”\}$，则有$len(u)=2,minlen(u)=1$ 后缀连接link 考虑后缀自动机中满足$u\not=t_0$的一些状态。我们知道$u$对应着一个endpos等价类。如果我们记这个类中最长的串为$w$，那么其它的串都是$w$的后缀 我们已经知道$w$的最长的一些后缀已经被包含在状态$u$里面了，而另一些则没有被包含。如果我们记这些没有被包含的后缀中最长的那个串所在的状态为$t$，那么$u$将使用后缀连接链接到$t$上 这告诉我们两个性质$$1. minlen(u)=len(link(u))+1\\\2. endpos(u)\subset endpos(link(u))$$我们规定$endpos(t_0)=\{0,1,2,\cdots,|s|\}$ 在我们的例子中，节点$u=\{“aba”,”ba”\}$的后缀连接为$t=\{“a”\}$ 引理3. 所有的后缀连接构成一棵根节点为$t_0$的树 考虑任意$u\not=t_0$的状态，如果我们沿着它的后缀连接走，每次走到的一定是一个$len$严格小于它的状态，最后一定会走到$t_0$ 引理4. 如果我们使用$endpos$集合构造一棵树（子节点为父亲节点的子集），那么这棵树由后缀连接链接起来 由引理2，我们可以通过$endpos$集合构造一棵树，因为两个集合要么包含，要么没有交集 现在考虑任意满足$u\not=t_0$的状态和它的后缀连接$link(u)$，根据后缀连接的定义以及引理2，我们可以得出$$endpos(u)\subset endpos(link(u))$$这表明，后缀连接构成的树本质上就是$endpos$集合构成的树 串“abcbc”构成的后缀自动机以及它的后缀连接 在线性时间内构造后缀自动机 构造后缀自动机的算法是在线的，并且使用增量法，即每次添加一个字符 每个状态我们需要保存两个值($len, link$) 作为初始化，一开始自动机内只有一个状态$t_0$，我们给它标记为0，并且有len = 0, link = -1 定义$last$为之前所添加的最后一个字符所在的状态对应的下标，作为初始化，last = 0 考虑加入字符$c$，创建一个新的状态$cur$，并将$len(cur)$赋值为$len(last)+1$，然后我们会进行下面所描述的循环 到了此时我们已经新建了一个状态并且初始化了，但是还没有将其添加到自动机上。运行一个循环，最开始我们处于$last$，如果这个状态没有$c$这个转移，我们就添加这样一个转移并使其指向$cur$，然后我们会从当前节点跳向它的后缀连接，直到到达$t_0$状态或者我们遇到了一个有$c$转移的点 如果我们停在了一个有$c$转移的点，我们将其标记为$p$，记$p$经过转移$c$到达的状态为$q$。那么此时有两种情况，取决于$len(p)=len(q)+1$是否成立 如果$len(p)=len(q)+1$，我们就将$cur$的后缀连接指向$q$，然后停止这个过程 否则我们必须新建$q$的一个复制状态，它的所有属性都与$q$相同，除了$len(clone)=len(p)+1$，然后将$q$与$cur$的后缀连接都指向$clone$，$p$的所有祖先中通过字符$c$转移至$q$的转移都要被重定向至$clone$ 如果我们没有在中途停下，那么我们就让$cur$的后缀连接指向0，即$t_0$ 为什么这样是正确的我们假设还没有加入$c$时，最长的串为$s$ 考虑加入$c$的时候，我们会多出一些后缀 在$last$不停网上跳的过程中，如果没有$c$这个转移，显然我们需要添加一个转移，这对应着一个新的后缀 如果我们遇到了$c$这个转移，比如以下这种情况 其中，节点$ab$的转移$d$是在添加字符$d$之前就有的 如果有$len(ab)+1=len(q)$，这意味着能走到$q$中的串只有节点$ab$所代表的串连接上$d$ 因为$ab$中的串能到达$q$，这意味着$q$中的串一定包含$_d$格式的串，其中_是$ab​$所代表的串 如果没有这个条件，那么其它以$ab$为后缀的串也可以转移到$q$，$q$就可以表示类似$zjkabd$这样的奇怪的串，而这样的串是$ab$所不能转移的，$q$也不是$abcd$的某个后缀，不能成为$abcd$的后缀连接 所以解决方法就是将转移到$q$的串分为两类，一类是一定为$abcd$的后缀的串，一类是其它奇怪的串 以$abcd$为后缀的串就是$ab$的所有祖先经过$d$的转移。如果这个转移走到了$q$，显然我们需要重定向至分出来的那个节点 此时这个节点就满足$len(clone)=len(p)+1$，可以成为$abcd$的后缀连接 显然，这个复制出来的节点的endpos集合包含$q$，因为多了$abcd$这个串，所以我们也需要将$q$的后缀连接指向复制节点 时间复杂度的证明不会，告辞 代码实现123456789101112131415161718192021222324252627282930313233343536373839struct state &#123; int len, link; map&lt;char,int&gt;next;&#125;; const int MAXLEN = 100000;state st[MAXLEN*2];int sz, last; void sa_init() &#123; sz = last = 0; st[0].len = 0; st[0].link = -1; ++sz;&#125; void sa_extend (char c) &#123; int cur = sz++; st[cur].len = st[last].len + 1; int p; for (p=last; p!=-1 &amp;&amp; !st[p].next.count(c); p=st[p].link) st[p].next[c] = cur; if (p == -1) st[cur].link = 0; else &#123; int q = st[p].next[c]; if (st[p].len + 1 == st[q].len) st[cur].link = q; else &#123; int clone = sz++; st[clone].len = st[p].len + 1; st[clone].next = st[q].next; st[clone].link = st[q].link; for (; p!=-1 &amp;&amp; st[p].next[c]==q; p=st[p].link) st[p].next[c] = clone; st[q].link = st[cur].link = clone; &#125; &#125; last = cur;&#125;]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>算法</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.20省选模拟]]></title>
    <url>%2F2019%2F03%2F21%2F3-20%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 全连 5分钟题目 dp[i][j]表示前$i$个音符，最后一个在$j$位置的最大收益 显然这个dp是可以用数据结构加速的 对于每个音符，查询$j$位于$[1,i-t_i]$的dp最大值 然后在位置$i+t_i$再把这个dp值放进树状数组，这样就保证了接下来点的时刻一定在$i+t_i$之后 这里用一个vector存一下待更新的答案即可 代码如下 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1000010using LL = long long;LL tree[N]; int n;inline void update(int x, LL y) &#123;for (;x &lt;= n + 1;x += x &amp; -x) tree[x] = max(tree[x], y);&#125;inline LL query(int x) &#123; LL res = 0; for (;x &gt; 0;x -= x &amp; -x) res = max(res, tree[x]); return res;&#125;#define P pair&lt;int, LL&gt;LL w[N]; int t[N], __rd; vector&lt;P &gt; q[N];template&lt;class T&gt; inline void read(T &amp;x) &#123; x = 0; char c = getchar(); while (c &lt; '0' || c &gt; '9') c = getchar(); while ('0' &lt;= c &amp;&amp; c &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - '0', c = getchar();&#125;#define RD (read(__rd), __rd)int main() &#123; freopen("fc.in", "r", stdin), freopen("fc.out", "w", stdout); n = RD; LL res = 0, tmp = 0; for (int i = 1;i &lt;= n;i++) t[i] = RD; for (int i = 1;i &lt;= n;i++) w[i] = RD, w[i] *= t[i]; for (int i = 1;i &lt;= n;i++) &#123; for (int j = 0;j &lt; q[i].size();j++) update(q[i][j].first, q[i][j].second); tmp = query(i - t[i]) + w[i], q[min(n + 1, i + t[i])].push_back(P(i, tmp)), res = max(res, tmp); &#125; printf("%lld\n", res); return 0;&#125; T2 原样输出 如果只有一个串，那么就是统计不同子串数量，显然后缀数组/后缀自动机都可以 但是这里有多个串，而且最后会忽略空行 我们考虑什么时候会重复 假设当前有两个串$aab,ab$ 我们在第一个串选择了$aa$，在第二个串选择了$b$ 此时得到的串是$aab$，我们发现这与第一个串的子串相同，它被重复统计了 所以，假设上一次取的是$i$串，这一次取的是$j$串，那么这两次取的串拼起来一定不是$i$串的子串 意思就是贪心地选，如果当前还可以向下转移某个字符就一定不要到另一个串去转移这个字符 还有一种情况 假设有三个串$a,b,b$ 那么取前两个串与取第一个与第三个串是等价的 所以我们使用类似子序列自动机的做法，设$next[i][j]$表示$i$串之后，第一个可以转移$j$字符的串 然后dfs的时候每次跳next就可以了 这个题的评测特别奇怪 输出长达200Mb，但是输出这么多会导致OLE 不知道出题人在想什么，感觉第二问完全没用 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1000010int cnt = 0;inline int id(char c) &#123; if (c == 'A') return 0; if (c == 'C') return 1; if (c == 'G') return 2; return 3;&#125;inline char rid(int c) &#123; if (c == 0) return 'A'; if (c == 1) return 'C'; if (c == 2) return 'G'; return 'T';&#125;#define CLR(x) memset(x, 0, sizeof x)struct SAM &#123; struct node &#123; int at, link, len, next[4]; node(int _at) : at(_at), link(0), len(0) &#123;CLR(next);&#125; &#125;; vector&lt;node&gt; T; int size, last; inline void init() &#123; node start(++cnt); start.len = size = last = 0, start.link = -1; T.push_back(start); &#125; inline void insert(char c) &#123; int cur = ++size, s = id(c), p; T.push_back(node(++cnt)); T[cur].len = T[last].len + 1; for (p = last;~p &amp;&amp; !T[p].next[s];p = T[p].link) T[p].next[s] = cur; if (p != -1) &#123; int q = T[p].next[s]; if (T[p].len + 1 == T[q].len) T[cur].link = q; else &#123; int clone = ++size; T.push_back(node(++cnt)); T[clone].link = T[q].link, memcpy(T[clone].next, T[q].next, sizeof(T[q].next)), T[clone].len = T[p].len + 1, T[cur].link = T[q].link = clone; while (p != -1 &amp;&amp; T[p].next[s] == q) &#123; T[p].next[s] = clone; p = T[p].link; &#125; &#125; &#125; last = cur; &#125; &#125; S[N];const int mod = 1e9 + 7;inline void Inc(int &amp;x, int y) &#123;x += y, x -= x &gt;= mod ? mod : 0;&#125;int dp[N * 2], n; const char NX[4] = &#123;'A', 'C', 'G', 'T'&#125;; int Next[N][4];int dfs(int now, int cur) &#123; if (~dp[S[now].T[cur].at]) return dp[S[now].T[cur].at]; int &amp;sum = dp[S[now].T[cur].at] = 1; for (int t = 0;t &lt; 4;t++) &#123; if (S[now].T[cur].next[t]) Inc(sum, dfs(now, S[now].T[cur].next[t])); else if (Next[now][t]) Inc(sum, dfs(Next[now][t], S[Next[now][t]].T[0].next[t])); &#125; return sum;&#125;int res = 0, top = 0; char str[N];void dfs2(int now, int cur) &#123; res++, str[top] = '\0', printf("%s\n", str); for (int t = 0;t &lt; 4;t++) &#123; top++, str[top - 1] = rid(t); if (S[now].T[cur].next[t]) dfs2(now, S[now].T[cur].next[t]); else if (Next[now][t]) dfs2(Next[now][t], S[Next[now][t]].T[0].next[t]); top--; &#125;&#125;char input[N];int main() &#123; freopen("copy.in", "r", stdin), freopen("copy.out", "w", stdout); scanf("%d", &amp;n), S[0].init(), memset(dp, -1, sizeof(dp)); for (int i = 1;i &lt;= n;i++) &#123; scanf("%s", input + 1), S[i].init(); int m = strlen(input + 1); for (int j = 1;j &lt;= m;j++) S[i].insert(input[j]); &#125; int del[4]; CLR(del); for (int i = n;i &gt;= 0;i--) &#123; memcpy(Next[i], del, sizeof(del)); for (int j = 0;j &lt; 4;j++) if (S[i].T[0].next[j]) del[j] = i; &#125; int k; scanf("%d", &amp;k); if (!k) printf("%d\n", dfs(0, 0)); else dfs2(0, 0), printf("%d\n", res);&#125; T3 不同的缩写 题意就是给出$n$个人的名字，对于每个人我们都要使用它的一个子序列去代表他，子序列不能有相同的，输出方案 首先我们可以二分出最小长度 然后判断是否满足似乎可以二分图匹配 具体来说就是原串放在左边，子序列放在右边，然后中间根据是否是这个串的子序列连边 但是我们发现这样的话右边最多有$2^n$个点，显然不行 那么我们考虑一个定理 如果二分图的两边的所有点的度数都不小于$n$，那么一定存在完美匹配 那么对于每个串我们跑出它的前$n$短的子序列，然后暴力连边 这样就只有$n^2$个点了 关于判断是否是某个串的子序列，仍然可以使用子序列自动机 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdc++.h&gt;using namespace std;#define N 310#pragma GCC optimize(2)struct edge &#123; int to, next, w;&#125; e[N * N * N / 2];int head[N * N], ecnt = 1, dep[N * N], cur[N * N];inline void adde(int from, int to, int w) &#123; e[++ecnt] = (edge)&#123;to, head[from], w&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to], 0&#125;, head[to] = ecnt;&#125;inline bool BFS(int s, int t) &#123; queue&lt;int&gt; q; q.push(s), memset(dep, -1, sizeof(dep)), dep[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u];i;i = e[i].next) if (e[i].w &amp;&amp; dep[e[i].to] == -1) &#123; dep[e[i].to] = dep[u] + 1, q.push(e[i].to); if (e[i].to == t) return true; &#125; &#125; return false;&#125;inline int DFS(int u, int f, int t) &#123; if (!f || u == t) return f; int res = 0; for (int &amp;i = cur[u], tmp;i;i = e[i].next) if (e[i].w &amp;&amp; dep[e[i].to] == dep[u] + 1 &amp;&amp; (tmp = DFS(e[i].to, min(f, e[i].w), t))) &#123; e[i].w -= tmp, e[i ^ 1].w += tmp, res += tmp, f -= tmp; if (!f) break; &#125; return res;&#125;inline int Dinic(int s, int t) &#123; int res = 0; while (BFS(s, t)) memcpy(cur, head, sizeof(head)), res += DFS(s, 1e9, t); return res;&#125;#define LL unsigned long longconst LL P = 29; set&lt;LL&gt; s;char base[N][N]; int nxt[26][N][N], mid, cnt, n, ncnt, S, T, len[N]; LL del;inline bool check(int cur, const string &amp;cc) &#123; int now = 0; for (int i = 0;i &lt; cc.size() &amp;&amp; now != -1;i++) now = nxt[cc[i] - 'a'][cur][now]; return now != -1;&#125;struct data &#123; string v; LL hash; int pos; data() : v(""), hash(0), pos(0) &#123;&#125;&#125;;string ans[N * N];inline void bfs(int now) &#123; queue&lt;data&gt; q; q.push(data()); while (!q.empty()) &#123; data u = q.front(); q.pop(); if (u.hash) cnt++; if (u.hash &amp;&amp; !s.count(u.hash)) ncnt++, adde(ncnt, T, 1), ans[ncnt] = u.v, s.insert(u.hash); if (cnt &gt;= n) return; for (int i = 0;i &lt; 26;i++) if (~nxt[i][now][u.pos]) &#123; int t = nxt[i][now][u.pos]; LL hash = u.hash * P + i + 1; data b; b.v = u.v + char(i + 'a'), b.hash = hash, b.pos = t, q.push(b); &#125; &#125;&#125;int ttt[26];inline void Pre(int now) &#123; int cur = len[now]; memset(ttt, -1, sizeof(ttt)); for (int i = cur;i &gt;= 0;i--) &#123; for (int j = 0;j &lt; 26;j++) nxt[j][now][i] = ttt[j]; if (i) ttt[base[now][i] - 'a'] = i; &#125;&#125;#define RG registerinline bool solve(int m) &#123; ecnt = 1, memset(head, 0, sizeof(head)); for (int i = 1;i &lt;= n;i++) adde(S, i, 1); for (RG int i = n + 3;i &lt;= ncnt;++i) if (ans[i].size() &lt;= m) &#123; adde(i, T, 1); for (RG int j = 1;j &lt;= n;++j) if (check(j, ans[i])) adde(j, i, 1); &#125; return Dinic(S, T) == n;&#125; string last[N];inline void solve2(int m) &#123; ecnt = 1, memset(head, 0, sizeof(head)); for (int i = 1;i &lt;= n;i++) adde(S, i, 1); for (int i = n + 3;i &lt;= ncnt;i++) if (ans[i].size() &lt;= m) &#123; adde(i, T, 1); for (int j = 1;j &lt;= n;j++) if (check(j, ans[i])) adde(j, i, 1); &#125; Dinic(S, T); for (int i = 1;i &lt;= n;i++) for (int j = head[i];j;j = e[j].next) if (n + 3 &lt;= e[j].to &amp;&amp; !e[j].w) last[i] = ans[e[j].to]; for (int i = 1;i &lt;= n;i++) cout &lt;&lt; last[i] &lt;&lt; endl;&#125;int main() &#123; freopen("diff.in", "r", stdin), freopen("diff.out", "w", stdout); scanf("%d", &amp;n); int mx = 0; for (int i = 1;i &lt;= n;i++) scanf("%s", base[i] + 1), len[i] = strlen(base[i] + 1), mx = max(mx, len[i]); for (int i = 1;i &lt;= n;i++) Pre(i); ncnt = n + 2, S = n + 1, T = n + 2; for (int i = 1;i &lt;= n;i++) cnt = 0, bfs(i); int l = 1, r = mx, ans = -1; while (l &lt;= r) &#123; if (solve(mid = (l + r) &gt;&gt; 1)) r = mid - 1, ans = mid; else l = mid + 1; &#125; printf("%d\n", ans); if (~ans) solve2(ans); cerr &lt;&lt; clock() &lt;&lt; endl; return 0;&#125; 总结Dev千万不要打开-std=c++11 防止CE]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>网络流</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
        <tag>二分答案</tag>
        <tag>字符串</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.18省选模拟]]></title>
    <url>%2F2019%2F03%2F19%2F3-18%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 One?One! 不会啊。。先贴上题解吧 T2 Two?Two! 首先考虑dp 假设现在已经排了前$i$个人，我们知道这两个队中有一个对的最大值一定是$M_i$，即前$i$个人的最大值 那么我们可以设dp[i][j]表示已经排好了$i$个人，其中$M_i$不在的那一队的最大值为$j$的答案 我们考虑一下几种情况： $M_i=x_i$ 显然，将$i$排到$M_{i-1}$那一队会更优秀 即对于任意的$j$，dp[i][j] = dp[i - 1][j] $x_i&lt;M_i,j\in[0,x_i)$ 排完了$i$这个人之后仍然有一队的最大值小于$x_i$，那么$i$一定排到了最大值更大的那一边，即$M_{i-1}$，也是$M_i$ 此时有dp[i][j] = dp[i - 1][j] + M[i] - x[i] $x_i&lt;M_i,j=x_i$ 排完了$i$这个人之后，最大值不在的那一对的最大值就咕了 那么我们可以知道，这一队之前的最大值一定是$\leq x_i$的 所以有dp[i][j] = min{dp[i - 1][k]}(k &lt;= j) $x_i&lt;M_i,j\in(x_i,M_i]$ 那么此时把$i$排到$j$那一队肯定更优秀 所以dp[i][j] = dp[i - 1][j] + j - x[i] 但是这样dp是$n^2$的，需要优化 我们考虑进行了哪些操作 第一种情况：什么都没做 第二种情况：区间加常数 第三种情况：区间取最小值，单点覆盖 第四种情况：区间加常数，区间加一次函数 这个区间加一次函数与区间最小值在一起好像有点不好维护 题解是splay，但我只会75分分块 考虑如何块内维护 我们在每个块都维护一个下凸壳，由于我们加的一次函数是单调递增的，所以只有下凸壳上的顶点才有可能成为最小值 由于某些操作没有下放，这导致询问的时候我们需要考虑这部分没有下放的标记 我们令一个块中的tag1为自变量 那么可以根据这个进行斜率优化，因为在更新时这个标记是不降的 所以我们维护凸包 每次查询的时候把最开始没用的直线pop掉就可以了 考虑时间复杂度 区间加常数时凸包不会改变 单点覆盖时最多加一个点 而凸包上的每个点只会进来一次，弹出一次 所以总时间复杂度$O(n\log n)$ 需要离散化 不知道出了什么问题的代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010#define M 1000#define LL long longconst int size = 120;int tag1[M], belong[N], to[N], n; LL f[N], tag2[M];deque&lt;int&gt; d[M];inline LL Get(int x) &#123; int bl = belong[x]; return f[x] + (LL)tag1[bl] * to[x] + tag2[bl];&#125;inline int Start(int block) &#123;return (block - 1) * size + 1;&#125;inline int End(int block) &#123;return min(n, block * size);&#125;inline void Pushdown(int block) &#123; if (tag1[block] == 0 &amp;&amp; tag2[block] == 0) return; int st = Start(block), ed = End(block); for (int i = st;i &lt;= ed;i++) f[i] = Get(i); tag1[block] = tag2[block] = 0;&#125;inline bool Calc(int a, int b, int c) &#123; return (LL)f[b] - f[a] &lt;= c * (a - b);&#125;inline void Rebuild(int block) &#123; int st = Start(block), ed = End(block); d[block].clear(); for (int i = ed;i &gt;= st;i--) &#123; while (d[block].size() &amp;&amp; f[*d[block].rbegin()] &gt;= f[i]) d[block].pop_back(); d[block].push_back(i); &#125;&#125;inline void Pre() &#123; for (int i = 2;i &lt;= n;i++) f[i] = 1e15; for (int i = 1;i &lt;= n;i++) belong[i] = (i + size - 1) / size; for (int i = 1;i &lt;= belong[n];i++) Rebuild(i);&#125;inline LL Min(int block) &#123; int x = tag1[block]; while (d[block].size() &gt;= 2 &amp;&amp; Calc(d[block][0], d[block][1], x)) d[block].pop_front(); return Get(d[block][0]);&#125;inline void UPD(int start, int end, int type, int x) &#123; for (int i = start;i &lt;= end;i++) if (type == 1) f[i] += x; else if (type == 2) f[i] += to[i];&#125;inline void update(int start, int end, int type, int x) &#123; if (start &gt; end) return; int st = belong[start], ed = belong[end], s = End(st), t = Start(ed); Pushdown(st), Pushdown(ed); if (st == ed) &#123;UPD(start, end, type, x), Rebuild(st); return;&#125; UPD(start, s, type, x), UPD(t, end, type, x), Rebuild(st), Rebuild(ed); for (int i = st + 1;i &lt; ed;i++) if (type == 1) tag2[i] += x; else if (type == 2) tag1[i]++;&#125;inline void Set(int at, LL x) &#123; int bl = belong[at]; Pushdown(bl), f[at] = x, Rebuild(bl);&#125;inline LL query(int start, int end) &#123; int st = belong[start], ed = belong[end], s = End(st), t = Start(ed); LL res = 1e18; if (st == ed) &#123; for (int i = start;i &lt;= end;i++) res = min(res, Get(i)); return res; &#125; for (int i = start;i &lt;= s;i++) res = min(res, Get(i)); for (int i = t;i &lt;= end;i++) res = min(res, Get(i)); for (int i = st + 1;i &lt; ed;i++) res = min(res, Min(i)); return res;&#125;int num[N];int main() &#123;// freopen("two.in", "r", stdin), freopen("two.out", "w", stdout); int _n; scanf("%d", &amp;_n); for (int i = 1;i &lt;= _n;i++) scanf("%d", &amp;num[i]), to[i] = num[i]; sort(to + 1, to + _n + 1), n = unique(to + 1, to + _n + 1) - to - 1, Pre(); for (int i = 1;i &lt;= _n;i++) num[i] = lower_bound(to + 1, to + n, num[i]) - to; for (int i = 2, mx = num[1];i &lt;= _n;i++) &#123; if (mx &lt;= num[i]) &#123;mx = num[i]; continue;&#125; Set(num[i], query(1, num[i])); update(1, num[i] - 1, 1, to[mx] - to[num[i]]), update(num[i] + 1, mx, 2, 0), update(num[i] + 1, mx, 1, -to[num[i]]); &#125; printf("%lld\n", query(1, n)); return 0;&#125; T3 More?More! 很奇妙的一道题，有两种方法 ZJK的做法考虑将每个选手选或不选转化成一个01串，那么对于一个有$i$位是1的01串，我们设$a$表示01对的数量，$b$表示10对的数量 那么显然有$$p(该集合满足条件)=(1-p)^ap^b$$注意到$b$是可以被$a$表示的，有$$b=\frac{n(n-1)}{2}-a$$所以上面的式子$$=(1-p)^ap^{\frac{n(n-1)}{2}-a}\\\=(\frac{1-p}{p})^ap^\frac{n(n+1)}{2}$$我们需要求出所有有$i$位是1的01串合法的概率之和，而这些串的$n$都是固定的 所以可以把$p^\frac{n(n-1)}{2}$提出来 所以我们实际上要求的是$$\sum_{s有i位是1}(\frac{1-p}{p})^{a_s}$$考虑$a_s$如何计算 我们采用总数减去多余情况的方法 那么对于每一个1的位置，前面的每一个位置都有机会和它构成01串，此时答案为所有1的下标之和 但是我们发现有些地方是构不成01串的，比如选了两个1 所以还需要减去$\frac{i(i+1)}{2}$(包含了两次都选同一个位置的情况) 所以$$a_s=\sum 1的下标-\frac{i(i+1)}{2}$$我们发现，对于所有有$i$位是1的集合，后面那个东西也是不变的，可以提出来 所以最终我们需要得到的是$$\sum_{s有i位是1}(\frac{1-p}{p})^{所有1的下标之和}$$考虑构造生成函数 显然它的生成函数是$$G(x)=\prod_{i=1}^n(1+(\frac{1-p}{p})^ix)$$含义是，枚举每一个位置是不是1 如果不是1，那么对应括号中的1 否则，当前答案就会乘上$(\frac{1-p}{p})^i$，$i$即当前位的下标 最后答案就是$x^i$项的系数 可以使用分治NTT倍增 标程的做法先考虑朴素的dp dp[i][j]表示有$i$个人，选了$j$个人并且合法的概率 那么有两种思路 当前添加的那个人的编号大于所有人的编号 此时显然有dp[i][j] = dp[i - 1][j] * p ^ j + dp[i - 1][j - 1] * (1 - p) ^ (i - j + 1) 当前添加的那个人的编号小于所有人的编号 有dp[i][j] = dp[i - 1][j] * (1 - p) ^ j + dp[i - 1][j - 1] * p ^ (i - j + 1) 根据dp的定义，我们可以得出：这两个转移一定是等价的！ 所以有$$dp_{i,j}*p^j+dp_{i,j-1}*p^{i-j+1}=dp_{i,j}*(1-p)^{j}+dp_{i,j-1}*p^{i-j+1}$$移项，可以得出$$dp_{i,j}(p^j-(1-p)^j)=dp_{i,j-1}((1-p)^{i-j+1}-p^{i-j+1})$$然后扫一遍就可以了 注意对于$p=\frac 12$需要特判 代码如下 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int dp[2010][2010], frac[1000010], inv[1000010];#define LL long longconst int mod = 998244353;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;inline int C(int n, int r) &#123; return (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;&#125;#define RG registerint main() &#123; freopen("more.in", "r", stdin), freopen("more.out", "w", stdout); dp[1][1] = dp[1][0] = 1; int n, p; scanf("%d%d", &amp;n, &amp;p); if (p == (mod + 1) / 2) &#123; frac[0] = inv[0] = 1; for (RG int i = 1;i &lt;= n;++i) frac[i] = (LL)frac[i - 1] * i % mod, inv[i] = Pow(frac[i], mod - 2); for (int i = 1;i &lt; n;i++) &#123; printf("%lld ", (LL)C(n, i) * Pow(Pow(p, n - i), i) % mod); &#125; &#125; else &#123; for (int i = 2;i &lt;= n;i++) for (int j = 0;j &lt;= i;j++) dp[i][j] = ((LL)dp[i - 1][j] * Pow(p, j) + (j ? (LL)dp[i - 1][j - 1] * Pow(mod + 1 - p, i - j) : 0)) % mod; for (int i = 1;i &lt; n;i++) cout &lt;&lt; dp[n][i] &lt;&lt; ' '; &#125;&#125; 总结关于总结，它不见了]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>数据结构</tag>
        <tag>多项式</tag>
        <tag>分块</tag>
        <tag>平衡树</tag>
        <tag>NTT</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.16省选模拟]]></title>
    <url>%2F2019%2F03%2F17%2F3-16%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 计算 比较简单的一道题 考虑将这个式子拆开 注意到这个幂是可以拆分的，即$a^b*a^c=a^{b+c}$ 而$\sum\sum ab=\sum a\sum b$ 如果将这个式子一位一位地拆分，假设$k$的第一位是$x$，有$m$位，那么有$$\sum_k e^{\frac kn}=\sum_xe^\frac{x*10^m}{n}\sum_{k去除第一位}e^{\frac kn}$$直接数位dp就可以了，注意需要特判$m=0$时的前导0的情况 对于“不含$m$这个子串”这个条件，可以先用KMP求出next数组，再处理合法的转移 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;#define double long doubleint ndig[101], mdig[101], Pow10[101], nxt[101][101], ndep, n;double dp[101][101][3][3];inline int get_digit(int digit[], int n) &#123; if (n == 0) &#123;digit[1] = 0; return 1;&#125; int res = 0; while (n) digit[++res] = n % 10, n /= 10; reverse(digit + 1, digit + res + 1); return res;&#125;double DP(int dep, int cur, int flag, int lead) &#123; if (dep == 0) return 1; if (dp[dep][cur][flag][lead] != -1) return dp[dep][cur][flag][lead]; double &amp;sum = dp[dep][cur][flag][lead]; sum = 0; int R = !flag ? 9 : ndig[ndep - dep + 1]; for (int i = 0;i &lt;= R;i++) if (nxt[cur][i] != -1 || (mdig[1] == 0 &amp;&amp; lead &amp;&amp; !i)) &#123; int nflag = flag &amp;&amp; i == R, nlead = lead &amp;&amp; !i; sum += exp(i * Pow10[dep - 1] / (double)n) * DP(dep - 1, ~nxt[cur][i] ? nxt[cur][i] : 0, nflag, nlead); &#125; return sum;&#125;int Nxt[101];inline void KMP(int n) &#123; for (int i = 2;i &lt;= n;i++) &#123; int t = Nxt[i - 1]; while (t &amp;&amp; mdig[i] != mdig[t + 1]) t = Nxt[t]; if (mdig[t + 1] == mdig[i]) t++; Nxt[i] = t; &#125;&#125;int main() &#123; int m; scanf("%d%d", &amp;n, &amp;m), Pow10[0] = 1; for (int i = 1;i &lt;= 9;i++) Pow10[i] = Pow10[i - 1] * 10; int dep = get_digit(ndig, n), mdep = get_digit(mdig, m); KMP(mdep), ndep = dep; for (int i = 0;i &lt; mdep;i++) &#123; for (int j = 0;j &lt;= 9;j++) &#123; int tmp = i; while (tmp &amp;&amp; mdig[tmp + 1] != j) tmp = Nxt[tmp]; nxt[i][j] = mdig[tmp + 1] == j ? tmp + 1 : tmp; if (nxt[i][j] == mdep) nxt[i][j] = -1; &#125; &#125; for (int i = 0;i &lt;= 10;i++) for (int j = 0;j &lt;= 10;j++) for (int k = 0;k &lt; 2;k++) dp[i][j][k][0] = dp[i][j][k][1] = -1; printf("%.3Lf\n", DP(dep, 0, 1, 1) - 1);&#125; T2 移动 很经典的一道题，可以参考环形均分纸牌问题 我们假设位置$i$向右传递了$x_i$，其原来的值为$c_i$ 那么有$$c_1+x_n-x_1=1\\\c_2+x_1-x_2=1\\\\Rightarrow c_2-1+c_1-1+x_n=x_2\\\c_3-1+c_2-1+c_1-1+x_n=x_3\\\ans=\sum_{i=1}^n|x_i|=\sum_{i=1}^n|\sum_{j=1}^i(c_j-1)+x_n|\\\=\sum_{i=1}^n|x_n-\sum_{j=1}^i(1-c_j)|$$如果要让$ans$尽量小，那么就要让后面那个数尽量小 我们设$s_n=\sum\limits_{i=1}^n(1-c_i)$ 所以$x_n$取到$s$的中位数时最优秀 代码如下 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1000010int num[N], tmp[N];#define LL long longint main() &#123; int n; scanf("%d", &amp;n); for (int i = 1;i &lt;= n;i++) num[i] = 1; for (int i = 1, a;i &lt;= n;i++) scanf("%d", &amp;a), num[a]--; for (int i = 1;i &lt;= n;i++) num[i] += num[i - 1]; sort(num + 1, num + n + 1); int middle = num[(n + 1) / 2]; LL res = 0; for (int i = 1;i &lt;= n;i++) res += abs(num[i] - middle); printf("%lld\n", res); return 0;&#125; 另外，dinic费用流可以拿50分 将SPFA部分改一下，改成从汇点开始跑费用最短路 然后将普通最大流的层级图改成最短路图即可 注意dfs的时候还要记录一个vis数组，每个点只能经过一次 可以多路增广 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;#define N 30010#define M 120010struct edge &#123; int to, next, w, c;&#125; e[M];#define LL long longint head[N], ecnt = 1, vis[N], cur[N]; LL dis[N];inline void adde(int from, int to, int f, int c) &#123; e[++ecnt] = (edge)&#123;to, head[from], f, c&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to], 0, -c&#125;, head[to] = ecnt;&#125;inline bool SPFA(int s, int t) &#123; memset(vis, 0, sizeof(vis)), memset(dis, 0x3f, sizeof(dis)), dis[t] = 0, vis[t] = 1; deque&lt;int&gt; q; q.push_back(t); while (!q.empty()) &#123; int u = q.front(); q.pop_front(), vis[u] = 0; for (int i = head[u];i;i = e[i].next) if (e[i ^ 1].w &amp;&amp; dis[e[i].to] &gt; dis[u] - e[i].c) &#123; dis[e[i].to] = dis[u] - e[i].c; if (!vis[e[i].to]) &#123; vis[e[i].to] = 1; if (!q.empty() &amp;&amp; dis[e[i].to] &lt; dis[q.front()]) q.push_front(e[i].to); else q.push_back(e[i].to); &#125; &#125; &#125; return dis[s] &lt; 1e17;&#125;LL MCMF;int DFS(int u, int f, int t) &#123; vis[u] = 1; int res = 0; if (u == t || !f) return f; for (int &amp;i = cur[u], tmp;i;i = e[i].next) if (!vis[e[i].to] &amp;&amp; e[i].w &amp;&amp; dis[u] - e[i].c == dis[e[i].to] &amp;&amp; (tmp = DFS(e[i].to, min(f, e[i].w), t))) &#123; f -= tmp, res += tmp, e[i].w -= tmp, e[i ^ 1].w += tmp, MCMF += (LL)tmp * e[i].c; if (!f) break; &#125; return res;&#125;inline LL Dinic(int s, int t) &#123; MCMF = 0; int f = 0; while (SPFA(s, t)) memcpy(cur, head, sizeof(head)), f += DFS(s, 1e9, t); return MCMF;&#125;int num[N];int main() &#123;// freopen("in.txt", "r", stdin); int n, s, t; scanf("%d", &amp;n), s = n + 1, t = n + 2; for (int i = 1, a;i &lt;= n;i++) scanf("%d", &amp;a), num[a]++; for (int i = 1;i &lt;= n;i++) adde(s, i, num[i], 0), adde(i, i == n ? 1 : i + 1, 1e9, 1), adde(i == n ? 1 : i + 1, i, 1e9, 1), adde(i, t, 1, 0); printf("%lld\n", Dinic(s, t)); return 0;&#125; T3 分离 折半搜索+打表 有一个结论：当$n\geq96$时，答案是0 不会，告辞 总结这次比赛有所进步，但是又粗心了 第一题犯了一个比较隐蔽的错误，导致有一些点RE了 不过还好]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>数位</tag>
        <tag>数学</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
        <tag>打表</tag>
        <tag>题解</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.15省选模拟]]></title>
    <url>%2F2019%2F03%2F15%2F3-15%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 Tried 之前做过一道Codeforces的题Run for beer，跟这道题很像 先把所有环都缩在一起，就变成了一个DAG 那么我们考虑在这个DAG上搞 显然一条最长的路径首先要满足长度最长，注意这里的长度指的是不包含前缀0的长度 其次要满足越靠下的路径要尽量长 对于每个点我们可以求出两个值 dep[u]表示从某个入度为0的点到$u$，经过的边数最多是多少 f[u]表示如果以$u$为终点，到某个入度为0的点经过的边数最多是多少。这要求连接$u$的那条边不能为0 然后我们就可以维护两个队列，代表当前可能成为答案的点 每次往上扩展一层，只扩展那些边权最大的边 123456789101112131415161718192021vector&lt;int&gt; q[2], res;inline void bfs(int dep, int cur) &#123; if (!dep) return; q[cur].clear(); int Mx = 0; for (int i = 0;i &lt; q[cur ^ 1].size();i++) &#123; int u = q[cur ^ 1][i]; for (int j = 0;j &lt; R[u].size();j++) if (dp[u] == dp[R[u][j].first] + 1) Mx = max(Mx, R[u][j].second); &#125; res.push_back(Mx); for (int i = 0;i &lt; q[cur ^ 1].size();i++) &#123; int u = q[cur ^ 1][i]; if (hh[u]) continue; hh[u] = 1; for (int j = 0;j &lt; R[u].size();j++) if (dp[u] == dp[R[u][j].first] + 1 &amp;&amp; R[u][j].second == Mx) q[cur].push_back(R[u][j].first); &#125; for (int i = 0;i &lt; q[cur ^ 1].size();i++) hh[q[cur ^ 1][i]] = 0; bfs(dep - 1, cur ^ 1);&#125; 然后根据答案从所有入度为0的点开始拓展，统计答案 这道题细节非常繁琐，首先有以下几种特殊情况： 有至少一个非0环，那么可以在这个环上永远走下去，答案为inf, inf 有0环，并且这个0环可以走到至少一条非0边，答案为inf, inf 有0环，并且不满足条件2，且在答案的路径上或者在某个终止节点的子树中，第二个答案为inf 所有边的边权都为0，此时枚举终点算方案数，注意只有一个点的路径也算 一条路径结束后仍然可以继续往下扩展，需要乘上终点的方案数 有自环，需要把它当成一个环 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010#define M 1000010const int mod = 998244353;#define LL long longstruct edge &#123; int from, to, next, w, used;&#125; e[M * 2];int head[N], ecnt;inline void adde(int from, int to, int w) &#123; e[++ecnt] = (edge)&#123;from, to, head[from], w, 0&#125;, head[from] = ecnt;&#125;int st[N], top, in[N], scc, belong[N], dfsn, dfn[N], low[N], sum[N], cnt[N];void Tarjan(int u) &#123; st[++top] = u, in[u] = 1, dfn[u] = low[u] = ++dfsn; for (int i = head[u];i;i = e[i].next) if (!dfn[e[i].to]) Tarjan(e[i].to), low[u] = min(low[u], low[e[i].to]); else if (in[e[i].to]) low[u] = min(low[u], dfn[e[i].to]); if (dfn[u] == low[u]) &#123; scc++; int v = -1; for (;v != u;top--) v = st[top], in[v] = 0, belong[v] = scc, cnt[scc]++; &#125;&#125;#define P pair&lt;int, int&gt;int ind[N], oud[N], dp[N], ok[N]; vector&lt;P &gt; G[N], R[N];inline void Topsort(int n) &#123; queue&lt;int&gt; q; for (int i = 1;i &lt;= n;i++) if (!ind[i]) q.push(i), st[++top] = i; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0;i &lt; G[u].size();i++) &#123; int v = G[u][i].first; if (!--ind[v]) q.push(v), st[++top] = v; &#125; &#125;&#125; int f[N], hh[N];vector&lt;int&gt; q[2], res;inline void bfs(int dep, int cur) &#123; if (!dep) return; q[cur].clear(); int Mx = 0; for (int i = 0;i &lt; q[cur ^ 1].size();i++) &#123; int u = q[cur ^ 1][i]; for (int j = 0;j &lt; R[u].size();j++) if (dp[u] == dp[R[u][j].first] + 1) Mx = max(Mx, R[u][j].second); &#125; res.push_back(Mx); for (int i = 0;i &lt; q[cur ^ 1].size();i++) &#123; int u = q[cur ^ 1][i]; if (hh[u]) continue; hh[u] = 1; for (int j = 0;j &lt; R[u].size();j++) if (dp[u] == dp[R[u][j].first] + 1 &amp;&amp; R[u][j].second == Mx) q[cur].push_back(R[u][j].first); &#125; for (int i = 0;i &lt; q[cur ^ 1].size();i++) hh[q[cur ^ 1][i]] = 0; bfs(dep - 1, cur ^ 1);&#125;int path[N], wocaonima[N], last[N], tmpind[N], toend[N], fuck[N], tostart[N];inline void getans(int dep, int cur) &#123; if (!dep) &#123; for (int i = 0;i &lt; q[cur ^ 1].size();i++) last[q[cur ^ 1][i]] = 1; return; &#125; q[cur].clear(); for (int i = 0;i &lt; q[cur ^ 1].size();i++) &#123; int u = q[cur ^ 1][i]; if (hh[u]) continue; hh[u] = 1; for (int j = 0;j &lt; G[u].size();j++) if (G[u][j].second == res[dep - 1] &amp;&amp; dp[u] + 1 == dp[G[u][j].first]) &#123; (path[G[u][j].first] += path[u]) %= mod; q[cur].push_back(G[u][j].first), wocaonima[G[u][j].first] |= wocaonima[u] | (cnt[u] != 1); &#125; &#125; for (int i = 0;i &lt; q[cur ^ 1].size();i++) hh[q[cur ^ 1][i]] = 0; getans(dep - 1, cur ^ 1);&#125;int main() &#123;// freopen("data.in", "r", stdin);// freopen("tried.in", "r", stdin), freopen("tried.out", "w", stdout); int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1, a, b, c;i &lt;= m;i++) &#123; scanf("%d%d%d", &amp;a, &amp;b, &amp;c), adde(a, b, c); &#125; for (int i = 1;i &lt;= n;i++) if (!dfn[i]) Tarjan(i); for (int i = 1;i &lt;= ecnt;i++) &#123; if (e[i].from == e[i].to) cnt[belong[e[i].from]]++; if (belong[e[i].from] != belong[e[i].to]) &#123; int u = belong[e[i].from], v = belong[e[i].to]; G[u].push_back(P(v, e[i].w)), R[v].push_back(P(u, e[i].w)), ind[v]++, oud[u]++, tmpind[v]++; &#125; else sum[belong[e[i].from]] += e[i].w; &#125; for (int i = 1;i &lt;= scc;i++) if (cnt[i] != 1 &amp;&amp; sum[i]) &#123; printf("inf\ninf\n"); return 0; &#125; Topsort(scc); for (int i = 1;i &lt;= scc;i++) if (!oud[i]) toend[i] = 1; for (int i = top;i &gt;= 1;i--) &#123; int u = st[i]; for (int j = 0;j &lt; G[u].size();j++) &#123; int v = G[u][j].first; ok[u] |= ok[v] | (G[u][j].second != 0), (toend[u] += toend[v] + 1) %= mod, fuck[u] |= fuck[v] | (cnt[v] != 1); &#125; &#125; for (int i = 1;i &lt;= scc;i++) if (cnt[i] != 1 &amp;&amp; ok[i]) &#123; printf("inf\ninf\n"); return 0; &#125;// for (int i = 1;i &lt;= scc;i++) if (!tmpind[i]) tostart[i] = 1; for (int i = 1;i &lt;= top;i++) for (int j = 0, u = st[i];j &lt; G[u].size();j++) &#123; int v = G[u][j].first; dp[v] = max(dp[v], dp[u] + 1), (tostart[v] += tostart[u] + 1) %= mod; &#125; int tmp = 0; for (int i = 1;i &lt;= scc;i++) for (int j = 0;j &lt; R[i].size();j++) if (R[i][j].second) f[i] = max(f[i], dp[R[i][j].first] + 1), tmp = max(tmp, f[i]); for (int i = 1;i &lt;= scc;i++) if (f[i] == tmp) q[0].push_back(i), dp[i] = f[i]; int dep = tmp; bfs(dep, 1); if (!res.size()) &#123; printf("0\n"); int ans = 0; for (int i = 1;i &lt;= scc;i++) if (cnt[i] != 1) &#123; printf("inf\n"); return 0; &#125; else (ans += tostart[i]) %= mod; printf("%d", (ans + n) % mod); return 0; &#125; for (int i = 0;i &lt; res.size();i++) printf("%d", res[i]); puts(""); q[0].clear(), q[1].clear(); for (int i = 1;i &lt;= scc;i++) if (!tmpind[i]) path[i] = 1, q[0].push_back(i); getans(dep, 1); int ans = 0; for (int i = 1;i &lt;= scc;i++) if (last[i]) &#123; if (wocaonima[i] || fuck[i] || cnt[i] != 1) &#123; printf("inf\n"); return 0; &#125; else ans = (ans + (LL)path[i] * toend[i]) % mod; &#125; printf("%d\n", ans); return 0;&#125; T2 简单的数论题 神仙题，不会啊 T3 恶熊咆哮 只会20分，即$n\leq 2000$的暴力分 注意到x,y坐标可以分离考虑，而对于一次咆哮，所有熊的相对顺序是不变的，但是可能又一些熊移动到了一起 那么可以使用线段树，区间加，单点查 需要先找到第一个小于当前位置的数以及第一个大于当前位置的数 放上这次比赛的题解 总结T1数据出锅了，但是改了之后还是只有90分，原因是某个地方忘取模了 看来还是有这样不该出现的问题，慢慢改吧]]></content>
      <tags>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.8省选模拟 冬至]]></title>
    <url>%2F2019%2F03%2F14%2F3-8%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F-%E5%86%AC%E8%87%B3%2F</url>
    <content type="text"><![CDATA[我们设$t_n$表示长度为$n$时的答案，$s_n$表示最后$k$个字符是一个给定的排列，在位置$n-1$时都合法的方案数 我们考虑两个基本的式子$$\begin{gather}t_n=kt_{n-1}-k!s_n (1)\\\t_n=\sum_{i=1}^{k}(k-i)!s_{n+i} (2)\end{gather}$$对于第一个式子，我们在$t_{n-1}$后面随便加一种字符，然后减去不合法的情况，即$k!s_n$，这里枚举了最后$k$个字符分别是什么 对于第二个式子，我们尝试在$t_n$之后依次加上$1,2,3,\cdots,k$，枚举在加到哪个数字时候，这个序列变得不合法 追加了$i$个，前面的最后$k-i$个一定是一个排列，共$(k-i)!$种方案 根据这两个式子，我们可以推出$$(1)\Rightarrow s_n=\frac1{k!}(kt_{n-1}-t_n)\\\(2)\Rightarrow t_n=\sum_{i=1}^k(k-i)!\frac1{k!}(kt_{n+i-1}-t_{n+i})\\\=t_n+\sum_{i=1}^{k-1}((k-i-1)!\frac1{k!}kt_{n+i}-(k-i)!\frac1{k!}t_{n+i})-\frac1{k!}t_{n+k}$$ 注意这里把第一项的$kt_{n+i+1}$和最后一项的$t_n$拿了出来$$t_n=t_n+\sum_{i=1}^{k-1}((k-i-1)!\frac1{k!}kt_{n+i}-(k-i)!\frac1{k!}t_{n+i})-\frac1{k!}t_{n+k}\\\t_{n+k}=\sum_{i=1}^{k-1}((k-i-1)!kt_{n+i}-(k-i)!t_{n+i})\\\=\sum_{i=1}^{k-1}(k-i-1)!*i*t_{n+i}$$然后线性递推就可以了]]></content>
      <tags>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>多项式求逆</tag>
        <tag>多项式除法</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.13省选模拟]]></title>
    <url>%2F2019%2F03%2F13%2F3-13%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 碱基配对 注意到每一种字符是互不影响的，所以我们可以对于每一种字符分别计算有哪些位置合法，最后取一个交集 问题就转化为了给出两个01串$A,B$，对于$B$的每一个为1的位置$B_i$，$A_{i+p-k}-A_{i+p+k}$这些位置中至少要有一个1 那么我们可以把第一个串转化一下，将$A_i$变成原来的$A’_{i-k}-A’_{i+k}$中是否有1 对于这种条件比较奇怪的字符串匹配问题，一个比较常用的方法是FFT 我们设差异函数$F(p)$代表$A$串在$p$这个位置的差异值 我们考虑什么时候会产生差异 如果当前$B_i=0$，那么$A_{i+p}$随意 如果当前$B_i=1$，那么$A_{i+p}$必须为1 所以定义差异函数为$$F(p)=\sum_{i=0}^m(B_i-A_{i+p})B_i$$那么只要$F(p)\not=1$，$p$这个位置就不能匹配 把它化简一下$$F(p)=\sum_{i=0}^mB_i^2-\sum_{i=0}^mA_{i+p}B_i\\\=\sum_{i=0}^mB_i-\sum_{i=0}^mA_{i+p}B_i$$根据套路，设$A’(x)=A(n-x)$ 有$$G(p)=\sum_{i=0}^mA_{i+p}B_i\\\=\sum_{i=0}^mA’_{n-i-p}B_i\\\$$令$$G’(n-p)=\sum_{i=0}^mA’_{n-i-p}B_i\\\G(p)=G’(n-p)$$直接NTT即可 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;#define N 800010int pre[N], ta[N], tb[N], n, m, k, tmp[N], r[N], ans[N]; char A[N], B[N];const int mod = 998244353;#define LL long longinline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;inline void NTT(int a[], int len, int type) &#123; for (int i = 1;i &lt; len;i++) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int mid = 2;mid &lt;= len;mid &lt;&lt;= 1) &#123; int Wn = Pow(3, type ? (mod - 1) / mid : mod - 1 - (mod - 1) / mid); for (int i = 0;i &lt; len;i += mid) for (int j = i, w = 1, t;j &lt; i + (mid &gt;&gt; 1);j++, w = (LL)w * Wn % mod) t = (LL)w * a[j + (mid &gt;&gt; 1)] % mod, a[j + (mid &gt;&gt; 1)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod; &#125; if (!type) for (int i = 0, inv = Pow(len, mod - 2);i &lt; len;i++) a[i] = (LL)a[i] * inv % mod;&#125;inline void solve(char s) &#123; int sum = 0, l = 0, len = 1; for (int i = 0;i &lt; n;i++) pre[i] = (i ? pre[i - 1] : 0) + (A[i] == s); for (int i = 0;i &lt; m;i++) tb[i] = (B[i] == s), sum += tb[i] * tb[i]; for (int i = 0;i &lt; n;i++) &#123; int t = i - k - 1; tmp[i] = (pre[min(n - 1, i + k)] - (t &gt;= 0 ? pre[t] : 0)) &gt; 0; &#125; for (int i = 0;i &lt; n;i++) ta[n - i] = tmp[i]; while (len &lt;= n + m) len &lt;&lt;= 1, l++; for (int i = 1;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); for (int i = n + 1;i &lt; len;i++) ta[i] = 0; for (int i = m;i &lt; len;i++) tb[i] = 0; ta[0] = 0; NTT(ta, len, 1), NTT(tb, len, 1); for (int i = 0;i &lt; len;i++) ta[i] = (LL)ta[i] * tb[i] % mod; NTT(ta, len, 0); for (int i = 0;i &lt;= n - m;i++) ans[i] &amp;= ta[n - i] == sum;&#125;int main() &#123;// freopen("base1.in", "r", stdin); freopen("base.in", "r", stdin), freopen("base.out", "w", stdout); scanf("%d%s%s", &amp;k, A, B), n = strlen(A), m = strlen(B); for (int i = 0;i &lt;= n - m;i++) ans[i] = 1; solve('Z'), solve('P'), solve('S'), solve('B'); int res = 0; for (int i = 0;i &lt;= n - m;i++) res += ans[i]; printf("%d\n", res); return 0;&#125; T2 小凯的疑惑 由于数据太水，暴力可以获得92分的高分 对于第一、三、四这几个subtask，可以预处理当所有点都加上某个值时的答案，注意如果没有询问是这个值时不需要计算答案 对于第二个subtask，直接使用完全图的最小生成树这道题的做法即可。 每次将所有点按照最高位分成两类，把这两类分别连成连通块后再选择一条连接这两个连通块的最优边 表示没看懂题解在说什么，先贴上来 T3 false-false-true 一道很妙的题 先考虑$20\%$怎么做 很简单，直接dp即可 dp[i][j]表示当前已经有$i$道题是true，$j$道题是false，按照最优策略期望还能有多少道题可以答对 最优策略就是剩下的题中，是true的题多还是false的题多，哪个多就猜哪个 对于$40\%$，可以OEIS我也不知道该怎么做 对于所有的数据，我们考虑将题目转化一下 有一个$n*m$的网格，现在要从$(1,1)$走到$(n,m)$。对于一条路径，往上走代表这道题是false，往右走代表这道题是true。你现在要在走的同时决策向上走还是向右走，问期望有多少个决策会和最终的答案一样 我们将这个网格分成两部分 对于蓝色的部分，我们使用的策略是一直向右走，显然这样会更优秀，因为答对的概率更大 对于橙色的部分，有一些时候会向右走，有些时候会向上走。具体来说 在直线上方的部分会选择向右走，在直线下方的部分会选择向上走 我们先不考虑在直线上的情况 考虑一条路径的固定贡献 如果我们的策略只有向右走，那么绿色的路径一定会决策正确，黑色的路径一定会决策错误 最后决策正确的题目的数量是$n$ 现在把位于虚线下方的路径都折到虚线上方，由于我们知道在虚线下方时，决策是一直向上走，折过来之后，就变成了一直向右走 红色即为处理之后的路径 通过这张图我们知道，对于不在虚线上的点，它们在这条路径上的贡献一定是$n$ 那么对于在虚线上的点，它们的贡献需要特殊考虑 我们考虑一个这样的点对最终答案的贡献是什么 首先枚举每一个在虚线上的点，一共只有$m$个 对于一条经过它的路径，在到达这个点的时候，它有$50\%$的概率向上走，有$50\%​$的概率向右走，因为此时选两边正确的概率都相等 也就是说，它对这条路径决策正确的次数的贡献是$\frac 12$ 它对答案的贡献就是$\frac12$乘以它被经过的概率 我们知道经过一个点$(x,y)$的概率是$$\frac{C_{x+y}^yC_{n-x+m-y}^{n-x}}{C_{n+m}^n}$$乘以$\frac12$之后求和就可以了 代码如下 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1000010#define LL long longint frac[N], inv[N];const int mod = 998244353;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;inline int C(int n, int r) &#123; return (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;&#125;inline int Go(int n, int m) &#123; return C(n + m, n);&#125;int main() &#123; frac[0] = inv[0] = 1; for (int i = 1;i &lt;= N - 10;i++) frac[i] = (LL)frac[i - 1] * i % mod, inv[i] = Pow(frac[i], mod - 2); int n, m, res = 0; scanf("%d%d", &amp;n, &amp;m); if (n &lt; m) swap(n, m); for (int i = 1;i &lt;= m;i++) res = (res + (LL)Go(i, i) * Go(n - i, m - i)) % mod; res = (LL)res * Pow(2 * Go(n, m) % mod, mod - 2) % mod; printf("%d\n", (n + m - n - res + mod) % mod);&#125; 总结这次考试一般，第二题有一个小地方写错了，导致丢了20分 感觉第二题和第三题如果没有做过的话我很难想出正解，做一道题记一道题吧 明天没有考试]]></content>
      <tags>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>多项式</tag>
        <tag>字符串</tag>
        <tag>NTT</tag>
        <tag>组合数学</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.12省选模拟]]></title>
    <url>%2F2019%2F03%2F12%2F3-12%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 Mas的仙人掌 考虑每一条非树边的贡献 首先它不能掉落$(1-p_i)$，而且所有与它有交的边都必须掉落$(p_i)$ 那么显然有$$E_i=(1-p_i)\prod_{j与i有交}p_j$$所以关键在于如何求所有与它有交的边的$\prod p_j$ 首先我们考虑一个比较基础的问题：如何判断两条路径是否有交 假设这两条路径分别是$(a,b),(c,d)$ 如果是判断点相交，那么我们有结论： 如果两条路径有公共点，那么其中一条路径的$lca$一定在另一条路径上 如果是判断边相交，我们可以将这个结论推广 如果两条路径有公共边，那么其中一条路径的$lca$的左右两条边一定至少有一条也在另一条路径上 我们分两种情况讨论（假设当前需要求的路径是$u,v$）： $u,v$的$lca$的左右两边中至少有一条是在另一条路径上 那么此时有三种可能：只有$l,lca$是公共边、只有$r,lca$是公共边、$(l,lca),(r,lca)$都是公共边 对于前两种可能，我们需要求出覆盖了$l,lca$或者$r,lca$的路径的$\prod p_i$，这个可以直接用树上差分维护 对于第三种可能，我们发现前两种可能都包含了这种情况，也就是说我们多乘了一个$p_i$。好在此时两条路径的$lca$一定是相同的，那么我们维护一个map，map[l][r]表示所有$u$所对应的儿子是$l$，$v$所对应的儿子是$r$的路径的$p$的乘积，把$(u,v)$的答案除以这个值 所以此时$W_{u,v}=\frac{V_{l,lca}*V_{r,lca}}{map[l][r]},V$即是边的权值 另一条路径的$lca$的左右两边中至少有一条在$u,v$上，且不是$(l,lca),(r,lca) $ 那么我们知道此时这两条边不可能同时出现在$u,v$上 我们并不需要具体地知道究竟是那条边成为了公共点，我们只需要让这条公共边满足在$u,l$上，或者在$v,r$上 我们另外维护一个标记，每次加入一条路径$u,v$时，就把$(l,lca),(r,lca)$这两条路径的这个标记乘上$p_i$，最后再做一个前缀积，即我们只在这两条边上维护这条路径的贡献 查询的时候直接就查$u,l$路径上所有边这个标记的乘积，以及$v,r$路径上所有乘积就可以了 所以此时$W_{u,v}=\frac{V_{u,l}}{V_{v,r}}$，这里的$V$是树上前缀积的形式 把这两种情况的答案加起来即可 最后说一下如何更新 之前使用了两个标记，假设分别为tag1, tag2 首先要将$u,v$这条路径上所有的边的tag1乘上$p_i$，这是覆盖了某条边的路径的概率乘积 然后求出$l,r$，将$(l,lca),(r,lca)$这两条边的tag2乘上$p_i$，即在这条边上处理情况2的乘积 最后再一遍dfs，求出tag1，同时将tag2处理成前缀积的形式 然后就可以了 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long longconst int mod = 998244353;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;#define N 1000010struct Data &#123; int zero, mul; Data() &#123;&#125; Data(int x) &#123;if (x) zero = 0, mul = x; else zero = mul = 1;&#125; Data(int x, int y) : zero(x), mul(y) &#123;&#125; Data operator * (const Data &amp;b) &#123;return Data(zero + b.zero, (LL)mul * b.mul % mod);&#125; Data operator / (const Data &amp;b) &#123;return Data(zero - b.zero, (LL)mul * Pow(b.mul, mod - 2) % mod);&#125; inline int get() &#123;return zero ? 0 : mul;&#125;&#125; tag1[N], tag2[N];struct edge &#123; int to, next;&#125; e[N * 2];int head[N], ecnt;inline void adde(int from, int to) &#123; e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;&#125;int fa[N][21], dep[N]; void dfs(int u, int f) &#123; dep[u] = dep[f] + 1, fa[u][0] = f, tag1[u] = tag2[u] = Data(1); for (int i = 1;i &lt;= 20;i++) fa[u][i] = fa[fa[u][i - 1]][i - 1]; for (int i = head[u];i;i = e[i].next) if (e[i].to != f) dfs(e[i].to, u);&#125;inline int LCA(int a, int b) &#123; if (dep[a] &lt; dep[b]) swap(a, b); for (int i = 20;i &gt;= 0;i--) if (dep[fa[a][i]] &gt;= dep[b]) a = fa[a][i]; if (a == b) return a; for (int i = 20;i &gt;= 0;i--) if (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i]; return fa[a][0];&#125;inline int Jump(int a, int x) &#123; for (int i = 20;i &gt;= 0;i--) if (x &amp; (1 &lt;&lt; i)) a = fa[a][i]; return a;&#125;inline void Get(int a, int b, int &amp;lca, int &amp;g1, int &amp;g2) &#123; lca = LCA(a, b), g1 = g2 = 0; if (a != lca) g1 = Jump(a, dep[a] - dep[lca] - 1); if (b != lca) g2 = Jump(b, dep[b] - dep[lca] - 1);&#125;void dfs2(int u, int f) &#123; for (int i = head[u];i;i = e[i].next) if (e[i].to != f) &#123; tag2[e[i].to] = tag2[e[i].to] * tag2[u]; dfs2(e[i].to, u); tag1[u] = tag1[u] * tag1[e[i].to]; &#125;&#125;map&lt;int, Data&gt; G[N];inline void update(int a, int b, Data x) &#123; int lca, g1, g2; Get(a, b, lca, g1, g2); tag1[a] = tag1[a] * x, tag1[b] = tag1[b] * x, tag1[lca] = tag1[lca] / (x * x); if (g1) tag2[g1] = tag2[g1] * x; if (g2) tag2[g2] = tag2[g2] * x; if (g1 &amp;&amp; g2) &#123; if (g1 &gt; g2) swap(g1, g2); if (G[g1].count(g2)) G[g1][g2] = G[g1][g2] * x; else G[g1][g2] = x; &#125;&#125; inline Data query(int a, int b) &#123; int lca, g1, g2; Get(a, b, lca, g1, g2); Data res(1); if (g1) res = res * tag1[g1] * tag2[a] / tag2[g1]; if (g2) res = res * tag1[g2] * tag2[b] / tag2[g2]; if (g1 &amp;&amp; g2) &#123; if (g1 &gt; g2) swap(g1, g2); if (G[g1].count(g2)) res = res / G[g1][g2]; &#125; return res;&#125;int A[N], B[N], C[N], __rd;inline void read(int &amp;x) &#123; x = 0; char c = getchar(); while (c &lt; '0' || c &gt; '9') c = getchar(); while ('0' &lt;= c &amp;&amp; c &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - '0', c = getchar();&#125;#define RD (read(__rd), __rd)int main() &#123; freopen("cactus1.in", "r", stdin), freopen("cactus.out", "w", stdout); int n = RD, m = RD; for (int i = 1, a, b;i &lt; n;i++) a = RD, b = RD, adde(a, b); dfs(1, 0); for (int i = 1;i &lt;= m;i++) A[i] = RD, B[i] = RD, C[i] = RD, update(A[i], B[i], C[i]); dfs2(1, 0); int ans = 0; for (int i = 1;i &lt;= m;i++) &#123; Data res = query(A[i], B[i]); res = res / Data(C[i]) * Data((mod + 1 - C[i]) % mod); ans = (ans + res.get()) % mod; &#125; printf("%d\n", ans);&#125; T2 Z的礼物 首先将所有的$a$前缀和 那么根据题意，我们可以推出这样的式子$$b_n=\sum_{i=1}^n\begin{Bmatrix}n\\ i\end{Bmatrix}a_i$$现在已知$b$，求$a$，那么我们可以斯特林反演一下$$a_n=\sum_{i=1}^n(-1)^{n-i}\begin{bmatrix}n\\ i\end{bmatrix}b_i$$对于第一类斯特林数，它的生成函数是$$\sum_{i=0}^n\begin{bmatrix}n\\ i\end{bmatrix}x^i=\prod_{i=0}^{n-1}(x+i)$$联系它的递推式$\begin{bmatrix}n\\ i\end{bmatrix}=\begin{bmatrix}n - 1\\ i - 1\end{bmatrix}+(n-1)\begin{bmatrix}n - 1\\ i\end{bmatrix}​$可以得到 对于$\prod\limits_{i=1}^{n-1}(x+i)$，可以使用倍增FFT 计算出$l-1$的那一行斯特林数，然后暴力推下去即可 时间复杂度$T(n)=2T(\frac n2)+n\log n=n\log^2n$ 没有代码 T3 Mas和Z玩游戏 这题我是真不会 还是先贴一下题解，之后再补吧 就这样吧 总结这次比赛一般，第一题没有写炸，但是第二题该拿的45分只拿了5分，是一个细节错误 本来第二题还是有希望想出正解的，但是我在想到那个生成函数之后以为计算它是$n^2$的，就没写 还是需要深入思考]]></content>
      <tags>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>多项式</tag>
        <tag>分治</tag>
        <tag>FFT</tag>
        <tag>树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BJOI2018 治疗之雨]]></title>
    <url>%2F2019%2F03%2F11%2FBJOI2018-%E6%B2%BB%E7%96%97%E4%B9%8B%E9%9B%A8%2F</url>
    <content type="text"><![CDATA[题目链接 表示并不会$n^2$高斯消元做法 如果用dp[i]表示当前为i，到0还需要进行操作数的期望值，那么显然有转移$$dp_0 = 0\\\dp_1 = G_{1,0}dp_0 + G_{1,1}dp_1 + G_{1,2}dp_2 + 1\\\\cdots\\\dp_{n-1} = G_{n-1,0}dp_0 + G_{n-1,1}dp_1 + \cdots + G_{n-1,n}dp_n + 1\\\dp_n = G_{n,0}dp_0 + G_{n,1}dp_1 + \cdots + G_{n,n}dp_n + 1$$其中，G表示系数矩阵，G[i][j]表示进行一次操作后，i变成j的概率 首先预处理f[i]表示一次操作中，对第一个数减i的概率 那么有 $$f[i]=\frac{C_i^km^{k-i}}{(m+1)^k}$$ 这个式子的意思是，一共有k次-1的操作，其中选i次对第一个数-1，剩下的k-i次对剩余的m个数减，方案总数为$(m+1)^k$ 然后求G就很方便了 这个dp转移的时候与后面的项有关系，所以使用高斯消元 等等，$n=1500$高斯消元？ 观察到这个矩阵比较特殊，根据玄学方法可以将高斯消元优化成$n^2$，但是我不会 所以说一下另一个奇妙的方法 注意到dp[i]转移的时候与dp[i+1]有关系，所以把上面的转移方程移项，把右边的dp[i+1]移到左边来 此时就可以按照普通的dp进行转移了 但是有一个问题，就是无法求出dp[1] 那么我们可以设dp[1]=x 注意此时表示dp[n]的有两个方程，那么我们求出dp[n]的这两种表示，求一次一元一次方程就可以得到x了 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1510#define LL long longint G[N][N], f[N]; const int mod = 1e9 + 7;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;struct Data &#123; int x, y; Data(int _x = 0, int _y = 0) : x(_x), y(_y) &#123;&#125; Data operator + (Data b) &#123;return Data(((LL)mod + x + b.x) % mod, ((LL)mod + y + b.y) % mod);&#125; Data operator - (Data b) &#123;return *this + Data(-b.x, -b.y);&#125; Data operator * (int b) &#123;return Data((LL)x * b % mod, (LL)y * b % mod);&#125; Data operator / (int b) &#123;return *this * Pow(b, mod - 2);&#125;&#125; dp[N];int main() &#123; int T; scanf("%d", &amp;T), dp[1] = Data(1, 0); while (T--) &#123; int n, p, m, k; scanf("%d%d%d%d", &amp;n, &amp;p, &amp;m, &amp;k); if (p == 0) &#123;printf("0\n"); continue;&#125; if (m == 0) &#123; if (k &lt;= 1) &#123;printf("-1\n"); continue;&#125; if (p == n) printf("%d\n", max(1, (p - 2) / (k - 1) + 1)); else printf("%d\n", max(1, (p + k - 2) / (k - 1))); continue; &#125; for (int i = 0;i &lt;= n;i++) f[i] = 0; for (int i = 0, res = 1;i &lt;= min(k, n);i++, res = (LL)res * Pow(i, mod - 2) % mod * (k - i + 1) % mod) f[i] = (LL)res * Pow(m, k - i) % mod * Pow(Pow(m + 1, k), mod - 2) % mod; int tmp = Pow(m + 1, mod - 2); for (int i = 1;i &lt;= n;i++) &#123; for (register int j = 1;j &lt;= min(i + 1, n);++j) &#123; if (i == n) G[i][j] = f[i - j]; else if (j != i + 1) G[i][j] = ((LL)f[i - j] * (mod + 1 - tmp) + (LL)f[i + 1 - j] * tmp) % mod; else G[i][j] = (LL)f[i + 1 - j] * tmp % mod; &#125; &#125; bool flag = true; for (int i = 2;i &lt;= n &amp;&amp; flag;i++) &#123; dp[i] = Data(0, 1); for (int j = 1;j &lt; i;j++) dp[i] = dp[i] + dp[j] * G[i - 1][j]; dp[i] = (dp[i] - dp[i - 1]) / (mod - G[i - 1][i]); if (!G[i - 1][i]) flag = false; &#125; Data other(0, 1); for (int i = 1;i &lt; n &amp;&amp; flag;i++) other = other + dp[i] * G[n][i]; other = other / ((1 - G[n][n] + mod) % mod); if (G[n][n] == 1 || dp[n].x == other.x) flag = false; int X = (LL)(other.y - dp[n].y + mod) % mod * Pow((dp[n].x - other.x + mod) % mod, mod - 2) % mod; if (!flag) printf("-1\n"); else printf("%d\n", ((LL)dp[p].x * X + dp[p].y) % mod); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>期望</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BJOI2017 喷式水战改]]></title>
    <url>%2F2019%2F03%2F11%2FBJOI2017-%E5%96%B7%E5%BC%8F%E6%B0%B4%E6%88%98%E6%94%B9%2F</url>
    <content type="text"><![CDATA[题目链接 平衡树维护dp 对于平衡树上的一个点，维护f[i][j]表示它的子树所表示的这段区间内，从状态i开始，以状态j结束，能获得的最大收益 显然有一个结论，对于一段连续的、并且a、b、c值都相等的燃料，一定有一种最优的方案使得这一段燃料的状态都相同 所以对把每一次插入的区间压缩成一个点，同时分裂插入位置所在的节点 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;#define N 200010#define LL long longint fa[N], ch[2][N], ncnt, cnt[N];LL F[4][4][N], G[4][4][N], size[N];inline void calc(int u) &#123; for (int len = 2;len &lt;= 4;len++) for (int start = 0, end;start + len - 1 &lt;= 3;start++) end = start + len - 1, F[start][end][u] = G[start][end][u] = max(F[start][end - 1][u], F[start + 1][end][u]);&#125;inline int create(LL val[], int f, int tot) &#123; int u = ++ncnt; fa[u] = f, cnt[u] = size[u] = tot; for (int i = 0;i &lt;= 3;i++) F[i][i][u] = val[i % 3]; return calc(u), ncnt;&#125;inline void pushup(int u) &#123; size[u] = size[ch[0][u]] + cnt[u] + size[ch[1][u]]; for (int start = 0; start &lt;= 3; start++) for (int end = start; end &lt;= 3;end++) &#123; G[start][end][u] = 0; for (int i = start;i &lt;= end;i++) for (int j = i;j &lt;= end;j++) G[start][end][u] = max(G[start][end][u], G[start][i][ch[0][u]] + F[i][j][u] + G[j][end][ch[1][u]]); &#125;&#125;inline void connect(int u, int f, int son) &#123;fa[u] = f, ch[son][f] = u;&#125;inline bool child(int u) &#123;return u == ch[1][fa[u]];&#125;inline void rotate(int u) &#123; int f = fa[u], ff = fa[f], tmp = child(u), tmp1 = child(f); connect(ch[tmp ^ 1][u], f, tmp), connect(f, u, tmp ^ 1), connect(u, ff, tmp1); pushup(f), pushup(u);&#125;inline void splay(int u) &#123;for (int f;fa[u];rotate(u)) if (fa[f = fa[u]]) rotate(child(u) ^ child(f) ? u : f);&#125;inline int Kth(int u, LL k) &#123; if (size[ch[0][u]] &lt; k &amp;&amp; size[u] - size[ch[1][u]] &gt;= k) return splay(u), u; return k &lt;= size[ch[0][u]] ? Kth(ch[0][u], k) : Kth(ch[1][u], k - size[u] + size[ch[1][u]]);&#125;LL input[3], tmp[3], del1[3], del2[3], del3[3];int main() &#123; ch[0][0] = create(input, 0, 1); int q; LL ls = 0; scanf("%d", &amp;q); while (q--) &#123; LL p; int tot, now; scanf("%lld%lld%lld%lld%d", &amp;p, &amp;input[0], &amp;input[1], &amp;input[2], &amp;tot), p++, now = Kth(ch[0][0], p); for (int i = 0;i &lt; 3;i++) tmp[i] = F[i][i][now] / cnt[now]; LL slice = p - size[ch[0][now]];// size: 1 -&gt; slice - 1, slice -&gt; size for (int i = 0;i &lt; 3;i++) del1[i] = tmp[i] * (slice - 1), del2[i] = input[i] * tot, del3[i] = tmp[i] * (cnt[now] - slice + 1); int a = create(del2, now, tot), b = create(del3, a, cnt[now] - slice + 1); ch[1][a] = b; cnt[now] = slice - 1, connect(ch[1][now], b, 1), ch[1][now] = a; for (int i = 0;i &lt;= 3;i++) F[i][i][now] = del1[i % 3]; calc(now), pushup(b), pushup(a), pushup(now); LL ans = 0; for (int i = 0;i &lt;= 3;i++) for (int j = i;j &lt;= 3;j++) ans = max(ans, G[i][j][now]); printf("%lld\n", ans - ls), ls = ans; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BJOI2017 树的难题]]></title>
    <url>%2F2019%2F03%2F11%2FBJOI2017-%E6%A0%91%E7%9A%84%E9%9A%BE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目链接 边数在l到r之间。。。那么这题就是点分治跑不掉了 由于是统计的每一段颜色的权值之和，所以对于一条到分治中心的路径，我们需要保存路径长度、权值之和、顶端的颜色这三个值 如果直接合并的话，时间复杂度最坏是$n^2$，呵呵 所以我们考虑合并时的两种情况，分别进行优化 1.两条路径的顶端颜色不同由于顶端颜色不同，那么这两条路径一定来自于两棵不同的子树 如果我们按照路径的顶端颜色排序，那么对于路径i，它所应当匹配的另一条路径是排在i之前、顶端颜色与i不同、路径长度在一个区间之内的权值之和最大的路径 也就是说，我们需要实现一个东西，可以支持单点修改、区间查最大值 上线段树 2.两条路径的顶端颜色相同那么这时有两种情况：来自同一棵子树；来自不同子树 第一种情况显然是我们不希望统计到的，所以我们对于每一条路径多维护一个值，表示分治中心到这条链的顶端的那条边的编号 编号相同，则表示来自同一棵子树 模仿之前的方法，如果两条路径的顶端颜色一样，则对那条边的编号进行排序，这样就可以保证编号相同的路径排在一起。 然后再开一颗线段树维护区间最大值即可 注意，这是一棵需要实现$O(1)$清空的线段树 方法很简单，直接打个标记即可 时间复杂度$n\log^2 n$，然而貌似比很多$n\log n$的还要快 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;#define N 200010const int INF = 2e9;struct Tree &#123; struct node &#123;int mx, tag;&#125; T[N &lt;&lt; 2]; inline void Clear() &#123;T[1].mx = -INF, T[1].tag = 1;&#125; inline void pushdown(int rt) &#123;T[rt &lt;&lt; 1].mx = T[rt &lt;&lt; 1 | 1].mx = -INF, T[rt &lt;&lt; 1].tag = T[rt &lt;&lt; 1 | 1].tag = 1, T[rt].tag = 0;&#125; void update(int rt, int l, int r, int at, int x) &#123; if (l == r) &#123;T[rt].mx = max(T[rt].mx, x); return;&#125; int mid = (l + r) &gt;&gt; 1; T[rt].mx = max(T[rt].mx, x); if (T[rt].tag) pushdown(rt); if (at &lt;= mid) update(rt &lt;&lt; 1, l, mid, at, x); else update(rt &lt;&lt; 1 | 1, mid + 1, r, at, x); &#125; int query(int rt, int l, int r, int start, int end) &#123; if (end &lt; l || start &gt; r) return -INF; if (start &lt;= l &amp;&amp; r &lt;= end) return T[rt].mx; if (T[rt].tag) return -INF; int mid = (l + r) &gt;&gt; 1, ans = -INF; if (start &lt;= mid) ans = max(ans, query(rt &lt;&lt; 1, l, mid, start, end)); if (end &gt; mid) ans = max(ans, query(rt &lt;&lt; 1 | 1, mid + 1, r, start, end)); return ans; &#125;&#125; A, B;struct edge &#123;int to, next, c;&#125; e[N * 2];int head[N], ecnt;inline void adde(int from, int to, int c) &#123; e[++ecnt] = (edge)&#123;to, head[from], c&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to], c&#125;, head[to] = ecnt;&#125;int size[N], vis[N], val[N];int Getsize(int u) &#123; size[u] = vis[u] = 1; for (int i = head[u];i;i = e[i].next) if (!vis[e[i].to]) size[u] += Getsize(e[i].to); return vis[u] = 0, size[u];&#125;int Getroot(int u, int tot) &#123; vis[u] = 1; for (int i = head[u], tmp;i;i = e[i].next) if (!vis[e[i].to] &amp;&amp; (tmp = Getroot(e[i].to, tot))) return vis[u] = 0, tmp; return vis[u] = 0, size[u] &gt;= (tot &gt;&gt; 1) ? u : 0;&#125;struct Data &#123;int from, dis, len;&#125; q[N];int qcnt = 0, mx, L, R, ans = -INF;void DFS(int u, int from, int ls, int dis, int len) &#123; q[++qcnt] = (Data)&#123;from, dis, len&#125;, vis[u] = 1, mx = max(mx, len); if (L &lt;= len &amp;&amp; len &lt;= R) ans = max(ans, dis); for (int i = head[u];i;i = e[i].next) if (!vis[e[i].to]) DFS(e[i].to, from, e[i].c, ls == e[i].c ? dis : dis + val[e[i].c], len + 1); vis[u] = 0;&#125;void Build(int u) &#123; u = Getroot(u, Getsize(u)), vis[u] = 1, qcnt = mx = 0; for (int i = head[u];i;i = e[i].next) if (!vis[e[i].to]) DFS(e[i].to, i, e[i].c, val[e[i].c], 1); sort(q + 1, q + qcnt + 1, [=](Data a, Data b) &#123;return e[a.from].c &lt; e[b.from].c || (e[a.from].c == e[b.from].c &amp;&amp; a.from &lt; b.from);&#125;), A.Clear(), B.Clear(); int cur1 = 0, cur2 = 0; for (int i = 1;i &lt;= qcnt;i++) &#123; if (e[q[i].from].c != e[q[i - 1].from].c) B.Clear(), cur2 = i - 1; while (q[cur2 + 1].from != q[i].from) cur2++, B.update(1, 1, mx, q[cur2].len, q[cur2].dis); while (e[q[cur1 + 1].from].c != e[q[i].from].c) cur1++, A.update(1, 1, mx, q[cur1].len, q[cur1].dis); ans = max(ans, A.query(1, 1, mx, L - q[i].len, R - q[i].len) + q[i].dis); ans = max(ans, B.query(1, 1, mx, L - q[i].len, R - q[i].len) + q[i].dis - val[e[q[i].from].c]); &#125; for (int i = head[u];i;i = e[i].next) if (!vis[e[i].to]) Build(e[i].to);&#125;int main() &#123; int n, m; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;L, &amp;R); for (int i = 1;i &lt;= m;i++) scanf("%d", &amp;val[i]); for (int i = 1, a, b, c;i &lt; n;i++) scanf("%d%d%d", &amp;a, &amp;b, &amp;c), adde(a, b, c); Build(1), printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>点分治</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BJOI2017 魔法咒语]]></title>
    <url>%2F2019%2F03%2F11%2FBJOI2017-%E9%AD%94%E6%B3%95%E5%92%92%E8%AF%AD%2F</url>
    <content type="text"><![CDATA[题目链接 感觉这题没啥好说的。。。就是对数据的分类讨论差评 首先对于所有的危险串建AC自动机，标记危险节点，转移的时候不从危险节点转移 然后预处理to[i][j]，即从自动机的i号节点出发，按照第j个基本串走，最后到达的节点，注意如果中途有危险节点就是-1 对于前60%的数据，直接dp即可，用dp[i][j]表示当前串长度为i，走到自动机的j号节点的方案数 对于后面40%的数据，没法直接dp了。注意到基本串的长度都特别小，直接上矩阵乘法 如果基本串的长度都为1，那么建一个$n*n$的矩阵就好了 否则要同时保存长度为$len-1,len-2$的方案，建一个$(2*n)^2$的矩阵 然后快速幂即可 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;#define N 110int ncnt, trie[N][26], val[N]; const int mod = 1e9 + 7;inline void insert(char s[], int len) &#123; int now = 0; for (int i = 1, c = s[i] - 'a';i &lt;= len;i++, c = s[i] - 'a') if (trie[now][c]) now = trie[now][c]; else now = trie[now][c] = ++ncnt; val[now] = 1;&#125; int fail[N]; queue&lt;int&gt; q; inline void BFS() &#123; for (int i = 0, now;i &lt; 26;i++) if (now = trie[0][i]) q.push(now); while (!q.empty()) &#123; int now = q.front(); q.pop(); for (int i = 0, f, son;i &lt; 26;i++) if (trie[now][i]) &#123; f = fail[now]; while (f &amp;&amp; !trie[f][i]) f = fail[f]; son = trie[now][i], fail[son] = trie[f][i], val[son] |= val[fail[son]], q.push(son); &#125; &#125; &#125;inline int query(int now, char s[], int len) &#123; for (int i = 1, c;i &lt;= len;i++) &#123; c = s[i] - 'a'; while (now &amp;&amp; !trie[now][c]) now = fail[now]; now = trie[now][c]; if (val[now]) return -1; &#125; return now;&#125;char basic[51][N], s[51][N]; int len[N], to[N][N], dp[N][N];#define LL long longstruct Matrix &#123; int a[2 * N][2 * N], n; Matrix(int _n = 0) : n(_n) &#123;memset(a, 0, sizeof(a));&#125; Matrix operator * (Matrix b) &#123; Matrix c(n); for (int i = 0;i &lt;= n;i++) for (int j = 0;j &lt;= n;j++) for (int k = 0;k &lt;= n;k++) c.a[i][j] = (c.a[i][j] + (LL)a[i][k] * b.a[k][j]) % mod; return c; &#125;&#125;;inline Matrix Pow(Matrix x, int y) &#123; Matrix res(x.n); for (int i = 0;i &lt;= res.n;i++) res.a[i][i] = 1; for (;y;y &gt;&gt;= 1, x = x * x) if (y &amp; 1) res = res * x; return res;&#125;inline int solve1(int n, int l) &#123; Matrix res(ncnt); for (int i = 0;i &lt;= ncnt;i++) if (!val[i]) for (int j = 1;j &lt;= n;j++) if (~to[i][j]) res.a[to[i][j]][i]++; res = Pow(res, l); int ans = 0; for (int i = 0;i &lt;= ncnt;i++) ans = (ans + res.a[i][0]) % mod; return ans;&#125;inline int solve2(int n, int l) &#123; Matrix res(2 * ncnt + 1); for (int i = ncnt + 1;i &lt;= 2 * ncnt + 1;i++) res.a[i][i - ncnt - 1] = 1; for (int i = 0;i &lt;= ncnt;i++) if (!val[i]) for (int j = 1;j &lt;= n;j++) if (~to[i][j]) res.a[to[i][j]][i + (len[j] == 1 ? 0 : ncnt + 1)]++; res = Pow(res, l); int ans = 0; for (int i = 0;i &lt;= ncnt;i++) ans = (ans + res.a[i][0]) % mod; return ans;&#125;int main() &#123; int n, m, l, mx = 0; scanf("%d%d%d", &amp;n, &amp;m, &amp;l); for (int i = 1;i &lt;= n;i++) scanf("%s", basic[i] + 1), len[i] = strlen(basic[i] + 1), mx = max(mx, len[i]); for (int i = 1;i &lt;= m;i++) scanf("%s", s[i] + 1), insert(s[i], strlen(s[i] + 1)); BFS(); for (int i = 0;i &lt;= ncnt;i++) for (int j = 1;j &lt;= n;j++) to[i][j] = val[i] ? -1 : query(i, basic[j], len[j]); if (l &lt;= 100) &#123; dp[0][0] = 1; for (int i = 0;i &lt;= l;i++) for (int j = 0;j &lt;= ncnt;j++) if (!val[j] &amp;&amp; dp[i][j]) for (int k = 1;k &lt;= n;k++) if (~to[j][k] &amp;&amp; i + len[k] &lt;= l) (dp[i + len[k]][to[j][k]] += dp[i][j]) %= mod; int ans = 0; for (int i = 0;i &lt;= ncnt;i++) (ans += dp[l][i]) %= mod; printf("%d\n", ans); &#125; else printf("%d\n", mx == 1 ? solve1(n, l) : solve2(n, l)); return 0; &#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>矩阵乘法</tag>
        <tag>AC自动机</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BJOI2017 机动训练]]></title>
    <url>%2F2019%2F03%2F11%2FBJOI2017-%E6%9C%BA%E5%8A%A8%E8%AE%AD%E7%BB%83%2F</url>
    <content type="text"><![CDATA[题目链接 显然一条合法的机动路径就是一直朝某个象限走，可以走坐标轴的路径 对于每一条机动路径，它的权值是经过地形与它相同的机动路径条数 也就是每种机动路径数量的平方和 对于这个平方，我们可以换一种统计方案，即两条机动路径，相同的方案数 分别枚举两条机动路径的朝向 记dp[i][j][p][q]表示在当前枚举的方向上第一条机动路径从$(i,j)$出发，第二条机动路径从$(p,q)$出发，相同的方案数 由于可以走坐标轴，这样会重复统计一些路径 比如当前选定了第一条路径走第二象限，我们会发现统计出来的结果与第一条路径走第一象限有交集 怎么办呢？减去重复的即可，也就是第一条路径只沿y正半轴走的方案数 记f[i][j][p][q]为第一条路径的方向为$(i,j)$，第二条路径的方向为$(p,q)$时的答案 先处理一下第一条路径和第二条路径的合法位移即可 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;#define N 41char G[N][N]; int dx[2][N], dy[2][N], cnt1, cnt2, n, m;int dp[N][N][N][N], f[3][3][3][3]; const int mod = 1e9 + 9;int DP(int x, int y, int p, int q) &#123; if (min(min(x, y), min(p, q)) &lt; 1 || max(x, p) &gt; n || max(y, q) &gt; m) return 0; if (G[x][y] != G[p][q]) return 0; if (~dp[x][y][p][q]) return dp[x][y][p][q]; int &amp;sum = dp[x][y][p][q]; sum = 1; for (int i = 1;i &lt;= cnt1;i++) for (int j = 1;j &lt;= cnt2;j++) (sum += DP(x + dx[0][i], y + dy[0][i], p + dx[1][j], q + dy[1][j])) %= mod; return sum;&#125;inline int AC(int x, int y, int p, int q) &#123; int &amp;sum = f[x + 1][y + 1][p + 1][q + 1]; cnt1 = cnt2 = 0; if (~sum) return sum; else sum = 0; for (int i = -1;i &lt;= 1;i++) if ((!i) || i == x) for (int j = -1;j &lt;= 1;j++) if ((i | j) &amp;&amp; ((!j) || j == y)) dx[0][++cnt1] = i, dy[0][cnt1] = j; for (int i = -1;i &lt;= 1;i++) if ((!i) || i == p) for (int j = -1;j &lt;= 1;j++) if ((i | j) &amp;&amp; ((!j) || j == q)) dx[1][++cnt2] = i, dy[1][cnt2] = j; memset(dp, -1, sizeof(dp)); for (int i = 1;i &lt;= n;i++) for (int j = 1;j &lt;= m;j++) for (int k= 1;k &lt;= n;k++) for (int l = 1;l &lt;= m;l++) (sum += DP(i, j, k, l)) %= mod; f[p + 1][q + 1][x + 1][y + 1] = f[-p + 1][-q + 1][-x + 1][-y + 1] = f[-x + 1][-y + 1][-p + 1][-q + 1] = sum; return sum;&#125;#define LL long longinline int AC(int x, int y) &#123; int sum = 0; sum = (sum + (LL)AC(x, y, 1, 1) + AC(x, y, 1, -1) + AC(x, y, -1, 1) + AC(x, y, -1, -1)) % mod; sum = (sum - (LL)AC(x, y, 1, 0) - AC(x, y, -1, 0) - AC(x, y, 0, 1) - AC(x, y, 0, -1)) % mod; return (sum + mod) % mod;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m), memset(f, -1, sizeof(f)); for (int i = 1;i &lt;= n;i++) scanf("%s", G[i] + 1); int ans = 0; ans = (ans + (LL)AC(1, -1) + AC(1, 1) + AC(-1, -1) + AC(-1, 1)) % mod; ans = (ans - (LL)AC(1, 0) - AC(-1 ,0) - AC(0, 1) - AC(0, -1)) % mod; printf("%d\n", (ans + mod) % mod); return 0;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BJOI2017 开车]]></title>
    <url>%2F2019%2F03%2F11%2FBJOI2017-%E5%BC%80%E8%BD%A6%2F</url>
    <content type="text"><![CDATA[题目链接 显然，最优的方案一定是将所有的加油站和车按照位置排序之后一一对应 但是如何考虑修改呢？这种东西是没法维护的 我们考虑另外一种统计答案的方式 将加油站和车都想象成数轴上的一些点，其中加油站是红点，车是黑点 单独考虑数轴上每一条线段的贡献 对于一条线段i，记这条线段的长度为$len_i$，前面一共有$a_i$个红点，$b_i$个黑点，那么这条线段对答案的贡献为 $$len_i|a_i-b_i|$$ 由于询问中涉及到更改点的位置这个操作，我们可以将询问离线下来，先把所有在询问中即将出现的点都标记出来就可以了 现在考虑每个询问都干了啥 将一辆车从A点挪到B点（A&lt;B），那么，对于区间$[A,B-1]$，$b_i$的值都减少了1 反之，如果A&gt;B，那么对于区间$[B,A-1]$，$b_i$的值将增加1 所以，我们要实现一个这样的东西：每个点有初始权值$w_i,a_i$，操作是区间将$a_i$的值加减1，维护$\sum w_i|a_i|$ 这个绝对值的符号非常讨厌，不过幸好每次操作只会增减1 考虑对一段区间$[A,B]$进行修改，我们需要首先将这段区间的$a_i$排好序，然后二分找到零点，具体来说 如果排好序之后的a是这样的，此时需要将这一串a全部加上1，那么A点右方的点的绝对值都增大1，左边的点的绝对值都减小1 此时，答案增加 $$\sum_i^{[A,D]} w_i-\sum_i^{[B,A)} w_i$$ 如果要减少1，那么C点左方的点的绝对值都增大1，右边的点的绝对值都减少1 此时，答案增加 $$\sum_i^{[B,C]}w_i-\sum_i^{(C,D]}w_i$$ 为了快速更新答案，我们需要预处理w在这一段中的前缀和，同时二分找到零点 线段树显然不行，所以考虑分块 对于每一块维护w在这一块中的前缀和，以及排好序后的a数组 对于修改，边角上的两个块暴力重构，中间完整的块用一个tag数组存一下有多少修改是没有下发到每个元素上的，重构时下放。然后二分找到零点，更新答案 代码还是挺好写的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;const int SZ = 400, N = 50010, M = 150010;#define LL long longstruct Data &#123;int sum;LL dis;&#125; t[M];int sum[M], dis[M], tag[N]; LL ans;bool cmp(Data a, Data b) &#123;return a.sum &lt; b.sum;&#125;inline void rebuild(int x) &#123; for (int i = x;i &lt; x + SZ;i++) t[i].sum = sum[i], t[i].dis = dis[i]; sort(t + x, t + x + SZ, cmp); for (int i = x + 1;i &lt; x + SZ;i++) t[i].dis += t[i - 1].dis;&#125; inline void update(int l, int r, int x) &#123; int bl = (l - 1) / SZ, br = (r - 1) / SZ; for (int i = bl * SZ + 1;i &lt;= (bl + 1) * SZ;i++) sum[i] += tag[bl]; tag[bl] = 0; if (bl == br) &#123; for (int i = l;i &lt;= r;i++) ans -= abs(sum[i]) * dis[i], ans += abs(sum[i] += x) * dis[i]; rebuild(bl * SZ + 1); &#125; else &#123; for (int i = br * SZ + 1;i &lt;= (br + 1) * SZ;i++) sum[i] += tag[br]; tag[br] = 0; for (int i = l;i &lt;= (bl + 1) * SZ;i++) ans -= abs(sum[i]) * dis[i], ans += abs(sum[i] += x) * dis[i]; for (int i = br * SZ + 1;i &lt;= r;i++) ans -= abs(sum[i]) * dis[i], ans += abs(sum[i] += x) * dis[i]; rebuild(bl * SZ + 1), rebuild(br * SZ + 1); &#125; for (int i = bl + 1;i &lt; br;i++) &#123; int L = i * SZ + 1, R = (i + 1) * SZ, mid, res = 0; tag[i] += x; if (x &lt; 0) &#123; while (L &lt;= R) if (t[mid = (L + R) &gt;&gt; 1].sum + tag[i] &lt; 0) res = mid, L = mid + 1; else R = mid - 1; ans -= t[(i + 1) * SZ].dis - 2 * t[res].dis; &#125; else &#123; while (L &lt;= R) if (t[mid = (L + R) &gt;&gt; 1].sum + tag[i] &lt;= 0) res = mid, L = mid + 1; else R = mid - 1; ans += t[(i + 1) * SZ].dis - 2 * t[res].dis; &#125; &#125;&#125;int a[N], b[N], ncnt, id[M], to[M];int main() &#123;// freopen("in.txt", "r", stdin); int n; scanf("%d", &amp;n); for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;a[i]), dis[++ncnt] = a[i]; for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;b[i]), dis[++ncnt] = b[i]; int q; scanf("%d", &amp;q); for (int i = 1;i &lt;= q;i++) scanf("%d%d", &amp;id[i], &amp;to[i]), dis[++ncnt] = to[i]; sort(dis + 1, dis + ncnt + 1), ncnt = unique(dis + 1, dis + ncnt + 1) - dis - 1; for (int i = 1;i &lt;= n;i++) sum[a[i] = lower_bound(dis + 1, dis + ncnt + 1, a[i]) - dis]++; for (int i = 1;i &lt;= n;i++) sum[b[i] = lower_bound(dis + 1, dis + ncnt + 1, b[i]) - dis]--; for (int i = 1;i &lt;= q;i++) to[i] = lower_bound(dis + 1, dis + ncnt + 1, to[i]) - dis; for (int i = 1;i &lt;= ncnt;i++) ans += abs(sum[i] += sum[i - 1]) * (dis[i] = dis[i + 1] - dis[i]); printf("%lld\n", ans); for (int i = 1;i &lt;= ncnt;i += SZ) rebuild(i); for (int i = 1;i &lt;= q;i++) &#123;// cout &lt;&lt; a[id[i]] &lt;&lt; ' ' &lt;&lt; to[i] &lt;&lt; endl; if (a[id[i]] &lt; to[i]) update(a[id[i]], to[i] - 1, -1); else if (a[id[i]] != to[i]) update(to[i], a[id[i]] - 1, 1); a[id[i]] = to[i], printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFT与NTT基础]]></title>
    <url>%2F2019%2F03%2F11%2FFFT%E4%B8%8ENTT%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[理论部分复数设$a, b$是实数，形如$a+bi$的数叫做复数，其中$i$叫做虚数单位 我们可以用一个复平面上的向量表示一个复数。x轴代表实数，y轴代表虚数。比如：向量$(a,b)$就表示复数$a+bi$ 模长：就是这个向量的长度 辐角：从x正半轴逆时针旋转到这个向量的角度 复数乘法的几何意义是，模长相乘，辐角相加 代数意义：$$(a+bi)*(c+di)$$ $$=ac+adi+cbi+bdi^2$$ $$= (ac-bd)+(ad+cb)i$$ 单位根在复平面上，以原点为圆心，半径为1画圆，得到的圆叫做单位圆 将这个圆做n等分，那么我们得到了n个向量，每个向量都对应了一个n次单位根 我们分别记这些单位根为$\omega_n^1,\omega_n^2,\cdots,\omega_n^n$ 其中，记$\omega_n^1$为主n次单位根 性质$$\omega_n^k=\cos k\frac{2\pi}{n}+i\sin k\frac{2\pi}{n}$$ 根据单位根的定义，显然有 消去定理 $$\omega_{dn}^{dk}=\omega_n^k$$ 折半定理 对于任意的大于0的整数n，都有n个n次单位复根的平方的集合，等于$\frac{n}{2}$个$\frac{n}{2}$次单位复根的集合 此时显然有 $$(\omega_n^k)^2=\omega_{n/2}^k$$ $$(\omega_n^{k+\frac{n}{2}})^2=\omega_{n}^{2k+n}=\omega_n^{2k}\times\omega_n^n=\omega_n^{2k}=(\omega_n^k)^2$$ 快速傅里叶变换(FFT)FFT的作用是，快速计算出两个多项式相乘的结果 按照朴素的算法，假如有两个次数为n的多项式，那么我们会遍历其中一个多项式的每一项，计算它与另一个多项式的乘积 然而这样的时间复杂度是$n^2$的，也没有什么可以显著优化的地方 点值表示我们知道，一个多项式$f(x)$可以写成$a_0x^0+a_1x^1+\cdots+a_nx^n$的形式，这被称作系数表示 而一个n次的多项式可以被n个点唯一确定 那么我们可以将主单位根的0到n-1次幂依次带入这个多项式求值，然后通过插值再把点值表达还原成系数表示 直接做显然还是$n^2$，而且还多了一堆巨大无比的常数 但是我们可以优化 设 $$A(x)=a_0+a_1x+a_2x^2+\cdots+a_nx^n$$ 将这个多项式按照x的幂的奇偶性分类 $$A_1(x)=a_0+a_2x^2+\cdots+a_{n-1}x^{n-1}$$ $$A_2(x)=a_1x+a_3x^3+\cdots+a_{n}x^{n}$$ 我们可以得到 $$A(x)=A_1(x)+A_2(x)$$ 设 $$A^{[1]}(x)=a_0+a_2x+\cdots+a_{n-1}x^{\frac{n}{2}}$$ $$A^{[2]}(x)=a_1+a_3x+\cdots+a_{n}x^{\frac{n}{2}}$$ 那么我们有 $$A(x)=A^{[1]}(x^2)+xA^{[2]}(x^2)$$ 代入单位复根$\omega_n^k(k&lt;\frac{n}{2})$，得 $$A(\omega_n^k)=A^{[1]}(\omega_{n/2}^k)+\omega_n^kA^{[2]}(\omega_{n/2}^k)$$ 代入另一个单位复根$\omega_n^{k+\frac{n}{2}}$，得 $$A(\omega_n^{k+\frac{n}{2}})=A^{[1]}(\omega_{n/2}^{k+\frac{n}{2}})-\omega_n^{k}A^{[2]}(\omega_{n/2}^{k+\frac{n}{2}})$$ $$=A^{[1]}(\omega_n^{k})-\omega_n^{k}A^{[2]}(\omega_n^{k})$$ 我们发现，这两个结果只有一个符合是不同的 这就意味着，在计算第一个点值的时候，我们可以$O(1)$得到第二个点值 加上分治，可以将原问题的规模缩小一半 现在，我们可以做到$O(n\log n)$计算点值表示了 快速傅里叶逆变换(IFFT)假如我们知道多项式A与多项式B的点值表达 那么我们可以直接求出$A*B$的点值表达 很明显，对应相乘即可 但是我们得到的终究还是一个点值 而点值表达是不常用的，要还原成系数表达 幸运的是，这个操纵同样能在$O(n\log n)$内解决。 假设原来的多项式系数分别为$a_0,a_1,\cdots,a_n$ 点值表达为$y_0,y_1,\cdots,y_n$ 将这个y强制看作系数 同时，设多项式c为y在$\omega_n^0,\omega_n^{-1},\cdots,\omega_n^{-n+1}$处的点值 那么有 $$c_k=\sum_{i=0}^{n-1}y_i(\omega_n^{-k})^i$$ $$y_k=\sum_{i=0}^{n-1}a_i(\omega_n^k)^i$$ $$\therefore c_k=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}a_j(\omega_n^i)^j(\omega_n^{-k})^i$$ $$=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}a_j(\omega_n^j)^i(\omega_n^{-k})^i$$ $$\sum_{i=0}^{n-1}a_j\sum_{j=0}^{n-1}(\omega_n^{j-k})^i$$ 设 $$S(x)=\sum_{i=0}^{n-1}x^i$$ 代入$\omega_n^k$可得 $$S(\omega_n^k)=1+\omega_n^k+(\omega_n^k)^2+\cdots+(\omega_n^k)^{n-1}$$ 当$k\not =0$，可得 $$\omega_n^kS(\omega_n^k)=\omega_n^k+(\omega_n^k)^2+\cdots+(\omega_n^k)^{n-1}+(\omega_n^k)^n$$ 两式相减，得 $$\omega_n^kS(\omega_n^k)-S(\omega_n^k)=(\omega_n^k)^n-1$$ $$S(\omega_n^k)=\frac{(\omega_n^k)^n-1}{\omega_n^k-1}$$ $$=\frac{(\omega_n^n)^k-1}{\omega_n^k-1}=0$$ 当$k=0$时，显然$S(\omega_n^0)=1$ 代入之前的式子，可以得到 $$c_k=\sum_{i=0}^{n-1}a_j\sum_{j=0}^{n-1}(\omega_n^{j-k})^i$$ $$=na_k$$ $$a_k=\frac{c_k}{n}$$ 至此，点值就成功转换成系数了 关于迭代FFT这里记一下反转后的多项式在原多项式中的下标r 有 1r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1) 关于NTT模意义下的单位根就是原根g 有 $$\omega_n^1\equiv g^{\frac{mod-1}{n}}$$ 然后像FFT一样即可 关于complex好像还是很好用的 就是有点慢 需要的话可以手写一个 目测会快2到3倍的样子 部分代码实现FFT12345678910111213#define N 400010int r[N]; const double PI = acos(-1);inline void FFT(int len, int type, complex&lt;double&gt; a[]) &#123; for (int i = 0;i &lt; len;i++) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int mid = 2;mid &lt;= len;mid &lt;&lt;= 1) &#123; complex&lt;double&gt; Wn(cos(2 * PI / mid), type * sin(2 * PI / mid)); for (int i = 0;i &lt; len;i += mid) &#123; complex&lt;double&gt; w(1, 0), t; for (int j = i;j &lt; i + (mid &gt;&gt; 1);j++, w *= Wn) t = w * a[j + (mid &gt;&gt; 1)], a[j + (mid &gt;&gt; 1)] = a[j] - t, a[j] += t; &#125; &#125;&#125; NTT1234567891011121314151617#define N 200010#define LL long longint r[N]; const int mod = 998244353;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;inline void NTT(int len, int type, int a[]) &#123; for (int i = 0;i &lt; len;i++) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int mid = 2;mid &lt;= len;mid &lt;&lt;= 1) &#123; int Wn = Pow(3, type ? (mod - 1) / mid : mod - 1 - (mod - 1) / mid); for (int i = 0;i &lt; len;i += mid) for (int j = i, t, w = 1;j &lt; i + (mid &gt;&gt; 1);j++, w = (LL)w * Wn % mod) t = (LL)w * a[j + (mid &gt;&gt; 1)] % mod, a[j + (mid &gt;&gt; 1)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod; &#125;&#125; 最后别忘了除以len]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>算法</tag>
        <tag>FFT</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.11省选模拟]]></title>
    <url>%2F2019%2F03%2F11%2F3-11%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 树上四次求和 本来写的100分算法，结果只有80分 发现是链的情况挂了，原因是有一个取模的地方我把%=写成了%，然后就呵呵了 考虑如何化简那个式子$$\sum_{i=1}^k\sum_{j=i}^kw(i,j)\\\=\sum_{i=1}^k\sum_{j=i}^k\sum_{l=i}^j\sum_{r=l}^jdis(a_l,a_r)\\\$$考虑后面每一个$dis(a_l,a_r)$对答案的贡献，就是把$\sum$提到前面来$$=\sum_{l=1}^k\sum_{r=l}^kdis(a_l,a_r)*l*(k-r+1)$$但是这样仍然是$n^kq$，难以承受 那么我们考虑分开维护$$\sum_{i=1}^n\sum_{j=i}^ndis(a_i,a_j)*i*(n-j+1)\\\=(n+1)\sum_{i=1}^ni\sum_{j=i}^ndis(a_i,a_j)-\sum_{i=1}^ni\sum_{j=i}^nj*dis(a_i,a_j)$$考虑将询问离线，当$n$变成$n+1$时式子将会如何变化 注意到第一项的系数$n+1​$与$n​$有关，所以把它去掉，考虑维护$\sum\limits_{i=1}^ni\sum\limits_{j=i}^ndis(a_i,a_j)​$ 那么有$$\sum\limits_{i=1}^{n+1}i\sum\limits_{j=i}^{n+1}dis(a_i,a_j)-\sum\limits_{i=1}^ni\sum\limits_{j=i}^ndis(a_i,a_j)\\=\sum_{i=1}^ni*dis(a_i,a_{n+1})$$而对于后一项$$\sum_{i=1}^{n+1}i\sum_{j=i}^{n+1}j*dis(a_i,a_j)-\sum_{i=1}^ni\sum_{j=i}^nj*dis(a_i,a_j)\\\=(n+1)\sum_{i=1}^ni*dis(a_i,a_{n+1})$$$n+1$是已知的，所以我们只需要维护$\sum\limits_{i=1}^ni*dis(a_i,a_{n+1})$就可以了 所以现在题目变成了给你一棵树，每个点有两种颜色，初始每个点都是黑色，有两种操作： 询问某个点到所有黑点的距离乘以该点编号的和 将某个白点改成黑点 那么很显然，直接动态点分治就可以了 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010typedef long long LL;const int mod = 998244353;struct edge &#123; int to, next;&#125; e[N * 2];int head[N], ecnt;inline void adde(int from, int to) &#123; e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;&#125;int fa[18][N], dep[N];void dfs(int u, int f) &#123; dep[u] = dep[f] + 1, fa[0][u] = f; for (int i = 1;i &lt;= 17;i++) fa[i][u] = fa[i - 1][fa[i - 1][u]]; for (int i = head[u];i;i = e[i].next) if (e[i].to != f) dfs(e[i].to, u);&#125;inline int LCA(int a, int b) &#123; if (dep[a] &lt; dep[b]) swap(a, b); for (int i = 17;i &gt;= 0;i--) if (dep[fa[i][a]] &gt;= dep[b]) a = fa[i][a]; for (int i = 17;i &gt;= 0;i--) if (fa[i][a] != fa[i][b]) a = fa[i][a], b = fa[i][b]; return a == b ? a : fa[0][a];&#125;;inline int Dis(int a, int b) &#123; return dep[a] + dep[b] - 2 * dep[LCA(a, b)];&#125;int vis[N], size[N];int Getsize(int u) &#123; vis[u] = size[u] = 1; for (int i = head[u];i;i = e[i].next) if (!vis[e[i].to]) size[u] += Getsize(e[i].to); return vis[u] = 0, size[u];&#125;int Getroot(int u, int tot) &#123; vis[u] = 1; for (int i = head[u],tmp;i;i = e[i].next) if (!vis[e[i].to] &amp;&amp; (tmp = Getroot(e[i].to, tot))) return vis[u] = 0, tmp; return vis[u] = 0, size[u] &gt;= (tot &gt;&gt; 1) ? u : 0;&#125;int F[18][N], D[18][N];int Build(int u) &#123; u = Getroot(u, Getsize(u)), vis[u] = 1; for (int i = head[u];i;i = e[i].next) if (!vis[e[i].to]) F[0][Build(e[i].to)] = u; return u;&#125;inline void Construct(int n) &#123; for (int i = 1;i &lt;= n;i++) if (F[0][i]) D[0][i] = Dis(F[0][i], i); for (int i = 1;i &lt;= 17;i++) for (int j = 1;j &lt;= n;j++) &#123; F[i][j] = F[i - 1][F[0][j]]; if (F[i][j]) D[i][j] = Dis(F[i][j], j); &#125;&#125;int cnt2[N], tot2[N], cnt1[N];inline int query(int u) &#123; int res2 = cnt2[u]; for (int i = 0;i &lt;= 17 &amp;&amp; F[i][u];i++) &#123; int ls = i ? F[i - 1][u] : u; res2 = ((res2 + (LL)cnt2[F[i][u]] - cnt1[ls] + (LL)D[i][u] * (tot2[F[i][u]] - tot2[ls])) % mod + mod) % mod; &#125; return res2;&#125;inline void update(int u, int id) &#123; (tot2[u] += id) %= mod, (cnt1[u] += (LL)D[0][u] * id % mod) %= mod; for (int i = 0;i &lt;= 17 &amp;&amp; F[i][u];i++) &#123; (cnt2[F[i][u]] += (LL)D[i][u] * id % mod) %= mod; (tot2[F[i][u]] += id) %= mod; (cnt1[F[i][u]] += (LL)D[i + 1][u] * id % mod) %= mod; &#125;&#125;int A[N], q[N], id[N], ans[N];bool cmp(int i, int j) &#123; return q[i] &lt; q[j];&#125;int main() &#123;// freopen("sumsumsum.in", "r", stdin), freopen("sumsumsum.out", "w", stdout); int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1, a, b;i &lt; n;i++) scanf("%d%d", &amp;a, &amp;b), adde(a, b); dfs(1, 0), Build(1), Construct(n); for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;A[i]); for (int i = 1;i &lt;= m;i++) scanf("%d", &amp;q[i]), id[i] = i; sort(id + 1, id + m + 1, cmp); int tmp1 = 0, tmp2 = 0; for (int i = 1, cur = 0;i &lt;= m;i++) &#123; while (cur &lt; q[id[i]]) &#123; int res = query(A[++cur]); (tmp1 += res) %= mod, (tmp2 += (LL)res * cur % mod) %= mod; update(A[cur], cur); &#125; ans[id[i]] = ((LL)tmp1 * (q[id[i]] + 1) % mod - tmp2 + mod) % mod; &#125; for (int i = 1;i &lt;= m;i++) printf("%d\n", ans[i]);&#125; T2 Cubelia 随机函数无关紧要，所以没有贴上来 我们考虑对于一个区间$[l,r]$求最大前缀和，答案是什么 很显然，这等价于从1开始，下标在$[l,r]$之间最大的前缀和，减去下标为$l-1$的前缀和 对于减去的那个东西，它是确定的，而且很好算，所以先不管他 问题转化为，有$n$个数，给出一段区间$[l,r]$，询问它所有子区间中最大数的和 我们先找出$[l,r]$中最大的那个数，假设它在$pos$ 那么我们可以把$[l,r]$所有的子区间分成3类 跨过$pos$ 左右端点都在$[l,pos)$中 左右端点都在$(pos,r]$中 对于第一种区间，它的答案很好计算 很显然，每一个这样的区间对答案的贡献一定是$a_{pos}$，$a$是那个位置对应的前缀和 而这样的区间一共有$(pos-l+1)(r-pos+1)$个 对于第二种区间，我们考虑设$f(i)​$表示两个端点都在$[l,n]​$的区间的权值之和 那么它可以被表示为$f(l)-f(pos)-[左端点在[l,pos)，右端点在[pos,n]的区间答案]$ 首先考虑$f$如何计算 很显然，这个$f$是可以预处理的 那么我们设$f_T(n)$表示左端点为$n$的区间的答案之和 那么显然有$f(n)=f(n+1)+f_T(n)$ 我们考虑$a_n$对$f_T(n)$的贡献 假设在$[l,r]$中，$a_n$都是最大的那个 那么对于右端点在$[n,r]$的区间，它的权值一定是$a_n$ 对于其它区间，$a_n$对它们已经没用了，因为有更大的数出现了 那么这些区间的答案就是$f_T(r+1)$，即左端点为$r+1$的区间权值总和 因为对于每一个被统计的区间，只要把$a_n,\cdots,a_r$拼在它的左边，就一定可以得到另一个区间，并且权值不变 所以有转移$$f_T(n)=a_n(r_n-n+1)+f_T(r+1)\\\f(n)=f(n+1)+f_T(n)$$那么如何求这个$[左端点在[l,pos)，右端点在[pos,n]的区间答案]$呢 我们已经知道$pos$是$[l,r]$中最大值的位置，换句话说，$a_l,\cdots,a_{pos-1}$一定不会对这个值造成影响 我们把每个合法的区间从$pos$划分成两半 对于右半部分，答案就是$f_T(pos)$ 对于左半部分，左端点可以随意选择 对于每一个从$pos$开始的区间，它的左端点可以为$[l,pos)$中的任意一个数，而权值不变 所以这个东西等于$(pos-l)f_T(pos)$ 最后说一下细节 对于如何求$l_i,r_i$，单调栈即可 对于最后要减去什么，我们可以枚举区间左端点，即$$\sum_{i=l}^ra_{i-1}(r-i)$$即对于每一个左端点，它会被选择$r-i$次 我们分别维护$$p_1(n)=\sum_{i=1}^na_{i-1}\\\p_2(n)=\sum_{i=1}^na_{i-1}i$$即可 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;#define N 2000010#define LL long longconst int mod = 998244353;LL pre[N], f[N], g[N], tf[N], tg[N], pre2[N], pre3[N]; int cur[21][N], lg[N], num[N];inline int Max(int a, int b) &#123; return pre[a] &gt; pre[b] ? a : b;&#125;int st[N], top, tl[N], tr[N];inline void Construct(int n) &#123; for (int i = 1;i &lt;= n;i++) &#123; pre[i] = pre[i - 1] + num[i], cur[0][i] = i, lg[i] = i == 1 ? 0 : lg[i &gt;&gt; 1] + 1; pre2[i] = pre2[i - 1] + pre[i - 1], pre3[i] = pre3[i - 1] + pre[i - 1] * i; &#125; for (int i = 1;i &lt;= 20;i++) for (int j = 1;j + (1 &lt;&lt; i) - 1 &lt;= n;j++) cur[i][j] = Max(cur[i - 1][j], cur[i - 1][j + (1 &lt;&lt; i - 1)]); for (int i = 1;i &lt;= n;i++) &#123; while (top &amp;&amp; pre[st[top]] &lt; pre[i]) tr[st[top--]] = i - 1; st[++top] = i; &#125; while (top) tr[st[top--]] = n; for (int i = n;i &gt;= 1;i--) &#123; while (top &amp;&amp; pre[st[top]] &lt; pre[i]) tl[st[top--]] = i + 1; st[++top] = i; &#125; while (top) tl[st[top--]] = 1; for (int i = 1;i &lt;= n;i++) &#123; tf[i] = tf[tl[i] - 1] + pre[i] * (i - tl[i] + 1); f[i] = f[i - 1] + tf[i]; &#125; for (int i = n;i &gt;= 1;i--) &#123; tg[i] = tg[tr[i] + 1] + pre[i] * (tr[i] - i + 1); g[i] = g[i + 1] + tg[i]; &#125;&#125;inline int query(int L, int R) &#123; int len = R - L + 1; return Max(cur[lg[len]][L], cur[lg[len]][R - (1 &lt;&lt; lg[len]) + 1]);&#125;inline LL solve(int L, int R) &#123; int pos = query(L, R); LL res = 0; res = pre[pos] * (R - pos + 1) * (pos - L + 1); res = res + g[L] - g[pos] - tg[pos] * (pos - L); res = res + f[R] - f[pos] - tf[pos] * (R - pos); return res - (pre2[R] - pre2[L - 1]) * (R + 1) + (pre3[R] - pre3[L - 1]);&#125;int S, A, B, P, tp; LL lastans;inline int Rand() &#123; S = (S * A % P + (B ^ (tp * lastans))) % P; S = S &lt; 0 ? -S : S; return S;&#125;int main() &#123; int n, q, l, r, res = 0; scanf("%d%d", &amp;n, &amp;q); for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;num[i]); scanf("%d%d%d%d%d", &amp;S, &amp;A, &amp;B, &amp;P, &amp;tp); Construct(n); while (q--) &#123; l = Rand() % n + 1, r = Rand() % n + 1; if (l &gt; r) swap(l, r); lastans = solve(l, r), res = (res + lastans) % mod; &#125; printf("%d\n", (res + mod) % mod);&#125; T3 Cuvelia 这可能是这次比赛最简单的题吧 假设一次询问给出的点是$a_1,a_2,\cdots,a_k$ 由于等于的传递性，我们只需要满足$dis(a_i,m)=dis(a_{i+1},m)$即可 所以我们一共有$k-1$个限制 如果每个限制我们能确定在树上有哪些节点合法，那么通过求他们的交集我们就能够确定最后的答案 考虑一个限制有哪些点合法 假设这两个点是$u,v$ 如果这两个点的距离为奇数，那么显然不存在满足条件的点 我们考虑这样一种情况 $u,v$两点的中点是$mid$，首先$mid$一定是合法的 其次，在以$mid$为根的树中，除$u,v$所在的子树都是合法的，即图中橙色的点 所以每次我们都是选定一个根，然后划去两棵子树 我们知道每棵子树的dfs序都是连续的，由于我们要求交集，所以可以使用线段树维护 具体来说，我们可以分两种情况： $mid$是$u,v$的$lca$ 此时直接找到$u,v$所对应的$lca$的两棵子树，划去这两棵子树即可 $mid$不是$u,v$的$lca$ 那么以$mid$为根时，一定会划去它父亲所在的子树，假设$mid$在以1为根的树中对应的dfs序是dfn[mid],end[mid] 此时dfs序在[1, dfn[mid] - 1], [end[mid] + 1, n]的点一定不合法，需要划去 也只有这两种情况了 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;#define N 300010struct node &#123; int l, r, sum, lazy;&#125; T[N &lt;&lt; 2];inline void pushup(int rt) &#123; T[rt].sum = T[rt &lt;&lt; 1].sum + T[rt &lt;&lt; 1 | 1].sum;&#125;inline void pushdown(int rt) &#123; if (T[rt].lazy == 1) T[rt &lt;&lt; 1].sum = T[rt &lt;&lt; 1 | 1].sum = 0, T[rt &lt;&lt; 1].lazy = T[rt &lt;&lt; 1 | 1].lazy = 1, T[rt].lazy = 0; if (T[rt].lazy == 2) &#123; int l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; 1; T[rt &lt;&lt; 1].sum = mid - l + 1, T[rt &lt;&lt; 1 | 1].sum = r - mid; T[rt &lt;&lt; 1].lazy = T[rt &lt;&lt; 1 | 1].lazy = 2, T[rt].lazy = 0; &#125; &#125; inline void build(int rt, int l, int r) &#123; T[rt].l = l, T[rt].r = r; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(rt &lt;&lt; 1, l, mid), build(rt &lt;&lt; 1 | 1, mid + 1, r);&#125;inline void modify(int rt, int start, int end, int x) &#123; int l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; 1; if (start &lt;= l &amp;&amp; r &lt;= end) &#123; T[rt].sum = x ? r - l + 1 : 0, T[rt].lazy = x + 1; return; &#125; if (T[rt].lazy) pushdown(rt); if (start &lt;= mid) modify(rt &lt;&lt; 1, start, end, x); if (end &gt; mid) modify(rt &lt;&lt; 1 | 1, start, end, x); pushup(rt);&#125;inline void mark(int start, int end) &#123; modify(1, start, end, 1);&#125;inline void reset() &#123; T[1].sum = 0, T[1].lazy = 1;&#125;inline int query() &#123; return T[1].r - T[1].l + 1 - T[1].sum;&#125;struct edge &#123; int to, next;&#125; e[N * 2];int head[N], ecnt;inline void adde(int from, int to) &#123; e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;&#125;int fa[18][N], dep[N], dfn[N], ed[N], dfsn;void dfs(int u, int f) &#123; fa[0][u] = f, dep[u] = dep[f] + 1, dfn[u] = ++dfsn; for (int i = 1;i &lt;= 17;i++) fa[i][u] = fa[i - 1][fa[i - 1][u]]; for (int i = head[u];i;i = e[i].next) if (e[i].to != f) dfs(e[i].to, u); ed[u] = dfsn;&#125;inline int LCA(int a, int b) &#123; if (dep[a] &lt; dep[b]) swap(a, b); for (int i = 17;i &gt;= 0;i--) if (dep[fa[i][a]] &gt;= dep[b]) a = fa[i][a]; if (a == b) return a; for (int i = 17;i &gt;= 0;i--) if (fa[i][a] != fa[i][b]) a = fa[i][a], b = fa[i][b]; return fa[0][a];&#125;inline int Jump(int a, int t) &#123; for (int i = 17;i &gt;= 0;i--) if (t &amp; (1 &lt;&lt; i)) a = fa[i][a]; return a;&#125;inline bool solve(int a, int b) &#123; if (dep[a] &lt; dep[b]) swap(a, b); if ((dep[a] + dep[b]) &amp; 1) return false; int lca = LCA(a, b); int mid = (dep[a] + dep[b] - 2 * dep[lca]) &gt;&gt; 1, cent = Jump(a, mid); if (cent == lca) &#123; a = Jump(a, mid - 1), b = Jump(b, mid - 1); mark(dfn[a], ed[a]), mark(dfn[b], ed[b]); &#125; else &#123; a = Jump(a, mid - 1); mark(dfn[a], ed[a]), mark(1, dfn[cent] - 1), mark(ed[cent] + 1, ed[1]); &#125; return true;&#125;int node[N];int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1, a, b;i &lt; n;i++) scanf("%d%d", &amp;a, &amp;b), adde(a, b); dfs(1, 0), build(1, 1, n); while (m--) &#123; reset(); int k, flag = 1; scanf("%d", &amp;k); for (int i = 1;i &lt;= k;i++) scanf("%d", &amp;node[i]); for (int i = 1;i &lt; k &amp;&amp; flag;i++) flag = solve(node[i], node[i + 1]); if (!flag) printf("0\n"); else printf("%d\n", query()); &#125;&#125; 总结这次考试很不理想，主要范了两个错误 一是第一题把代码打错了，%=打成了%，丢了20分 二是第三题数组开小了，丢了40分 第三题没有深入思考，考试时只想到了相邻两个求交集，没有想到用线段树维护 对于第二题，我觉得需要多做一些这样的题，积累经验 orz WKR]]></content>
      <tags>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>数据结构</tag>
        <tag>点分治</tag>
        <tag>线段树</tag>
        <tag>动态点分治</tag>
        <tag>rmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性递推]]></title>
    <url>%2F2019%2F03%2F10%2F%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8%2F</url>
    <content type="text"><![CDATA[求一个满足$k$阶齐次线性递推数列$a_i$的第$n​$项 即：$a_n=\sum\limits_{i=1}^kf_i\times a_{n-i}$ 已知$f$，以及$a_0,a_1,\cdots,a_{k-1}$$$n\leq 10^9, k\leq 32000$$如果$k$小一点，那么直接矩阵乘法是可以的 但是这个是$O(k^3\log n)$的，时间复杂度难以承受 注意到这个是其次线性递推，也就是说，我们构造出的矩阵只有第一行是$f​$，其余的行上全是1和0 我们设这个矩阵是$A$，现在有一个奇妙的序列$c$使得$$A^n=\sum_{i=0}^{k-1}c_iA^i$$我们设初始列向量是$base$，那么有$$A^n\times base=\sum_{i=0}^{k-1}c_iA^i\times base\\$$在矩阵运算中，我们只取第一行的值，那么有$$a_n=\sum_{i=0}^{k-1}c_ia_i$$这也就是说，如果我们成功地构造出了这个$c$，那么我们就可以使用$a$的前$k$项推出$a_n$ 我们重新考虑之前的那个式子$$A^n=\sum_{i=0}^{k-1}c_iA^i$$它一定可以被写成这样的式子$$A^n=Q(A)G(A)+R(A)$$即$$R(A)=A^n\mod G(A)$$ 其中$Q,G,R$都是以矩阵为参数的函数 我们令这个$G$的次数为$k$，那么$R$的次数为$k-1$ 如果存在一个函数$G$，使得对于$A$，有$G(A)=0$，那么前面的$Q(A)G(A)$就可以消去，从而使得$A^n=R(A)$ 此时多项式$R$的每一项的系数，就对应着之前我们需要构造的$c$ 所以实际上我们要构造一个序列$g$，使得$$\sum_{i=0}^kg_iA^i=0$$这里先上结论：对于满足题意的递推系数$f$，有$g_i=-f_{k-i},g_k=1$ 注意这里我们需要把这个$f$倒过来再取相反数，因为我们把列向量倒过来了，即从上到下分别为$a_0,a_1,\cdots,a_{k-1} $ 注意$f$的下标是从1到$k$，$g$是从0到$k​$ 计算的时候就像快速幂一样，只不过模的是一个多项式$G$ 证明过程之后再补 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;#define N 202010const int mod = 998244353;typedef long long LL;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;int r[N];inline void NTT(int a[], int len, int type) &#123; for (int i = 1;i &lt; len;i++) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int mid = 2;mid &lt;= len;mid &lt;&lt;= 1) &#123; int Wn = Pow(3, type ? (mod - 1) / mid : mod - 1 - (mod - 1) / mid); for (int i = 0;i &lt; len;i += mid) for (int j = i, w = 1, t;j &lt; i + (mid &gt;&gt; 1);j++, w = (LL)w * Wn % mod) t = (LL)w * a[j + (mid &gt;&gt; 1)] % mod, a[j + (mid &gt;&gt; 1)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod; &#125; if (!type) for (int inv = Pow(len, mod - 2), i = 0;i &lt; len;i++) a[i] = (LL)a[i] * inv % mod;&#125;int tmp[N];// b[i] = 2 * b'[i] - a[i] * b'[i] * b'[i]inline void Inv(const int a[], int b[], int n) &#123; if (n == 1) return void(b[0] = Pow(a[0], mod - 2)); Inv(a, b, (n + 1) &gt;&gt; 1); int l = 0, len = 1; while (len &lt;= n * 3) l++, len &lt;&lt;= 1; for (int i = 1;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); for (int i = 0;i &lt; n;i++) tmp[i] = a[i]; for (int i = n;i &lt; len;i++) tmp[i] = 0; NTT(tmp, len, 1), NTT(b, len, 1); for (int i = 0;i &lt; len;i++) b[i] = (2 - (LL)tmp[i] * b[i] % mod + mod) % mod * b[i] % mod; NTT(b, len, 0); for (int i = n;i &lt; len;i++) b[i] = 0;&#125;int tmpa[N], tmpb[N], tmpc[N], binv[N];inline void Div(const int a[], const int b[], int c[], int d[], int n, int m) &#123;// memset(tmpa, 0, sizeof(tmpa)), memset(tmpb, 0, sizeof(tmpb)), memset(tmpc, 0, sizeof(tmpc)), memset(binv, 0, sizeof(binv)); for (int i = 0;i &lt; n * 6 - m * 6 + 1;i++) tmpa[i] = tmpb[i] = tmpc[i] = binv[i] = 0; for (int i = 0;i &lt;= n - m;i++) tmpa[i] = a[n - i]; for (int i = 0;i &lt;= m;i++) tmpb[i] = b[m - i]; Inv(tmpb, binv, n - m + 1); int l = 0, len = 1; while (len &lt;= n * 2 - m * 2) l++, len &lt;&lt;= 1; for (int i = 1;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); NTT(tmpa, len, 1), NTT(binv, len, 1); for (int i = 0;i &lt; len;i++) c[i] = (LL)tmpa[i] * binv[i] % mod; NTT(c, len, 0); for (int i = n - m + 1;i &lt; len;i++) c[i] = 0; for (int i = 0;i * 2 &lt; n - m;i++) swap(c[i], c[n - m - i]); l = 0, len = 1; while (len &lt;= n) l++, len &lt;&lt;= 1; for (int i = 1;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); for (int i = 0;i &lt;= n;i++) tmpa[i] = a[i]; for (int i = 0;i &lt;= m;i++) tmpb[i] = b[i]; for (int i = 0;i &lt;= n - m;i++) tmpc[i] = c[i]; NTT(tmpa, len, 1), NTT(tmpb, len, 1), NTT(tmpc, len, 1); for (int i = 0;i &lt; len;i++) d[i] = (tmpa[i] - (LL)tmpb[i] * tmpc[i] % mod + mod) % mod; NTT(d, len, 0); for (int i = m;i &lt; len;i++) d[i] = 0;&#125;int base[N], f[N], res[N], del[N], A[N], rub[N];inline void mul(int a[], const int b[], const int c[], int k) &#123; int l = 0, len = 1; while (len &lt;= k * 2) len &lt;&lt;= 1, l++; for (int i = 1;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); for (int i = 0;i &lt;= k;i++) tmpb[i] = b[i]; for (int i = k + 1;i &lt; len;i++) tmpb[i] = 0; NTT(a, len, 1), NTT(tmpb, len, 1); for (int i = 0;i &lt; len;i++) del[i] = (LL)a[i] * tmpb[i] % mod; NTT(del, len, 0), Div(del, c, rub, a, k * 2, k);&#125;int main() &#123; int n, k, ans = 0; scanf("%d%d", &amp;n, &amp;k), f[k] = 1; for (int i = 1;i &lt;= k;i++) scanf("%d", &amp;f[k - i]), (f[k - i] = mod - f[k - i]) %= mod; for (int i = 0;i &lt; k;i++) scanf("%d", &amp;base[i]), (base[i] += mod) %= mod; res[0] = 1, A[1] = 1; for (;n;n &gt;&gt;= 1, mul(A, A, f, k)) if (n &amp; 1) mul(res, A, f, k); for (int i = 0;i &lt; k;i++) ans = (ans + (LL)res[i] * base[i]) % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>多项式求逆</tag>
        <tag>多项式除法</tag>
        <tag>多项式</tag>
        <tag>算法</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.8省选模拟 斐波那契树]]></title>
    <url>%2F2019%2F03%2F09%2F3-8%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[$$n,q\leq 2*10^5$$ 不知道出题人怎么想的，模$10^9+7$而不是$10^9+9$，$5$在模$10^9+7$下没有二次剩余 我们知道斐波那契数列是可以叠加的，也就是一个斐波那契数列加上另一个斐波那契数列仍然是斐波那契数列 那么我们只需要维护这个数列的第0项和第1项就可以了 由于5没有二次剩余，所以可以通过预处理/矩阵乘法求得数列的第$k$项 考虑如何维护这两个操作 很显然，这是一个动态点分治 对于点分树上的每一个点，我们维护两个树状数组 两个数组都是根据深度建的，但是一个维护它对它自己子树的贡献，另一个维护它对它父亲的贡献 比如现在要处理第一个询问 将$u$往上跳，假设它的第$i$级祖先是F[i][u]，它距离这个祖先的距离是D[i][u] 那么现在$u$可以经过这个祖先，到达这个祖先的其它子树 我们知道，距离$m$以内的点都会被更新 当$u$跳到这个祖先的时候，这个距离还剩下m - D[i][u] 也就是说，这个祖先所有离它不超过m - D[i][u]的点都会被更新 这对应着树状数组上的一段前缀和 当然，我们还要算出$a,b$在这一级祖先变成了多少 查询的时候，也是跳它的祖先 对于每一级祖先，我们知道它距离这个祖先的距离，以及在它这个深度累加的答案 那么我们就可以算出这个祖先对它的贡献 但是这样会重复计数 我们考虑这样一种情况：$u$的某一级祖先是$f$，第一个询问更新了$u$，这导致$f$也更新了 现在要查询$v$，其中$v,u$在$f$的同一棵子树内 之前更新祖先时依据是$u$经过这个祖先，到达这个祖先其它子树的点 然而现在$u$不需要经过$f$，就可以到达$v$ 当跳到$f$的时候，$u$的贡献又会被算一次，这样就重复计数了 解决方法是同时维护每个节点对它父亲的贡献 查询的时候，假设$u$的上一级祖先是$f$，那么我们查$f$对子树的贡献，减去$u$对其父亲$f$的贡献，就可以了 动态点分治要注意内存开销 还是vector+树状数组比较妥当 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;bits/stdc++.h&gt;#pragma GCC optimize(3)using namespace std;const int mod = 1e9 + 7;typedef long long LL;typedef pair&lt;int, int&gt; P;#define N 200010inline void Inc(int &amp;x, int y) &#123;x += y, x -= x &gt;= mod ? mod : 0;&#125;inline void Dec(int &amp;x, int y) &#123;x = x + mod - y, x -= x &gt;= mod ? mod : 0;&#125;inline void Inc(P &amp;x, P y) &#123;Inc(x.first, y.first), Inc(x.second, y.second);&#125;inline void Dec(P &amp;x, P y) &#123;Dec(x.first, y.first), Dec(x.second, y.second);&#125;namespace FIB &#123; struct Matrix &#123; int a[3][3]; Matrix() &#123;memset(a, 0, sizeof(a));&#125; Matrix operator * (const Matrix &amp;b) &#123; Matrix c; for (int i = 1;i &lt;= 2;i++) for (int j = 1;j &lt;= 2;j++) for (int k = 1;k &lt;= 2;k++) Inc(c.a[i][j], (LL)a[i][k] * b.a[k][j] % mod); return c; &#125; &#125;; inline Matrix Pow(Matrix x, int y) &#123; Matrix res; res.a[1][1] = res.a[2][2] = 1; for (;y;y &gt;&gt;= 1, x = x * x) if (y &amp; 1) res = res * x; return res; &#125; inline int Kth(P x, int k) &#123; Matrix base; base.a[1][1] = base.a[1][2] = base.a[2][1] = 1; if (k == 0) return x.first; if (k == 1) return x.second; base = Pow(base, k - 1); return ((LL)base.a[1][1] * x.second + (LL)base.a[1][2] * x.first) % mod; &#125; &#125;vector&lt;P &gt; tree[2][N];inline void add(int type, int id, int x, P y) &#123; x = min(x + 1, (int)tree[type][id].size() - 1); for (;x;x -= x &amp; -x) Inc(tree[type][id][x], y);&#125;inline P que(int type, int id, int x) &#123; P res; x++; for (;x &lt; tree[type][id].size();x += x &amp; -x) Inc(res, tree[type][id][x]); return res;&#125;struct edge &#123; int to, next;&#125; e[N * 2];int head[N], ecnt;inline void adde(int from, int to) &#123; e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;&#125;int dep[N], fa[20][N];void dfs(int u, int f) &#123; fa[0][u] = f, dep[u] = dep[f] + 1; for (int i = 1;i &lt;= 19;i++) fa[i][u] = fa[i - 1][fa[i - 1][u]]; for (int i = head[u];i;i = e[i].next) if (e[i].to != f) dfs(e[i].to, u);&#125;inline int LCA(int a, int b) &#123; if (dep[a] &lt; dep[b]) swap(a, b); for (int i = 19;i &gt;= 0;i--) if (dep[fa[i][a]] &gt;= dep[b]) a = fa[i][a]; if (a == b) return a; for (int i = 19;i &gt;= 0;i--) if (fa[i][a] != fa[i][b]) a = fa[i][a], b = fa[i][b]; return fa[0][a];&#125;inline int Dis(int a, int b) &#123; return dep[a] + dep[b] - 2 * dep[LCA(a, b)];&#125;int vis[N], size[N], mxd[N];int Getsize(int u) &#123; vis[u] = size[u] = 1; for (int i = head[u];i;i = e[i].next) if (!vis[e[i].to]) size[u] += Getsize(e[i].to); return vis[u] = 0, size[u];&#125;int Getroot(int u, int tot) &#123; vis[u] = 1; for (int i = head[u], tmp;i;i = e[i].next) if (!vis[e[i].to] &amp;&amp; (tmp = Getroot(e[i].to, tot))) return vis[u] = 0, tmp; return vis[u] = 0, size[u] &gt;= (tot &gt;&gt; 1) ? u : 0;&#125;int Getdep(int u) &#123; int res = 1; vis[u] = 1; for (int i = head[u];i;i = e[i].next) if (!vis[e[i].to]) res = max(res, Getdep(e[i].to) + 1); return vis[u] = 0, res;&#125;int F[20][N], D[20][N];int Build(int u) &#123; u = Getroot(u, Getsize(u)), vis[u] = 1; int deep = 0; for (int i = head[u];i;i = e[i].next) if (!vis[e[i].to]) deep = max(deep, Getdep(e[i].to)); tree[0][u].resize(deep + 2), mxd[u] = deep; for (int i = head[u];i;i = e[i].next) if (!vis[e[i].to]) F[0][Build(e[i].to)] = u; return u;&#125;inline void Construct(int n) &#123; for (int i = 1;i &lt;= n;i++) if (F[0][i]) D[0][i] = Dis(F[0][i], i); for (int i = 1;i &lt;= 19;i++) for (int j = 1;j &lt;= n;j++) &#123; F[i][j] = F[i - 1][F[0][j]]; if (F[i][j]) D[i][j] = Dis(F[i][j], j); &#125; for (int i = 1;i &lt;= n;i++) tree[1][i].resize(mxd[F[0][i]] + 2);&#125;inline void update(int x, int dis, P data) &#123; add(0, x, dis, data); for (int i = 0;i &lt;= 19 &amp;&amp; F[i][x];i++) if (D[i][x] &lt;= dis) &#123; int ta = FIB::Kth(data, D[i][x]), tb = FIB::Kth(data, D[i][x] + 1); add(0, F[i][x], dis - D[i][x], P(ta, tb)); add(1, i ? F[i - 1][x] : x, dis - D[i][x], P(ta, tb)); &#125;&#125;inline int query(int x) &#123; int res = que(0, x, 0).first; for (int i = 0;i &lt;= 19 &amp;&amp; F[i][x];i++) &#123; Inc(res, FIB::Kth(que(0, F[i][x], D[i][x]), D[i][x])); Dec(res, FIB::Kth(que(1, i ? F[i - 1][x] : x, D[i][x]), D[i][x])); &#125; return res;&#125;int __rd;inline void read(int &amp;x) &#123; x = 0; char c = getchar(); while (c &lt; '0' || c &gt; '9') c = getchar(); while ('0' &lt;= c &amp;&amp; c &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - '0', c = getchar();&#125;#define RD (read(__rd), __rd)int main() &#123;// freopen("fibtree.in", "r", stdin); int n = RD, q = RD; for (int i = 1, a, b;i &lt; n;i++) a = RD, b = RD, adde(a, b); dfs(1, 0), Build(1), Construct(n); while (q--) &#123; int op = RD, a = RD, b, c, d; if (op == 1) b = RD, c = RD, d = RD, update(a, b, P(c, d)); else printf("%d\n", query(a)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>点分治</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式除法]]></title>
    <url>%2F2019%2F03%2F09%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%99%A4%E6%B3%95%2F</url>
    <content type="text"><![CDATA[已知多项式$F(x),G(x)​$，求出多项式$Q(x),R(x)​$，使得在模$998244353​$意义下，有$$F(x)=Q(x)G(x)+R(x) \mod 998244353$$其中$F$的次数为$n$，$G$的次数为$m$ 那么我们知道$Q$是一个$n-m$次的多项式，而$R$是一个$m-1$次的多项式 我们定义变换$R$，满足$$F_R(x)=x^nF(\frac 1x)$$我们考虑这个$R$是怎么得到的 假设有$$F(x)=a_0+a_1x+a_2x^2+\cdots+a_nx^n$$代入$\frac 1x$之后我们得到$$F(\frac 1x)=a_0+\frac{a_1}{x}+\frac{a_2}{x^2}+\cdots+\frac{a_n}{x^n}$$再乘以$x^n$$$x^nF(\frac 1x)=a_n+a_{n-1}x+a_{n-2}x^2+\cdots+a_0x^n$$我们发现，得到的结果就是把原来多项式的系数反过来，就是$R​$变换 那么有$$F(x)=Q(x)G(x)+R(x)$$代入$\frac 1x$$$F(\frac 1x)=Q(\frac 1x)G(\frac 1x)+R(\frac 1x)$$同时乘以$x^n$$$x^nF(\frac 1x)=x^{n-m}Q(\frac 1x)x^mG(\frac 1x)+x^{n-m+1}*x^{m-1}R(\frac 1x)\\\F_R(x)=Q_R(x)G_R(x)+x^{n-m+1}R_R(x)$$考虑如何把最后那个余数$R$给搞掉 注意到它乘了一个系数 那么我们直接在模$x^{n-m+1}$下运算即可 此时有$$F_R(x)=Q_R(x)G_R(x)\mod x^{n-m+1}\\\Q_R(x)=\frac{F_R(x)}{G_R(x)}\mod x^{n-m+1}$$所以我们求出$G_R$在模$x^{n-m+1}$下的逆，再乘上$F_R$就可以得到$G_R$ 由于$Q​$的次数就是$n-m​$，所以此时求出的模意义下的$Q_R​$等价于$Q_R​$ 注意此时$F_R,G_R​$都是$n-m​$次多项式 我们求出了$Q_R​$，将它倒序可以得到$Q​$，然后将$Q​$代入$F(x)=Q(x)G(x)+R(x)​$，就可以求出$R​$了 代码如下（有点毒瘤） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;#define N 600010typedef long long LL;int r[N]; const int mod = 998244353;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1,x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;inline void NTT(int a[], int len, int type) &#123; for (int i = 1;i &lt; len;i++) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int mid = 2;mid &lt;= len;mid &lt;&lt;= 1) &#123; int Wn = Pow(3, type ? (mod - 1) / mid : mod - 1 - (mod - 1) / mid); for (int i = 0;i &lt; len;i += mid) for (int j = i, w = 1, t;j &lt; i + (mid &gt;&gt; 1);j++, w = (LL)w * Wn % mod) t = (LL)w * a[j + (mid &gt;&gt; 1)] % mod, a[j + (mid &gt;&gt; 1)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod; &#125; if (!type) &#123; int Inv = Pow(len, mod - 2); for (int i = 0;i &lt; len;i++) a[i] = (LL)a[i] * Inv % mod; &#125;&#125;int tmp[N];inline void Inv(const int a[], int b[], int n) &#123; if (n == 1) return void(b[0] = Pow(a[0], mod - 2)); Inv(a, b, (n + 1) &gt;&gt; 1); int l = 0, len = 1; while (len &lt;= n * 3) len &lt;&lt;= 1, l++; for (int i = 1;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); for (int i = 0;i &lt; n;i++) tmp[i] = a[i]; for (int i = n;i &lt; len;i++) tmp[i] = 0; NTT(tmp, len, 1), NTT(b, len, 1); for (int i = 0;i &lt; len;i++) b[i] = (2 - (LL)tmp[i] * b[i] % mod + mod) % mod * b[i] % mod; NTT(b, len, 0); for (int i = n;i &lt; len;i++) b[i] = 0;&#125;int tmpa[N], tmpb[N], binv[N], tmpc[N];inline void Div(const int a[], const int b[], int c[], int d[], int n, int m) &#123; for (int i = 0;i &lt;= n - m;i++) tmpa[i] = a[n - i]; for (int i = 0;i &lt;= m;i++) tmpb[i] = b[m - i]; Inv(tmpb, binv, n - m + 1); int l = 0, len = 1; while (len &lt;= 2 * n - 2 * m) len &lt;&lt;= 1, l++; for (int i = 1;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); NTT(tmpa, len, 1), NTT(binv, len, 1); for (int i = 0;i &lt; len;i++) c[i] = (LL)tmpa[i] * binv[i] % mod; NTT(c, len, 0); for (int i = n - m + 1;i &lt; len;i++) c[i] = 0; for (int i = 0;i * 2 &lt; n - m;i++) swap(c[i], c[n - m - i]); for (int i = 0;i &lt;= n;i++) tmpa[i] = a[i]; for (int i = 0;i &lt;= m;i++) tmpb[i] = b[i]; for (int i = 0;i &lt;= n - m;i++) tmpc[i] = c[i]; l = 0, len = 1; while (len &lt;= n) len &lt;&lt;= 1, l++; for (int i = 1;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); NTT(tmpa, len, 1), NTT(tmpb, len, 1), NTT(tmpc, len, 1); for (int i = 0;i &lt; len;i++) d[i] = (tmpa[i] - (LL)tmpb[i] * tmpc[i] % mod + mod) % mod; NTT(d, len, 0); for (int i = m;i &lt; len;i++) d[i] = 0;&#125;int A[N], B[N], C[N], D[N];int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 0;i &lt;= n;i++) scanf("%d", &amp;A[i]); for (int i = 0;i &lt;= m;i++) scanf("%d", &amp;B[i]); Div(A, B, C, D, n, m); for (int i = 0;i &lt;= n - m;i++) printf("%d ", C[i]); puts(""); for (int i = 0;i &lt; m;i++) printf("%d ", D[i]); return 0;&#125;]]></content>
      <tags>
        <tag>多项式求逆</tag>
        <tag>多项式除法</tag>
        <tag>多项式</tag>
        <tag>算法</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式求逆]]></title>
    <url>%2F2019%2F03%2F09%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E9%80%86%2F</url>
    <content type="text"><![CDATA[有$A(x)*B(x)\equiv1\mod x^n$，已知$A$，求$B$，每一项的系数模$998244353$ 考虑分治，假设我们已经求出了$A$在模$x^{\lfloor\frac n2\rfloor}$下的逆$B’$ 那么有 $$A(x)B’(x)\equiv 1 \mod x^{\lceil\frac n2\rceil}$$ $$A(x)B(x)\equiv 1 \mod x^{\lceil\frac n2\rceil}$$ 可以推出 $$B’(x)-B(x)\equiv 0\mod x^{\lceil\frac n2\rceil}$$ 两边同时平方 $$(B’(x)-B(x))^2\equiv 0\mod x^n$$ 展开 $$B(x)^2-2B’(x)B(x)+B’(x)^2\equiv 0\mod x^n$$ 同时乘以A $$B(x)-2B’(x)+A(x)B’(x)^2\equiv 0\mod x^n$$ $$B(x)\equiv 2B’(x)-A(x)B’(x)^2\mod x^n$$ 注意分治的时候我们只关心所有多项式的前n项，大于n项的常数需要置0 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;#define N 600010#define LL long longconst int mod = 998244353;inline int Pow(int x, int y) &#123; int res = 1; for (; y; y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;struct Poly &#123; static int r[N], len, l; int A[N]; Poly() &#123;memset(A, 0, sizeof(A));&#125; inline static void Reset(int _n) &#123; Poly::l = 0, Poly::len = 1; while (len &lt;= _n) len &lt;&lt;= 1, l++; for (int i = 1; i &lt; len; i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); &#125; void operator *= (int type) &#123; for (int i = 1; i &lt; len; i++) if (i &lt; r[i]) swap(A[i], A[r[i]]); for (int mid = 2; mid &lt;= len; mid &lt;&lt;= 1) for (int i = 0; i &lt; len; i += mid) &#123; int Wn = Pow(3, type ? (mod - 1) / mid : mod - 1 - (mod - 1) / mid); for (int j = i, w = 1, t; j &lt; i + (mid &gt;&gt; 1); j++, w = (LL)w * Wn % mod) t = (LL)w * A[j + (mid &gt;&gt; 1)] % mod, A[j + (mid &gt;&gt; 1)] = (A[j] - t + mod) % mod, A[j] = (A[j] + t) % mod; &#125; &#125;&#125;;int Poly::r[N], Poly::len, Poly::l;// b(x) = 2b'(x) - a(x)b'(x) ^ 2inline void Inv(const Poly &amp;a, Poly &amp;b, int n) &#123; if (n == 1) return void(b.A[0] = Pow(a.A[0], mod - 2)); else Inv(a, b, (n + 1) &gt;&gt; 1); Poly c(a); Poly::Reset(n * 3); int l = Poly::len; for (int i = n; i &lt; l; i++) c.A[i] = 0; c *= 1, b *= 1; for (int i = 0;i &lt; l;i++) b.A[i] = (2 - (LL)c.A[i] * b.A[i] % mod + mod) % mod * b.A[i] % mod; b *= 0; int inv = Pow(l, mod - 2); for (int i = 0;i &lt; l;i++) b.A[i] = (LL)b.A[i] * inv % mod; for (int i = n;i &lt; l;i++) b.A[i] = 0;&#125;int main() &#123; Poly a, b; int n; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;a.A[i]); Inv(a, b, n); for (int i = 0; i &lt; n; i++) printf("%d ", b.A[i]);&#125;]]></content>
      <tags>
        <tag>多项式求逆</tag>
        <tag>多项式</tag>
        <tag>算法</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.8省选模拟 奇怪的树]]></title>
    <url>%2F2019%2F03%2F08%2F3-8%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F-%E5%A5%87%E6%80%AA%E7%9A%84%E6%A0%91%2F</url>
    <content type="text"><![CDATA[$$n\leq 3*10^5$$树链剖分好题，链上维护虚子树信息 我们考虑如何更新一条链 假设询问节点是$u$，$AC$是一条重链，$PB$是一条轻链，$P$是一个奇怪的节点 那么我们知道，此时$B$的点权加上了$P$ 如果$A$的下方还连接着一个奇怪的点$P_1$，那么$B$也会加上$P_1$的权值 而此时$C$不会加上$P_1$的权值，因为它不是lca 所以当$u$从一条链的顶端跳到另一条链时，对于$u$的父亲我们需要特殊考虑贡献，对于这条链上其它的点，权值都会加上在其子树中，且不在其重儿子子树中的奇怪的点的编号之和 这个东西不是很好维护，那么我们考虑维护它所乘的系数，即它的权值加了多少次不在重儿子的奇怪的点的编号之和 这样的话，我们只需要实现区间加1就可以了 我们另开一个数组ans，表示每个点除了那个区间加1以外的贡献 比如之前提到的$u$的父亲，我们就将它的重儿子所在的子树中奇怪的点的编号之和加入ans 假如一个点加了$a_i$次1，在它的子树中，且不在它重儿子的子树中的奇怪的点的编号之和为$b_i$，那么一个点最终的答案就是$a_ib_i+ans_i$ 12345678inline void Tupdate1(int u) &#123; ans[u] += query(1, id[u], 2); while (u) &#123; update(1, id[top[u]], id[u], 0, 1); // 区间ai + 1 u = top[u], ans[fa[u]] += query(1, id[fa[u]], 2) - query(1, id[u], 1) - query(1, id[u], 2); // 特殊处理链顶的父亲，注意要减去u自己所在的子树的贡献 u = fa[u]; &#125;&#125; 我们考虑如何实现询问2 我们记一个点的非重儿子子树中，奇怪的点的点权之和是$V_u$ 其重儿子子树中，奇怪的点的点权之和是$W_u$ 如果把$u$的状态改变了，那么这会影响一些点的$V_u$和$W_u$ 仍然考虑这张图 对于$B$，它的$V$变化而$W$不变化 对于$C$，它的$W$变化而$V$不变化 对于$A$，它的$W$和$V$都不变化 我们仍然将$B$视为特殊点，特殊处理贡献 注意到之前我们维护了$V_u$的贡献系数 而这里$B$的$V$值更新了，那么这会导致答案多统计一部分 方法是，在更新$B$之前，将$a_bV_b$下放到ans[b]，然后将$a_b$清零 注意最开始$u$还没有向上爬的时候，$u$节点本身也是一个特殊点 1234567891011inline void Tupdate2(int u) &#123; int tmp = mark[u] ? -u : u; mark[u] ^= 1; // 权值更改的值 LL del = query(1, id[u], 0); ans[u] += del * query(1, id[u], 1), update(1, id[u], id[u], 0, -del); // 特殊处理u ：0代表a[u]，1代表V[u]，2代表W[u]，清空a[u]并更新V[u] update(1, id[u], id[u], 1, tmp); while (u) &#123; update(1, id[top[u]], id[fa[u]], 2, tmp), u = top[u]; del = query(1, id[fa[u]], 0); ans[fa[u]] += del * query(1, id[fa[u]], 1), update(1, id[fa[u]], id[fa[u]], 0, -del), update(1, id[fa[u]], id[fa[u]], 1, tmp); // 同理 u = fa[u]; &#125;&#125; 关于动态dp，也是链上维护虚子树信息 去年四川省选D1T1也许可以LCT维护虚子树信息 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;using namespace std;#define N 300010#define LL long longstruct edge &#123;int to, next;&#125; e[N * 2];int head[N], ecnt;inline void adde(int from, int to) &#123; e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;&#125;struct node &#123; int l, r; LL sum, lazy, s1, s2, lazy1, lazy2; &#125; T[N &lt;&lt; 2];inline void pushdown(int rt) &#123; T[rt &lt;&lt; 1].sum += T[rt].lazy, T[rt &lt;&lt; 1 | 1].sum += T[rt].lazy, T[rt &lt;&lt; 1].lazy += T[rt].lazy, T[rt &lt;&lt; 1 | 1].lazy += T[rt].lazy, T[rt].lazy = 0; T[rt &lt;&lt; 1].s1 += T[rt].lazy1, T[rt &lt;&lt; 1 | 1].s1 += T[rt].lazy1, T[rt &lt;&lt; 1].lazy1 += T[rt].lazy1, T[rt &lt;&lt; 1 | 1].lazy1 += T[rt].lazy1, T[rt].lazy1 = 0; T[rt &lt;&lt; 1].s2 += T[rt].lazy2, T[rt &lt;&lt; 1 | 1].s2 += T[rt].lazy2, T[rt &lt;&lt; 1].lazy2 += T[rt].lazy2, T[rt &lt;&lt; 1 | 1].lazy2 += T[rt].lazy2, T[rt].lazy2 = 0;&#125;int rk[N]; LL v1[N], v2[N], ans[N];void build(int rt, int l, int r) &#123; T[rt].l = l, T[rt].r = r; int mid = (l + r) &gt;&gt; 1; if (l == r) &#123;T[rt].s1 = v1[rk[l]], T[rt].s2 = v2[rk[l]]; return;&#125; build(rt &lt;&lt; 1, l, mid), build(rt &lt;&lt; 1 | 1, mid + 1, r);&#125;void update(int rt, int start, int end, int type, LL x) &#123; if (end &lt;= 0 || start &gt; end) return; int l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; 1; if (start &lt;= l &amp;&amp; r &lt;= end) &#123; if (type == 0) T[rt].lazy += x, T[rt].sum += x; else if (type == 1) T[rt].lazy1 += x, T[rt].s1 += x; else T[rt].lazy2 += x, T[rt].s2 += x; return; &#125; pushdown(rt); if (start &lt;= mid) update(rt &lt;&lt; 1, start, end, type, x); if (end &gt; mid) update(rt &lt;&lt; 1 | 1, start, end, type, x);&#125;LL query(int rt, int at, int type) &#123; if (!at) return 0; int l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; 1; if (l == r) &#123; if (type == 0) return T[rt].sum; else if (type == 1) return T[rt].s1; else return T[rt].s2; &#125; pushdown(rt); return at &lt;= mid ? query(rt &lt;&lt; 1, at, type) : query(rt &lt;&lt; 1 | 1, at, type);&#125;int dfsn, sz[N], top[N], id[N], fa[N], mark[N], son[N];void dfs1(int u, int f) &#123; sz[u] = 1, fa[u] = f; for (int i = head[u];i;i = e[i].next) if (e[i].to != f) &#123; dfs1(e[i].to, u), sz[u] += sz[e[i].to]; if (sz[son[u]] &lt; sz[e[i].to]) son[u] = e[i].to; &#125;&#125;void dfs2(int u, int t) &#123; id[u] = ++dfsn, top[u] = t, v1[u] = mark[u] ? u : 0, rk[id[u]] = u; if (son[u]) dfs2(son[u], t), v2[u] += v2[son[u]] + v1[son[u]]; for (int i = head[u];i;i = e[i].next) if (e[i].to != fa[u] &amp;&amp; e[i].to != son[u]) dfs2(e[i].to, e[i].to), v1[u] += v1[e[i].to] + v2[e[i].to];&#125;inline void Tupdate1(int u) &#123; ans[u] += query(1, id[u], 2); while (u) &#123; update(1, id[top[u]], id[u], 0, 1); u = top[u], ans[fa[u]] += query(1, id[fa[u]], 2) - query(1, id[u], 1) - query(1, id[u], 2); u = fa[u]; &#125;&#125;inline void Tupdate2(int u) &#123; int tmp = mark[u] ? -u : u; mark[u] ^= 1; LL del = query(1, id[u], 0); ans[u] += del * query(1, id[u], 1), update(1, id[u], id[u], 0, -del); update(1, id[u], id[u], 1, tmp); while (u) &#123; update(1, id[top[u]], id[fa[u]], 2, tmp), u = top[u]; del = query(1, id[fa[u]], 0); ans[fa[u]] += del * query(1, id[fa[u]], 1), update(1, id[fa[u]], id[fa[u]], 0, -del), update(1, id[fa[u]], id[fa[u]], 1, tmp); u = fa[u]; &#125;&#125;inline LL query(int u) &#123; return ans[u] + query(1, id[u], 0) * query(1, id[u], 1);&#125;int __rd;inline void read(int &amp;x) &#123; x = 0; char c = getchar(); while (c &lt; '0' || c &gt; '9') c = getchar(); while ('0' &lt;= c &amp;&amp; c &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - '0', c = getchar();&#125;#define RD (read(__rd), __rd)#define OPEN(x) freopen(x".in", "r", stdin), freopen(x".out", "w", stdout)int main() &#123;// OPEN("strtree"); int n = RD, m = RD; for (int i = 1;i &lt;= n;i++) mark[i] = RD; for (int i = 1, a, b;i &lt; n;i++) a = RD, b = RD, adde(a, b); dfs1(1, 0), dfs2(1, 1), build(1, 1, n); while (m--) &#123; int a = RD, b = RD; if (a == 1) Tupdate1(b); else Tupdate2(b); &#125; for (int i = 1;i &lt;= n;i++) printf("%lld\n", query(i));&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gcd应用]]></title>
    <url>%2F2019%2F03%2F08%2Fgcd%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[两有理数间求一个分数，使得分子最小就是要求$\frac ab&lt;\frac xy&lt;\frac cd$$$几种情况：\\\ a=0:x=1,y=\lfloor\frac dc\rfloor+1\\\ a\geq b:将\frac ab转化成真分数，递归\\\ c&gt;d:此时有a&lt;b,则a=1,b=1\\\ 否则有\frac dc\leq \frac yx\leq \frac ba，递归然后交换分母和分子$$代码 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;#define P pair&lt;int, int&gt;P work(int a, int b, int c, int d) &#123; // a / b &lt;= x &lt;= c / d if (!a) return P(1, d / c + 1); P tmp; if (a &gt;= b) return tmp = work(a % b, b, c - (a / b) * d, d), tmp.first += tmp.second * (a / b), tmp; if (c &gt; d) return P(1, 1); return tmp = work(d, c, b, a), swap(tmp.first, tmp.second), tmp;&#125;int main() &#123; while (true) &#123; int a, b, c, d; scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d); P tmp = work(a, b, c, d); printf("%d/%d\n", tmp.first, tmp.second); &#125;&#125; 高精度$gcd$显然，直接模是不行的 按照奇偶性分类，时间复杂度$O(\log n)​$ 有理多边形内整点个数枚举每一条线段，假设点距为$m$ 等价于求$$\sum_{i=1}^n\lfloor\frac{k_i+b}{m}\rfloor$$]]></content>
      <tags>
        <tag>gcd</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CodeChef] Adi and the Matrix]]></title>
    <url>%2F2019%2F03%2F08%2FCodeChef-Adi-and-the-Matrix%2F</url>
    <content type="text"><![CDATA[题目链接 有$N*M\leq 550$ 注意到数据范围，它的含义是说，N和M中较小的那个不会超过23 我们考虑置换，首先假设$N\leq M$ 枚举N的划分方案，注意要从小到大枚举，这个数不会太大 这个划分方案中每一个集合对应着一个循环 如果元素个数是$n$，划分方案为$(a_i,b_i)$，即长度为$a_i$的循环有$b_i$个 那么它对应的置换总数为$$\frac{n!}{\prod a_i^{b_i}b_i!}$$这个式子的意思是说，将所有元素进行排列，每一个循环中都有$a_i$种等价方案，即旋转0次、旋转1次，……，旋转$a_i-1$次，长度相同的循环之间可以互换顺序 假如我们已经知道了M对应的循环，那么考虑如何计算不动点个数 对于一个格子，它在行内的循环假设长度为$a$，在列内的循环假设长度为$b$。那么我们知道，它在经过$a$次置换后会回到原来所在的行，在经过$b$次置换后会回到原来所在的列 所以，最少需要$lcm(a,b)$次置换才能回到原点 也就是说，每一种方案，都有$lcm(a,b)$种方案是与它等价的 对于这两个循环中，我们知道一共有$ab$个格子 所以，不动点的个数是$\frac{ab}{lcm(a,b)}=gcd(a,b)$ 每个不动点都有两种染色方案，即0或1 我们考虑使用dp来计算贡献 dp[i][j]表示还剩下i列没有分配，还没有分配循环长度j时所有方案的不动点个数之和 我们枚举长度为j的循环个数 求出之前枚举出来的$N$的划分中每一个$a_i$与j的$gcd$之和 注意循环对应的置换个数是$\frac{M!}{\prod a_i^{b_i}b_i!}$，这里我们把$M$提出来，在dp的时候顺便转移分母 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;#define N 600typedef long long LL;int dp[N][N], a[N], top, n, m, frac[N], inv[N], g[N][N], Pow2[N];const int mod = 1e9 + 7;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;inline void Inc(int &amp;x, int y) &#123;x += y, x -= x &gt;= mod ? mod : 0;&#125;int gcd(int a, int b) &#123;return b ? gcd(b, a % b) : a;&#125;inline int solve() &#123; memset(dp, 0, sizeof(dp)), dp[m][m] = 1; for (int i = m;i &gt;= 0;i--) for (int j = m;j &gt;= 1;j--) if (dp[i][j]) &#123; int val = 0, tmp = dp[i][j]; for (int k = 1;k &lt;= top;k++) val += g[j][a[k]]; for (int k = 0;j * k &lt;= i;k++) &#123; Inc(dp[i - j * k][j - 1], (LL)tmp * inv[k] % mod); tmp = (LL)tmp * inv[j] % mod * frac[j - 1] % mod * Pow2[val] % mod; &#125; &#125; return (LL)dp[0][0] * frac[m] % mod;&#125;inline int calc() &#123; // for (int i = 1;i &lt;= top;i++) cout &lt;&lt; a[i] &lt;&lt; ' '; // cout &lt;&lt; endl; int res = frac[n]; for (int i = 1;i &lt;= top;i++) &#123; int cnt = 1; while (i &lt;= top &amp;&amp; a[i] == a[i + 1]) i++, cnt++; res = (LL)res * Pow(Pow(a[i], cnt), mod - 2) % mod * inv[cnt] % mod; &#125; return (LL)res * solve() % mod;&#125;int ans = 0;void dfs(int n, int cur, int dep) &#123; if (n &lt; 0) return; if (!n) &#123;top = dep, Inc(ans, calc()); return;&#125; if (n &lt; cur) return; dfs(n, cur + 1, dep); a[++dep] = cur, dfs(n - cur, cur, dep);&#125;int main() &#123; frac[0] = inv[0] = Pow2[0] = 1; for (int i = 1;i &lt;= N - 10;i++) frac[i] = (LL)frac[i - 1] * i % mod, inv[i] = Pow(frac[i], mod - 2), Pow2[i] = Pow2[i - 1] * 2 % mod; for (int i = 0;i &lt;= N - 10;i++) for (int j = 0;j &lt;= i;j++) g[i][j] = g[j][i] = gcd(i, j); scanf("%d%d", &amp;n, &amp;m); if (n &gt; m) swap(n, m); dfs(n, 1, 0); printf("%d\n", (LL)ans * inv[n] % mod * inv[m] % mod); return 0;&#125; 其中，inv[i]表示i的阶乘的逆元，g[i][j]表示$gcd(i,j)$，Pow2[i]表示$2^i$，frac[i]表示$i!$ 那个inv[j] * frac[j - 1]等价于除以j 注意最后需要将答案除以置换总数$n!m!​$]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>题解</tag>
        <tag>置换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[置换专题]]></title>
    <url>%2F2019%2F03%2F08%2F%E7%BD%AE%E6%8D%A2%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[A – Necklace of BeadsBurnside定理模板 假设有n个条件$S$，每个条件都是形如“$A$与$B$等价”的形式，要求集合$X$在这些条件下的方案数 将条件分解成循环的形式，那么方案数 $$=\frac{1}{n}\sum_{g\in S}|X^g|$$ 其中，$X^g$是置换$g$作用于集合$X$之后的不动点个数，即不变的元素的个数 那么对于这道题，我们考虑两类置换 1.旋转 假设有一条长度为n的项链，旋转之后相同被视为相同方案，那么显然地，我们有n种对应的置换 即不旋转，旋转1次，旋转2次，…，旋转n-1次 考虑计算不动点个数 假设现在旋转了2次 如果要求旋转之后不变（不动点），那么1号点、3号点、5号点的颜色必须相同 因为1号点转一次可以转到3号点，而3号点转一次可以转到5号点 如果这三个点的颜色不相同，那么旋转之后就变了，不能再称之为不动点 同理，2号点、4号点、6号点的颜色必须相同 总结一下： 对于长度为n的项链，旋转i次之后得到的不动点个数为$gcd(i,n)$ 不动点之间互不影响，假设有m种颜色，那么此时的染色方案为$m^{gcd(i,n)}$ 2.翻转 分奇偶考虑 先考虑奇数 一条对称轴必定穿过一个顶点，也就是说，一个顶点对应一条对称轴 如果要满足变换之后不变，显然2、5号点必须相等，3、4号点必须相等，1号点随意 如果有n个点，m种颜色，且n为奇数，那么这种置换一共有n个，每种置换有$m^{\frac{n+1}{2}}$种方案 考虑偶数的情况 稍微麻烦一点 1.对称轴穿过一条边的中点，不穿过点 显然，此时有$m^{\frac{n}{2}}$种方案，共$\frac{n}{2}$种置换 2.对称轴穿过两个点 其它点两两配对，这两个点随便染色 共$m^{\frac{n-2}{2}+2}$种方案，共$\frac{n}{2}$种置换 最后除以置换总数2n即可 B – Let it Bead和A题相同，将颜色数从3改为m即可 C – ColorN颗珠子，N种颜色，而且$N\leq 10^9$ 显然枚举旋转方案i不行 考虑枚举gcd 假设gcd=x，那么实际上就是要计算有多少个i满足$i\leq n$且$gcd(i,n)=x$ 首先，x必须是n的因数，而且是i的因数 假设$n=x*a,i=x*b$，那么a与b互质 所以，i的个数为$\varphi(\frac{n}{x})$ x只有$\sqrt n$种取值 筛一下2e5之内的质数即可 D – Magic Braceletn颗珠子，m种颜色，k种限制，每种限制形如“颜色a与颜色b不能放在一起” 先不管限制 考虑旋转i步之后的状态 假设虚线中是一个循环节，显然，1号点和5号点的颜色应当相同，而与2、3、4、5号点的颜色无关 如果要求满足限制，那么在上图中的含义等价为“放5颗珠子，第1颗珠子与第5颗珠子颜色相同并且满足限制的方案数” 循环节长度为i，那么珠子数就为i+1 将这个过程想象成一张图 如果a与b不能相邻，那么点a到点b之间没有边，否则有一条双向边 最开始的图是一张完全图，每个条件会删去一条双向边 答案就等于在这张图上走i+1步，且起点与终点相同的方案数 这张图的邻接矩阵是一个01矩阵，那么走i+1步就是取这个矩阵的i次方 答案为对角线上的数之和 由于又是$n\leq 10^9$，所以需要矩阵乘法 剩下的和上一道题一样，先筛质数然后求$\varphi$即可 E – Who’s Aunt Zhang一个三阶魔方，给每个面、每个角、每条棱上色，共n中颜色，将魔方整体旋转之后相同的视为等价情况，问方案数 首先面数+棱数+角数=54+12+8=74 有4类置换 1.不动方案数$n^{74}$ 有1种置换 2.以某个面的中心为轴旋转 有3种方案：转90度、转180度、转270度 注意到第一种方案和第三种方案要求轴所在的那一面的四条棱都相等，而第二种方案仅要求两条棱相等 对于第一种和第三种方案，答案为$n^{20}$ 正对着的两个面共有$3*2$)种方案 中心有1种，棱上的面有1种，角上的面有1种，这样的面有2个，所以有6种 剩下的四个面染色方案必须一样，但每个面中的颜色独立，共9种 正对着的两个面每个面上的棱只有1种方案，共2种 剩下的四条棱有1种 角分为两组，坐标一组，右边一组，每组颜色必须相同，共2种 所以共$6+9+3+2=20$种方案 置换个数为$2*3=6$种（以某两个面为轴，转90度或270度） 对于第二种方案，答案为$n^{38}​$ 正对着的两个面上，将面两两分组，每组颜色必须相同 共$(2+2+1)*2=10​$种（角上的面两种，棱上的面两种，中心一种，共两个这样的面） 其余的四个面两两配对，每个面上颜色独立，共$9*2=18$种 将棱两两配对，每对的颜色必须相同，共6种 将角两两配对，每对的颜色必须相同，共4种 总方案数为$10+18+6+4=32$种 置换有3种（将面两两配对，每一对只有1种置换） 以相对的两个角为中心旋转 在这种情况下，旋转120度和旋转240度是等价的 都有$n^{26}$种方案 对着的两个角特殊考虑，其余的角、边、棱三个为一组，每组颜色互不影响，共$2+\frac{74-2}{3}=26$种 共$2*4=8​$种置换 以相对的两条棱的中心为轴旋转 选中的两条棱特殊考虑，其余元素两两配对 共$2+\frac{74-2}{2}=38$种方案 有$\frac{12}{2}=6$种置换 所以总置换数为24，最后除以24即可 F – Toy前置题目轮状病毒 首先不考虑等价的情况 有两种方法 矩阵树定理+打表(oeis) 矩阵是度数矩阵-邻接矩阵，再随便去掉某一行和某一列 然后打表 递推 先不考虑连成环的情况 设$f(n)$表示除了中心点，还有n个点的生成树个数 那么有 $$f(n)=\sum_{i=1}^{n}f(n-i)*i$$ 含义是，假设这次选取的连通块有i个节点，剩下的点共有$f(n-i)$种方案，这个连通块可以选择任意一个点连向中心点，共i种方案 化简这个式子 $$f(n)=\sum_{i=0}^{n-1}f(i)*(n-i)$$ $$f(n-1)=\sum_{i=0}^{n-2}f(i)*(n-i-1)$$ $$f(n)=f(n-1)+\sum_{i=0}^{n-1}f(i)$$ $$f(n-1)=f(n-2)+\sum_{i=0}^{n-2}f(i)$$ $$f(n)-f(n-1)=f(n-1)-f(n-2)+f(n-1)$$ $$f(n)=3f(n-1)-f(n-2)$$ 注意这个式子仅当$n\geq 3$时成立 考虑连成环的情况 就是1号点和n号点连了起来 假设这个连通块有i个点 那么有i-1种连通块可以选择（包含1-n这条边的连通块数），随便选一个点连向中心点 设方案数为$g(n)$ 那么 $$g(n)=\sum_{i=2}^{n}i*(i-1)*f(n-i)$$ $$=\sum_{i=1}^{n}i*(i-1)*f(n-i)$$ 总方案数 $$F(n)=f(n)+g(n)$$ $$=\sum_{i=1}^{n}f(n-i)*i^2$$ 我们有$f(0)=1,f(1)=1,f(2)=3$ $$\because \sum_{i=n-2}^nf(n-i)*i^2=3*(n-2)^2+(n-1)^2+n^2$$ $$=3*(n-1)^2+2*(n-2)^2+2$$ $$\therefore F(n)=\sum_{i=1}^{n-3}f(n-i)*i^2+3*(n-1)^2+2*(n-2)^2+2$$ $$\because n-i\geq 3$$ $$\therefore F(n)=\sum_{i=1}^{n-3}[3*f(n-i-1)-f(n-i-2)]*i^2+3*(n-1)^2*f(0)+(n-2)^2*[3*f(1)-f(0)]+2$$ $$=\sum_{i=1}^{n-2}[3*f(n-i-1)-f(n-i-2)]*i^2+3*(n-1)^2*f(0)+2$$ $$=3*\sum_{i=1}^{n-1}f(n-i-1)*i^2-\sum_{i=1}^{n-2}f(n-i-2)+2$$ $$=3*F(n-1)-F(n-2)+2$$ 写成矩阵的形式就是 $$\begin{bmatrix}3&amp;-1&amp;2\\\1&amp;0&amp;0\\\0&amp;0&amp;1\end{bmatrix}^{n-2}*\begin{bmatrix}F(2)\\\F(1)\\\1\end{bmatrix}$$ 然后再求欧拉函数，枚举gcd即可 G – Birthday Toy考虑n个位置，m种颜色，要求相邻颜色不同，并且首位颜色一样的方案数（$n,m\leq 10^9$） 先考虑朴素的dp:dp[i][j][k]表示到了第i个位置，这一位颜色为j，最开始的颜色为k的方案数 转移很好转移 考虑优化：我们并不关心当前位置的颜色是什么，我们只关心它与首位颜色相不相同，所以可以简化状态 dp[i][0/1]表示到了第i位，与当前首位颜色相同/不相同的方案数 那么有 12dp[i][0]=dp[i-1][1]dp[i][1]=dp[i-1][0]*(m-1)+dp[i-2][1]*(m-2) 矩阵乘法加速即可 I – Leonardo’s Notebook结论： 两个长度为n的相同循环相乘，当n为奇数是结果是一个长为n的循环，否则是两个长度为$\frac{n}{2}$的循环的乘积 所以长度为奇数的循环一定可以被拆成两个相同循环的乘积，长度为偶数的循环需要两两配对，如果能配对上就可以 K – Find the Permutations下标与序列构成了一个置换 将置换分解，注意到每个循环所需要的交换次数是循环长度-1 加起来就是n-循环节个数 所以dp，dp[i][j]表示到第i个位置，一共有j个循环的方案数 i这个数可以新开一个循环，也可以插入到前面任意一个数的后面 1dp[i][j]=dp[i-1][j-1]+dp[i-1][j]*(i-1) L – Necklace每种颜色的珠子有限制个数 还是枚举gcd，但是要求$\frac{n}{gcd}$必须是每种珠子个数的因数 然后可重排列 翻转有点毒瘤，考虑两种情况：n为奇数或是偶数 奇数比较简单，偶数又要分两种情况 注意细节，还是比较模板的 M – CubesL + E]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>矩阵乘法</tag>
        <tag>置换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫比乌斯反演与杜教筛专题]]></title>
    <url>%2F2019%2F03%2F08%2F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E4%B8%8E%E6%9D%9C%E6%95%99%E7%AD%9B%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[A – GCD莫比乌斯反演模板，注意去重 当$i\leq min(n,m)$时，每个gcd都被计算了两遍，除以2即可 B – CA Loves GCD见莫比乌斯反演 CA Loves GCD C – Hillan and the girl首先转化成总数-gcd是完全平方数的个数 $$\sum_{i=1}^{n}\sum_{j=1}^{n}[gcd(i,j)\in sqrt number]$$ 按照套路，先枚举gcd，此处是gcd的平方根 $$=\sum_{d=1}^{\sqrt n}\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=d^2]$$ 莫比乌斯反演 $$=\sum_{d=1}^{\sqrt n}\sum_{l=1}^{\lfloor\frac{n}{d^2}\rfloor}\mu(l)\lfloor\frac{n}{d^2l}\rfloor\lfloor\frac{m}{d^2l}\rfloor$$ 然后换T $$T=d^2l$$ 改写式子 $$=\sum_{T=1}^{n}\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor\sum_{l|T}\mu(l)$$ 最后那个可以预处理 对于每一个$\mu$，枚举一个完全平方数更新，最后算一下前缀和即可 D – Trick GCD很经典的一道题 题目要求$gcd\geq 2$，转化成求$gcd=1$的方案数，再用总数去减 设$f(x)$为gcd恰好为x的方案数，$g(x)$为gcd为x的倍数的方案数 显然有 $$g(x)=\sum_{x|d}f(d)$$ $$f(x)=\sum_{x|d}g(d)\mu(\frac{d}{x})$$ 此时f中的x是1 现在关键是要求出g 假设当前是$g(x)$ 对于每一个$A_i$，有$\lfloor\frac{A_i}{x}\rfloor$的贡献，注意到一段区间内的$A_i$贡献相同，所以对A整体分块计算贡献，然后乘起来就好了 一部分代码 12345678for (int i = 1, a;i &lt;= n;i++) scanf("%d", &amp;a), buk[a]++, mn = min(mn, a), mx = max(mx, a);for (int i = 1;i &lt;= mx * 2;i++) buk[i] += buk[i - 1]; for (int i = 2;i &lt;= mn;i++) &#123; int tmp = -mu[i]; for (int j = i;j &lt;= mx;j += i) tmp = (LL)tmp * Pow(j / i, buk[j + i - 1] - buk[j - 1]) % mod; ans = (ans + tmp) % mod;&#125; E,F,G – GCD Extreme(x)直接用$\varphi$替换gcd即可 经典题目 H – Zap莫比乌斯反演模板 上界同时除以d即可 I – 数表求 $$\sum_{i=1}^{n}\sum_{j=1}^{m}\sigma(gcd(i,j))[\sigma(gcd(i,j))\leq a]$$ 先莫比乌斯反演一波 $$=\sum_{i=1}^{n}\sum_{j=1}^{m}\sigma(gcd(i,j))[\sigma(gcd(i,j))\leq a]$$ $$=\sum_{d=1}^{n}\sigma(d)[\sigma(d)\leq a]\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=d]$$ $$=\sum_{d=1}^{n}\sigma(d)[\sigma(d)\leq a]\sum_{l=1}^{\lfloor\frac{n}{d}\rfloor}\mu(l)\lfloor\frac{n}{dl}\rfloor\lfloor\frac{m}{dl}\rfloor$$ 设 $$T=dl$$ 改写式子 $$=\sum_{T=1}^{n}\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor\sum_{d|T}\sigma(d)\mu(\frac{T}{d})[\sigma(d)\leq a]$$ 约数和这个函数是可以直接求的 考虑将询问按照限制大小从小到大排序 将约数和也从小到大排序 当一个约数和达到限制以下后，枚举它的倍数更新 由于计算要用到前缀和，使用树状数组维护即可 J – Crash的数字表格见莫比乌斯反演 K – DZY Loves Math神仙题 先来反演一波 $$\sum_{i=1}^{n}\sum_{j=1}^{m}f(gcd(i,j))$$ $$=\sum_{d=1}^{n}f(d)\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=d]$$ $$=\sum_{d=1}^{n}f(d)\sum_{l=1}^{\lfloor\frac{n}{d}\rfloor}\mu(l)\lfloor\frac{n}{dl}\rfloor\lfloor\frac{m}{dl}\rfloor$$ 设 $$T=dl$$ 则有 $$=\sum_{T=1}^{n}\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor\sum_{d|T}f(d)\mu(\frac{T}{d})$$ 关键就是要求最后的那个东西 假设有$T=\prod p_i^{k_i}$，要想最后的那个$\mu$不为0，d的每一个质数的次数最少不会少于T中所对应的次数-1 也就是说，假如$f(T)=x$，那么$x-1\leq f(d)\leq x$ 进一步考虑，最后可能影响答案的只有那些次数最高的项。如果T中质数的次数不全相等，那么对于$f(d)=x$的每一种方案，其它的项可以乱选，方案数是2的这些项的个数次方（要么次数不减，要么次数减1） 注意到$\mu(\frac{T}{d})$的值在上述的这两种情况中取值互为相反数，仅当T中质数的次数全部相等时，剩余项的方案数是$2^0$，在这一步中不能被抵消，其余情况均可两两抵消，这个$\sum$的值永远是0 考虑所有次数相等的情况 假设T的质因子个数为k 每个数仍然可以选或不选，$\mu$的和为0 但是对于所有质数都不选的情况，$f(d)$的值并不是x，而是x-1，所以答案要减去$-1*(-1)^k$，那个$(-1)^l$是$\mu(\frac{T}{d})$ 所以此时的答案为 $$(-1)^{k+1}$$ 假设当前要求的是 $$\sum_{d|T}f(d)\mu(\frac{T}{d})$$ 那么： 假设存在x，使得$\mu(x)\not=0$，且T是x的k次方，那么$\sum_{d|T}f(d)\mu(\frac{T}{d})=-\mu(x)]$ 否则这个值为0 代码如下 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;#define N 10000010#define LL long longint prime[N], ncnt, mu[N], sum[N], flag[N];inline void sieve() &#123; mu[1] = 1; for (int i = 2;i &lt;= N - 10;i++) &#123; if (!flag[i]) prime[++ncnt] = i, mu[i] = -1; for (int j = 1;j &lt;= ncnt &amp;&amp; i * prime[j] &lt;= N - 10;j++) &#123; flag[i * prime[j]] = 1; if (i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; &#125; for (int i = 2;i &lt;= N - 10;i++) if (mu[i] != 0) for (LL j = i;j &lt;= N - 10;j *= i) sum[j] = -mu[i]; for (int i = 2;i &lt;= N - 10;i++) sum[i] += sum[i - 1]; &#125; inline LL solve(int n, int m) &#123; if (n &gt; m) swap(n, m); LL ans = 0; for (int l = 1, r;l &lt;= n;l = r + 1) &#123; r = min(n / (n / l), m / (m / l)); ans += (LL)(n / l) * (m / l) * (sum[r] - sum[l - 1]); &#125; return ans;&#125;int main() &#123; int T; scanf("%d", &amp;T), sieve(); while (T--) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); printf("%lld\n", solve(a, b)); &#125;&#125; L – Sum杜教筛模板 见杜教筛 M – 能量采集讲一讲求 $$\sum_{i=1}^{n}\sum_{j=1}^{m}gcd(i,j)$$ 的两种求法 以前已经写过了，直接贴上来 第二种方法 可以看出选择合适的解法的重要性 N – DZY Loves Math VI还是套路，先设出gcd，然后反演，最后换T 精雕细琢即可]]></content>
      <tags>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>杜教筛</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的数学题]]></title>
    <url>%2F2019%2F03%2F08%2F%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98%2F</url>
    <content type="text"><![CDATA[求 $$\sum_{i=1}^{n}\sum_{j=1}^{n}ijgcd(i,j)$$ $$n\leq 10^{10}$$ 根据$\varphi$的性质 $$\sum_{i|d}\varphi(i)=d$$ 可以改写上面那个式子 $$=\sum_{i=1}^{n}\sum_{j=1}^{n}ij\sum_{d|gcd(i,j)}\varphi(d)$$ 把d提到前面来 $$=\sum_{i=1}^{n}\sum_{j=1}^{n}ij\sum_{d|gcd(i,j)}\varphi(d)$$ 为了方便快捷，设 $$F(n)=\sum_{i=1}^{n}i$$ 那么原式就改写为 $$=\sum_{d=1}^{n}\varphi(d)*d^2*F(\lfloor\frac{n}{d}\rfloor)^2$$ 注意到后面的那个F括号内只有$\sqrt n$种取值，直接分块 现在关键就是要求前面那个的前缀和 但是有$n\leq 10^{10}$，直接筛显然不行，所以上杜教筛 设 $$S(n)=\sum_{i=1}^{n}\varphi(i)*i^2$$ 现在关键就是要找一个函数g来与$f(i)=\varphi(i)*i^2$卷积 观察到有$\sum_{i|d}\varphi(i)=d$，所以中间的那个$\varphi$可以不管 但是那个$i^2$很烦，要弄掉这个 所以考虑使用$g(x)=x^2$这个函数来卷积 根据杜教筛的公式 $$g(1)S(n)=\sum_{i=1}^{n}(g*f)(i)-\sum_{i=2}^{n}g(i)S(\lfloor\frac{n}{i}\rfloor)$$ 这个$(g*f)(i)$其实就是 $$\sum_{j=1}^{i}\varphi(j)*j^2*\frac{n^2}{j^2}=n^3$$ 而$g(1)=1^2=1$ 所以 $$S(n)=\sum_{i=1}^{n}i^3-\sum_{i=2}^{n}i^2S(\lfloor\frac{n}{i}\rfloor)$$ 有神仙公式 $$\sum_{i=1}^{n}i^3=(\sum_{i=1}^{n}i)^2$$ 以及 $$\sum_{i=1}^{n}i^2=\frac{1}{6}n*(n+1)*(2n+1)$$ 记忆化一波就可以了]]></content>
      <tags>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>杜教筛</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杜教筛]]></title>
    <url>%2F2019%2F03%2F08%2F%E6%9D%9C%E6%95%99%E7%AD%9B%2F</url>
    <content type="text"><![CDATA[假设有一道题：求 $$\sum_{i=1}^{n}\mu(i)$$ 然后$n\leq 10^9$ 线筛大家都知道怎么做 考虑把这个东西转化 设 $$S(n)=\sum_{i=1}^{n}\mu(n)$$ 我们知道 $$\sum_{i|d}\mu(i)=[d=1]$$ 如何利用这个性质呢？考虑用另一个函数来与这个$\mu$卷积 我们使用1来卷，因为没有什么要抵消的 $$\sum_{i|d}\mu(i)*1 = [d=1]=(\mu*1)(d)$$ $$1=\sum_{d=1}^{n}\sum_{i|d}\mu(\frac{d}{i})*1$$ $$=\sum_{i=1}^{n}\sum_{d=1}^{\lfloor\frac{n}{i}\rfloor}\mu(d)=\sum_{i=1}^{n}S(\lfloor\frac{n}{i}\rfloor)$$ 我们已经将这个东西转化成了$S$，移一下项 $$1=\sum_{i=1}^{n}S(\lfloor\frac{n}{i}\rfloor)$$ $$1-\sum_{i=2}^{n}S(\lfloor\frac{n}{i}\rfloor)=S(n)$$ 注意到$\lfloor\frac{n}{i}\rfloor$的取值不超过$\sqrt n$个，直接分块即可 然后DFS 记得要记忆化！！！ 一般式假设要求一个积性函数$f(x)$的前缀和$S(n)$ 先找到另一个积性函数$g(x)$，与f做卷积 这个g函数的要求有几点： 1.前缀和很好求，要不然找g之后反而更慢 2.与f的卷积的前缀和很好求 开始 $$(g*f)(d)=\sum_{i|d}g(i)f(\frac{d}{i})$$ $$\sum_{i=1}^{n}(g*f)(i)=\sum_{i=1}^{n}\sum_{d|i}g(d)f(\frac{i}{d})$$ 枚举d $$=\sum_{d=1}^{n}g(d)\sum_{d|i}f(\frac{i}{d})$$ $$=\sum_{d=1}^{n}g(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}f(i)$$ $$=\sum_{d=1}^{n}g(d)S(\lfloor\frac{n}{d}\rfloor)$$ 移项 $$g(1)S(n)=\sum_{i=1}^{n}(g*f)(i)-\sum_{i=2}^{n}g(i)S(\lfloor\frac{n}{i}\rfloor)$$ 然后开始分块即可 代码其实很短 123456789101112map&lt;int, int&gt; m;// sum[N - 10] 是预处理的前缀和，一般大小为3e6inline int calc(int n) &#123; // 算 sum mu if (n &lt;= N - 10) return sum[n]; else if (m.count(n)) return m[n]; // 记忆化 int res = 1; for (LL l = 2, r;l &lt;= n;l = r + 1) &#123; r = n / (n / l); res -= (r - l + 1) * calc1(n / l); &#125; return m1[n] = res;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>算法</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫比乌斯反演]]></title>
    <url>%2F2019%2F03%2F07%2F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[一些定义 $\mu(i)$ 莫比乌斯函数 设$i=p_1^{k_1} p_2^{k_2} p_3^{k_3} \cdots p_m^{k_m}$ 当$max(k) &gt; 1$时$\mu(i)=0$ 否则$\mu(i)=(-1)^{\sum k}$ $\varphi(i)$ 欧拉函数，为$[1,i]$内与i互质的数的个数 设$n=p_1^{k_1} p_2^{k_2} p_3^{k_3} \cdots p_m^{k_m}$ 则$\varphi(n)=n*\prod{(1-\frac{1}{p_i})}$ 关于狄利克雷卷积 定义二元关系$_​$，$f_g ​$的狄利克雷卷积为 $$(f*g)(n)=\sum_{d|n}f(d)g(\frac{n}{d})​$$ 卷积满足交换律 $$f*g=g*f$$ 结合律 $$(f*g)*h=f*(g*h)$$ 单位元 $$e(n)=[n=1]$$ $$\displaystyle f*e=f$$ 逆元 $$f*f^{-1}=e$$ 一些性质$$\sum_{d|n}\mu(d)=[n=1]$$ $$\displaystyle \sum_{d|n}\varphi(d)=n$$ $\mu$与$\varphi$都是积性函数，可以线性筛 1234567891011121314151617#define N 10000010int flag[N], prime[N], mu[N], ncnt;inline void sieve() &#123; mu[1] = 1; for (int i = 2;i &lt;= N - 10;i++) &#123; if (!flag[i]) mu[i] = -1, prime[++ncnt] = i; //i是质数，mu[i]为-1 for (int j = 1;j &lt;= ncnt &amp;&amp; i * prime[j] &lt;= N;j++) &#123; flag[i * prime[j]] = 1; //筛质数用 if (i % prime[j] == 0) break; //此时根据定义，mu为0 mu[i * prime[j]] = -mu[i]; //mu[i * prime[j]] = mu[i] * mu[prime[j]] = -mu[i] &#125; &#125;&#125; 积性函数都可以线性筛 莫比乌斯反演： 定理1 若 $$F(n)=\sum_{d|n}f(d)$$ 则 $$f(n)=\sum_{d|n}F(d)\mu(\frac{n}{d})$$ 定理2 若 $$F(n)=\sum_{n|d}f(d)$$ 则 $$f(n)=\sum_{n|d}F(d)\mu(\frac{n}{d})$$ 证明 $$F=f*1$$ 有 $$\mu(n)*1=\sum_{d|n}\mu(d)*1=[n=1]=e$$ 所以$$\mu^{-1}=1$$ $$F=f*1=f*\mu^{-1}$$ $$F*\mu=f$$ $$f(n)=(F*\mu)(n)=\sum_{d|n}F(d)\mu(\frac{n}{d})$$ 一些套路以Crash的数字表格为例 求 $$\sum_{i=1}^{n}\sum_{j=1}^{m}lcm(i,j)$$ 套路1.设出$gcd$，然后按照$gcd$分类$$\sum_{k=1}^{n}\sum_{i=1}^{n}\sum_{j=1}^{m}\frac{i*j}{k}[gcd(i,j)=k]$$ 方法1.凑出$[gcd(i,j)=1]$然后使用$\mu$函数的性质换元将i,j同时除以k，注意$\frac{i*j}{k}$需要乘回去 $$\sum_{k=1}^{n}\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}i*j*k[gcd(i,j)=1]$$ 有$$\sum_{d|n}\mu(d)=[n=1]$$ 所以 $$[gcd(i,j)=1]=\sum_{d|gcd(i,j)}\mu(d)$$ 方法2.使用莫比乌斯反演基本公式设 $$f(x)=\sum_{i=1}^{n}\sum_{j=1}^{m}\frac{i*j}{x}[gcd(i,j)=x]$$ $$\displaystyle F(x)=\sum_{i=1}^{n}\sum_{j=1}^{m}\frac{i*j}{x}[x|gcd(i,j)]$$ 改写一下$F$ 由于$gcd$是x的倍数，所以n,m都是x的倍数 同时除以x $$F(x)=\sum_{x|d}f(x)=\sum_{i=1}^{\lfloor\frac{n}{x}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{x}\rfloor}i*j*x$$ 套用反演公式 $$f(x)=\sum_{x|d}F(d)\mu(\frac{d}{x})$$ 得到 $$f(x)=\sum_{x|d}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}i*j*d*\mu(\frac{d}{x})$$ 代入原式即可 个人推荐推式子的时候用第一种方法，使用莫比乌斯反演容斥的时候使用第二种方法 从方法1的最后一步继续 $$\sum_{k=1}^{n}\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}i*j*k[gcd(i,j)=1]$$ $$=\sum_{k=1}^{n}\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}i*j*k\sum_{d|gcd(i,j)}\mu(d)$$ 套路2.枚举d，并放到前面去此时i,j都应该是d的倍数 同样，注意要乘回去 $$=\sum_{k=1}^{n}k\sum_{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d)\sum_{i=1}^{\lfloor\frac{n}{kd}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{kd}\rfloor}i*j*d^2$$ 整理一下 $$=\sum_{k=1}^{n}k\sum_{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d)*d^2\sum_{i=1}^{\lfloor\frac{n}{kd}\rfloor}i\sum_{j=1}^{\lfloor\frac{m}{kd}\rfloor}j$$ 为了方便快捷，设$$F(n)=\sum_{i=1}^{n}i$$将原式替换成$$=\sum_{k=1}^{n}k\sum_{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d)*d^2*F(\lfloor\frac{n}{kd}\rfloor)*F(\lfloor\frac{m}{kd}\rfloor)$$ 套路3.换T大法为了提升时间复杂度，我们需要设一个神奇的T 设$$T=kd$$所以原式等于$$\sum_{k=1}^{n}k\sum_{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d)*d^2*F(\lfloor\frac{n}{T}\rfloor)*F(\lfloor\frac{m}{T}\rfloor)$$枚举T，放到最前面$$\sum_{T=1}^{n}F(\lfloor\frac{n}{T}\rfloor)*F(\lfloor\frac{m}{T}\rfloor)\sum_{d|T}\mu(d)*\frac{T}{d}*d^2$$ $$\sum_{T=1}^{n}F(\lfloor\frac{n}{T}\rfloor)*F(\lfloor\frac{m}{T}\rfloor)\sum_{d|T}\mu(d)*d$$ 考虑优化最后那一坨的求法 直接求显然是$n log n$的 套路4.设出积性函数观察到$\mu$以及$f(x)=x$（它还有个名字叫id）都是积性函数 两个积性函数的狄利克雷卷积以及直接对应相乘的结果都是积性函数 也就是说，这个东西是可以线性筛的 设$$g(x)=\sum_{d|x}\mu(d)*d$$对x分类 x是质数 此时显然有$g(x)=1-x$ x被表示成了$i*prime[j]$，其中$prime[j]\bot i$ 此时根据积性函数性质，$g(i_prime[j])=g(i)_g(prime[j])$，直接乘即可 x被表示成了$i*prime[j]$，其中$prime[j]|i$ 考虑乘之后多出来的因数 由于多出来的因数prime[j]这个质数的次数至少是2，而根据$\mu$的定义此时$\mu$为0，对g没有贡献，直接忽略即可 所以此时$g(i*prime[j]$ 套路5.数论分块预处理完了g，我们再来说说最后答案怎么求 答案等于$$\sum_{T=1}^{n}F(\lfloor\frac{n}{T}\rfloor)*F(\lfloor\frac{m}{T}\rfloor)*g(T)$$考虑从$\lfloor\frac{n}{T}\rfloor$,$\lfloor\frac{m}{T}\rfloor$ 开始优化 可以发现对于某一段的T，上面的两个式子的值都是不变的 这种不变的值的段数一共有$\sqrt n​$段 考虑一段一段地枚举，而不是一个一个的枚举 此时变化的就只有$g(T)$ 对$g(T)$求一下前缀和，算的时候直接求区间的和就好了 代码如下 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define LL long longconst LL mod=20101009;int flag[10000010],prime[10000010],cnt,f[10000010],sum[10000010];// sum是前缀和，f就是gvoid sieve() &#123; f[1]=sum[1]=1; for (int i=2;i&lt;=10000000;i++) &#123; if (!flag[i]) prime[++cnt]=i,f[i]=(1-i+mod)%mod; for (int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=10000000;j++) &#123; flag[i*prime[j]]=1; if (i%prime[j]==0) &#123; f[i*prime[j]]=f[i]%mod; break; &#125; f[i*prime[j]]=(LL)f[i]*f[prime[j]]%mod; &#125; sum[i]=(sum[i-1]+(LL)f[i]*i%mod)%mod; &#125;&#125;LL zjk(LL n,LL m) &#123; LL ans=0; if (n&gt;m) swap(n,m); for (LL l=1,r;l&lt;=n;l=r+1) &#123; r=min(n/(n/l),m/(m/l)); // 分块：[l,r] ans=(ans+((n/l*(n/l+1)/2)%mod*((m/l*(m/l+1)/2)%mod))%mod*(LL)(sum[r]-sum[l-1]))%mod; &#125; return (ans+mod)%mod;&#125;int main() &#123; sieve(); int n,m;scanf("%d%d",&amp;n,&amp;m); printf("%lld\n",zjk(n,m));&#125; %%% ZJK 下面讨论一下使用莫比乌斯反演来容斥的题 CA Loves GCD 题意：给出n个[1,1000]的数，问所有选法中所选择的数的gcd的和 $n \leq 1000$ 首先，还是对gcd分类，$f(i)$表示gcd为i的方案数 发现f好像很不好求，考虑设辅助函数 设$g(i)$表示gcd是i的倍数的方案数 很显然，在一个gcd为i的集合中，每一个数都是i的倍数 那么我们假设在这n个数中，i的倍数一共有k个 每个数可以选或者不选，一共有$2^k$种方案 减去所有数都不选的情况，就这一种 之后得到的就是$g(i)$的值 将g转化成f 显然有$$g(i)=\sum_{i|d}f(i)$$反演得$$f(i)=\sum_{i|d}g(d)\mu(\frac{i}{d})$$对于每一个i，枚举每一个i的倍数转移即可 对于如何求i的倍数的个数，可以开一个桶。先预处理每个数的约数，当输入一个数a时，就把a的所有约数在桶中加一，最后桶中的第i个位置就是i的倍数的个数 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1010vector&lt;int&gt; Div[N];int flag[N], prime[N], ncnt, mu[N], Pow[N];#define LL long longconst int mod = 1e8 + 7;inline void sieve() &#123; Pow[0] = 1, Pow[1] = 2, mu[1] = 1; for (int i = 2;i &lt;= N - 10;i++) &#123; Pow[i] = Pow[i - 1] * 2 % mod; if (!flag[i]) mu[i] = -1, prime[++ncnt] = i; for (int j = 1;j &lt;= ncnt &amp;&amp; i * prime[j] &lt;= N - 10;j++) &#123; flag[i * prime[j]] = 1; if (i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; for (int j = i;j &lt;= N - 10;j += i) Div[j].push_back(i); &#125; for (int i = 1;i &lt;= N - 10;i++) Div[i].push_back(1);&#125;int buk[N], ans[N], tmp[N];int main() &#123; int T; scanf("%d", &amp;T), sieve(); while (T--) &#123; int n; scanf("%d", &amp;n), memset(buk, 0, sizeof(buk)), memset(tmp, 0, sizeof(tmp)); for (int i = 1, a;i &lt;= n;i++) scanf("%d", &amp;a), tmp[a]++; for (int i = 1;i &lt;= 1000;i++) if (tmp[i]) for (int j = 0;j &lt; Div[i].size();j++) buk[Div[i][j]] += tmp[i]; memset(ans, 0, sizeof(ans)); for (int i = 1;i &lt;= 1000;i++) for (int j = i;j &lt;= 1000;j += i) ans[i] = (ans[i] + (Pow[buk[j]] - 1) * mu[j / i] + mod) % mod; int res = 0; for (int i = 1;i &lt;= 1000;i++) res = (res + (LL)i * ans[i] % mod) % mod; printf("%d\n", res); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>算法</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组]]></title>
    <url>%2F2019%2F03%2F07%2F%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[一些约定 _sa[i]_ 排名为_i_的后缀在原串中的编号 _rk[i]_ 原串中第_i_个后缀所对应的排名 _height[i]_ 排名为_i_的后缀与排名为_i – 1_的后缀的最长公共前缀 一些例子字符串_S = bacaab_ 中，_sa，rk，height_分别为 一些解释在_S_中，所有的后缀分别为_bacaab, acaab, caab, aab, ab, b_ 将这些串按照字典序排序，可以得到_aab, ab, acaab, b, bacaab, caab_ 对应出来的_rk_值就是5, 3, 6, 1, 2, 4 根据上面的定义可以得出_sa[rk[i]] = i, rk[sa[i]] = i_ _sa[1] = 4_ 对应后缀_aab_，_sa[2] = 5_ 对应后缀_ab_ 因此_height[2]_ = _lcp(sa[1], sa[2]) = lcp(aab, ab) = 1_ 注：_height[1]_ 没有意义，约定其等于0 倍增直接暴力求_sa_显然不行，由于涉及到后缀排序，所以考虑倍增 假设对于每个后缀的前k个字符，我们已经排好了序，考虑进一步的转移 如果直接比较每个后缀的第_k + 1_个字符，忽视了太多已经求出的信息 对于两个后缀_s1 = S[i, …], s2 = S[j,_ …]，如果它们的前_k_个字母不全相同，那么我们在之前的比较中就已经确定好了这两个后缀的顺序 如果这两个后缀的前_k_个字母都相同，我们这次就比较_s1[k + 1, 2k], s2[k + 1, 2k]_的大小 显然，这两个串的长度都是_k_，这意味着我们已经比较过这两个串 图中括号中的数字表示当前层中此串的排名，注意相同串的排名相同。 第一次比较将串_s1_与_s2_拼在一起，将串_s2_与_s3_拼在一起… 第二次比较将串_s1_与_s3_拼在一起，将串_s2_与_s4_拼在一起… 第三次比较将串_s1_与_s5_拼在一起，将串_s2_与_s6_拼在一起… 直到不同的串的个数为原串长度 那么问题来了，如何高效地比较？ 首先利用好已得出的信息，将这次比较前各个串的排名作为第一关键字 在这次比较中，每个字符串都将添加_k_个字符，对于串_s[i, …]_来说，将串_s[i + k, …]_的排名作为第二关键字 注意空串的字典序最小，假设原串长度为_n_，注意到在_n – k + 1_到_n_位置的第二关键字都是空串，我们约定此时_n_位置的第二关键字最小，其次是_n – 1_，然后以此类推 123456for (int i = n;i &gt;= n - k + 1;i--) y[++num] = i; // 添加的串为空for (int i = 1;i &lt;= n;i++) if (sa[i] &gt; k) y[++num] = sa[i] - k; // 此时的i就是串sa[i] - k的第二关键字，注意枚举的i代表排名// sa[i] &lt;= k时没有串会在后面添加串sa[i]，所以无视// y[i] 表示排名为i的第二关键字对应的是哪个串 对此时的所有串重新排序，第一关键字小的排前面，如果第一关键字相同，则第二关键字小的排前面 不能直接$n \log n$排序，这样的总时间复杂度与直接用哈希构造无异，因此选择桶排序 我们开一个桶_c_，将所有的第一关键字放进去，然后做一遍前缀和，可以得出每个元素的最大排名 由于第一关键字相同时，第二关键字较小的排名较前，因此我们从大到小枚举第二关键字，更新每个桶此时的最大排名和当前的_sa_数组 12345678for (int i = 1;i &lt;= m;i++) c[i] = 0; // 先清空， m是当前第一关键字大小for (int i = 1;i &lt;= n;i++) c[x[i]]++; // 将每个第一关键字加入桶for (int i = 1;i &lt;= m;i++) c[i] += c[i - 1]; // 获得每个值的最大排名for (int i = n;i &gt;= 1;i--) sa[c[x[y[i]]]--] = y[i]; // 第一关键字相同时，第二关键字越大排名越靠后 最后，我们需要更新此时的第一关键字 用一个_num_表示当前不同元素个数，仅当_sa[i], sa[i – 1]_至少有一个关键字不同时，_num_才会累加1，更新_x_数组 用_m_更新_num_ 12345678memcpy(y, x, sizeof(x)), num = x[sa[1]] = 1;// 这个memcpy只是临时存一下，后面那个是初值for (int i = 2;i &lt;= n;i++) x[sa[i]] = (y[sa[i - 1]] == y[sa[i]] &amp;&amp; y[sa[i - 1] + k] == y[sa[i] + k]) ? num : ++num; // 更新此时的第一关键字if (num == n) break; else m = num; // 更新第一关键字的最大值// 如果m等于n，则代表已经分清了所有后缀的排名，没有必要继续比较下去 最后总代码如下 1234567891011121314151617inline void GetSA(int n, char s[]) &#123; for (int i = 1;i &lt;= n;i++) c[x[i] = s[i]]++; for (int i = 1;i &lt;= m;i++) c[i] += c[i - 1]; for (int i = n;i &gt;= 1;i--) sa[c[x[i]]--] = i; for (int k = 1, num = 0;k &lt;= n;k &lt;&lt;= 1, num = 0) &#123; for (int i = n;i &gt;= n - k + 1;i--) y[++num] = i; for (int i = 1;i &lt;= n;i++) if (sa[i] &gt; k) y[++num] = sa[i] - k; for (int i = 1;i &lt;= m;i++) c[i] = 0; for (int i = 1;i &lt;= n;i++) c[x[i]]++; for (int i = 1;i &lt;= m;i++) c[i] += c[i - 1]; for (int i = n;i &gt;= 1;i--) sa[c[x[y[i]]]--] = y[i]; memcpy(y, x, sizeof(x)), num = x[sa[1]] = 1; for (int i = 2;i &lt;= n;i++) x[sa[i]] = (y[sa[i - 1]] == y[sa[i]] &amp;&amp; y[sa[i - 1] + k] == y[sa[i] + k]) ? num : ++num; if (num == n) break; else m = num; &#125;&#125; 关于DC3时间复杂度$O(n)$，但是实现较为繁琐，不推荐 其实是我不会233333 关于_height_ $LCP$ 的几条定理 定义$LCP(i, j)​$为排名为_i_的后缀与排名为_j_的后缀的最长公共前缀长度 根据_height_数组的定义，$height[i] = LCP(i – 1, i)​$ $LCP(i, j) = LCP(j, i)$ // 显然 $LCP(i, i) = LCP(i, i)$ // 同上 $LCP(i, j) = \min\{LCP(i, k), LCP(k, j)\}$ // 对于任意_i ≤_ _k ≤ j_，即$LCP​$具有传递性 设$h[i] = height[rk[i]]$，即$height[i] = h[sa[i]]$，有$h[i] ≥ h[i – 1] – 1$ 第4条定理的证明： 代码如下 12345678910111213inline void Getheight(int n, char s[]) &#123; for (int i = 1;i &lt;= n;i++) rk[sa[i]] = i;// 根据定义，给rk赋值 for (int i = 1, k = 0;i &lt;= n;i++) &#123;// k表示h[i - 1]，注意i是编号 if (rk[i] == 1) continue; if (k) k--;// height[1]没有意义，且h[i] &gt;= h[i - 1] - 1 int at = sa[rk[i] - 1]; while (at + k &lt;= n &amp;&amp; i + k &lt;= n &amp;&amp; s[at + k] == s[i + k]) k++;// 暴力向后匹配 height[rk[i]] = k; &#125;&#125; 关于最长公共前缀由$LCP$的第三条定理可以快速确定任意两个后缀的最长公共前缀，具体地 $LCP(rk[i], rk[j]) = \min\{height[rk[i] + 1], height[rk[i] + 2], \cdots ,height[rk[j]]\}​$ 使用ST表查找区间最小值即可 1234567891011121314inline void GetST(int n) &#123; memset(mn, 0x3f, sizeof(mn)); for (int i = 2;i &lt;= n;i++) lg[i] = lg[i &gt;&gt; 1] + 1; for (int i = 1;i &lt;= n;i++) mn[0][i] = height[i]; for (int i = 1;i &lt;= 20;i++) for (int j = 1;j + (1 &lt;&lt; i) - 1 &lt;= n;j++) mn[i][j] = min(mn[i - 1][j], mn[i - 1][j + (1 &lt;&lt; i - 1)]); &#125;inline int GetLCP(int L, int R) &#123; // rank 为 L, R if (L &gt; R) swap(L, R); L++; int len = R - L + 1; if (!len) return 1e9; return min(mn[lg[len]][L], mn[lg[len]][R - (1 &lt;&lt; lg[len]) + 1]);&#125;]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>算法</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
</search>
