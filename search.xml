<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[莫比乌斯反演]]></title>
    <url>%2F2019%2F03%2F07%2F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[一些定义 $\mu(i)$ 莫比乌斯函数 设$i=p_1^{k_1} p_2^{k_2} p_3^{k_3} \cdots p_m^{k_m}$ 当$max(k) &gt; 1$时$\mu(i)=0$ 否则$\mu(i)=(-1)^{\sum k}$ $\varphi(i)$ 欧拉函数，为$[1,i]$内与i互质的数的个数 设$n=p_1^{k_1} p_2^{k_2} p_3^{k_3} \cdots p_m^{k_m}$ 则$\varphi(n)=n*\prod{(1-\frac{1}{p_i})}$ 关于狄利克雷卷积 定义二元关系$​$，$fg ​$的狄利克雷卷积为 $$(f*g)(n)=\sum_{d|n}f(d)g(\frac{n}{d})​$$ 卷积满足交换律 $$f*g=g*f$$ 结合律 $$(f*g)*h=f*(g*h)$$ 单位元 $$e(n)=[n=1]$$ $$\displaystyle f*e=f$$ 逆元 $$f*f^{-1}=e$$ 一些性质$$\sum_{d|n}\mu(d)=[n=1]$$ $$\displaystyle \sum_{d|n}\varphi(d)=n$$ $\mu$与$\varphi$都是积性函数，可以线性筛 1234567891011121314151617#define N 10000010int flag[N], prime[N], mu[N], ncnt;inline void sieve() &#123; mu[1] = 1; for (int i = 2;i &lt;= N - 10;i++) &#123; if (!flag[i]) mu[i] = -1, prime[++ncnt] = i; //i是质数，mu[i]为-1 for (int j = 1;j &lt;= ncnt &amp;&amp; i * prime[j] &lt;= N;j++) &#123; flag[i * prime[j]] = 1; //筛质数用 if (i % prime[j] == 0) break; //此时根据定义，mu为0 mu[i * prime[j]] = -mu[i]; //mu[i * prime[j]] = mu[i] * mu[prime[j]] = -mu[i] &#125; &#125;&#125; 积性函数都可以线性筛 莫比乌斯反演： 定理1 若 $$F(n)=\sum_{d|n}f(d)$$ 则 $$f(n)=\sum_{d|n}F(d)\mu(\frac{n}{d})$$ 定理2 若 $$F(n)=\sum_{n|d}f(d)$$ 则 $$f(n)=\sum_{n|d}F(d)\mu(\frac{n}{d})$$ 证明 $$F=f*1$$ 有 $$\mu(n)*1=\sum_{d|n}\mu(d)*1=[n=1]=e$$ 所以$$\mu^{-1}=1$$ $$F=f*1=f*\mu^{-1}$$ $$F*\mu=f$$ $$f(n)=(F*\mu)(n)=\sum_{d|n}F(d)\mu(\frac{n}{d})$$ 一些套路以Crash的数字表格为例 求 $$\sum_{i=1}^{n}\sum_{j=1}^{m}lcm(i,j)$$ 套路1.设出$gcd$，然后按照$gcd$分类$$\sum_{k=1}^{n}\sum_{i=1}^{n}\sum_{j=1}^{m}\frac{i*j}{k}[gcd(i,j)=k]$$ 方法1.凑出$[gcd(i,j)=1]$然后使用$\mu$函数的性质换元将i,j同时除以k，注意$\frac{i*j}{k}$需要乘回去 $$\sum_{k=1}^{n}\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}i*j*k[gcd(i,j)=1]$$ 有$$\sum_{d|n}\mu(d)=[n=1]$$ 所以 $$[gcd(i,j)=1]=\sum_{d|gcd(i,j)}\mu(d)$$ 方法2.使用莫比乌斯反演基本公式设 $$f(x)=\sum_{i=1}^{n}\sum_{j=1}^{m}\frac{i*j}{x}[gcd(i,j)=x]$$ $$\displaystyle F(x)=\sum_{i=1}^{n}\sum_{j=1}^{m}\frac{i*j}{x}[x|gcd(i,j)]$$ 改写一下$F$ 由于$gcd$是x的倍数，所以n,m都是x的倍数 同时除以x $$F(x)=\sum_{x|d}f(x)=\sum_{i=1}^{\lfloor\frac{n}{x}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{x}\rfloor}i*j*x$$ 套用反演公式 $$f(x)=\sum_{x|d}F(d)\mu(\frac{d}{x})$$ 得到 $$f(x)=\sum_{x|d}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}i*j*d*\mu(\frac{d}{x})$$ 代入原式即可 个人推荐推式子的时候用第一种方法，使用莫比乌斯反演容斥的时候使用第二种方法 从方法1的最后一步继续 $$\sum_{k=1}^{n}\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}i*j*k[gcd(i,j)=1]$$ $$=\sum_{k=1}^{n}\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}i*j*k\sum_{d|gcd(i,j)}\mu(d)$$ 套路2.枚举d，并放到前面去此时i,j都应该是d的倍数 同样，注意要乘回去 $$=\sum_{k=1}^{n}k\sum_{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d)\sum_{i=1}^{\lfloor\frac{n}{kd}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{kd}\rfloor}i*j*d^2$$ 整理一下 $$=\sum_{k=1}^{n}k\sum_{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d)*d^2\sum_{i=1}^{\lfloor\frac{n}{kd}\rfloor}i\sum_{j=1}^{\lfloor\frac{m}{kd}\rfloor}j$$ 为了方便快捷，设$$F(n)=\sum_{i=1}^{n}i$$将原式替换成$$=\sum_{k=1}^{n}k\sum_{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d)*d^2*F(\lfloor\frac{n}{kd}\rfloor)*F(\lfloor\frac{m}{kd}\rfloor)$$ 套路3.换T大法为了提升时间复杂度，我们需要设一个神奇的T 设$$T=kd$$所以原式等于$$\sum_{k=1}^{n}k\sum_{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d)*d^2*F(\lfloor\frac{n}{T}\rfloor)*F(\lfloor\frac{m}{T}\rfloor)$$枚举T，放到最前面$$\sum_{T=1}^{n}F(\lfloor\frac{n}{T}\rfloor)*F(\lfloor\frac{m}{T}\rfloor)\sum_{d|T}\mu(d)*\frac{T}{d}*d^2$$ $$\sum_{T=1}^{n}F(\lfloor\frac{n}{T}\rfloor)*F(\lfloor\frac{m}{T}\rfloor)\sum_{d|T}\mu(d)*d$$ 考虑优化最后那一坨的求法 直接求显然是$n\ log\ n$的 套路4.设出积性函数观察到$\mu$以及$f(x)=x$（它还有个名字叫id）都是积性函数 两个积性函数的狄利克雷卷积以及直接对应相乘的结果都是积性函数 也就是说，这个东西是可以线性筛的 设$$g(x)=\sum_{d|x}\mu(d)*d$$对x分类 x是质数 此时显然有$g(x)=1-x$ x被表示成了$i*prime[j]$，其中$prime[j]\bot i$ 此时根据积性函数性质，$g(iprime[j])=g(i)g(prime[j])$，直接乘即可 x被表示成了$i*prime[j]$，其中$prime[j]|i$ 考虑乘之后多出来的因数 由于多出来的因数prime[j]这个质数的次数至少是2，而根据$\mu$的定义此时$\mu$为0，对g没有贡献，直接忽略即可 所以此时$g(i*prime[j]$ 套路5.数论分块预处理完了g，我们再来说说最后答案怎么求 答案等于$$\sum_{T=1}^{n}F(\lfloor\frac{n}{T}\rfloor)*F(\lfloor\frac{m}{T}\rfloor)*g(T)$$考虑从$\lfloor\frac{n}{T}\rfloor$,$\lfloor\frac{m}{T}\rfloor$ 开始优化 可以发现对于某一段的T，上面的两个式子的值都是不变的 这种不变的值的段数一共有$\sqrt n​$段 考虑一段一段地枚举，而不是一个一个的枚举 此时变化的就只有$g(T)$ 对$g(T)$求一下前缀和，算的时候直接求区间的和就好了 代码如下 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define LL long longconst LL mod=20101009;int flag[10000010],prime[10000010],cnt,f[10000010],sum[10000010];// sum是前缀和，f就是gvoid sieve() &#123; f[1]=sum[1]=1; for (int i=2;i&lt;=10000000;i++) &#123; if (!flag[i]) prime[++cnt]=i,f[i]=(1-i+mod)%mod; for (int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=10000000;j++) &#123; flag[i*prime[j]]=1; if (i%prime[j]==0) &#123; f[i*prime[j]]=f[i]%mod; break; &#125; f[i*prime[j]]=(LL)f[i]*f[prime[j]]%mod; &#125; sum[i]=(sum[i-1]+(LL)f[i]*i%mod)%mod; &#125;&#125;LL zjk(LL n,LL m) &#123; LL ans=0; if (n&gt;m) swap(n,m); for (LL l=1,r;l&lt;=n;l=r+1) &#123; r=min(n/(n/l),m/(m/l)); // 分块：[l,r] ans=(ans+((n/l*(n/l+1)/2)%mod*((m/l*(m/l+1)/2)%mod))%mod*(LL)(sum[r]-sum[l-1]))%mod; &#125; return (ans+mod)%mod;&#125;int main() &#123; sieve(); int n,m;scanf("%d%d",&amp;n,&amp;m); printf("%lld\n",zjk(n,m));&#125; %%% ZJK 下面讨论一下使用莫比乌斯反演来容斥的题 CA Loves GCD 题意：给出n个[1,1000]的数，问所有选法中所选择的数的gcd的和 $n \leq 1000$ 首先，还是对gcd分类，$f(i)$表示gcd为i的方案数 发现f好像很不好求，考虑设辅助函数 设$g(i)$表示gcd是i的倍数的方案数 很显然，在一个gcd为i的集合中，每一个数都是i的倍数 那么我们假设在这n个数中，i的倍数一共有k个 每个数可以选或者不选，一共有$2^k$种方案 减去所有数都不选的情况，就这一种 之后得到的就是$g(i)$的值 将g转化成f 显然有$$g(i)=\sum_{i|d}f(i)$$反演得$$f(i)=\sum_{i|d}g(d)\mu(\frac{i}{d})$$对于每一个i，枚举每一个i的倍数转移即可 对于如何求i的倍数的个数，可以开一个桶。先预处理每个数的约数，当输入一个数a时，就把a的所有约数在桶中加一，最后桶中的第i个位置就是i的倍数的个数 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1010vector&lt;int&gt; Div[N];int flag[N], prime[N], ncnt, mu[N], Pow[N];#define LL long longconst int mod = 1e8 + 7;inline void sieve() &#123; Pow[0] = 1, Pow[1] = 2, mu[1] = 1; for (int i = 2;i &lt;= N - 10;i++) &#123; Pow[i] = Pow[i - 1] * 2 % mod; if (!flag[i]) mu[i] = -1, prime[++ncnt] = i; for (int j = 1;j &lt;= ncnt &amp;&amp; i * prime[j] &lt;= N - 10;j++) &#123; flag[i * prime[j]] = 1; if (i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; for (int j = i;j &lt;= N - 10;j += i) Div[j].push_back(i); &#125; for (int i = 1;i &lt;= N - 10;i++) Div[i].push_back(1);&#125;int buk[N], ans[N], tmp[N];int main() &#123; int T; scanf("%d", &amp;T), sieve(); while (T--) &#123; int n; scanf("%d", &amp;n), memset(buk, 0, sizeof(buk)), memset(tmp, 0, sizeof(tmp)); for (int i = 1, a;i &lt;= n;i++) scanf("%d", &amp;a), tmp[a]++; for (int i = 1;i &lt;= 1000;i++) if (tmp[i]) for (int j = 0;j &lt; Div[i].size();j++) buk[Div[i][j]] += tmp[i]; memset(ans, 0, sizeof(ans)); for (int i = 1;i &lt;= 1000;i++) for (int j = i;j &lt;= 1000;j += i) ans[i] = (ans[i] + (Pow[buk[j]] - 1) * mu[j / i] + mod) % mod; int res = 0; for (int i = 1;i &lt;= 1000;i++) res = (res + (LL)i * ans[i] % mod) % mod; printf("%d\n", res); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组]]></title>
    <url>%2F2019%2F03%2F07%2F%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[一些约定 sa[i] 排名为i的后缀在原串中的编号 rk[i] 原串中第i个后缀所对应的排名 height[i] 排名为i的后缀与排名为i – 1的后缀的最长公共前缀 一些例子字符串S = bacaab 中，sa，rk，height分别为 一些解释在S中，所有的后缀分别为bacaab, acaab, caab, aab, ab, b 将这些串按照字典序排序，可以得到aab, ab, acaab, b, bacaab, caab 对应出来的rk值就是5, 3, 6, 1, 2, 4 根据上面的定义可以得出sa[rk[i]] = i, rk[sa[i]] = i sa[1] = 4 对应后缀aab，sa[2] = 5 对应后缀ab 因此height[2] = lcp(sa[1], sa[2]) = lcp(aab, ab) = 1 注：height[1] 没有意义，约定其等于0 倍增直接暴力求sa显然不行，由于涉及到后缀排序，所以考虑倍增 假设对于每个后缀的前k个字符，我们已经排好了序，考虑进一步的转移 如果直接比较每个后缀的第k + 1个字符，忽视了太多已经求出的信息 对于两个后缀s1 = S[i, …], s2 = S[j, …]，如果它们的前k个字母不全相同，那么我们在之前的比较中就已经确定好了这两个后缀的顺序 如果这两个后缀的前k个字母都相同，我们这次就比较s1[k + 1, 2k], s2[k + 1, 2k]的大小 显然，这两个串的长度都是k，这意味着我们已经比较过这两个串 图中括号中的数字表示当前层中此串的排名，注意相同串的排名相同。 第一次比较将串s1与s2拼在一起，将串s2与s3拼在一起… 第二次比较将串s1与s3拼在一起，将串s2与s4拼在一起… 第三次比较将串s1与s5拼在一起，将串s2与s6拼在一起… 直到不同的串的个数为原串长度 那么问题来了，如何高效地比较？ 首先利用好已得出的信息，将这次比较前各个串的排名作为第一关键字 在这次比较中，每个字符串都将添加k个字符，对于串s[i, …]来说，将串s[i + k, …]的排名作为第二关键字 注意空串的字典序最小，假设原串长度为n，注意到在n – k + 1到n位置的第二关键字都是空串，我们约定此时n位置的第二关键字最小，其次是n – 1，然后以此类推 123456for (int i = n;i &gt;= n - k + 1;i--) y[++num] = i; // 添加的串为空for (int i = 1;i &lt;= n;i++) if (sa[i] &gt; k) y[++num] = sa[i] - k; // 此时的i就是串sa[i] - k的第二关键字，注意枚举的i代表排名// sa[i] &lt;= k时没有串会在后面添加串sa[i]，所以无视// y[i] 表示排名为i的第二关键字对应的是哪个串 对此时的所有串重新排序，第一关键字小的排前面，如果第一关键字相同，则第二关键字小的排前面 不能直接n log n排序，这样的总时间复杂度与直接用哈希构造无异，因此选择桶排序 我们开一个桶c，将所有的第一关键字放进去，然后做一遍前缀和，可以得出每个元素的最大排名 由于第一关键字相同时，第二关键字较小的排名较前，因此我们从大到小枚举第二关键字，更新每个桶此时的最大排名和当前的sa数组 12345678for (int i = 1;i &lt;= m;i++) c[i] = 0; // 先清空， m是当前第一关键字大小for (int i = 1;i &lt;= n;i++) c[x[i]]++; // 将每个第一关键字加入桶for (int i = 1;i &lt;= m;i++) c[i] += c[i - 1]; // 获得每个值的最大排名for (int i = n;i &gt;= 1;i--) sa[c[x[y[i]]]--] = y[i]; // 第一关键字相同时，第二关键字越大排名越靠后 最后，我们需要更新此时的第一关键字 用一个num表示当前不同元素个数，仅当sa[i], sa[i – 1]至少有一个关键字不同时，num才会累加1，更新x数组 用m更新num 12345678memcpy(y, x, sizeof(x)), num = x[sa[1]] = 1;// 这个memcpy只是临时存一下，后面那个是初值for (int i = 2;i &lt;= n;i++) x[sa[i]] = (y[sa[i - 1]] == y[sa[i]] &amp;&amp; y[sa[i - 1] + k] == y[sa[i] + k]) ? num : ++num; // 更新此时的第一关键字if (num == n) break; else m = num; // 更新第一关键字的最大值// 如果m等于n，则代表已经分清了所有后缀的排名，没有必要继续比较下去 最后总代码如下 1234567891011121314151617inline void GetSA(int n, char s[]) &#123; for (int i = 1;i &lt;= n;i++) c[x[i] = s[i]]++; for (int i = 1;i &lt;= m;i++) c[i] += c[i - 1]; for (int i = n;i &gt;= 1;i--) sa[c[x[i]]--] = i; for (int k = 1, num = 0;k &lt;= n;k &lt;&lt;= 1, num = 0) &#123; for (int i = n;i &gt;= n - k + 1;i--) y[++num] = i; for (int i = 1;i &lt;= n;i++) if (sa[i] &gt; k) y[++num] = sa[i] - k; for (int i = 1;i &lt;= m;i++) c[i] = 0; for (int i = 1;i &lt;= n;i++) c[x[i]]++; for (int i = 1;i &lt;= m;i++) c[i] += c[i - 1]; for (int i = n;i &gt;= 1;i--) sa[c[x[y[i]]]--] = y[i]; memcpy(y, x, sizeof(x)), num = x[sa[1]] = 1; for (int i = 2;i &lt;= n;i++) x[sa[i]] = (y[sa[i - 1]] == y[sa[i]] &amp;&amp; y[sa[i - 1] + k] == y[sa[i] + k]) ? num : ++num; if (num == n) break; else m = num; &#125;&#125; 关于DC3时间复杂度O(n)，但是实现较为繁琐，不推荐 其实是我不会233333 关于height LCP 的几条定理 定义LCP(i, j)为排名为i的后缀与排名为j的后缀的最长公共前缀长度 根据height数组的定义，height[i] = LCP(i – 1, i) LCP(i, j) = LCP(j, i) // 显然 LCP(i, i) = LCP(i, i) // 同上 LCP(i, j) = min{LCP(i, k), LCP(k, j)} // 对于任意i ≤ k ≤ j，即LCP具有传递性 设h[i] = height[rk[i]]，即height[i] = h[sa[i]]，有h[i] ≥ h[i – 1] – 1 第4条定理的证明： 代码如下 12345678910111213inline void Getheight(int n, char s[]) &#123; for (int i = 1;i &lt;= n;i++) rk[sa[i]] = i;// 根据定义，给rk赋值 for (int i = 1, k = 0;i &lt;= n;i++) &#123;// k表示h[i - 1]，注意i是编号 if (rk[i] == 1) continue; if (k) k--;// height[1]没有意义，且h[i] &gt;= h[i - 1] - 1 int at = sa[rk[i] - 1]; while (at + k &lt;= n &amp;&amp; i + k &lt;= n &amp;&amp; s[at + k] == s[i + k]) k++;// 暴力向后匹配 height[rk[i]] = k; &#125;&#125; 关于最长公共前缀由LCP的第三条定理可以快速确定任意两个后缀的最长公共前缀，具体地 LCP(rk[i], rk[j]) = min{height[rk[i] + 1], height[rk[i] + 2], … height[rk[j]]} 使用ST表查找区间最小值即可 1234567891011121314inline void GetST(int n) &#123; memset(mn, 0x3f, sizeof(mn)); for (int i = 2;i &lt;= n;i++) lg[i] = lg[i &gt;&gt; 1] + 1; for (int i = 1;i &lt;= n;i++) mn[0][i] = height[i]; for (int i = 1;i &lt;= 20;i++) for (int j = 1;j + (1 &lt;&lt; i) - 1 &lt;= n;j++) mn[i][j] = min(mn[i - 1][j], mn[i - 1][j + (1 &lt;&lt; i - 1)]); &#125;inline int GetLCP(int L, int R) &#123; // rank 为 L, R if (L &gt; R) swap(L, R); L++; int len = R - L + 1; if (!len) return 1e9; return min(mn[lg[len]][L], mn[lg[len]][R - (1 &lt;&lt; lg[len]) + 1]);&#125;]]></content>
      <tags>
        <tag>后缀数组</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
</search>
