<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[4.17省选模拟]]></title>
    <url>%2F2019%2F04%2F18%2F4-17%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 圈草地 我们只考虑有用的左上角和右下角 考虑两个点$a,b$，如果$a$在$b$的第二象限，那么选择$a$作为左上角一定比选择$b$作为左上角优秀 那么我们将所有有用的点分两层排在一起，第一层是可以作为左上角的点，第二层是可以作为右下角的点 我们考虑当右下角的点移动的时候左上角的最优决策点会如何变化 假如原来的最优决策点是$a$，另一个在$a$右上角的点是$b$，那么我们可以发现，右下角的点移动之后，$b$与之构成的矩形的面积与$a$与之构成的矩形的面积之差变大了 也就是说，移动之后，$b$会变得更加优秀 所以最优决策点是单调向右上角移动的 我们可以采用分治 solve(l, r, L, R)表示右下角的点对应的区间是$[L,R]$，对应的最优决策点的区间是$[l,r]$ 我们找到$l,r$的中点$mid$，二分出右下角那些点的最优决策点在$[l,mid]$中 然后继续分治下去 对于找一个矩形内部有多少个点，可以使用主席树 时间复杂度$O(n\log^3n)$ 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010struct node &#123; int l, r, lson, rson, sum;&#125; T[N * 20];int RT[N], ncnt;int build(int l, int r) &#123; int rt = ++ncnt; T[rt].l = l, T[rt].r = r, T[rt].lson = T[rt].rson = T[rt].sum = 0; if (l == r) return rt; int mid = (l + r) &gt;&gt; 1; T[rt].lson = build(l, mid), T[rt].rson = build(mid + 1, r); return rt;&#125;int update(int rt, int at) &#123; int nw = ++ncnt, l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; 1; T[nw] = T[rt], T[nw].sum++; if (l == r) return nw; if (at &lt;= mid) T[nw].lson = update(T[nw].lson, at); else T[nw].rson = update(T[nw].rson, at); return nw;&#125;int query(int rt1, int rt2, int start, int end) &#123; int l = T[rt2].l, r = T[rt2].r, mid = (l + r) &gt;&gt; 1, res = 0; if (start &lt;= l &amp;&amp; r &lt;= end) return T[rt2].sum - T[rt1].sum; if (start &lt;= mid) res += query(T[rt1].lson, T[rt2].lson, start, end); if (mid &lt; end) res += query(T[rt1].rson, T[rt2].rson, start, end); return res;&#125;struct point &#123; int x, y;&#125; st1[N], st2[N];int ans = 1, top1, top2;inline int query(int a, int b) &#123; int x1 = st1[a].x, y1 = st1[a].y, x2 = st2[b].x, y2 = st2[b].y; return query(RT[x1 - 1], RT[x2], y2, y1);&#125;inline bool check(int l, int r, int x, int mid) &#123; int pos = l, res = 0; for (int i = l;i &lt;= r;i++) if (st1[i].x &lt;= st2[x].x &amp;&amp; st2[x].y &lt;= st1[i].y) &#123; int tmp = query(i, x); if (res &lt;= tmp) res = tmp, pos = i; if (pos &gt; mid) return false; &#125; return res != 0;&#125;void solve(int l, int r, int L, int R) &#123; if (L &gt; R) return; if (l == r) &#123; for (int i = L;i &lt;= R;i++) if (st1[l].x &lt;= st2[i].x &amp;&amp; st2[i].y &lt;= st1[l].y) ans = max(ans, query(l, i)); return; &#125; int mid = (l + r) &gt;&gt; 1, l1 = L, r1 = R, m, pos = l1; while (l1 &lt;= r1) &#123; if (check(l, r, m = ((l1 + r1) &gt;&gt; 1), mid)) pos = m, l1 = m + 1; else r1 = m - 1; &#125; solve(l, mid, L, pos), solve(mid + 1, r, pos + 1, R);&#125;inline void solve2(int l, int r, int L, int R) &#123; for (int i = l;i &lt;= r;i++) for (int j = L;j &lt;= R;j++) if (st1[i].x &lt;= st2[j].x &amp;&amp; st2[j].y &lt;= st1[i].y) ans = max(ans, query(i, j));&#125;int main() &#123; int n; scanf("%d", &amp;n), RT[0] = build(1, n); for (int i = 1, a;i &lt;= n;i++) &#123; scanf("%d", &amp;a), RT[i] = update(RT[i - 1], a); if (a &gt; st1[top1].y) st1[++top1] = (point)&#123;i, a&#125;; else &#123; while (top2 &amp;&amp; st2[top2].y &gt; a) top2--; st2[++top2] = (point)&#123;i, a&#125;; &#125; &#125; if (top1 &lt;= 500 &amp;&amp; top2 &lt;= 500) solve2(1, top1, 1, top2); else solve(1, top1, 1, top2); printf("%d\n", ans);&#125; T2 道路修建 容易发现一个结论：对于一个点$u$，假设它与$v$相连，那么它距离一号城市的最短路距离$d_u$一定满足$d_v-1\leq d_u\leq d_v+1$ 那么我们可以通过这个建图跑网络流 将每个点拆成$n$个点，第$x$个点表示当前点的最短路是否大于等于$x-1$ 将第一个拆出来的点与源点连一条$\infty$的边，将最后一个拆出来的点与汇点连一条$\infty$的边 将第$i$个拆出来的点向第$i+1$个点连一条权值为题中给出公式的边 最小割中，与$S$集合连接代表为true，否则为false 为了满足$d_v-1\leq d_u\leq d_v+1$这个限制，我们可以模仿切糕这道题的做法 对于任意两个有边相连的点$u,v$，$u$拆出来的第$i$个点向$v$拆出来的第$i-1$个点连一条无法割掉的$\infty$ 的边 注意$(u,v)和(v,u)$是不一样的 T3 美术作业 可以看出，这是一个基环外向树 我们先考虑一棵树的情况：如何求它的染色方案 由于边是有向的，所以置换对答案的影响只有可能是对于$u$这个点，它有一些子树是完全同构的 比如这样 注意到如果$2,3,4$这几个点互换编号，那么结构是不变的 比如“2染颜色1，3染颜色1，4染颜色2”这种方案与“2染颜色2，3染颜色1，4染颜色1”是完全等价的 而不同构的子树之间是没有关系的 那么对于这种同构的情况怎么办呢 由于$2,3,4$都是同构的，所以它们的染色方案一定都一样，我们假设有$f$种方案，有$t$棵子树 我们将这$f$种染色方案分别编号为$1,2\cdots,f$，对于这些同构的子树按照根节点的编号排序 然后在这$f$种方案中选出$t$种，可以重复，然后按照从小到大的顺序依次给这些同构的子树染色，这样统计出来的结构一定不会重复 等价于将$t$个球放入$f$个盒子，每个盒子可以空 所以方案数为$$f{f+t-1\choose f-1}=f{f+t-1\choose t}$$现在我们求出了环上每棵树的染色方案 我们来考虑环的置换 对于一种置换后的不动点，它们对应树的结构必须相同，染的颜色也必须相同 所以对于每棵树最后得到的hash值我们跑一个KMP，求出它的最小循环节，这样每次转的次数一定是循环节长度的倍数 每个循环节我们将它看作一个点，染色方案为它包含的树的染色方案的乘积 然后就是普通polya了，枚举转多少次，然后不动点个数就是每个循环节的方案的$gcd(总长度，转的次数)$次方 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010#define LL long long#define uLL unsigned long longconst int mod = 1e9 + 7;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;int frac[N], inv[N];inline int C(int n, int r) &#123; int res = inv[r]; for (int i = 1;i &lt;= r;i++) res = (LL)res * (n - i + 1) % mod; return res;&#125;struct edge &#123; int to, next;&#125; e[N * 2];int head[N], ecnt, dp[N], tmp[N], m;uLL P = 233, h[N], s[N];inline void adde(int from, int to) &#123; e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;&#125;int nxt[N];inline int KMP(int n) &#123; for (int i = 2;i &lt;= n;i++) &#123; int ls = nxt[i - 1]; while (ls &amp;&amp; s[ls + 1] != s[i]) ls = nxt[ls]; nxt[i] = ls + (s[ls + 1] == s[i]); &#125; return n % (n - nxt[n]) ? -1 : n - nxt[n];&#125;void dfs(int u, int f) &#123; int top = 0; for (int i = head[u];i;i = e[i].next) if (e[i].to != f) dfs(e[i].to, u); for (int i = head[u];i;i = e[i].next) if (e[i].to != f) tmp[++top] = e[i].to; sort(tmp + 1, tmp + top + 1, [](int a, int b)&#123;return h[a] &lt; h[b];&#125;), h[u] = 7; for (int i = 1;i &lt;= top;i++) h[u] = ((h[u] * P + h[tmp[i]]) ^ h[tmp[i]]) + h[tmp[i]]; dp[u] = m; for (int i = 1, last;i &lt;= top;i = last) &#123; for (last = i;last &lt;= top &amp;&amp; h[tmp[last]] == h[tmp[i]];last++); dp[u] = (LL)dp[u] * C(dp[tmp[i]] + last - i - 1, last - i) % mod; &#125;&#125;int gcd(int a, int b) &#123;return b ? gcd(b, a % b) : a;&#125;int to[N], vis[N], cir[N], mark[N];int main() &#123; int n, tot = 0; scanf("%d%d", &amp;n, &amp;m), frac[0] = inv[0] = 1; for (int i = 1;i &lt;= n;i++) frac[i] = (LL)frac[i - 1] * i % mod, inv[i] = Pow(frac[i], mod - 2); for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;to[i]); for (int i = 1, j;i &lt;= n;i++) &#123; if (vis[i]) continue; for (j = i;!vis[j];j = to[j]) vis[j] = i; if (vis[j] != i) continue; for (;!mark[j];j = to[j]) mark[j] = 1, cir[++tot] = j; &#125; for (int i = 1;i &lt;= n;i++) if (!mark[i]) adde(to[i], i); for (int i = 1;i &lt;= tot;i++) dfs(cir[i], 0), s[i] = h[cir[i]]; int zjk = KMP(tot), ans = 0; if (~zjk) &#123; int f = 1; for (int i = 1;i &lt;= zjk;i++) f = (LL)f * dp[cir[i]] % mod; for (int i = 1;i &lt;= tot / zjk;i++) ans = (ans + Pow(f, gcd(i, tot / zjk))) % mod; printf("%d\n", (LL)ans * Pow(tot / zjk, mod - 2) % mod); &#125; else &#123; ans = 1; for (int i = 1;i &lt;= tot;i++) ans = (LL)ans * dp[cir[i]] % mod; printf("%d\n", ans); &#125;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>数据结构</tag>
        <tag>分治</tag>
        <tag>字符串</tag>
        <tag>置换</tag>
        <tag>主席树</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SCOI2019 游记]]></title>
    <url>%2F2019%2F04%2F14%2FSCOI2019-%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[写在之前的话感觉NOIP之后就有点没救了，之后冬令营全机房都去了 425分有点凉凉 不过可以试试冲E类 赶紧复习一下exBSGS, exCRT, Cipolla 朱刘算法懒得看了 Day0比赛之前发了一个笔试考察范围，结果是去年NOI的笔试题库 本来以为要考什么神仙内容，结果笔试及其简单 重点是连题目顺序都和题库一样 笔试时间是一个小时，结果30分钟可以走人的时候我在的这个考室已经没人了 感觉只要看了题库就应该是100分吧（雾 话说电子科大的教学楼上“电子科技大学”这几个字看起来好像电子神技大学 晚上看卢爷颓风暴英雄 Celeste真好玩 Day1路上单向模ZJK 我自闭了 我爆零了 来机房看神仙 rank $10^9+7$ 结果每次考完之后都rank 1 这是某些选手的真实写照 拿到试题之后解压，嗯？密码是一串数字 先看T1，那个图片有点劣质啊。。。 貌似是用mspaint画的 不过还将就 手玩了一下样例，好像找到了一点规律的样子 开考5分钟找工作人员要了几张纸 上个厕所冷静一下，顺便思考一下T1 嗯？这不是SB题吗，只要不是划水选手都会做吧。。。 对于最有步数，显然有$$f_m=3f_{m-1}+n-1$$然后随便分治一下就行了 一发过掉大样例 题目中说$Q_i$小于等于答案的上限，然而又没说上限是多少 感觉有阴谋 保证答案小于等于30，有什么用呢 意思是$Q_i\leq (n-1)*3^{30}$吗 然后发现显然是假的，$Q_i$可以达到$3^{1000}$ 手写高精度！ T2的名字叫“肯赛训练” 这里是否有肯德基强行打广告的成份 思考了一下，感觉那个边权是假的 所以是个区间求重心？不会啊 先写暴力吧，好像很莫队的样子 加一个点很好处理，新的重心一定在原来的重心与加的点的连线上 貌似LCT维护虚子树信息可以做到$\log$? 于是开始码LCT，做好了6kb的准备 码了2kb的时候 woc?加点可以直接$\log$，那删点怎么办？ 冷静一下 这个东西好像不是很好维护的样子，干脆暴跳吧 好像加点之后重心的移动次数是$O(\log)​$的 先码一个树状数组 代码还是挺简单的 我的程序跑得巨慢无比 30s后过了大样例 来看T3 好像很多项式的样子 卷积的运算符是乘？是不是可以原根什么的啊 然后发现显然不是 还好暴力分给得很足 直接一行代码有5分 剩下的直接暴力数论分块可以再拿25分 貌似有两个$q=1$的点 欸是不是可以爆搜然后乘一个排列数啊 写完之后发现T成SB了 这个时候离考试结束大概还有10分钟 再来检查一下T1吧 手输了一组极限数据 wtf?RE? 赶紧看一下 还好在最后一分钟的时候发现是高精板子错了 那个高精乘的时候我是边乘边取模233 所以最后估分$100+[30-50]+30$? 莫队的分数很玄学的 ZJK说他T1可能会被卡常，然后期望$50+50+50$ ZYW貌似切了T2的60分 都好强啊 很不幸，我面试是第6轮，也就是最后一轮 本来以为要考什么小学奥数，结果是政治问题？（雾 Bh是第一轮，他说他们那组的面试题目是评论中美贸易战 hxy的题目是七中食堂事件 还有什么国民党为什么会失败 好有趣啊 4：10之前一直在楼梯上坐着 看陈爷玩炉石 经过漫长的等待，终于轮到我了 感觉我们这组只有我一个初中的 拿到题目：如何评价近年来自主招生政策遭到限制？ 开始10分钟讨论 丝毫没有面试经验 10分钟之后 考官：之前我提出的要求是讨论并选出一位代表发言，但是10分钟已经过去了，你们却没有选出一位代表 我们：。。。 考官：从面试的角度来说，你们这次讨论是失败的 我们：。。。 考官：现在再给你们一次机会，选出一个代表发言 显然不是我了2333 感觉面试是不是有点凉啊 晚上来看成绩 嗯？$60+45+30?$ T1的高精度果然T了啊 如果把11位压到17位应该就不会超时了 还是太菜了 orz陈爷180 ZYW165，看来她进E类稳了 ZJK好像有点爆炸？只有100，但是如果算上NOIP的话还是在我前面 看了看此时的加权成绩，rk21，好像有点凉？ 明天加油吧 Day2考前陈爷口胡动态SA，感觉他A类很稳 拿到试题，密码又全是数字 先看T1 好像很模板的样子 感觉那个分成两半部分，再取一个部分的操作没啥用 如果根据询问把每个点变一下，那不是最大子段和吗？ 50pts get 如果要动态的话，线段树维护凸包？？？ 反正这种东西我是很难写出来的 那线段树维护矩阵？？？ 好像不是 两个自变量有点不爽，可以去掉一个 等等，前缀和之后好像是个很裸的斜率优化 15分钟码完，代码只有2kb。。 对拍了上万组数据，感觉很稳 来看T2 哇，这是论文题欸！ 去年国家集训队论文，有一个“解决树上连通块问题的一些技巧和工具” 原题啊！！！！ 具体方法是利用“边数 = 点数 - 1”这个等式来容斥 枚举某个点作为$x$的方案数，减去某条边两个端点都是$x$的方案数 然后就切了？？？ 跑一下大样例 嗯？输出负数？改成long long 嗯？还是负数，看看答案 woc？答案怎么这么小 举手向监考老师求助 我：第二道题有模数吗 老师：题目中写了吗 我：没有啊，但是大样例无论如何都不可能这么小 老师：这个。。。你自己认真读题吧 我：&amp;#fsdl&amp;DFfd*#$jkrhf29873Q@!Rds 不久之后更正通知下来了，模数是$10^9+7$ 改一下程序，过了！很好 开始看T3 这看上去很线性基 事实上线性基的确可以获得20分的好成绩 思考了一下感觉没有发现什么好的性质，果断写暴力 前20分直接暴力，后面20分线性基，然后还有20分貌似是找规律？ 好像是$2^{不同数的个数}$的样子？ 写！ 11：00的时候我就码完了 T1仍然没有拍出错 前面好像有个七中大佬在玩纸牌？ 我默默地点开了扫雷 2min后 太不友好了！ 还是试试虚拟机吧 结果打开虚拟机让我的电脑卡了一会儿 无聊打了一个程序模ZJK 之后看了看各个IDE的作者信息 坐了2h后考试结束了 所以我今天估分$100+100+60?$感觉翻盘有望？ ZJK和ZYW都估分$100+40+40$ ZYW说她T1是在线，是在凸包上二分 蒟蒻只会离线 下午拿到成绩，前两道题确实是100，但是第三题只有40，总分240 看来是规律假了 不过，我竟然是rk 1？ ZYW和ZJK确实是180，E类稳了 BH有点神仙啊，切了T2，但是T1爆零了，本来是很有希望的 坐看卢爷翻盘240，orz 事实证明考前无聊的时候看看论文总是有用的 预祝陈爷NOI取得好成绩！ 后记如果不是第二天的成功翻盘，我有可能进不了E类 感觉这次我们学校进步好大啊，去年只有一个省队 强者都上了400分orz 想起去年我失败的SCOI，想要了解详情可以知乎搜索SCOI2018 希望我能够坚持到最后 NOI2019见 补充：关于题意D1T1 跳跃游戏有$m​$个小红球，$n​$个空岛。其中第一个、最后一个空岛以及中间的第$k​$个空岛是固定的$(1&lt;k&lt;n)​$是固定的，其余空岛是悬浮的。一开始所有小红球都在第一个空岛，你的目标是把他们都移动到最后一个空岛，并且使用的步数尽量小。 每回合你可以移动一个小红球到它左边或者右边的那个平台，但是有一些限制： 移动的小红球必须是移动前/移动后它所在的平台上编号最小的。 如果一个小红球移动到了一个浮动平台上，那下一回合必须将这个小红球移走，否则它就会掉下去。 有$q$个询问，每次给出一个时刻，你需要回答在最优方案中，这个时刻正在跳跃的是哪个小红球。 保证答案小于$30$，$n\leq 10^8,m\leq1000,q\leq5000$，时限$1$s 保证询问给出的时刻小于等于最优方案数 部分分： 对于$20\%$的数据，保证$m,n,q\leq10$ 对于$50\%​$的数据，保证$n\leq 10^8,m\leq 10,q\leq 5000​$ D1T2 肯赛训练给出一棵树，$n$个节点，每条边有边权$c_i$。 给出一个点的序列，这个序列有$m$个数，第$i$个数$a_i$代表编号为$a_i$的点 有$q​$个询问，每次询问给出一段区间$[l,r]​$，你要在树上选出一个点，使得这个点离$a_l,a_{l+1},\cdots,a_{r}​$的距离之和尽量小，输出这个点的编号 注意，选出的点不一定是$a_{l},a_{l+1},\cdots,a_r​$其中的某一个 保证$n\leq 3*10^5,c_i\leq 1000,m\leq5*10^5,q\leq10^6$，区间的长度是奇数，时限$3$s 部分分： 对于前$20\%​$的数据，保证$n,m,q\leq2*10^3​$ 对于前$35\%$的数据，保证$m,q\leq2*10^3$ 对于前$60\%$的数据，保证$n,m,q\leq10^5$ 对于另$15\%​$的数据，保证每个点的度数不超过$2​$ D1T3 超矩形给出一个数$n$，你需要找到$k$个数$a_1,a_2,\cdots,a_k$使得$\prod_{i=1}^ka_i\leq n$ 给出一个变换$b_1,b_2,\cdots,b_k$，保证$b_i&lt;10$ 你需要求出$$\sum_{所有合法的方案}\prod_{i=1}^ka_i^{b_i}\pmod {998244353}$$ 多组数据（$t$组） 保证$n\leq10^6,\sum k\leq10^6,t\leq100$，时限$4$s 给出$b​$的方式是$q​$个$s_i,r_i​$，表示有连续$r_i​$个$b_i​$是$s_i​$ 保证$s_i$互不相同，$q&lt;5$ 部分分： 对于前$10\%$的数据，保证$k=1,q=1,s=0$ 对于前$20\%$的数据，保证$k=1,q=1,s\leq1$ 对于前$30\%$的数据，保证$k\leq2,q\leq2$ 对于另$20\%$的数据，保证$q=1$ D2T1 湖之精灵的游戏一个二维平面上有$n$个点，第$i$个点的坐标是$(x_i,y_i)$，你要和一位神仙玩游戏。 每次神仙会告诉你一个坐标$(x,y)$，连一条经过$(0,0),(x,y)$的直线，这会把平面分成两个部分$A,B$ 你要选择一个区间$[l,r]$，那么计算的时候只会考虑编号在$[l,r]$之内的点 一个半平面的价值是这个半平面中，编号在$[l,r]$范围内的点与$(0,0),(x,y)$组成三角形的面积之和 你要选择一个半平面，神仙会选择另一个半平面，你想要使得你得到的价值减去神仙得到的价值的结果尽量大 有$m​$轮游戏，对于每轮游戏输出这个最大值乘以$2​$的结果 保证$n,m\leq 10^6$，$1\leq x,y\leq1000$，时限$2$s 部分分： 对于$20\%$的数据，$n,m\leq200$ 对于$50\%$的数据，$n,m\leq 10^4$ D2T2 RGB有一棵树，$n$个节点，每条边有边权$c_i$，每个点的颜色为R,G,B三种颜色之一 你要统计有序对$(U,V)$的数量，其中$U,V​$是两个点集 它还需要满足以下条件： $U​$和$V​$都必须是连通的 $U$的颜色只能是红色或者绿色，$V$的颜色只能是绿色或者蓝色 存在一个$U,V$均包含的点$x$，使得对于所有在$U,V$集合中的点$y$，有$dis(x,y)\leq w$ 保证$n\leq 2000,w\leq10^7,c_i\leq10^6$，时限$1$s，对$10^9+7$取模 部分分： 对于$30\%$的数据，$n\leq 15$ 对于另$10\%$的数据，只有一个G 对于另$20\%$的数据，树是一条链 D2T3 函数有$n$个数$v_1,v_2,\cdots,v_n$，现在有一类函数$f_T(x)$，其中$T$是$V$的一个子集，它的定义是$$f_T(x)=\bigoplus_{v_i\in T}(x+v_i)\\f_\emptyset(x)=0$$我们称两个函数$f_s,f_t$是$W-$本质不同的，当且仅当存在一个$0\leq x\leq W$，使得$f_s(x)\not=f_t(x)$ 问在这$2^n$个函数中，有多少函数是$W-$本质不同的 保证$n,w,v_i&lt; 2^{17}$，时限$1$s 部分分： 对于$20\%$的数据，$n\leq15,w\leq10$ 对于另$20\%$的数据，$w=0$ 对于前$70\%$的数据，$n,w,v_i\leq2^{10}$]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二次剩余]]></title>
    <url>%2F2019%2F04%2F09%2F%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99%2F</url>
    <content type="text"><![CDATA[若方程$x^2\equiv a\pmod p$有解，那么称$a$为$p$的二次剩余，否则$a$为$p$的非二次剩余 勒让德符号及欧拉判别法定义勒让德符号为$$\left(\frac{a}{p}\right)=\begin{cases}1&amp;a为p的二次剩余\\ -1&amp;a为p的非二次剩余\\ 0 &amp;a能被p整除\end{cases}$$ 欧拉判别法就是：如果$a$不能被$p$整除，那么有$$\left(\frac{a}{p}\right)=a^{\frac{p-1}{2}}$$ 定理1 对于方程$x^2\equiv a\pmod p$ ，共有$\frac{p-1}{2}$个不同的$a$使得该方程有解 我们忽略$x=0$，如果枚举$x$再求出$a$，那么$x$一共有$p-1$个不同的值，也就产生了$p-1$个$a$ 我们知道一个二次剩余恰好会产生两个解，那么这$p-1$个$a$就被分配到了$\frac{p-1}{2}$个不同的桶里面 所以共有$\frac{p-1}{2}$个$a$ 定理2 $(x+y)^p\equiv x^p+y^p\pmod p$ 我们将其二项式展开$$(x+y)^p=\sum_{i=0}^p{p\choose i}x^iy^{p-i}$$当$i\not=0$且$i\not=p$时，$p\choose i$一定包含因数$p$，所以可以忽略 只剩下第一项和最后一项 Cipolla算法现在要求出方程$x^2\equiv n\pmod p$的一个解 我们找出一个$a​$，使得$(a^2-n)^{\frac{p-1}{2}}\equiv-1\pmod p​$ 设$\omega=\sqrt{a^2-n}$ 结论：$x=(a+\omega)^{\frac{p+1}{2}}$ 证明如下： 我们知道 $$(a^2-n)^{\frac{p-1}{2}}\equiv-1\pmod p\Rightarrow (\omega^2)^{\frac{p-1}{2}}\equiv -1\pmod p\\\omega^{p-1}\equiv -1\pmod p$$ 那么有$$\begin{aligned}x&amp;\equiv (a+\omega)^{\frac{p+1}{2}}\\x^2&amp;\equiv (a+\omega)^{p+1}\equiv(a+\omega)^p(a+\omega)\\&amp;\equiv(a^p+\omega^p)(a+\omega)\\&amp;\equiv(a-\omega)(a+\omega)\\&amp;\equiv a^2-\omega^2\equiv a^2-a^2+n\equiv n\end{aligned}$$我们可以通过实现一个类似复数的结构体来进行运算 由于$p$的二次剩余一共有$\frac{p-1}{2}$个，而$a$在$[0,p)$中随机选取 那么成功的概率就是$\frac{1}{2}$ 此时答案中$\omega$部分的系数必然为0]]></content>
      <tags>
        <tag>数学</tag>
        <tag>算法</tag>
        <tag>二次剩余</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BSGS及其拓展]]></title>
    <url>%2F2019%2F04%2F09%2FBSGS%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95%2F</url>
    <content type="text"><![CDATA[BSGS解高次同余方程$$A^x\equiv B\mod C且A\bot B$$根据费马小定理，我们直到$A^{C-1}\equiv B\mod C$ 那么如果这个方程有解，那么解的周期一定不会大于$C$，所以必然存在一个不大于$C$的解 如果$C$比较小，那么我们可以直接枚举$x$然后暴力判断 考虑$C$比较大的情况，这时就需要使用BSGS了 我们设$x=i*m-j$，其中$j&lt;m$，这个$m$是一个常量，我们设为$\sqrt{C}$ 那么有$$A^{i*m-j}\equiv B\mod C\\A^{i*m}\equiv B*A^j\mod C$$我们开一个map，枚举$j$，将$B*A^j$放到这个map里面 然后我们枚举$i*m$，在map中查找是否存在$A^{i*m}​$即可 注意这样枚举是取不到$x=0$的，这种情况我们需要特判 如果$i*m$此时已经大于$C$了，那么就无解 代码如下 12345678910unordered_map&lt;int, int&gt; s;inline int BSGS(int A, int B, int C) &#123; if (B % C == 1) return 0; s.clear(); int m = ceil(sqrt(C)), ls = 1; for (int i = 0;i &lt; m;i++, ls = (LL)ls * A % C) s[(LL)B * ls % C] = i; for (int i = m, t = ls;i &lt;= C;i += m, t = (LL)t * ls % C) if (s.count(t)) return i - s[t]; return -1;&#125; exBSGS同样是解上面那个方程 但是如果$A,C$不互质呢 原方程等价于$$A^x+Cy=B$$我们不停地消去$A,C$的非1因子，可以使得方程变为$$aA^z+C’y=B’$$每消去一次，我们就从$A^x$里面拿一个$A$出来，消完之后乘到系数$a$里面去 注意在消去过程中时，如果存在某个时刻使得$a=B’$，那么直接返回此时的消去次数就可以了 如果在消去过程中，$B’$没有当前要消去的那个因子，那么直接返回$-1$ 我们设消去次数为$k$ 那么此时方程就变成了$$aA^z\equiv B’\mod C’(A\bot C’)$$使用普通的BSGS可以解出$z$，注意此时前面还有一个系数$a$ 最后我们将解出的$z$加上$k$即可，因为最开始拿出了$k$个$A$来消去因数 代码如下 123456789101112131415161718192021int gcd(int a, int b) &#123;return b ? gcd(b, a % b) : a;&#125;unordered_map&lt;int, int&gt; s;inline int BSGS(int A, int B, int C, int basic) &#123; if (B % C == basic) return 0; s.clear(); int m = ceil(sqrt(C)), ls = 1; for (int i = 0;i &lt; m;i++, ls = (LL)ls * A % C) s[(LL)B * ls % C] = i; for (int i = m, t = (LL)ls * basic % C;i &lt;= C;i += m, t = (LL)t * ls % C) if (s.count(t)) return i - s[t]; return -1;&#125;inline int exBSGS(int A, int B, int C) &#123; int a = 1, cnt = 0, d; A %= C, B %= C; while ((d = gcd(A, C)) != 1) &#123; if (B % d) return -1; a = (LL)a * (A / d) % C, C /= d, B /= d, cnt++; if (a == B) return cnt; &#125; int res = BSGS(A, B, C, a); return ~res ? res + cnt : -1;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>算法</tag>
        <tag>BSGS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12省联考2019 字符串问题]]></title>
    <url>%2F2019%2F04%2F08%2F12%E7%9C%81%E8%81%94%E8%80%832019-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题面题意给出一个字符串$S$， 现在要选取它的$n_a$个子串作为$A$类串，选取$n_b$个子串作为$B$类串 其中第$i$个$A$类串为$S(la_i,ra_i)$，第$i$个$B$类串为$S(lb_i,rb_i)$，$la_i,ra_i,lb_i,rb_i,n_a,n_b$均已给出 现额外给定$m$组支配关系，每组关系$(x,y)$表示第$x$个$A$类串支配第$y$个$B$类串 求出一个长度最大的字符串$T$，满足$T$是由$A$类串拼接而成的。我们假设$T$被划分成了$t_1,t_2,\cdots,t_k$（都是$A$类串），要求满足对于任意的$i&lt;k$，$t_i$所支配的串中至少有一个是$t_{i+1}$的前缀 题解对于这种要求所求值最大的问题，不是动态规划就是最长路 那么对于这道题显然就只能是最长路了 如果最后构建出来的图有环，那么$T$就可以无限长 否则我们拓扑排序，然后跑一个dp就可以了 首先我们将$S$串翻转，将所有的$A$串与$B$串都翻转 这样限制条件就可以变为我们熟悉的后缀 我们先考虑一种暴力连边方式 每个$A$串建一个点，每个$B$串建一个点 对于$A_i$，将所有是其后缀的$B$连向$A_i$，权值为$|A_i|$ 对于一组支配$(A_i,B_i)$，$A_i$往$B_i$连一条权值为0的边 但是这样最坏会连$n_a*n_b$条边，需要优化 我们考虑这样一种优化方案 对于任意的$A_i,B_i$，如果$B_i$是$A_i$的后缀，那么$B_i$的后缀也是$A_i$的后缀 我们对于$B$单独建一个子图，这个子图需要满足如果$B_i$是$B_j$的后缀，那么所有能走到$B_i$的路径都可以走到$B_j$ 这样的话$A_i$只需要从它包含的那个最长的$B$串后缀连边就可以了 那么什么图满足这个性质呢？ 很明显是parent树 我们建出parent树，然后从父亲往儿子节点连边 因为父亲对应的点一定是儿子的后缀 对于每个串$A_i,B_i$，找到它在树上的位置，这个可以通过倍增实现 实际上我们不需要对于每个串$A$，都找到那个最长的且是它后缀的$B$ 直接从parent树上$A_i$的对应节点往$A_i$连边就可以了 因为这样同样可以保证最长的且是它后缀的$B$可以走到$A_i$ 兴奋地写完，发现第三个样例过不去($-1$) 事实上是我们少考虑了一种情况 parent树上的某个节点可以表示长度在一段区间的串 如果一条路径是从父亲走向儿子，那么当然没有问题，因为此时它代表的串是这个节点所能代表的最短的串 如果有一个串$A_i$以及另一个串$B_j$，它们对应着树上的同一个点 在之前的建图方式中，$B_j$一定能到达$A_i$ 但是如果$|B_j|&gt;|A_i|$呢，显然这种转移是不合法的 解决方法是对于树上的一个点$u$，假如有$a_u$个$A$串挂在上面 那么我们将这些$A$串按照长度从小到大排序，将$u$拆成$a_u+1$个点，第$i$个点往$i+1$个点连边，父亲的最右边那个点往儿子的最左边那个点连边 对于一个串$B$，它就对应着它在树上的那个点所拆成的点中，第一个长度不小于它的点 这样就没有问题了 注意开long long 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;bits/stdc++.h&gt;using namespace std;using P = pair&lt;int, int&gt;;using LL = long long;#define N 200010int LEN;namespace SAM &#123; struct node &#123; map&lt;char, int&gt; next; int link, len; &#125; st[N * 2]; int ncnt, last; inline void init() &#123;st[0].link = -1, st[0].len = ncnt = last = 0, st[0].next.clear();&#125; inline int extend(char c) &#123; int cur = ++ncnt, p; st[cur].len = st[last].len + 1, st[cur].link = 0, st[cur].next.clear(); for (p = last;p != -1 &amp;&amp; !st[p].next.count(c);p = st[p].link) st[p].next[c] = cur; if (p != -1) &#123; int q = st[p].next[c]; if (st[q].len == st[p].len + 1) st[cur].link = q; else &#123; int clone = ++ncnt; st[clone].len = st[p].len + 1, st[clone].next = st[q].next, st[clone].link = st[q].link; for (;p != -1 &amp;&amp; st[p].next[c] == q;p = st[p].link) st[p].next[c] = clone; st[q].link = st[cur].link = clone; &#125; &#125; return last = cur; &#125; inline void debug() &#123; for (int i = 0;i &lt;= ncnt;i++) for (auto v : st[i].next) cout &lt;&lt; "sam: " &lt;&lt; i &lt;&lt; ' ' &lt;&lt; v.second &lt;&lt; ' ' &lt;&lt; v.first &lt;&lt; endl; &#125;&#125;namespace SUF_Tree &#123; struct edge &#123;int to, next;&#125; e[N * 2]; int head[N * 2], ecnt, len[N * 2], fa[18][N * 2]; vector&lt;P&gt; nodes[N * 2]; inline void adde(int from, int to) &#123; e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt; &#125; void dfs(int u, int f) &#123; fa[0][u] = f; for (int i = 1;i &lt;= 17;i++) fa[i][u] = fa[i - 1][fa[i - 1][u]]; for (int i = head[u];i;i = e[i].next) if (e[i].to != f) dfs(e[i].to, u); &#125; inline void init() &#123; for (int i = 0;i &lt;= 2 * LEN;i++) head[i] = 0, nodes[i].clear(), nodes[i].push_back(P(1e9, -1)); ecnt = 0; &#125; inline int find(int u, int l) &#123; int now = u; for (int i = 17;i &gt;= 0;i--) if (fa[i][u]) if (l &lt;= len[fa[i][now]]) now = fa[i][now]; return now; &#125;&#125;char s[N]; int id[N], tot, onT[N], sz[N], onT2[N], na;namespace GRAPH &#123; struct edge &#123;int to, next, w;&#125; e[N * 6]; int head[N * 4], ecnt, ind[N * 4], st[N * 4], top, ncnt; LL dp[N * 4]; inline void adde(int from, int to, int w) &#123; e[++ecnt] = (edge)&#123;to, head[from], w&#125;, ind[to]++, head[from] = ecnt; &#125; inline bool Topsort() &#123; top = 0; queue&lt;int&gt; q; for (int i = 1;i &lt;= ncnt;i++) if (!ind[i]) q.push(i), st[++top] = i; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u];i;i = e[i].next) if (!(--ind[e[i].to])) q.push(e[i].to), st[++top] = e[i].to; &#125; return top == ncnt; &#125; inline void init() &#123; for (int i = 1;i &lt;= ncnt;i++) head[i] = ind[i] = dp[i] = 0; ecnt = 0; &#125; inline LL DP() &#123; LL res = 0; for (int i = top;i &gt;= 1;i--) &#123; int u = st[i]; for (int j = head[u];j;j = e[j].next) dp[u] = max(dp[u], dp[e[j].to] + e[j].w); if (u &lt;= na) res = max(res, dp[u] + sz[u]); &#125; return res; &#125;&#125;vector&lt;int&gt; p[N * 2];void dfs(int u) &#123; p[u].clear(); for (auto v : SUF_Tree::nodes[u]) &#123; p[u].push_back(++tot); if (v.second &gt; 0) onT[v.second] = tot; &#125; for (int i = 0;i + 1 &lt; p[u].size();i++) GRAPH::adde(p[u][i], p[u][i + 1], 0); for (int i = SUF_Tree::head[u];i;i = SUF_Tree::e[i].next) &#123; dfs(SUF_Tree::e[i].to); GRAPH::adde(*p[u].rbegin(), *p[SUF_Tree::e[i].to].begin(), 0); &#125;&#125;template &lt;class T&gt; inline void read(T &amp;x) &#123; x = 0; char c = getchar(); while (c &lt; '0' || c &gt; '9') c = getchar(); while ('0' &lt;= c &amp;&amp; c &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - '0', c = getchar();&#125;int main() &#123; int T; read(T); while (T--) &#123; scanf("%s", s + 1), LEN = strlen(s + 1), reverse(s + 1, s + LEN + 1), SAM::init(), SUF_Tree::init(); for (int i = 1;i &lt;= LEN;i++) id[i] = SAM::extend(s[i]);// cout &lt;&lt; SAM::ncnt &lt;&lt; endl; for (int i = 1;i &lt;= SAM::ncnt;i++) SUF_Tree::adde(SAM::st[i].link, i), SUF_Tree::len[i] = SAM::st[i].len; SUF_Tree::dfs(0, 0); read(na), tot = na;// cout &lt;&lt; "ok" &lt;&lt; endl; for (int i = 1, l, r;i &lt;= na;i++) &#123; read(l), read(r), l = LEN - l + 1, r = LEN - r + 1, swap(l, r), sz[i] = r - l + 1; int t = SUF_Tree::find(id[r], r - l + 1); SUF_Tree::nodes[t].push_back(P(r - l + 1, i)); &#125; GRAPH::ncnt = na * 2 + SAM::ncnt + 1, GRAPH::init(); for (int i = 1;i &lt;= SAM::ncnt;i++) sort(SUF_Tree::nodes[i].begin(), SUF_Tree::nodes[i].end()); dfs(0); for (int i = 1;i &lt;= na;i++) GRAPH::adde(onT[i], i, sz[i]); int nb; read(nb); for (int i = 1, l, r;i &lt;= nb;i++) &#123; read(l), read(r), l = LEN - l + 1, r = LEN - r + 1, swap(l, r); int t = SUF_Tree::find(id[r], r - l + 1); int pos = lower_bound(SUF_Tree::nodes[t].begin(), SUF_Tree::nodes[t].end(), P(r - l + 1, -2)) - SUF_Tree::nodes[t].begin(); onT2[i] = p[t][pos]; &#125; int matches; read(matches); for (int i = 1;i &lt;= matches;i++) &#123; int a, b; read(a), read(b), GRAPH::adde(a, onT2[b], 0); &#125; GRAPH::ncnt = tot; if (!GRAPH::Topsort()) &#123;puts("-1"); continue;&#125; printf("%lld\n", GRAPH::DP()); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>优化连边</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BJOI2018 双人猜数游戏]]></title>
    <url>%2F2019%2F04%2F07%2FBJOI2018-%E5%8F%8C%E4%BA%BA%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题目链接 神仙题啊 首先来模拟一下样例 Alice知道乘积是60，Bob知道和是16，且两个数均不小于5 Bob：此时两个数有可能为 $(5, 11), (6, 10), (7, 9), (8, 8)$ 而Bob在第一轮没有猜出来，也就是说，这两个数的和不是10或11 Alice：此时两个数有可能为 $(5, 12), (6, 10)$ 由于Alice也没有猜出来，所以对于Bob来说，以下情况就被排除了 $(5, 11), (7, 9), (8, 8)$ 对于$(5, 11)$而言，55只有这一种分解方式，而Alice在第一轮中没有猜出来，所以不是 对于$(7, 9)$而言，63还可以被分解成$(3, 21)$，但是不满足两个数都大于等于5，而Alice没有猜出来，所以也不是 $(8, 8)​$同理 所以对于Bob来说，这两个数只有可能是$(6, 10)$，他也就确定了答案 Alice知道，Bob已经猜出来了，所以$(5, 12)$就被排除了，因为在这种情况下，$Bob​$不可能这么早就猜出答案 所以Alice也知道答案是$(6, 10)​$了 我们用dp来描述这个过程，dp[i][n][m]表示，当前是第i轮，且两个答案分别是$n,m$，在$1-i​$轮中，是否能决定答案 如果这一轮是Bob猜，那么我们就枚举$n+m$的划分方式。如果每一种合法的划分方式都能在$1-(i-1)$轮被猜出来，那么Bob一定能确定这两个数分别为$n, m$ 否则，我们则枚举$n*m$的约数， 判断方式与Bob的相同 但是这样可能会出现一种特殊情况，就是已经到了$t$轮，第一个人猜出来了，而第二个人没有猜出来 那么我们就多进行一轮转移，这次转移与之前的转移相反，如果每一种合法的划分方式在$1-t$轮都不能被猜出来，那么才能确定答案 $n,m$的最大值不会超过500，直接枚举 直接交程序，数组只开500的话是秒跑 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;#define N 500int dp[N + 10][N + 10][16], m;inline bool check1(int a, int b, int c) &#123; int cnt = 0, tmpa, tmpb; for (int i = m, j;i &lt;= a + b - i &amp;&amp; cnt &lt; 2;i++) if (!dp[i][j = a + b - i][c - 1] || c == 1) cnt++, tmpa = i, tmpb = j; return cnt == 1 &amp;&amp; a == tmpa &amp;&amp; b == tmpb;&#125;inline bool check2(int a, int b, int c) &#123; int cnt = 0, tmpa, tmpb; for (int i = m, j;i * i &lt;= a * b &amp;&amp; cnt &lt; 2;i++) if (a * b % i == 0 &amp;&amp; (!dp[i][j = a * b / i][c - 1] || c == 1)) cnt++, tmpa = i, tmpb = j; return cnt == 1 &amp;&amp; a == tmpa &amp;&amp; b == tmpb;&#125;inline bool check3(int a, int b, int c) &#123; int cnt = 0, tmpa, tmpb; for (int i = m, j;i &lt;= a + b - i &amp;&amp; cnt &lt; 2;i++) if (dp[i][j = a + b - i][c] &amp;&amp; !dp[i][j][c - 2]) cnt++, tmpa = i, tmpb = j; return cnt == 1 &amp;&amp; a == tmpa &amp;&amp; b == tmpb;&#125;inline bool check4(int a, int b, int c) &#123; int cnt = 0, tmpa, tmpb; for (int i = m, j;i * i &lt;= a * b &amp;&amp; cnt &lt; 2;i++) if (a * b % i == 0 &amp;&amp; dp[i][j = a * b / i][c] &amp;&amp; !dp[i][j][c - 2]) cnt++, tmpa = i, tmpb = j; return cnt == 1 &amp;&amp; a == tmpa &amp;&amp; b == tmpb;&#125;char name[8];int main() &#123; int t, flag; scanf("%d%s%d", &amp;m, name + 1, &amp;t), flag = name[1] == 'B'; for (int i = 1;i &lt;= t + 1;i++) for (int a = m;a &lt;= N / 2;a++) for (int b = a;b &lt;= N;b++) dp[a][b][i] = dp[a][b][i - 2] | (((i &amp; 1) ^ flag ^ 1) ? check1(a, b, i) : check2(a, b, i)); for (int s = m * 2;s;s++) for (int a = m, b = s - a;a * 2 &lt;= s;a++, b = s - a) if (dp[a][b][t + 1] &amp;&amp; !(dp[a][b][t - 1] | dp[a][b][t])) &#123; int tmp = t &amp; 1 ^ flag; if (!(tmp ? check4(a, b, t + 1) : check3(a, b, t + 1))) continue; cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; endl; return 0; &#125;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BJOI2018 二进制]]></title>
    <url>%2F2019%2F04%2F07%2FBJOI2018-%E4%BA%8C%E8%BF%9B%E5%88%B6%2F</url>
    <content type="text"><![CDATA[题目链接 先考虑哪些二进制在重新排列之后可以是3的倍数 我们分3种情况讨论： 0 ：模3的余数是0 10 ：就是1出现在下标为偶数的地方，模3余2 01 ：1出现在下标为奇数的地方，模3余1 那么，我们就可以用这三种余数来进行组合 考虑以下情况： 有偶数个1 ：显然，通过情况2与3组合可以成为3的倍数 有奇数个1 ：注意到3个情况2或者情况3的叠加仍然可以成为3的倍数，而这样至少需要2个0和3个1（10101） 那么综合上面两种情况，我们可以得出结论，一段区间为不合法的区间当且仅当： 区间内只有1个1 区间中有奇数个1且没有0 区间中有奇数个1且有1个0 这道题是带修改的，所以需要将dp放到线段树上统计 那么我们考虑一段区间应该维护什么 首先将第一种情况分开，先不管 那么对于一段区间，我们可以用dp[i][j(0/1)][k(0/1)]表示 即状态为$i$，1的个数是奇数还是偶数，出现了0个0还是1个0的区间总数 线段树pushup的时候子区间也是可以跨mid合并的 具体来说，就是一个左子树的以mid为右端点的区间和一个右子树的以mid + 1为左端点的区间合并 所以，对于状态i，我们这样设计 i = 0 表示不取左端点和右端点 i = 1 表示必须取左端点，不能取右端点 i = 2 表示必须取右端点，不能取左端点 i = 3 表示必须左右端点都取 合并的时候枚举一下有几个0以及1的奇偶性就可以了 我们另外开一个数组，单独统计情况1，也就是只有1个1的区间的数量 转移与上面的类似 g[i][j(0/1)]表示状态为$i$，出没出现1的区间的总数 但是统计的时候不能直接将两个加起来 注意到这两个统计是有重复的，当我们进行第一次统计时也顺便统计了区间内有1个1，只有0/1个0的数量，需要去重 对于有1个1，0个0的区间数量，显然也就是区间内1的数量 对于有1个1，1个0的区间数量，我们用一个树状数组维护，在这个01区间的第一位维护即可 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010#define LL long longstruct Data &#123; LL f[4][2][2], g[4][2]; Data() &#123;memset(f, 0, sizeof(f)), memset(g, 0, sizeof(g));&#125;&#125; T[N &lt;&lt; 2];inline Data UN(Data a, Data b) &#123; Data c; for (int i = 0;i &lt;= 1;i++) &#123; for (int j = 0;j &lt;= 1;j++) &#123; c.f[0][i][j] += a.f[0][i][j] + b.f[0][i][j] + a.f[2][i][j] + b.f[1][i][j]; c.f[1][i][j] += a.f[1][i][j] + a.f[3][i][j], c.f[2][i][j] += b.f[2][i][j] + b.f[3][i][j]; &#125; c.g[0][i] += a.g[0][i] + b.g[0][i] + a.g[2][i] + b.g[1][i]; c.g[1][i] += a.g[1][i] + a.g[3][i], c.g[2][i] += b.g[2][i] + b.g[3][i]; &#125; for (int i = 0;i &lt;= 1;i++) for (int j = 0;j &lt;= 1;j++) &#123; if (i + j &lt;= 1) &#123; c.g[0][i + j] += a.g[2][i] * b.g[1][j], c.g[1][i + j] += a.g[3][i] * b.g[1][j]; c.g[2][i + j] += a.g[2][i] * b.g[3][j], c.g[3][i + j] += a.g[3][i] * b.g[3][j]; &#125; for (int k = 0;k &lt;= 1;k++) for (int l = 0;k + l &lt;= 1;l++) &#123; int ti = (i + j) &amp; 1, tj = k + l; c.f[0][ti][tj] += a.f[2][i][k] * b.f[1][j][l], c.f[1][ti][tj] += a.f[3][i][k] * b.f[1][j][l]; c.f[2][ti][tj] += a.f[2][i][k] * b.f[3][j][l], c.f[3][ti][tj] += a.f[3][i][k] * b.f[3][j][l]; &#125; &#125; return c;&#125;int val[N];void build(int rt, int l, int r) &#123; if (l == r) return void(T[rt].f[3][val[l]][val[l] ^ 1] = T[rt].g[3][val[l]] = 1); int mid = (l + r) &gt;&gt; 1; build(rt &lt;&lt; 1, l, mid), build(rt &lt;&lt; 1 | 1, mid + 1, r); T[rt] = UN(T[rt &lt;&lt; 1], T[rt &lt;&lt; 1 | 1]);&#125;void update(int rt, int l, int r, int at) &#123; if (l == r) &#123; val[l] ^= 1, T[rt] = Data(); T[rt].f[3][val[l]][val[l] ^ 1] = T[rt].g[3][val[l]] = 1; return; &#125; int mid = (l + r) &gt;&gt; 1; if (at &lt;= mid) update(rt &lt;&lt; 1, l, mid, at); else update(rt &lt;&lt; 1 | 1, mid + 1, r, at); T[rt] = UN(T[rt &lt;&lt; 1], T[rt &lt;&lt; 1 | 1]);&#125;Data query(int rt, int l, int r, int start, int end) &#123; if (start &lt;= l &amp;&amp; r &lt;= end) return T[rt]; int mid = (l + r) &gt;&gt; 1; if (end &lt;= mid) return query(rt &lt;&lt; 1, l, mid, start, end); if (start &gt; mid) return query(rt &lt;&lt; 1 | 1, mid + 1, r, start, end); return UN(query(rt &lt;&lt; 1, l, mid, start, mid), query(rt &lt;&lt; 1 | 1, mid + 1, r, mid + 1, end));&#125;int tree[2][N], n;inline void update(int id, int at, int x) &#123;for (;at &lt;= n;at += at &amp; -at) tree[id][at] += x;&#125;inline int query(int id, int at) &#123; int res = 0; for (;at;at -= at &amp; -at) res += tree[id][at]; return res;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;val[i]), update(0, i, val[i]); for (int i = 1;i &lt; n;i++) if (val[i] != val[i + 1]) update(1, i, 1); build(1, 1, n); int q; scanf("%d", &amp;q); while (q--) &#123; int a, b, c; scanf("%d%d", &amp;a, &amp;b); if (a == 1) &#123; if (b != n) update(1, b, -2 * (val[b] != val[b + 1]) + 1); if (b != 1) update(1, b - 1, -2 * (val[b - 1] != val[b]) + 1); update(0, b, -2 * val[b] + 1), update(1, 1, n, b); &#125; else &#123; scanf("%d", &amp;c); Data tmp = query(1, 1, n, b, c); LL res = 0; for (int i = 0;i &lt;= 3;i++) res += tmp.f[i][1][0] + tmp.f[i][1][1] + tmp.g[i][1]; res -= query(0, c) - query(0, b - 1) + query(1, c - 1) - query(1, b - 1); printf("%lld\n", (LL)(c - b + 1) * (c - b + 2) / 2 - res); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>二进制</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFT与NTT专题]]></title>
    <url>%2F2019%2F04%2F07%2FFFT%E4%B8%8ENTT%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[A – 礼物先不管旋转操作，考虑化简这个差异值 $$\begin{aligned}\sum_{i=1}^n(x_i-y_i-c)^2&amp;=\sum_{i=1}^n(x_i-y_i)^2+nc^2-2c\sum_{i=1}^n(x_i-y_i)\\&amp;=\sum_{i=1}^nx_i^2+\sum_{i=1}^ny_i^2+nc^2-2c\sum_{i=1}^n(x_i-y_i)-2\sum_{i=1}^nx_iy_i\end{aligned}$$ 注意到$\sum x^2+\sum y^2$是常数，先不管 可以发现，这是一个关于$c$的二次函数 那么我们知道，此时$c$的极值点就在$-\frac{b}{2a}$处 所以，我们可以得出$c$的最优值是 $$\frac{\sum_{i=1}^n x_i-\sum_{i=1}^n y_i}{n}$$ 而分子的两个数均与旋转无关 但是$c$只能是整数 所以判一下$c, c-1, c+1$哪个与上面的式子更接近 注意到旋转唯一能改变的是$\sum xy$ 而我们要让这个值尽量小 设 $$F(m)=\sum_{i=1}^nx_iy_{i+m}$$ 我们可以看出，这是一个类似卷积的东西 但是一般的卷积是后两式下标的和不变 而这个是差不变 所以把这个式子变一下 设 $$x_{n-i+1}=x_i$$ 就是将x倒序一下 可以得到 $$F(m)=\sum_{i=1}^nx_{n-i+1}y_{i+m}$$ 不妨设后面$xy$的卷积是$A$，也就是 $$A(n+m+1)=\sum_{i=1}^nx_{n-i+1}y_{i+m}$$ 可以发现，这个$A$就是将$F$整体向右平移了$n+1$ 所以 $$F(m)=A(n+m+1)$$ 为了不丢精度，NTT即可（保证答案不会超过mod） 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010#define LL long longint r[N &lt;&lt; 2]; const int mod = 998244353;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;inline void NTT(int len, int type, int a[]) &#123; for (int i = 0;i &lt; len;i++) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int mid = 2;mid &lt;= len;mid &lt;&lt;= 1) &#123; int Wn = Pow(3, type ? (mod - 1) / mid : mod - 1 - (mod - 1) / mid); for (int i = 0;i &lt; len;i += mid) for (int j = i, w = 1, t;j &lt; i + (mid &gt;&gt; 1);j++, w = (LL)w * Wn % mod) t = (LL)w * a[j + (mid &gt;&gt; 1)] % mod, a[j + (mid &gt;&gt; 1)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod; &#125;&#125;int x[N], y[N], A[N &lt;&lt; 2], B[N &lt;&lt; 2], res[N];template&lt;class T&gt; inline T Abs(const T x) &#123;return x &gt; 0 ? x : -x;&#125;int main() &#123; int n, m, sumx = 0, sumy = 0, sumx2 = 0, sumy2 = 0; scanf("%d%d", &amp;n, &amp;m); for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;x[i]), A[i] = x[i], sumx += x[i], sumx2 += x[i] * x[i]; for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;y[i]), B[2 * n - i] = B[n - i] = y[i], sumy += y[i], sumy2 += y[i] * y[i]; int len = 1, l = 0; while (len &lt;= 3 * n) len &lt;&lt;= 1, l++; for (int i = 1;i &lt;= len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); NTT(len, 1, A), NTT(len, 1, B); for (int i = 0;i &lt; len;i++) A[i] = (LL)A[i] * B[i] % mod; NTT(len, 0, A); int Inv = Pow(len, mod - 2); for (int i = 0;i &lt; n;i++) res[i] = (LL)A[2 * n - i] * Inv % mod; int c = (sumx - sumy) / n; LL ans = 1e18; if (Abs((LL)c * n - sumx + sumy) &gt; Abs(((LL)c * n + n - sumx + sumy))) c++; if (Abs((LL)c * n - sumx + sumy) &gt; Abs(((LL)c * n - n - sumx + sumy))) c--; for (int i = 0;i &lt; n;i++) &#123; LL tmp = (LL)sumx2 + sumy2 - 2 * res[i] - (LL)2 * c * (sumx - sumy) + (LL)n * c * c; if (tmp &lt; ans) ans = tmp; &#125; printf("%lld\n", ans); return 0;&#125; B – 求和我们知道 $$S(n,m)=\sum_{i=0}^m(-1)^i{m\choose i}(m-i)^n\frac{1}{m!}$$ 原理很简单，容斥有几个盒子没有放球，有$m\choose i$种选法，再将$n$个球放入$m-i$个盒子。由于盒子是无序的，最后除以$m$的阶乘 那么我们用这个化简原式 注意到第二个$\sum$的上界是$i$，非常讨厌 由于斯特林数的性质，把这个$i$换成$n$也没有问题 因为当$m&gt;n$时，$S(n,m)=0$ 所以有 $$\begin{aligned}\sum_{i=0}^n\sum_{j=0}^nS(i,j)*2^j*j!&amp;=\sum_{j=0}^n2^j*j!\sum_{i=0}^n\sum_{k=0}^j(-1)^k{j\choose k}(j-k)^i\frac{1}{j!}\\&amp;=\sum_{j=0}^n2^j*j!\sum_{k=0}^j\frac{(-1)^k}{k!}*\frac{\sum_{i=0}^n(j-k)^i}{(j-k)!}\end{aligned}$$ 注意到后面那个是卷积的形式 第一个多项式很好求，第二个的分子是等比数列 我们设$B$是第二个多项式 显然有 $$B(0)=0, B(1)=n+1$$ 对于其它情况，直接用等比数列求和公式算出来就行了 代码如下 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010#define LL long longint r[N &lt;&lt; 2]; const int mod = 998244353;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;inline void NTT(int len, int type, int a[]) &#123; for (int i = 0;i &lt; len;i++) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int mid = 2;mid &lt;= len;mid &lt;&lt;= 1) &#123; int Wn = Pow(3, type ? (mod - 1) / mid : mod - 1 - (mod - 1) / mid); for (int i = 0;i &lt; len;i += mid) for (int j = i, w = 1, t;j &lt; i + (mid &gt;&gt; 1);j++, w = (LL)w * Wn % mod) t = (LL)w * a[j + (mid &gt;&gt; 1)] % mod, a[j + (mid &gt;&gt; 1)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod; &#125;&#125;int A[N &lt;&lt; 2], B[N &lt;&lt; 2], frac[N];int main() &#123; int n, len = 1, l = 0; scanf("%d", &amp;n); frac[0] = 1; for (int i = 1;i &lt;= n;i++) frac[i] = (LL)frac[i - 1] * i % mod; while (len &lt;= 2 * n) len &lt;&lt;= 1, l++; for (int i = 0;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); A[0] = B[0] = 1, B[1] = n + 1; for (int i = 1;i &lt;= n;i++) A[i] = (i &amp; 1 ? -1 : 1) * Pow(frac[i], mod - 2), A[i] = (A[i] + mod) % mod; for (int i = 2;i &lt;= n;i++) B[i] = ((LL)(Pow(i, n + 1) - 1) * Pow(i - 1, mod - 2) % mod * Pow(frac[i], mod - 2) % mod + mod) % mod; NTT(len, 1, A), NTT(len, 1, B); for (int i = 0;i &lt; len;i++) A[i] = (LL)A[i] * B[i] % mod; NTT(len, 0, A); int Inv = Pow(len, mod - 2); int tmp = 1, res = 0; for (int i = 0;i &lt;= n;i++) res = (res + (LL)tmp * frac[i] % mod * A[i]) % mod, tmp = tmp * 2 % mod; printf("%d\n", (LL)res * Inv % mod); return 0;&#125; C – 序列统计这题的难点在于转化成原根 注意到要求的是所有数的乘积而非和 如果是和的话直接NTT就好了 那么我们就将乘积转化成和的形式 如果两个数都是某个数的某次方，那么这两个数乘起来就是指数相加 而原根恰好可以表示模$m$剩余系下的每个数 所以把每个数转化成原根的某次方就好了 求原根代码 12345678inline int G(int x) &#123; if (x == 2) return 1; for (int i = 2, flg = 1;i;i++, flg = 1) &#123; for (int j = 2;j * j &lt; x;j++) if ((x - 1) % j == 0 &amp;&amp; Pow(i, (x - 1) / j, x) == 1) &#123;flg = 0; break;&#125; if (flg) return i; &#125;&#125; D – 残缺的字符串带通配符的字符串匹配问题 首先考虑不带通配符的怎么做 那么拓展KMP， 后缀数组都可以 但是我们有一个更高级的方法：FFT求字符串匹配 首先我们需要定义“匹配” 所以设差异函数$g(i)$表示从$B$串的$i$位置开始，与$A$串的差异程度 有 $$g(x)=\sum_{i=x}^{x+m-1}(B_i-A_{i-x+1})^2$$ 显然，只有当$A$串从$x$位置开始与$B$串完全相同，$g$的值才为0 化简原式 $$\begin{aligned}g(x)&amp;=\sum_{i=x}^{x+m-1}A_{i-x+1}^2+\sum_{i=x}^{x+m-1}B_i^2-2\sum_{i=x}^{x+m-1}B_iA_{i-x+1}\\&amp;=\sum_{i=1}^mA_i^2+\sum_{i=1}^mB_{i+x-1}^2-2\sum_{i=1}^mA_iB_{i+x-1}\end{aligned}$$ 前两项可以通过预处理前缀和得出，后面的是一个下标差相等的卷积 那么模仿之前的套路，我们将$A$序列倒序一下再求卷积就行了 解决了不带通配符的问题，再考虑带通配符 这个通配符是可以匹配任意字符的，所以把差异函数改一下 $$g(x)=\sum_{i=x}^{x+m-1}(B_i-A_{i-x+1})^2A_{i-x+1}B_i$$ 当$i$处的字符是$*$时，我们设那个地方的值为0 化简得 $$=\sum_{i=1}^mA_i^3B_{i-x+1}+\sum_{i=1}^mA_iB_{i-x+1}^3-2\sum_{i=1}^xA_i^2B_{i-x+1}^2$$ 做3次FFT即可 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;#define N 300010int r[N &lt;&lt; 2]; const double PI = acos(-1);inline void FFT(int len, int type, complex&lt;double&gt; a[]) &#123; for (int i = 1;i &lt; len;i++) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int mid = 2;mid &lt;= len;mid &lt;&lt;= 1) &#123; complex&lt;double&gt; Wn(cos(2 * PI / mid), type * sin(2 * PI / mid)); for (int i = 0;i &lt; len;i += mid) &#123; complex&lt;double&gt; w(1), t; for (int j = i;j &lt; i + (mid &gt;&gt; 1);j++, w *= Wn) t = w * a[j + (mid &gt;&gt; 1)], a[j + (mid &gt;&gt; 1)] = a[j] - t, a[j] += t; &#125; &#125;&#125;char a[N], b[N]; complex&lt;double&gt; A[N &lt;&lt; 2], B[N &lt;&lt; 2]; int a1[N], b1[N];#define LL long longLL res[N]; vector&lt;int&gt; ans;#define Clear(x) for (int i = 0;i &lt; len;i++) x[i] = 0;inline void mul(int len, int n, int k) &#123; FFT(len, 1, A), FFT(len, 1, B); for (int i = 0;i &lt; len;i++) A[i] *= B[i]; FFT(len, -1, A); for (int i = 1;i &lt;= n;i++) res[i] += k * (LL)(A[i].real() / len + 0.5);&#125;int main() &#123; int n, m; scanf("%d%d%s%s", &amp;m, &amp;n, a + 1, b + 1); for (int i = 1;i &lt;= m;i++) a1[m - i] = a[i] == '*' ? 0 : a[i] - 'a' + 1; for (int i = 1;i &lt;= n;i++) b1[i] = b[i] == '*' ? 0 : b[i] - 'a' + 1; int len = 1, l = 0; while (len &lt;= m + n) len &lt;&lt;= 1, l++; for (int i = 0;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); for (int i = 0;i &lt; m;i++) A[i] = a1[i] * a1[i] * a1[i]; for (int i = 1;i &lt;= n;i++) B[i] = b1[i]; mul(len, n, 1); Clear(A) Clear(B) for (int i = 0;i &lt; m;i++) A[i] = a1[i]; for (int i = 1;i &lt;= n;i++) B[i] = b1[i] * b1[i] * b1[i]; mul(len, n, 1); Clear(A) Clear(B) for (int i = 0;i &lt; m;i++) A[i] = a1[i] * a1[i]; for (int i = 1;i &lt;= n;i++) B[i] = b1[i] * b1[i]; mul(len, n, -2); for (int i = m;i &lt;= n;i++) if (res[i] == 0) ans.push_back(i - m + 1); printf("%d\n", ans.size()); for (auto i : ans) printf("%d ", i); return 0;&#125; E – 万径人踪灭假设当前确定了一个对称中心$i$ 那么当两个位置$j,k$关于i对称且这两个位置的字母相同时对答案有贡献 对称则意味着$j+k=i*2​$，可以FFT 枚举字符，然后FFT 假设这个中心有x对这样的位置 那么每一对都是独立的，可以选也可以不选，但是不能都不选 所以此时的答案为$2^x-1$ 题目要求不能全部连续，那么最后再跑一边manacher，减去全部连续的答案即可 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010#define LL long longint r[N &lt;&lt; 2]; const int mod = 998244353;inline int Pow(int x, int y, int p = mod) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % p) if (y &amp; 1) res = (LL)res * x % p; return res;&#125;inline void NTT(int len, int type, int a[]) &#123; for (int i = 0;i &lt; len;i++) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int mid = 2;mid &lt;= len;mid &lt;&lt;= 1) &#123; int Wn = Pow(3, type ? (mod - 1) / mid : mod - 1 - (mod - 1) / mid); for (int i = 0;i &lt; len;i += mid) for (int j = i, t, w = 1;j &lt; i + (mid &gt;&gt; 1);j++, w = (LL) w * Wn % mod) t = (LL)w * a[j + (mid &gt;&gt; 1)] % mod, a[j + (mid &gt;&gt; 1)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod; &#125;&#125;int A[N &lt;&lt; 2], B[N &lt;&lt; 2], pal[N &lt;&lt; 2], Pow2[N]; char s[N], t[N * 2]; const int p = 1e9 + 7;inline int manacher(int n) &#123; t[0] = '#', t[n * 2 + 1] = '$', t[n * 2 + 2] = '@'; for (int i = 1;i &lt;= n;i++) t[i * 2 - 1] = '$', t[i * 2] = s[i]; int pos = 1, mx = 1, res = 0; pal[1] = 1; for (int i = 2;i &lt;= n * 2;i++) &#123; if (i &lt;= mx) pal[i] = min(mx - i + 1, pal[2 * pos - i]); else pal[i] = 1; while (t[i - pal[i]] == t[i + pal[i]]) pal[i]++; if (i + pal[i] - 1 &gt; mx) mx = i + pal[i] - 1, pos = i; res = (res + pal[i] / 2) % p; &#125; return res;&#125;int main() &#123; scanf("%s", s + 1); int n = strlen(s + 1); for (int i = 1;i &lt;= n;i++) if (s[i] == 'a') A[i] = 1; else B[i] = 1; int len = 1, l = 0, ans = 0; Pow2[0] = 1; for (int i = 1;i &lt;= n;i++) Pow2[i] = Pow2[i - 1] * 2 % p; while (len &lt;= n * 2) len &lt;&lt;= 1, l++; for (int i = 0;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); NTT(len, 1, A), NTT(len, 1, B); for (int i = 0;i &lt; len;i++) A[i] = (LL)A[i] * A[i] % mod, B[i] = (LL)B[i] * B[i] % mod; NTT(len, 0, A), NTT(len, 0, B); int Inv = Pow(len, mod - 2); for (int i = 2, t;i &lt;= n * 2;i++) &#123; t = (LL)(A[i] + B[i]) * Inv % mod + (i &amp; 1 ^ 1); ans = (ans + Pow2[t / 2] - 1) % p; &#125; printf("%d\n", (ans - manacher(n) + p) % p); return 0;&#125; F – 性能优化这道题利用到了FFT的原理 如果模数是质数，那么非常好办 但是这题不仅模数不是质数，而且求的是循环卷积，直接FFT会爆炸 贴一篇我觉得很好的题解 这个rev数组可以模拟FFT的过程，递归地求出来 单位根满足消去律，上面的$F(\omega_n^i)$指的是$i\leq \frac{n}{p}$的情况 对于剩余的情况，有$\omega_{\frac{n}{p}}^i=\omega_{\frac{n}{p}}^{i-\frac{n}{p}}$ 也就是说，代入的$F^{[0]},F^{[1]},\cdots,F^{[p-1]}$都相同，但是系数不同 然后分治就可以了 同样地，最后需要除以len，也就是模数$-1$ 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define N 500010inline int Pow(int x, int y, int mod) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;int tot, prime[N], r[N];int GetPos(int x, int dep, int len, int cnt) &#123; if (dep == tot + 1) return cnt; int tmp = len / prime[dep], s = x % prime[dep]; return GetPos((x - s) / prime[dep], dep + 1, tmp, cnt + tmp * s);&#125;int tmp[N], g;inline void NTT(int len, int a[], int mod, int type) &#123; for (int i = 0;i &lt; len;i++) tmp[r[i]] = a[i]; for (int i = 0;i &lt; len;i++) a[i] = tmp[i]; for (int i = tot, block = 1;i &gt;= 1;i--) &#123; int mid = block; block *= prime[i]; int Wn = Pow(g, type ? (mod - 1) / block : mod - 1 - (mod - 1) / block, mod); for (int j = 0;j &lt; len;j++) tmp[j] = 0; for (int j = 0, Wk = 1;j &lt; len;j += block, Wk = 1) for (int k = 0;k &lt; block;k++) &#123; for (int l = k % mid, w = 1;l &lt; block;l += mid, w = (LL)w * Wk % mod) tmp[j + k] = (tmp[j + k] + (LL)w * a[j + l]) % mod; Wk = (LL)Wk * Wn % mod; &#125; for (int j = 0;j &lt; len;j++) a[j] = tmp[j]; &#125; &#125;inline int GetG(int x) &#123; if (x == 2) return 1; for (int i = 2, flag = 1;i;i++, flag = 1) &#123; for (int j = 2;j * j &lt; x;j++) if (Pow(i, (x - 1) / j, x) == 1) &#123;flag = 0; break;&#125; if (flag == 1) return i; &#125;&#125;int A[N &lt;&lt; 2], B[N &lt;&lt; 2];int main() &#123; int n, C; scanf("%d%d", &amp;n, &amp;C); for (int i = 0;i &lt; n;i++) scanf("%d", &amp;A[i]); for (int i = 0;i &lt; n;i++) scanf("%d", &amp;B[i]); int tmp = n; g = GetG(n + 1); for (int i = 2;i * i &lt;= tmp;i++) while (tmp % i == 0) prime[++tot] = i, tmp /= i; if (tmp != 1) prime[++tot] = tmp; for (int i = 0;i &lt; n;i++) r[i] = GetPos(i, 1, n, 0); NTT(n, A, n + 1, 1), NTT(n, B, n + 1, 1); for (int i = 0;i &lt; n;i++) A[i] = (LL)A[i] * Pow(B[i], C, n + 1) % (n + 1); NTT(n, A, n + 1, 0); int Inv = Pow(n, n - 1, n + 1); for (int i = 0;i &lt; n;i++) printf("%d\n", (LL)A[i] * Inv % (n + 1)); return 0;&#125; H – Frightful Formula算是比较简单的一道题 公式等价于一个表格，往右走有$a$种方法，往下走有$b$种方法，还可以直接从这个格子开始走，有$c$种方法 先不考虑第一行和第一列格子 假设是从$i,j$这个格子开始走的 那么，这个格子需要向右走$n-j$步，向下走$n-i$步 对答案的贡献是 $$c*a^{n-i}*b^{n-j}*{n-i+n-j\choose n-i}$$ 含义是，从这个格子开始，有$c$种走法，向有走$n-j$次，向下走$n-i$次，在$n-j+n-i$步中，有$n-i​$步是往下走的 那么，把这些空白的格子加起来，我们可以得到 $$\begin{aligned}c\sum_{i=2}^n\sum_{j=2}^na^{n-i}b^{n-j}{n-i+n-j\choose n-i}&amp;=c\sum_{i=0}^{n-2}\sum_{j=0}^{n-2}a^ib^j{i+j\choose i}\\&amp;=c\sum_{i=0}^{n-2}\frac{a^i}{i!}\sum_{j=0}^{n-2}(i+j)!\frac{b^j}{j!}\end{aligned}$$ 我们可以枚举$i$，后面的是一个下标差相等的卷积 将多项式逆序一下就可以了 这道题没有给模数，而答案又很大 为了防止丢精度，所以使用MTT 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;#define N 200010#define LL long longconst int mod = 1e6 + 3;inline int Pow(int x, int y, int p = mod) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % p) if (y &amp; 1) res = (LL)res * x % p; return res;&#125;const int ZJK = (1 &lt;&lt; 19) + 233;int frac[N * 2], f[2][N];inline int C(int n, int r) &#123;return (LL)frac[n] * Pow(frac[r], mod - 2) % mod * Pow(frac[n - r], mod - 2) % mod;&#125;// #define double long doublestruct CP &#123; double x, y; CP(double _x = 0, double _y = 0) : x(_x), y(_y) &#123;&#125; CP operator * (const CP &amp;b) &#123;return CP(x * b.x - y * b.y, x * b.y + y * b.x);&#125; CP operator + (const CP &amp;b) &#123;return CP(x + b.x, y + b.y);&#125; CP operator - (const CP &amp;b) &#123;return CP(x - b.x, y - b.y);&#125; CP operator / (const double b) &#123;return CP(x / b, y / b);&#125;&#125;;int r[ZJK]; const double PI = acos(-1);inline void FFT(int len, int type, CP a[]) &#123; for (int i = 0;i &lt; len;i++) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int mid = 2;mid &lt;= len;mid &lt;&lt;= 1) &#123; CP Wn(cos(2 * PI / mid), type * sin(2 * PI / mid)); for (int i = 0;i &lt; len;i += mid) &#123; CP w(1), t; for (int j = i;j &lt; i + (mid &gt;&gt; 1);j++, w = w * Wn) t = w * a[j + (mid &gt;&gt; 1)], a[j + (mid &gt;&gt; 1)] = a[j] - t, a[j] = a[j] + t; &#125; &#125; if (type == -1) for (int i = 0;i &lt; len;i++) a[i] = a[i] / len;&#125;#define LL long longCP a[ZJK], b[ZJK], c[ZJK], d[ZJK];int A[ZJK], B[ZJK];inline void MTT(int len, LL m) &#123; for (int i = 0;i &lt; len;i++) a[i] = A[i] / m, b[i] = A[i] % m, c[i] = B[i] / m, d[i] = B[i] % m; FFT(len, 1, a), FFT(len, 1, b), FFT(len, 1, c), FFT(len, 1, d); for (int i = 0;i &lt; len;i++) &#123; CP a1 = a[i], b1 = b[i], c1 = c[i], d1 = d[i]; a[i] = a1 * c1, b[i] = a1 * d1, c[i] = b1 * c1, d[i] = b1 * d1; &#125; FFT(len, -1, a), FFT(len, -1, b), FFT(len, -1, c), FFT(len, -1, d); for (int i = 0;i &lt; len;i++) A[i] = ((LL)(a[i].x + 0.5) * m % mod * m % mod + (LL)(b[i].x + 0.5) * m % mod + (LL)(c[i].x + 0.5) * m % mod + (LL)(d[i].x + 0.5)) % mod;&#125;int main() &#123; int a, b, c, n; scanf("%d%d%d%d", &amp;n, &amp;a, &amp;b, &amp;c), frac[0] = 1; for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;f[1][i]); for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;f[0][i]); for (int i = 1;i &lt;= n * 2;i++) frac[i] = (LL)frac[i - 1] * i % mod; int ans = 0, tmp1 = Pow(b, n - 1), tmp2 = Pow(a, n - 1); for (int i = 2;i &lt;= n;i++) ans = (ans + (LL)f[0][i] * C(2 * n - 2 - i, n - i) % mod * tmp1 % mod * Pow(a, n - i)) % mod; for (int i = 2;i &lt;= n;i++) ans = (ans + (LL)f[1][i] * C(2 * n - 2 - i, n - i) % mod * tmp2 % mod * Pow(b, n - i)) % mod; int len = 1, l = 0; while (len &lt;= 2 * n) len &lt;&lt;= 1, l++; for (int i = 0;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); for (int i = 0, t;i &lt;= n - 2;i++) t = Pow(frac[i], mod - 2), A[i] = (LL)Pow(a, i) * t % mod, B[i] = (LL)Pow(b, i) * t % mod; MTT(len, 1000); for (int i = 0;i &lt;= 2 * n - 4;i++) ans = (ans + (LL)c * A[i] % mod * frac[i]) % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>多项式</tag>
        <tag>字符串</tag>
        <tag>FFT</tag>
        <tag>manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.3省选模拟]]></title>
    <url>%2F2019%2F04%2F06%2F4-3%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 Diyiti 我们先考虑这样一个问题：给出$x,y$，如何计算$f(x,y)$ 分析一下第一个操作的本质，就是将$x$末尾连续的0都变成1，将第一处1变成0 考虑一种特殊情况：$y$是$x$的子集 也就是说，我们可以只通过操作2将$x$变成$y$ 如果我们使用了操作1，可以将最后一个1变成0 但是这样有一个副作用，就是后面所有的数都变成了1 根据之前的限制：$y$是$x$的子集，而$x$在这一位之后都是0 也就是说，$y$在这一位之后也全部是0 在这次操作之后，后面的数都变成了1 如果这次操作在第$i$位，那么我们至少还需要$i-1$次操作2才能将后面的位变得与$y$相同 只有在$i=1$即操作第一位的时候，$-1$操作才与操作2等价 否则$-1$操作一定没有操作2优秀 也就是说，如果我们能用操作2，就尽量用操作2 那么什么情况不能用操作2呢 就是$x$在某一位上为0，而$y$在这一位上为1 这个时候我们只能用$-1$操作 如果第$i$位是这样的情况，就意味着，我们必须将这一位之后的第一个$1-0$对前面的所有位都变成0，然后在这个$1-0$对位置使用一次$-1$操作 比如$x=(10010)_2,y=(00101)_2$ 注意“第$k$位”指的是从右边开始的第$k$位 对于第一位来说，我们至少需要将第一位变成0 对于第三位来说，我们至少需要将第四位到第一位变成0 为了让操作数尽量小，我们选择将第一位至第四位都变成0 之后就变成了第一种情况，即$y$是$x$的子集 总结一下流程： 我们找到最高的满足$x_i=0,y_i=1$的位置 找到第一个比这一位高的，满足$x_i=1,y_i=0$的位置$j$ 通过操作2，将位置$1-(j-1)$全部变成0 在$j$位置使用一次$-1$操作 对于每一处$x_i=1,y_i=0$的位置使用操作2 所以，我们可以得出$$f(x,y)=\begin{cases}\sum_{k&gt;j}[x_k\not=y_k]+1+\sum_{k&lt;j}[x_k=1]+\sum_{k&lt;j}[y_k=0]&amp;y\not\in x\\ \sum_k[x_k\not=y_k]&amp;y\in x\end{cases}$$ 那么我们现在将它扩展到$x&lt;N$ 显然，我们可以使用数位dp 根据我们之前的计算过程，我们从高位向低位dp，将$x$分为3个状态 还没有遇到$x_i=0,y_i=1$，即此时$y\in x$，这个状态可以作为终止状态 钦定此时会有一个$-1$操作，这个状态的起点必须是$x_i=1,y_i=0$且在这个状态中不能再出现其它的$x_i=1,y_i=0$以及$x_i=0,y_i=1$，这个状态不能作为终止状态 遇到了第一个$x_i=0,y_i=1$，然后就可以随便转移了，这个状态可以作为终止状态 第二个状态之所以不能成为终止状态，是因为必须至少有一个$x_i=0,y_i-1$，否则就不应该进入2状态 那么我们可以设f[2][2][3][N], g[2][2][3][N]表示当前在第$i$位，此时$x$是否等于$N$，$y$是否等于$x$，当前在第几个状态时的答案以及转移到结尾的方案数 为了偷懒，我们也可以只用一个dp dp[2][2][3][N][N]表示当前到了第$i$位，之前已经用了$j$次操作，此时$x$是否等于$N$，$y$是否等于$x$，当前在第几个状态时的答案 代码如下 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;#define N 510int num[N], dp[2][2][3][N][N * 2], len; const int mod = 1e9 + 7;inline void Inc(int &amp;x, int y) &#123; x += y, x -= x &gt;= mod ? mod : 0;&#125;int DP(int cur, bool flag1, bool flag2, int state, int cnt) &#123; if (cur == len + 1) return state == 1 ? 0 : cnt; int &amp;sum = dp[flag1][flag2][state][cur][cnt]; if (~sum) return sum; sum = 0; for (int x = 0;x &lt; 4;x++) &#123; int i = x &amp; 1, j = x &gt;&gt; 1 &amp; 1, tflag1 = flag1 &amp;&amp; (i == num[cur]), tflag2 = flag2 &amp;&amp; (j == i); if (flag1 &amp;&amp; i &gt; num[cur]) continue; if (flag2 &amp;&amp; j &gt; i) continue; if (state == 0) &#123; if (i &lt; j) continue; Inc(sum, DP(cur + 1, tflag1, tflag2, 0, cnt + (i &gt; j))); if (i &gt; j) Inc(sum, DP(cur + 1, tflag1, tflag2, 1, cnt + 1)); &#125; else if (state == 1) &#123; if (i &gt; j) continue; if (i == j) Inc(sum, DP(cur + 1, tflag1, tflag2, 1, cnt + (i == 1) + (j == 0))); else Inc(sum, DP(cur + 1, tflag1, tflag2, 2, cnt)); &#125; else Inc(sum, DP(cur + 1, tflag1, tflag2, 2, cnt + (i == 1) + (j == 0))); &#125; return sum;&#125;char input[N];int main() &#123; freopen("diyiti.in", "r", stdin), freopen("diyiti.out", "w", stdout); scanf("%s", input + 1), len = strlen(input + 1), memset(dp, -1, sizeof(dp)); for (int i = 1;i &lt;= len;i++) num[i] = input[i] - '0'; printf("%d\n", DP(1, 1, 1, 0, 0));&#125; T2 Dierti 看起来是一道好题，可惜没有题解 这里讲一下部分分做法（只会部分分） 首先我们可以枚举最后选到的是哪个$n$以及哪个$m$，求这个东西的$k$阶中心矩，最后再求期望 这里的$x$就是实际选的袋子中球的数量 考虑$$\begin{aligned}E((x-E(x))^k)&amp;=E(\sum_{i=0}^k{k\choose i}x^k(-1)^{k-i}E(x)^{k-i})\\&amp;=\sum_{i=0}^k{k\choose i}(-1)^{k}E(x)^{k}E(x^{k-i})\end{aligned}$$ 显然$E(x)=\frac{m}{n}$，所以关键是要求出$E(x^k)$ 这等价于有一个数，现在要对这个数进行$m$次操作，每次操作都有$\frac{1}{n}$的概率会加1，否则不变 很像一道题osu 我们分别维护$E(x),E(x^2),\cdots,E(x^k)$，转移的时候再次使用二项式展开 这样一次转移是$k^3$的，可以使用矩阵乘法优化 可以拿到60分 T3 Disanti 我不会啊，而且没有题解 先咕在这里吧]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>数据结构</tag>
        <tag>二进制</tag>
        <tag>期望</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.2省选模拟]]></title>
    <url>%2F2019%2F04%2F06%2F4-2%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 Painting 我们考虑这样一种情况：122133441 显然，1必须在最开始就刷上，如果先刷其它的数再刷1，那么颜色2,3,4不可能被1包含 颜色3,4刷的顺序无关紧要 我们考虑更一般的情况 如果存在颜色序列a...b...b...a，其中省略号的部分可能代表其它颜色，那么a一定在b之前被刷上 对于颜色序列a..ab...b，a,b被刷的顺序可以随意 我们可以通过这两个条件将拓扑关系建出来，可以发现，这是一棵树 树的祖先与后代刷的顺序是确定的，同一个父亲的儿子节点刷的顺序可以随意 于是我们考虑分治，假设当前分治到了区间[l,r]，这要求这个区间的左右两个端点的颜色相同 比如上面那个例子中，这个颜色就是1 这个颜色将这个区间分成了若干段，对于每一段我们只关心当前颜色的儿子节点，将每一个颜色序列都缩成一个点 比如序列12332144551，1将序列分成了两个部分2332,4455 对于颜色2，我们将它缩成一个长度为4的点，它在第一段 对于颜色3，我们不管它，因为它不是1的儿子，它在第二段 对于颜色4,5，我们将它们各缩成长度为2的点，它在第二段 对于每一段，我们分别进行dp，算出答案的最大值，因为段与段之间不能相互跨越，否则中间那个1就永远都刷不上了 我们用dp[i][j]表示已经刷好了[i,j]这些点，能获得的最大收益 如果我们假设第$i$个点缩成的长度是$b_i$，那么这个dp就满足$$dp_{i,j}=\sum_{l=i}^jb_l+\max_{mid=i}^j{dp_{i,mid-1}+dp_{mid+1,j}}$$含义是我们枚举第一次刷的颜色$mid$，这会将序列分成两段独立的区间，分别刷即可 这个dp是$m^3$的 如果我们打出这个dp取最优值的位置，可以发现它一定在左端点或者右端点转移 不会证明 此时dp就是$m^2$的了 题解的证明过程如下 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;#define P pair&lt;int, int&gt;#define N 100010#define M 5010int num[N], nxt[N], lst[N];vector&lt;int&gt; tmp; int dp[M][M], pre[M];inline int DP() &#123; int n = tmp.size(); for (int i = 1;i &lt;= n;i++) pre[i] = pre[i - 1] + tmp[i - 1]; for (int i = 0;i &lt;= n;i++) for (int j = 0;j &lt;= n;j++) dp[i][j] = 0; for (int i = 1;i &lt;= n;i++) dp[i][i] = tmp[i - 1]; for (int len = 2;len &lt;= n;len++) for (int start = 1;start + len - 1 &lt;= n;start++) &#123; int end = start + len - 1; dp[start][end] = max(dp[start + 1][end], dp[start][end - 1]) + pre[end] - pre[start - 1]; &#125; return dp[1][n];&#125;int res;void solve(int l, int r) &#123; for (int ls = l, cur = nxt[l];ls != r;cur = nxt[ls = cur]) &#123; tmp.clear(); for (int at = ls + 1;at != cur;at = lst[at] + 1) tmp.push_back(lst[at] - at + 1); res += DP(); &#125; for (int ls = l, cur = nxt[l];ls != r;cur = nxt[ls = cur]) for (int at = ls + 1;at != cur;at = lst[at] + 1) solve(at, lst[at]);&#125;int tmp1[N], beg[N];int main() &#123; freopen("color.in", "r", stdin), freopen("color.out", "w", stdout); int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1;i &lt;= n;i++) &#123; scanf("%d", &amp;num[i]); if (tmp1[num[i]]) nxt[tmp1[num[i]]] = i; else beg[num[i]] = i; tmp1[num[i]] = i, lst[beg[num[i]]] = i; &#125; nxt[0] = n + 1, solve(0, n + 1), printf("%d\n", res); return 0;&#125; T2 Path 假设当前点是$u$ 可以发现，最优策略一定是选择一个点集$v$，然后一直在$u$点等待，直到$u$和$v$连通，然后走这条出现的边 我们用dp[u]表示在最优策略下，$u$点到$n$需要的期望时间 我们将$u$点能到达的边按照dp值排序，可以发现选择的点集一定是一段前缀 我们枚举这个前缀，对于一个前缀$v_i$，如果选择这个前缀的点集，那么有转移$$dp_u=\min_{i=1}^{|v|}{\frac{1}{i}\sum_{t\in v_i}dp_t+\frac{m}{i}}$$含义是，如果选择了这个前缀，那么所选择的点中作为第一个出现的点的概率是相等的，为了走这一条边，我们期望要等$\frac{m}{i}$轮 由于有$\min$，所以无法高斯消元 一种方法是进行若干次迭代，每次迭代枚举每个点更新 另一种方法是使用一个类似SPFA的方法，将这次更新的点放进队列，继续拓展 代码如下 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010double dp[N]; vector&lt;int&gt; G[N];bool cmp(int i, int j) &#123; return dp[i] &lt; dp[j];&#125;int main() &#123; freopen("path.in", "r", stdin), freopen("path.out", "w", stdout); int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1, a, b;i &lt;= m;i++) scanf("%d%d", &amp;a, &amp;b), G[a].push_back(b), G[b].push_back(a); for (int i = 1;i &lt; n;i++) dp[i] = 1e9; for (int t = 1;t &lt;= 2000000 / m;t++) &#123; for (int i = 1;i &lt;= n;i++) &#123; sort(G[i].begin(), G[i].end(), cmp); double tmp = 0, ans = 0, ls = 1e9; for (int j = 1;j &lt;= G[i].size();j++) &#123; tmp += dp[G[i][j - 1]], ans = tmp / j + (double)m / j; if (ans &gt; ls) break; dp[i] = min(dp[i], ans); &#125; &#125; &#125; printf("%.7lf\n", dp[1]); return 0;&#125; T3 Tree 如果最远点的距离是$x$，那么所选择的点数必须不小于$\frac{n}{x}$ 这个式子看上去就很像分块 我们暴力枚举答案$1-\sqrt{n}$，找到答案为当前值的关键点数的区间 对于现在还没有确定答案的那些关键点数，我们直接二分，然后暴力算答案 所谓暴力就是直接树上贪心 这样可以获得60分的好成绩 贴一下题解]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>数据结构</tag>
        <tag>最短路</tag>
        <tag>期望</tag>
        <tag>分治</tag>
        <tag>线段树</tag>
        <tag>贪心</tag>
        <tag>分块</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.1省选模拟]]></title>
    <url>%2F2019%2F04%2F03%2F4-1%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 Line 如果我们知道了这条直线在$y$轴上的截距，那么我们就可以通过这$n$个点确定最终斜率的区间 假设这条直线是$kx+b$，现在我们已知$b$ 对于一个$r_i$，我们知道有$$ki+b\leq r_i\Rightarrow k\leq\lfloor\frac{r_i-b}{i}\rfloor$$对于一个$l_i$，我们知道有$$ki+b\geq l_i\Rightarrow k\geq\lceil\frac{l_i-b}{i}\rceil$$那么对于一个$b$，它对答案的贡献就是$$\max{0,\min_{i=1}^n{\lfloor\frac{r_i-b}{i}\rfloor}-\max_{j=1}^n{\lceil\frac{l_j-b}{j}\rceil}+1}$$如果我们知道此时$\min$取的是哪个位置，$\max$取的是哪个位置，我们就可以$O(1)$计算答案 由于我们之前是枚举的$b$，现在就把$b$看作自变量$x$ 对于$\min,\max$我们分开考虑 以$\min$为例 此时我们要求$\frac{r_i-x}{i}$的最小值 可以使用斜率优化，即将这个东西看作一条斜率为$-\frac{1}{i}$，截距是$\frac{r_i}{i}$的直线 此时我们就得到了当$b$在一个范围内的时候，最小值的位置 同样，我们可以得出当$b$在一个范围内的时候，最大值的位置 我们将这两个范围合并，就可以得出当$b$在一个范围内时，最小值以及最大值的位置 现在考虑对于一个区间的$b$，如何计算答案 此时我们已经确定了$\min,\max$的位置 首先考虑将前面那个0搞掉 我们发现这对应着收紧一下区间 解方程$$\begin{align}\frac{r_i-x}{i}&amp;=\frac{l_j-x}{j}\\r_ij-xj&amp;=l_ji-xi\\x(i-j)&amp;=l_ji-r_ij\\\Rightarrow x&amp;=\frac{l_ji-r_ij}{i-j}\end{align}$$当$i=j$时，我们不做处理 当$i&gt;j$时，这对应着$b$的新下界 当$i&lt;j$时，这对应着$b$的新上界 此时我们就可以把前面的0搞掉了 考虑如何计算$$\sum_{i=L}^R\lfloor\frac{a-i}{b}\rfloor$$我们发现如果不考虑边角上的数，这其实是一个每个数都重复了$b$次的等差数列 如果$\lfloor\frac{a}{b}\rfloor=k$，那么有$bk\leq a\leq (b+1)k-1$ 我们对边角特殊处理即可 考试的时候由于某些未知的地方没有开long long，导致只有33.3分 听说可以算出斜率的区间 好像我写毒瘤了 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define int long long#define double long doubleinline LL calc(int L, int R, int a, int b) &#123; L = -L, R = -R, swap(L, R); int l1 = floor((L + a) / (double)b) + 1, r1 = floor((R + a) / (double)b); LL res = (LL)(r1 - l1 + 1) * (l1 + r1) * b / 2; l1 = l1 * b - 1, r1 = (r1 + 1) * b; res += floor((a + L) / (double)b) * (LL)(l1 - L - a + 1) + floor((a + R) / (double)b) * (LL)(R + a - r1 + 1); return res;&#125;inline LL calc(int L, int R, int lj, int ri, int j, int i) &#123; // L &lt;= x &lt;= R if (i == j) return calc(L, R, ri, i) - calc(L, R, lj + j - 1, j) + R - L + 1; double k = (ri - lj) / (double)(i - j), y = lj - k * j; if (j &lt; i) L = max(L, (int)ceil(y)); else R = min(R, (int)floor(y)); if (L &gt; R) return 0; return calc(L, R, ri, i) - calc(L, R, lj + j - 1, j) + R - L + 1;&#125;#define N 200010struct Line &#123;int b, kinv;&#125; l1[N], l2[N];inline double inter(Line a, Line b) &#123; return ((LL)a.b * b.kinv - (LL)b.b * a.kinv) / (double)(a.kinv - b.kinv);&#125;double eps = 1e-8;inline int dcmp(double x) &#123; if (fabs(x) &lt; eps) return 0; return x &gt; 0 ? 1 : -1;&#125;inline bool check(Line a, Line b, Line c) &#123; return dcmp(inter(a, b) - inter(a, c)) &lt; 0;&#125;int l[N], r[N], head, tail; struct data &#123;int l, r, at;&#125;;vector&lt;data&gt; tmp1, tmp2;signed main() &#123; freopen("line.in", "r", stdin); freopen("line.out", "w", stdout); int n; scanf("%lld", &amp;n); for (int i = 1;i &lt;= n;i++) scanf("%lld%lld", &amp;l[i], &amp;r[i]); head = 1, tail = 0; for (int i = 1;i &lt;= n;i++) &#123; Line now = (Line)&#123;-l[i], -i&#125;; while (head &lt; tail &amp;&amp; !check(l1[tail - 1], l1[tail], now)) tail--; l1[++tail] = now; &#125; for (int i = head, ls = -2e9, cur;i &lt;= tail;i++, ls = cur + 1) &#123; cur = i != tail ? floor(inter(l1[i], l1[i + 1])) : 2e9; if (ls &lt;= cur) tmp1.push_back((data)&#123;ls, cur, -l1[i].kinv&#125;); &#125; head = 1, tail = 0; for (int i = n;i &gt;= 1;i--) &#123; Line now = (Line)&#123;-r[i], -i&#125;; while (head &lt; tail &amp;&amp; !check(l2[tail - 1], l2[tail], now)) tail--; l2[++tail] = now; &#125; for (int i = head, ls = -2e9, cur;i &lt;= tail;i++, ls = cur + 1) &#123; cur = i != tail ? floor(inter(l2[i], l2[i + 1])) : 2e9; if (ls &lt;= cur) tmp2.push_back((data)&#123;ls, cur, -l2[i].kinv&#125;); &#125; int cur1 = 0, cur2 = 0, ls = -2e9; LL ans = 0; while (233) &#123; int nxt, at1 = tmp1[cur1].at, at2 = tmp2[cur2].at, R; if (cur1 != tmp1.size() - 1 &amp;&amp; cur2 != tmp2.size() - 1) &#123; if (tmp1[cur1].r &lt; tmp2[cur2].r) nxt = 1; else nxt = 2; &#125; else nxt = (cur1 == tmp1.size() - 1) ? 2 : 1; R = nxt == 1 ? tmp1[cur1].r : tmp2[cur2].r; ans += calc(ls, R, l[tmp1[cur1].at], r[tmp2[cur2].at], tmp1[cur1].at, tmp2[cur2].at), ls = R + 1; if (cur1 == tmp1.size() - 1 &amp;&amp; cur2 == tmp2.size() - 1) break; if (nxt == 1) cur1++; else cur2++; &#125; printf("%lld\n", ans);&#125; T2 Seat 不会，先放题解 T3 Dist 如果我们将每个集合看作一个点，那么一共只有18个点，我们在这个图上跑最短路 那么对于两个点$a,b$，$a$到$b$的最短路径等于$$\min_{a\in U,b\in V}dis(U,V)$$我们枚举起点$a$，将所有集合按照离$a$的距离排序，然后从小到大依次加入 当加入一个新的集合$y$时，它对答案的贡献就是$y$集合中包含的点减去被$y$和之前的集合包含的点 这个我们处理出一个子集和就可以了，就是半个FWT 注意某个点离自己的距离是0，这种方法会将这个距离算成包含$a$的集合的点权最小值]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>斜率优化</tag>
        <tag>gcd</tag>
        <tag>最短路</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FWT基础]]></title>
    <url>%2F2019%2F04%2F02%2FFWT%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[FWT有啥用啊我们知道，FFT可以解决多项式的卷积，即$$C_k=\sum_{i+j=k}A_i*B_j$$如果将操作符换一下，换成集合运算符 比如$$C_k=\sum_{i|j=k}A_i*B_j\\C_k=\sum_{i\&amp;j=k}A_i*B_j\\C_k=\sum_{i\oplus j=k}A_i*B_j$$这时就不能使用FFT了 但是FFT使我们产生了一种想法 我们能不能用一种类似FFT的方法，用另一个多项式来表示$A,B$，然后再对应相乘，最后再变换回来呢 答案是可以的，这就是FWT，即快速沃尔什变换 一些定义令$A,B$为两个向量，且维数为$n$，$n$是$2$的整数次幂 定义记号 $A\pm B=(A_0\pm B_0,A_1\pm B_1,A_2\pm B_2,\cdots,A_{n-1}\pm B_{n-1})$ $A\oplus B=(\sum\limits_{i\oplus j=0}A_i*B_j,\sum\limits_{i\oplus j=1}A_i*B_j,\sum\limits_{i\oplus j=3}A_i*B_j,\cdots,\sum\limits_{i\oplus j=n-1}A_i*B_j)​$ 这里的$\oplus$代表集合运算 或卷积及其逆运算我们定义$FWT$变换，有$$FWT(A)[i]=\sum_{j|i=i}A_j$$ 性质1：$FWT(A\pm B)=FWT(A)\pm FWT(B)$ 根据此时$FWT​$变换的定义我们知道这是一个$A​$数组的线性组合，故加减法满足分配律 我们断言，此时的$FWT$满足$$FWT(A)=\begin{cases}(FWT(A_0),FWT(A_0)+FWT(A_1))&amp; n&gt;1\\ A &amp; n=0\end{cases}$$$A_0,A_1$分别代表$A$数组的前半部分、后半部分 证明如下： 实际上此时$A_0,A_1$的下标只有最高位是不同的 根据$FWT$的定义，合并之后左半部分的最高位仍然是0，右半部分的最高位仍然是1 由于$FWT(A_1)$的最高位一定为1，而此时$j|i$的最高位不可能为0，所以右半部分对于合并之后是没有贡献的 而对于右半边，如果左半边的数满足$j|i=i​$，那么在$i​$加上最高位1之和，这个式子仍然成立 而此时右半边原来的$FWT$本来就对右半边的数有贡献 所以这个式子成立 性质2：$FWT(A|B)=FWT(A)*FWT(B)\ \ (对应相乘)$ 我们采用归纳法证明$$\begin{aligned}FWT(A|B)&amp;=FWT((A|B)_0,(A|B)_1)\\&amp;=FWT(A_0|B_0,A_1|B_0+A_0|B_1+A_1|B_1)\\&amp;=(FWT(A_0|B_0),FWT(A_0|B_0+A_1|B_0+A_0|B_1+A_1|B_1))\\&amp;=(FWT(A_0)*FWT(B_0),FWT(A_0)*FWT(B_0)+FWT(A_1)*FWT(B_0)\\&amp;+FWT(A_0)*FWT(B_1)+FWT(A_1)*FWT(B_1))\\&amp;=(FWT(A_0)*FWT(B_0),(FWT(A_0)+FWT(A_1)*(FWT(B_0)+FWT(B_1))))\\&amp;=(FWT(A_0),FWT(A_0)+FWT(A_1))*(FWT(B_0),FWT(B_0)+FWT(B_1))\\&amp;=FWT(A)*FWT(B)\end{aligned}$$定义$IFWT$变换为$FWT$变换的逆变换 我们断言，$IFWT$满足$$IFWT(A)=\begin{cases}(IFWT(A_0),IFWT(A_1)-IFWT(A_0))&amp;n&gt;1\\ A&amp;n=0\end{cases}$$证明如下：$$\begin{aligned}IFWT(FWT(A))&amp;=IFWT(FWT(A_0),FWT(A_0)+FWT(A_1))\\&amp;=(IFWT(FWT(A_0)),IFWT(FWT(A_1)))\\&amp;=(A_0,A_1)\\&amp;=A\end{aligned}$$ 与卷积及其逆运算定义$FWT$变换为$$FWT(A)[i]=\sum_{i\&amp;j=j}A_i$$类似或卷积，我们可以得出此时$FWT$的递推式$$FWT(A)=\begin{cases}(FWT(A_0)+FWT(A_1),FWT(A_1))&amp;n&gt;1\\ A &amp;n=0\end{cases}$$证明很简单，$A$数组的右半部分与上一个首位为0的数，得到的结果一定在$A$的左半部分 显然，它们仍然对自己所在的部分有贡献 $FWT(A\&amp;B)=FWT(A)*FWT(B)$在此时成立 证明如下：$$\begin{aligned}FWT(A\&amp;B)&amp;=FWT((A\&amp;B)_0,(A\&amp;B)_1)\\&amp;=FWT(A_0\&amp;B_0+A_0\&amp;B_1+A_1\&amp;B_0,A_1\&amp;B_1)\\&amp;=(FWT(A_0\&amp;B_0+A_0\&amp;B_1+A_1\&amp;B_0+A_1\&amp;B_1),FWT(A_1\&amp;B_1))\\&amp;=((FWT(A_0)+FWT(A_1))*(FWT(B_0)+FWT(B_1)),FWT(A_1)*FWT(B_1))\\&amp;=(FWT(A_0)+FWT(A_1),FWT(A_1))*(FWT(B_0)+FWT(B_1),FWT(B_1))\\&amp;=FWT(A)*FWT(B)\end{aligned}$$定义$IFWT$变换为$$IFWT(A)=\begin{cases}(IFWT(A_0)-IFWT(A_1),IFWT(A_1))&amp;n&gt;1\\ A&amp;n=0\end{cases}$$证明如下：$$\begin{aligned}IFWT(FWT(A))&amp;=IFWT(FWT(A_0)+FWT(A_1),FWT(A_1))\\&amp;=(IFWT(FWT(A_0)),IFWT(FWT(A_1))\\&amp;=(A_0,A_1)\\&amp;=A\end{aligned}$$ 异或卷积及其逆运算异或卷积的$FWT$稍微麻烦一点 我们定义函数$d(x)$表示$x$在二进制下1的数量 定义$FWT$变换为$$FWT(A)[i]=\sum_{d(j\&amp;i)\equiv0\mod 2}A_j-\sum_{d(k\&amp;i)\equiv1\mod 2}A_k$$那么此时，它的递推式为$$FWT(A)=\begin{cases}(FWT(A_0)+FWT(A_1),FWT(A_0)-FWT(A_1))&amp;n&gt;0\\ A&amp;n=0\end{cases}$$我们考虑这个式子是怎么来的 先看这个式子左边的$FWT(A_0)+FWT(A_1)$ $A_0$的下标没有变化，所以要加上$FWT(A_0)$，而现在$A_1$的下标的最高位变成了1，但是与上一个最高位为0的数之后是不变的 所以这个式子是正确的 我们看右边的$FWT(A_0)-FWT(A_1)$ $A_0$的最高位不变，与上一个最高位为1的数之后结果仍然不变 $A_1$的下标的最高位多了一个1，与上一个最高位为1的数之后奇偶性就变了，所以要取反 所以这个也是成立的 $FWT(A\oplus B)=FWT(A)*FWT(B)$在此时成立 证明如下$$\begin{aligned}FWT(A\oplus B)&amp;=FWT((A\oplus B)_0,(A\oplus B)_1)\\&amp;=FWT(A_0\oplus B_0+A_1\oplus B_1,A_0\oplus B_1+A_1\oplus B_0)\\&amp;=(FWT(A_0\oplus B_0+A_1\oplus B_1+A_0\oplus B_1+A_1\oplus B_0),\\&amp;FWT(A_0\oplus B_0+A_1\oplus B_1-A_0\oplus B_1-A_1\oplus B_0))\\&amp;=((FWT(A_0)+FWT(A_1))*(FWT(B_0)+FWT(B_1)),\\&amp;(FWT(A_0)-FWT(A_1))*(FWT(B_0)-FWT(B_1)))\\&amp;=(FWT(A_0+A_1),FWT(A_0-A_1))*(FWT(B_0+B_1),FWT(B_0-B_1))\\&amp;=FWT(A)*FWT(B)\end{aligned}$$定义$IFWT$为$$IFWT(A)=\begin{cases}(\frac{IFWT(A_0+A_1)}{2},\frac{IFWT(A_0-A_1)}{2})&amp;n&gt;1\\ A&amp;n=0\end{cases}$$证明如下：$$\begin{aligned}IFWT(FWT(A))&amp;=IFWT(FWT(A_0)+FWT(A_1),FWT(A_0)-FWT(A_1))\\&amp;=(IFWT(FWT(A_0)),IFWT(FWT(A_1)))\\&amp;=(A_0,A_1)\\&amp;=A\end{aligned}$$]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>FWT</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.30省选模拟]]></title>
    <url>%2F2019%2F04%2F01%2F3-30%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 唐时月夜 直接维护显然不太可行，我们考虑每个点单独维护 对于某个点$(x,y)$，对它有影响的修改一定是一段后缀，那么我们可以二分出这个后缀 考虑一个修改的本质是什么 假如现在要对一个矩形$(x_1,y_1),(x_2,y_2)$进行行翻转，并且$(x,y)$在这个矩形内部 那么此时$y$不变，$x$变为$x_1+x_2-x$ 如果要进行列翻转，那么$x$不变，$y$变为$y_1+y_2-y$ 现在来考虑最复杂的转置 如果我们强制让$(x_1,y_1)$为原点，重置坐标系，那么此时每个点的$x,y$都会互换 那么我们模拟这个过程，首先让$x$减去$x_1$,$y$减去$y_1$，再将$x,y$互换，最后把减去的加回来 那么最后我们一定可以用一个与$x,y$有关的代数式表示最后变换之后的$x,y$，并且$x,y$的系数一定是$1,-1$ 如果当前这个点的转置次数为奇数次，那么最后的$x$应该由最初的$y$表示，最后$y$应该由最初的$x$表示 否则不变 我们维护这个符号，以及前面的常数，还有交换次数即可 比赛的时候我用了线段树，好像很没必要，直接扫描线就可以了 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;#define Q 200010struct node &#123;int l, r, rev, tag[2], sgn[2], lazy;&#125; T[Q &lt;&lt; 2];inline void Swap(int rt) &#123; swap(T[rt].tag[0], T[rt].tag[1]), swap(T[rt].sgn[0], T[rt].sgn[1]), T[rt].rev ^= 1, T[rt].lazy++;&#125;inline void work(int rt, int rt1, int id) &#123; if (T[rt].sgn[id] == 1 &amp;&amp; T[rt].tag[id] == 0) return; if (T[rt].sgn[id] == 1) T[rt1].tag[id] += T[rt].tag[id]; else T[rt1].sgn[id] = -T[rt1].sgn[id], T[rt1].tag[id] = T[rt].tag[id] - T[rt1].tag[id];&#125;inline void pushdown(int rt) &#123; if (T[rt].rev) Swap(rt &lt;&lt; 1), Swap(rt &lt;&lt; 1 | 1), T[rt].rev = 0; work(rt, rt &lt;&lt; 1, 0), work(rt, rt &lt;&lt; 1, 1), work(rt, rt &lt;&lt; 1 | 1, 0), work(rt, rt &lt;&lt; 1 | 1, 1); T[rt].sgn[0] = T[rt].sgn[1] = 1, T[rt].tag[0] = T[rt].tag[1] = 0;&#125;inline void build(int rt, int l, int r) &#123; T[rt].l = l, T[rt].r = r, T[rt].sgn[0] = T[rt].sgn[1] = 1; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(rt &lt;&lt; 1, l, mid), build(rt &lt;&lt; 1 | 1, mid + 1, r);&#125;inline void update(int rt, int start, int end, int type, int x, int sp = 0) &#123; int l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; 1; if (start &lt;= l &amp;&amp; r &lt;= end) &#123; if (sp) &#123;T[rt].tag[type - 1] += x; return;&#125; if (type == 1) T[rt].sgn[0] = -T[rt].sgn[0], T[rt].tag[0] = x - T[rt].tag[0]; else if (type == 2) T[rt].sgn[1] = -T[rt].sgn[1], T[rt].tag[1] = x - T[rt].tag[1]; else Swap(rt); return; &#125; pushdown(rt); if (start &lt;= mid) update(rt &lt;&lt; 1, start, end, type, x, sp); if (end &gt; mid) update(rt &lt;&lt; 1 | 1, start, end, type, x, sp);&#125;inline int query(int rt, int at) &#123; int l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; 1; if (l == r) return rt; pushdown(rt); return at &lt;= mid ? query(rt &lt;&lt; 1, at) : query(rt &lt;&lt; 1 | 1, at);&#125;#define LL unsigned intint X1[Q], X2[Q], Y1[Q], Y2[Q]; LL f[20000010];template &lt;class T&gt; inline void rd(T &amp;x) &#123; x = 0; char c = getchar(); while (c &lt; '0' || c &gt; '9') c = getchar(); while ('0' &lt;= c &amp;&amp; c &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - '0', c = getchar();&#125;int tag[2][Q], sgn[2][Q], lzy[Q];int main() &#123; freopen("evernight.in", "r", stdin), freopen("evernight.out", "w", stdout); int n, m, q; LL a, b, c; rd(n), rd(n), rd(m), rd(q), rd(a), rd(b), rd(c); build(1, 1, max(q, 1)), f[0] = c; for (int i = 1;i &lt;= q;i++) &#123; int op; rd(op), rd(X1[i]), rd(Y1[i]), rd(X2[i]), rd(Y2[i]); if (op == 2) update(1, 1, i, 1, X1[i] + X2[i]); else if (op == 1) update(1, 1, i, 2, Y1[i] + Y2[i]); else update(1, 1, i, 1, 1 - X1[i], 1), update(1, 1, i, 2, 1 - Y1[i], 1), update(1, 1, i, 3, 0), update(1, 1, i, 1, X1[i] - 1, 1), update(1, 1, i, 2, Y1[i] - 1, 1); &#125; for (int i = 1;i &lt;= q;i++) &#123; int at = query(1, i); tag[0][i] = T[at].tag[0], tag[1][i] = T[at].tag[1], sgn[0][i] = T[at].sgn[0], sgn[1][i] = T[at].sgn[1], lzy[i] = T[at].lazy; &#125; for (int i = 1;i &lt;= n * m;i++) f[i] = f[i - 1] * a + b; LL res = 0; for (int x = 1;x &lt;= n;x++) for (int y = 1;y &lt;= m;y++) &#123; int id = (x - 1) * m + y, l = 1, r = q, ans = -1, mid, tx = x, ty = y; while (l &lt;= r) &#123; mid = (l + r) &gt;&gt; 1; if (x &gt;= X1[mid] &amp;&amp; x &lt;= X2[mid] &amp;&amp; y &gt;= Y1[mid] &amp;&amp; y &lt;= Y2[mid]) ans = mid, r = mid - 1; else l = mid + 1; &#125; if (~ans) &#123; if (lzy[ans] &amp; 1) tx = tag[0][ans] + sgn[0][ans] * y, ty = tag[1][ans] + sgn[1][ans] * x; else tx = tag[0][ans] + sgn[0][ans] * x, ty = tag[1][ans] + sgn[1][ans] * y; &#125; res += f[(tx - 1) * m + ty] * f[id]; &#125; printf("%u\n", res); return 0;&#125; T2 附耳而至 一道很妙的题 首先我们转个对偶图，这里贴一下转对偶图的方法 将每个点的所有出边按照极角排序 找到一条没有被标记过的边$(u,v)$，设为当前边，重复以下过程： 将当前边$(u,v)$标记 找到$v$的所有出边中，极角序在$(v,u)$前的最后一条边，设为下一次的当前边 重复这个过程，直到遇到一条标记过的边，那么此时刚刚选出的边就构成了一个区域 举个例子： 我们一开始选择了$A$，当前边是$AD$，将这条边标记 出点是$D$，$D$点的所有出边按照极角排序之后是$DF,DA,DE,DC$ 那么$DA$的前一条边就是$DF$，我们选择这条边 如果当前边是排序之后的第一条边，那么我们就选择排序之后最大的那条边 同理，$F$点只有两条出边，我们选择$FB$ 最后我们选择$BA$，回到了$A$点，下一条边$AD$是已经被标记过的 所以此时我们就找到了一个区域$ADFB$ 注意边是双向的，标记也是双向的 这意味着，如果$AB$被标记，不代表$BA$被标记 我们模拟这个过程就好了 转完对偶图之后，我们就得到了一个区域被光明之神选中的代价，被黑暗之神选中的代价，以及相邻两个区域所需要扣除的贡献 然后很显然是个最小割 我考试的时候使用了一种错误的建图方法：将每个点拆成两个点，代表光明的点在左边，代表黑暗的点在右边，源点连向左边的点，权值为光明之神选中的代价，右边的点连向汇点，权值为黑暗之神选中的代价，对应的点连一条权值为正无穷的边，代表这个点不能被两个神同时选中。如果两个区域$a,b$相邻，那么将$a$的光明连向$b$的黑暗，将$b$的黑暗连向$a$的光明，权值为$c_i$，然后答案就是所有光明的代价之后加上黑暗的代价之和减去最小割 这样建图有一个很严重的问题：有可能一个点的光明与黑暗都被割了，即不被任何一个神选中 题解的做法是不拆点，也就没有必要连权值为证无穷的边，$a,b$之间连双向边 zyw大佬的解释： 如果存在一种最小割，使得某个点连向源点和汇点的边都被割掉了，那么这就意味着，至少有一个黑暗之神所选中的区域与它相邻，至少有一个光明之神选中的区域与它相邻，要不然割掉这两条边没有意义 而这两个区域所对应的点与当前点有无向边连接，并且我们知道，这条边没有被割掉，否则我们没有必要割去两条边 我们考虑以下这种情况 橙色的边代表被割去的边，显然中间那个点就是不合法的点，因为它上下两条边都被割去了 图中所对应的情况，就是左边那个点被黑暗之神选中，右边那个点被光明之神选中 但是此时，由黑色边构成的路径使得$s,t$连通了，不符合割的性质 所以这种情况是不可能出现的 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010#define M 200010#define MX 2000010int x[N], y[N], val[N], val2[N], n, s, t, tot; const double PI = acos(-1);namespace Flow &#123; struct edge &#123;int to, next, w;&#125; e[MX]; int head[N * 2], cur[N * 2], ecnt = 1, dep[N * 2]; inline void adde(int from, int to, int w) &#123; e[++ecnt] = (edge)&#123;to, head[from], w&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to], 0&#125;, head[to] = ecnt; &#125; inline bool BFS(int s, int t) &#123; queue&lt;int&gt; q; q.push(s), memset(dep, -1, sizeof(dep)), dep[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u];i;i = e[i].next) if (e[i].w &amp;&amp; dep[e[i].to] == -1) &#123; dep[e[i].to] = dep[u] + 1, q.push(e[i].to); if (e[i].to == t) return true; &#125; &#125; return false; &#125; int DFS(int u, int f, int t) &#123; if (u == t || !f) return f; int res = 0; for (int &amp;i = cur[u], tmp;i;i = e[i].next) if (e[i].w &amp;&amp; dep[e[i].to] == dep[u] + 1 &amp;&amp; (tmp = DFS(e[i].to, min(f, e[i].w), t))) &#123; res += tmp, f -= tmp, e[i].w -= tmp, e[i ^ 1].w += tmp; if (!f) break; &#125; return res; &#125; inline int Dinic(int s, int t) &#123; int res = 0; while (BFS(s, t)) memcpy(cur, head, sizeof(head)), res += DFS(s, 1e9, t); return res; &#125;&#125;namespace Planner_G &#123; struct edge &#123; int u, v, w, w2, c; double angle; edge(int u = 0, int v = 0, int w = 0, int w2 = 0, int c = 0) : u(u), v(v), w(w), w2(w2), c(c) &#123; int tx = x[v] - x[u], ty = y[v] - y[u]; angle = atan2(ty, tx); if (angle &lt; 0) angle += 2 * PI; &#125; &#125; e[M * 2]; int ecnt = 0; inline void adde(int from, int to, int c) &#123; int v1 = val[from] + val[to], v2 = val2[from] + val2[to]; e[ecnt++] = edge(from, to, v1, v2, c), e[ecnt++] = edge(to, from, v1, v2, c); &#125; vector&lt;int&gt; G[N]; int rank[M * 2], near[M * 2], vis[M * 2], pval[N], pval2[N], rcnt; inline void mark(int u, int eid) &#123; if (vis[eid]) return; int tmp1 = 0, tmp2 = 0; while (!vis[eid]) &#123; tmp1 += e[eid].w, tmp2 += e[eid].w2, vis[eid] = 1, near[eid] = rcnt; int v = e[eid].v; if (!rank[eid ^ 1]) eid = G[v].back(); else eid = G[v][rank[eid ^ 1] - 1]; &#125; pval[rcnt] = tmp1 / 2, pval2[rcnt] = tmp2 / 2, rcnt++; &#125; inline void build() &#123; pair&lt;double, int&gt; *tmp = new pair&lt;double, int&gt;[ecnt + 10]; for (int i = 0;i &lt; ecnt;i++) tmp[i] = make_pair(e[i].angle, i); sort(tmp, tmp + ecnt); for (int i = 0;i &lt; ecnt;i++) &#123; int eid = tmp[i].second; rank[eid] = G[e[eid].u].size(), G[e[eid].u].push_back(eid); &#125; for (int i = 1;i &lt;= n;i++) for (int j = 0;j &lt; G[i].size();j++) mark(i, G[i][j]); &#125; inline void link() &#123; s = rcnt + 1, t = rcnt + 2; for (int i = 1;i &lt;= rcnt;i++) Flow::adde(s, i, pval[i - 1]), Flow::adde(i, t, pval2[i - 1]), tot += pval[i - 1] + pval2[i - 1]; for (int i = 0;i &lt; ecnt;i += 2) &#123; int u = near[i] + 1, v = near[i ^ 1] + 1; Flow::adde(u, v, e[i].c), Flow::adde(v, u, e[i].c); &#125; &#125;&#125;int main() &#123; freopen("everfeel.in", "r", stdin), freopen("everfeel.out", "w", stdout); int m; scanf("%*d%d%d", &amp;n, &amp;m); for (int i = 1;i &lt;= n;i++) scanf("%d%d%d%d", &amp;x[i], &amp;y[i], &amp;val[i], &amp;val2[i]); for (int i = 1, a, b, c;i &lt;= m;i++) scanf("%d%d%d", &amp;a, &amp;b, &amp;c), Planner_G::adde(a, b, c); Planner_G::build(), Planner_G::link(); printf("%d\n", tot - Flow::Dinic(s, t)); return 0;&#125; T3 星辰大海]]></content>
  </entry>
  <entry>
    <title><![CDATA[3.29省选模拟]]></title>
    <url>%2F2019%2F04%2F01%2F3-29%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 循环流 一道比较神仙的题 考试的时候我使用的是手玩+找规律 我们考虑以下几种情况： $n=2$：这时需要特殊考虑 如果没有1边，那么2边的数量必须是偶数 否则如果1边的数量是奇数，那么一定不行 此时如果1边的数量是偶数，如果2边的数量是奇数，那么我们可以用两条1边凑出一条2边，而此时1边的数量仍然是偶数 $a=1$：显然此时不可能存在合法情况，因为找不到另一条1边来与这条边匹配 $n\not=2,a=0或b=0$：我们可以将数量不为0的那条边连成一个环，这样至少需要$n$条边。如果数量不为0的那条边的边数大于$n$，并且是偶数，那么我们连两条相反的边即可使得边数$-2$，否则我们连成一个长度为$3$的环，可以使得边数$-3$，如果边数为$n+1$，那么我们可以连一个长度为$2$的环，再将剩下的$n-1$个点连成环 剩余情况：将1连成一个环，将2连成一个环，则至少要用$n+1$条边，同样可以使用3中的方法调整 代码如下 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; freopen("flow.in", "r", stdin), freopen("flow.out", "w", stdout); int k, T, cnt = 0; scanf("%d%d", &amp;k, &amp;T); while (T--) &#123; int n, a, b; scanf("%d%d%d", &amp;n, &amp;a, &amp;b); if (a + b &lt; n) &#123; puts("0"); continue; &#125; if (a == 1) &#123; puts("0"); continue; &#125; if (n == 2) &#123; if (a == 0 &amp;&amp; b % 2 == 0) puts("1"); else if (a != 0 &amp;&amp; a % 2 == 0) puts("1"); else puts("0"); continue; &#125; if (a == 0) &#123; if (b &gt;= n) puts("1"); else puts("0"); continue; &#125; if (b == 0) &#123; if (a &gt;= n) puts("1"); else puts("0"); continue; &#125; if (a + b - 1 &gt;= n) puts("1"); else puts("0"); &#125;&#125; T2 整除分块 先贴上题解 T3 森林 一道很奇妙的题：LCT维护虚子树信息 观察变换之后答案的本质：其实就是这棵树的直径加上从直径上的某一点出发的最长链的长度- 1 我们考虑使用LCT维护，那么我们需要维护这些信息： 从当前区间的左端点出发，可以走重链也可以走轻链，能走出的最长路径所包含的点数 从当前区间的右端点出发，可以走重链也可以走轻链，能走出的最长路径所包含的点数 某个点的虚子树内，来自每个轻儿子的路径所包含点数的最大值（注意是每个轻儿子都会贡献一个最大值） 从当前区间内的任意一点出发，向虚子树重走所走出的路径包含的点数的最大值（出发点不算） 由于我们需要区间翻转，所以维护第一个值的时候附带了需要维护第二个值 我们知道只有在link, access的时候子树的虚实才会产生变化，也就是说，这个时候我们需要更新第三个值 比如access： 假设上一次的点为$v$，当前点为$u$，$u$的右儿子为$v’$ 此时$u$会损失一个右儿子$v’$，获得另一个右儿子$v$ 本来$v$是$u$的轻儿子，对$u$的第三个值有贡献，但是现在$v$变成了重儿子，这个贡献应当删去 本来$v’$是$u$的重儿子，对$u$的第三个值没有贡献，但是现在$v’$变成了轻儿子，这个贡献应当加上 12345678inline void access(int u) &#123; for (int ls = 0;u;u = fa[ls = u]) &#123; splay(u); if (ls) dep[u].erase(dep[u].find(l[ls])); if (ch[1][u]) dep[u].insert(l[ch[1][u]]); ch[1][u] = ls, pushup(u); &#125;&#125; dep就是第三个值，l是第一个值 pushup的时候也比较简单，当前区间的l要么是左子树的l，要么是左子树的size加一再加上右子树的l r同理 注意区间翻转的时候我们需要先翻转当前点，rev标记代表已经rev了当前点，但是当前点的子树还没有翻转 貌似是去年省选D1T1的加强版 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;using namespace std;#define N 200010int fa[N], ch[2][N], rev[N], l[N], r[N], s[N], mxdep[N];multiset&lt;int&gt; dep[N];inline void connect(int u, int f, int son) &#123; fa[u] = f, ch[son][f] = u;&#125;inline bool isroot(int u) &#123; return (u != ch[0][fa[u]] &amp;&amp; u != ch[1][fa[u]]) || !u;&#125;inline bool child(int u) &#123; return u == ch[1][fa[u]];&#125;inline void pushup(int u) &#123; s[u] = s[ch[0][u]] + 1 + s[ch[1][u]]; int t = dep[u].size() ? *dep[u].rbegin() : 0; l[u] = max(l[ch[0][u]], s[ch[0][u]] + 1 + max(t, l[ch[1][u]])); r[u] = max(r[ch[1][u]], s[ch[1][u]] + 1 + max(t, r[ch[0][u]])); mxdep[u] = max(mxdep[ch[0][u]], max(mxdep[ch[1][u]], t));&#125;inline void work(int u) &#123; swap(ch[0][u], ch[1][u]), rev[u] ^= 1, swap(l[u], r[u]);&#125;inline void pushdown(int u) &#123; if (rev[u]) work(ch[0][u]), work(ch[1][u]), rev[u] = 0;&#125;inline void rotate(int u) &#123; int f = fa[u], ff = fa[f], tmp = child(u), tmp1 = child(f); if (!isroot(f)) connect(u, ff, tmp1); fa[u] = ff, connect(ch[tmp ^ 1][u], f, tmp), connect(f, u, tmp ^ 1), pushup(f), pushup(u);&#125;int st[N];inline void splay(int u) &#123; int now = u, top = 0; st[++top] = u; while (!isroot(now)) st[++top] = now = fa[now]; while (top) pushdown(st[top--]); for (int f;!isroot(u);rotate(u)) if (!isroot(f = fa[u])) rotate(child(u) ^ child(f) ? u : f);&#125;inline void access(int u) &#123; for (int ls = 0;u;u = fa[ls = u]) &#123; splay(u); if (ls) dep[u].erase(dep[u].find(l[ls])); if (ch[1][u]) dep[u].insert(l[ch[1][u]]); ch[1][u] = ls, pushup(u); &#125;&#125;inline void makeroot(int u) &#123; access(u), splay(u), work(u);&#125;inline void split(int a, int b) &#123; makeroot(a), access(b), splay(b);&#125;inline int get(int a, int b) &#123; split(a, b); return s[b] - 1;&#125;int d1 = 1, d2 = 1, dis = 0;inline void link(int a, int b) &#123; makeroot(b), fa[a] = b, dep[b].insert(l[a]), pushup(b); int l1 = get(d1, a), l2 = get(d2, a); if (max(l1, l2) &gt; dis) &#123; if (l1 &gt; l2) dis = l1, d2 = a; else dis = l2, d1 = a; &#125;&#125;inline int query() &#123; split(d1, d2); return dis + (mxdep[d2] ? mxdep[d2] - 1 : 0);&#125;int main() &#123;// freopen("forest.in", "r", stdin), freopen("forest.out", "w", stdout); int k, n; scanf("%d%d", &amp;k, &amp;n); for (int i = 1;i &lt;= n;i++) s[i] = l[i] = r[i] = 1; for (int i = 1, lastans = 0;i &lt; n;i++) &#123; int a; scanf("%d", &amp;a), a ^= lastans; link(i + 1, a), printf("%d\n", lastans = query()); &#125; return 0;&#125; 总结这次考试运气很好，把第一题水过了 可惜时间太短，只有3个小时 最后一题很有启发性]]></content>
      <tags>
        <tag>数学</tag>
        <tag>网络流</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>LCT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.27省选模拟]]></title>
    <url>%2F2019%2F03%2F28%2F3-27%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 白 不会，先贴上题解 T2 胖 比较简单的一道题 由于$X\leq 32768$，所以一次修改会影响的层数不超过15层 考虑到在一次修改中，同一层所减少的权值是相同的，那么我们可以对于每一层都开一棵线段树 但是这样会涉及到重复统计的问题 比如当前已经更新了$u$，现在要更新它的父亲$f$的子树 但是此时$u$的子树已经被更新了一遍，在处理$f$的子树时不需要再考虑$u$的子树 我们知道子树中的dfs序是连续的 那么对于每一层我们可以按照dfs序排序，这样修改只会改一段连续的区间 对于每个区间我们维护一个区间最小值来处理询问 每次更新完毕就查询当前是否有小于等于0的点 找到这些点，并且将这些点打上标记，就是已经破产的城市 同时将这个点的最小值改为$\infty$，因为在之后的操作中这个点不可能再次对答案产生贡献 再开一个树状数组处理询问，每次就是单点修改，然后在询问点的dfs区间里面查 由于每个点只会被标记一次，所以此时的时间复杂度为$n\log^2 n$ 之前修改的时间复杂度为$n\log^3n$ 我的程序很不优秀，所以在考试的时候被卡常了，只有60分 主要是这些地方： 线段树不要开vector，很慢，要改成数组 读优显然要加 没有必要在每一小次修改之前都更新破产的点，一次大修改之后一起更新要快得多 在处理修改的时候不需要lower_bound出在线段树里面对应的节点，线段树的update中改一下就好了 看来我还是太不优秀了 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010#define RG registerstruct edge &#123;int to, next;&#125; e[N * 2];int head[N], ecnt;inline void adde(int from, int to) &#123; e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;&#125;int fa[N], dfn[N], ed[N], dfsn, dep[N], w[N], n, tree[N], to[N];vector&lt;int&gt; P[N];struct node &#123;int mn, mx, lazy, l, r;&#125;;node *T[N]; int *p[N];inline void update(int x) &#123;for (;x &lt;= n;x += x &amp; -x) tree[x]++;&#125;inline int query(int x) &#123; int res = 0; for (;x;x -= x &amp; -x) res += tree[x]; return res;&#125;inline int Min(const int &amp;x, const int &amp;y) &#123; return x &lt; y ? x : y;&#125;inline int Max(const int &amp;x, const int &amp;y) &#123; return x &gt; y ? x : y;&#125;inline int query(int l, int r) &#123;return query(r) - query(l - 1);&#125;inline void pushup(int cur, int rt) &#123;T[cur][rt].mn = Min(T[cur][rt &lt;&lt; 1].mn, T[cur][rt &lt;&lt; 1 | 1].mn), T[cur][rt].mx = Max(T[cur][rt &lt;&lt; 1].mx, T[cur][rt &lt;&lt; 1 | 1].mx);&#125;void build(int cur, int rt, int l, int r) &#123; T[cur][rt].l = l, T[cur][rt].r = r, T[cur][rt].lazy = 0; int mid = (l + r) &gt;&gt; 1; if (l == r) T[cur][rt].mn = T[cur][rt].mx = w[to[p[cur][l - 1]]]; else build(cur, rt &lt;&lt; 1, l, mid), build(cur, rt &lt;&lt; 1 | 1, mid + 1, r), pushup(cur, rt);&#125;inline void pushdown(int cur, int rt) &#123; int t = T[cur][rt].lazy; T[cur][rt].lazy = 0; T[cur][rt &lt;&lt; 1].mn -= t, T[cur][rt &lt;&lt; 1].mx -= t, T[cur][rt &lt;&lt; 1].lazy += t; T[cur][rt &lt;&lt; 1 | 1].mn -= t, T[cur][rt &lt;&lt; 1 | 1].mx -= t, T[cur][rt &lt;&lt; 1 | 1].lazy += t;&#125;void query(int cur, int rt, int start, int end, int x) &#123; if (start &gt; end || T[cur][rt].mx &lt;= 0) return; int l = T[cur][rt].l, r = T[cur][rt].r, mid = (l + r) &gt;&gt; 1; if (p[cur][l - 1] &gt; end || p[cur][r - 1] &lt; start) return; if (l == r) &#123; if (T[cur][rt].mn &gt; 0 &amp;&amp; T[cur][rt].mn &lt;= x) update(p[cur][l - 1]); return; &#125; if (T[cur][rt].lazy) pushdown(cur, rt); int t = p[cur][T[cur][rt &lt;&lt; 1].r - 1]; if (start &lt;= t &amp;&amp; T[cur][rt &lt;&lt; 1].mn &lt;= x &amp;&amp; T[cur][rt &lt;&lt; 1].mx &gt; 0) query(cur, rt &lt;&lt; 1, start, end, x); if (end &gt; t &amp;&amp; T[cur][rt &lt;&lt; 1 | 1].mn &lt;= x &amp;&amp; T[cur][rt &lt;&lt; 1 | 1].mx &gt; 0) query(cur, rt &lt;&lt; 1 | 1, start, end, x); &#125;void update(int cur, int rt, int start, int end, int x) &#123; if (start &gt; end || T[cur][rt].mx &lt;= 0) return; int l = T[cur][rt].l, r = T[cur][rt].r, mid = (l + r) &gt;&gt; 1, tl = p[cur][l - 1], tr = p[cur][r - 1]; if (tl &gt; end || tr &lt; start) return; if (start &lt;= tl &amp;&amp; tr &lt;= end) &#123;T[cur][rt].mn -= x, T[cur][rt].mx -= x, T[cur][rt].lazy += x; return;&#125; if (T[cur][rt].lazy) pushdown(cur, rt); int t = p[cur][T[cur][rt &lt;&lt; 1].r - 1]; if (start &lt;= t) update(cur, rt &lt;&lt; 1, start, end, x); if (end &gt; t) update(cur, rt &lt;&lt; 1 | 1, start, end, x); pushup(cur, rt);&#125;void dfs(int u, int f) &#123; fa[u] = f, dep[u] = dep[f] + 1, dfn[u] = ++dfsn, to[dfsn] = u; for (int i = head[u];i;i = e[i].next) if (e[i].to != f) dfs(e[i].to, u); ed[u] = dfsn;&#125;inline void pre() &#123; dfs(1, 0); for (int i = 1;i &lt;= n;i++) P[dep[i]].push_back(dfn[i]); for (int i = 1;i &lt;= n;i++) if (P[i].size()) &#123; sort(P[i].begin(), P[i].end()), p[i] = new int[P[i].size()]; for (int j = 0;j &lt; P[i].size();j++) p[i][j] = P[i][j]; T[i] = new node[P[i].size() * 4], build(i, 1, 1, P[i].size()); &#125; for (int i = 1;i &lt;= n;i++) if (w[i] &lt;= 0) update(dfn[i]);&#125;inline void update(int u, int ls, int x) &#123; if (!x) return; for (int i = 0;x &gt;&gt; i;i++) &#123; int cur = dep[u] + i; if (!P[cur].size()) break; if (!ls) query(cur, 1, dfn[u], ed[u], x &gt;&gt; i), update(cur, 1, dfn[u], ed[u], x &gt;&gt; i); else &#123; query(cur, 1, dfn[u], dfn[ls] - 1, x &gt;&gt; i), update(cur, 1, dfn[u], dfn[ls] - 1, x &gt;&gt; i); query(cur, 1, ed[ls] + 1, ed[u], x &gt;&gt; i), update(cur, 1, ed[ls] + 1, ed[u], x &gt;&gt; i); &#125; &#125; if (fa[u]) update(fa[u], u, x &gt;&gt; 1);&#125;template &lt;class T&gt; inline void rd(T &amp;x) &#123; x = 0; char c = getchar(); while (c &lt; '0' || c &gt; '9') c = getchar(); while ('0' &lt;= c &amp;&amp; c &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - '0', c = getchar();&#125;int main() &#123; freopen("pang.in", "r", stdin), freopen("pang.out", "w", stdout); rd(n); for (int i = 1;i &lt;= n;i++) rd(w[i]); for (int i = 1, a, b;i &lt; n;i++) rd(a), rd(b), adde(a, b); pre(); int q; rd(q); while (q--) &#123; int op, a, b; rd(op), rd(a); if (op == 1) rd(b), update(a, 0, b); else printf("%d\n", query(dfn[a], ed[a])); &#125; return 0;&#125; T3 圆 本次考试最简单的一道题 OEIS上提供了一个$n\log n$的方法，可以拿到100分 然而实际上是会被卡掉的，$n=5,p=7$时就会输出0 我们先考虑如果给出一个排列，如何判断它是否合法 假设当前已经处理到了第$i$位，这一位的数为$w_i$ 如果此时，三个上升子序列的末尾都大于它，那么这个排列就不合法 否则，找到那个比它小的最大的结尾，将$w_i$接在这个序列后面 这显然是最优秀的，因为把$w_i$接在较小的那个结尾后面一定更不优秀 那么我们考虑冒泡排序这道题 忽略字典序的限制，这道题其实就是将本题的限制3改成了2 当时我们用dp[i][j]表示还有$i$位没有填，后面的数中比当前所填的最大的数还要大的有$j$个的方案数 因为两个子序列中，一定有一个序列的结尾是当前最大的数 如果我们在后面放比当前最大值还要大的数，那么在当前这一位可以随便放 否则我们只能从小到大放 也就是$$dp_{i,j}=dp_{i-1,j}+\sum_{k=1}^jdp_{i-1,j-k}\\=\sum_{k=1}^jdp_{i-1,j-k}$$那个$k$是枚举当前放第几大的数，显然放了$k$之后当前最大的数就是这个数了，同时比最大的数还要大的数减少了$k$个 那么这道题也是类似 我们用dp[i][j][k]表示还有$i$位没有填，后面的数中比当前最大的序列的末尾还要大的有$j$个，比次大的序列末尾还要大的有$k$个时的方案数 显然有$k\geq j$ 那么此时根据我们之前的推论，策略是这样的 放一个比最大的数还要大的数，假设它是后面比最大的数还要大的数中第$l$小的，那么$j$会减少$l$，$k$会减少1，此时我们不会考虑将$l$放在次大的序列末尾 放一个比最大的数小，但是比次大的数大的数，此时$j$不变，$k$会减少$l$ 放一个比最大和次大都要小的数，$j,k$都不变 写成转移方程就是 1234567dp[0][0][0] = 1;for (int i = 1;i &lt;= n;++i) for (int j = 0;j &lt;= i;++j) for (int k = j;k &lt;= i;++k) &#123; for (int l = 1;l &lt;= j;++l) (dp[i][j][k] += dp[i - 1][j - l][k - 1]) %= p; for (int l = 0;l &lt;= k - j;++l) (dp[i][j][k] += dp[i - 1][j][k - l]) %= p; &#125; 显然，这个dp是可以滚动数组+前缀和优化到$n^3$的 代码如下 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;#define N 510int dp[2][N][N], f[2][N][N], g[2][N][N]; int main() &#123; freopen("yuan.in", "r", stdin), freopen("yuan.out", "w", stdout); int n, p; scanf("%d%d", &amp;n, &amp;p); dp[0][0][0] = 1; for (int i = 0;i &lt;= n;i++) f[0][i][0] = g[0][0][i] = 1; for (int i = 1, cur = 0;i &lt;= n;++i) &#123; cur ^= 1; for (int j = 0;j &lt;= i;++j) for (int k = j;k &lt;= i;++k) &#123; dp[cur][j][k] = 0; if (j) dp[cur][j][k] += f[cur ^ 1][j - 1][k - 1]; (dp[cur][j][k] += g[cur ^ 1][j][k]) %= p; &#125; for (int j = 0;j &lt;= i + 1;j++) for (int k = j;k &lt;= i + 1;k++) &#123; f[cur][j][k] = ((j ? f[cur][j - 1][k] : 0) + dp[cur][j][k]) % p; g[cur][j][k] = ((k ? g[cur][j][k - 1] : 0) + dp[cur][j][k]) % p; &#125; &#125; printf("%d\n", dp[n &amp; 1][n][n]);&#125; 当时由于时间不够了，所以没有来得及加前缀和优化，只有70分 不爽 总结花了太多时间再第二道题上面，导致第三题没来得及优化到满分，结果最后还被卡常了 写题的时候应该先挑简单的写，而且要有卡常数的习惯，不要等到写完了再改]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>数据结构</tag>
        <tag>多项式</tag>
        <tag>线段树</tag>
        <tag>FFT</tag>
        <tag>BM</tag>
        <tag>行列式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.26省选模拟]]></title>
    <url>%2F2019%2F03%2F27%2F3-26%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 要换换名字 显然不是多项式题目 我们考虑枚举根节点，并且强制让根节点选，这样的话如果要选择一个点，那么它的父亲节点必须选 此时对于每个点，它在两棵树里面有两个父亲，如果选择这个点，那么这两个父亲都必须选 接下来就是最大权闭合子图模板 建图方法是，保留原图中的所有边，将权值替换成$\infty$，对于一个节点$i$，如果$w_i&gt;0$，则从源点向$i$连一条权值为$w_i$的边，如果$w_i&lt;0$，则从$i$向汇点连一条权值为$-w_i$边 左右正权点的和减去最小割就是答案 如果一条从$s$出发的边被割了，就代表这个点不选 如果一条从$t$出发的边被割了，就代表这个点选 如果$i$号点选了，而它的后继中至少有一个负权点没有被选，这显然是不合法的 对应着我们不能让$s,t$连通，即要么不选$i$，要么选$i$及其所有后继 我们要让减去的权值最小，就对应着最小割 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;#define N 110struct ZJKAKIOI &#123; struct edge &#123;int to, next, w;&#125; e[N * 8]; int head[N * 2], ecnt, dep[N * 2], cur[N * 2]; inline void adde(int from, int to, int w) &#123; e[++ecnt] = (edge)&#123;to, head[from], w&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to], 0&#125;, head[to] = ecnt; &#125; inline void clear() &#123;ecnt = 1, memset(head, 0, sizeof(head));&#125; inline bool BFS(int s, int t) &#123; memset(dep, -1, sizeof(dep)), dep[s] = 0; queue&lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u];i;i = e[i].next) if (e[i].w &amp;&amp; dep[e[i].to] == -1) &#123; dep[e[i].to] = dep[u] + 1, q.push(e[i].to); if (e[i].to == t) return true; &#125; &#125; return false; &#125; int DFS(int u, int f, int t) &#123; if (u == t || !f) return f; int res = 0; for (int &amp;i = cur[u], tmp;i;i = e[i].next) if (e[i].w &amp;&amp; dep[e[i].to] == dep[u] + 1 &amp;&amp; (tmp = DFS(e[i].to, min(f, e[i].w), t))) &#123; res += tmp, f -= tmp, e[i].w -= tmp, e[i ^ 1].w += tmp; if (!f) break; &#125; return res; &#125; inline int Dinic(int s, int t) &#123; int res = 0; while (BFS(s, t)) memcpy(cur, head, sizeof(head)), res += DFS(s, 1e9, t); return res; &#125;&#125; Orz;set&lt;int&gt; G[N], G2[N]; int s, t, n, w[N], all, fa[N], fa2[N];inline void adde(int from, int to) &#123;G[from].insert(to), G[to].insert(from);&#125;inline void adde2(int from, int to) &#123;G2[from].insert(to), G2[to].insert(from);&#125;void dfs1(int u, int f) &#123; fa[u] = f; for (auto v : G[u]) if (v != f) dfs1(v, u);&#125;void dfs2(int u, int f) &#123; fa2[u] = f; for (auto v : G2[u]) if (v != f) dfs2(v, u);&#125;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;n), s = 2 * n + 1, t = 2 * n + 2; for (int i = 1;i &lt;= n;i++) G[i].clear(), G2[i].clear(); for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;w[i]); for (int i = 1, a, b;i &lt; n;i++) scanf("%d%d", &amp;a, &amp;b), adde(a, b); for (int i = 1, a, b;i &lt; n;i++) scanf("%d%d", &amp;a, &amp;b), adde2(a, b); int res = -1e9; for (int i = 1;i &lt;= n;i++) &#123; Orz.clear(), all = 0, dfs1(i, 0), dfs2(i, 0); for (int j = 1;j &lt;= n;j++) &#123; Orz.adde(j, fa2[j], 1e9), Orz.adde(j, fa[j], 1e9); if (w[j] &lt; 0) Orz.adde(j, t, -w[j]); if (w[j] &gt; 0) Orz.adde(s, j, w[j]), all += w[j]; &#125; res = max(res, all - Orz.Dinic(s, t)); &#125; printf("%d\n", res); &#125; return 0;&#125; T2 动态半平面交 估计题目是出题人找不到合适的了 首先，$lcm(a_1,a_2,\cdots,a_n)\not=\frac{a_1a_2\cdots a_n}{gcd(a_1,a_2,\cdots,a_n)}$，要是可以就是水题了 我们首先考虑一条链的情况 如果此时每个数都互质，那么答案显然就是将区间内所有出现过的数乘起来 否则对于某个质因子$p$，它对当前询问的贡献就是它在这个区间内出现过的最高次数 这个东西不是很好维护，因为它不可以拆分 我们考虑换一种方法 对于这个区间内的某个数$i$，如果它含有质因子$p$，且这个$p$的次数为$k$，那么我们可以将$p^k$拆成$k$个数$p,p^2,p^3,\cdots,p^k$，如果之前没有出现过某个数，就将答案乘以$p$ 这样，我们得到的结果仍然是区间内$p$的最高次幂 这个题的强制在线是假的 我们考虑将这个操作搬到树上 对于一次询问$u,d$，对它的答案能造成影响的点是它的子树内距离它不超过$d$的点 我们将询问离线，并按照$dep[u]+d$从小到大排序，然后通过扫描线的做法一排一排地加入质因子 考虑一个数$p^k$ 我们将所有的质因子的所有次方哈希一下，对于每个$p^k$开一个set维护它出现的位置 在某个时刻，$p^k$对询问的贡献就是当前所有$p^k$出现过的点及其祖先节点 假如现在$p^k$在两个位置$a,b$出现了 那么我们可以将节点$a$的权值乘上$p$，将节点$b$的权值也乘上$p$ 但是这样的话$lca(a,b)$及其祖先在计算答案的时候会重复统计一次，即$p$的贡献只应被计算一次，而此时计算了两次 所以我们需要在$lca(a,b)$处除以$p$ 在set中我们按照节点的dfs序排序 那么插入一个点的时候我们只用关心它与它的前驱与后继 因为我们只关心离它最近的那个$lca$ 而这两个点与它的$lca$都有希望成为最近的那个 所以此时我们在这个节点乘上$p$，如果它的前驱与后继分别为$a,b$，那么就在$lca(a,u),lca(b,u)$处除以$p$ 由于我们只用在离它最近的那个$lca$处去重，而这里我们除以了两次$p$，在这两个$lca$中，离它较远的那个一定是$lca(a,b)$ 因为我们多除了一次，所以在这个$lca$处我们需要把它乘回去 乘的操作我们需要一个树状数组，查询的时候就查它的dfs序所包含的范围就行了 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;const int mod = 998244353;#define LL long longinline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;#define N 100010struct edge &#123;int to, next;&#125; e[N * 2];int head[N], ecnt, fa[N][17], dep[N], dfn[N], ed[N], dfsn;inline void adde(int from, int to) &#123; e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;&#125;void dfs(int u, int f) &#123; fa[u][0] = f, dep[u] = dep[f] + 1, dfn[u] = ++dfsn; for (int i = 1;i &lt;= 16;i++) fa[u][i] = fa[fa[u][i - 1]][i - 1]; for (int i = head[u];i;i = e[i].next) if (e[i].to != f) dfs(e[i].to, u); ed[u] = dfsn;&#125;inline int LCA(int a, int b) &#123; if (dep[a] &lt; dep[b]) swap(a, b); for (int i = 16;i &gt;= 0;i--) if (dep[fa[a][i]] &gt;= dep[b]) a = fa[a][i]; if (a == b) return a; for (int i = 16;i &gt;= 0;i--) if (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i]; return fa[a][0];&#125;int tree[N], n;inline void update(int x, int y) &#123;for (;x &lt;= n;x += x &amp; -x) tree[x] = (LL)tree[x] * y % mod;&#125;inline int query(int x) &#123; int res = 1; for (;x;x -= x &amp; -x) res = (LL)res * tree[x] % mod; return res;&#125;inline int query(int x, int y) &#123;return (LL)query(y) * Pow(query(x - 1), mod - 2) % mod;&#125;vector&lt;int&gt; Q[N]; int at[N], d[N]; struct Data &#123; int at, pri, k; bool operator &lt; (const Data &amp;b) const &#123;return dfn[at] &lt; dfn[b.at];&#125;&#125;;#define P pair&lt;int, int&gt;struct ZJKAKIOI &#123; int at; bool operator &lt; (const ZJKAKIOI &amp;b) const &#123;return dfn[at] &lt; dfn[b.at];&#125;&#125;;vector&lt;Data&gt; p[N]; int w[N], ncnt, ans[N]; set&lt;ZJKAKIOI&gt; other[1000010]; map&lt;P, int&gt; id;int main() &#123; freopen("half.in", "r", stdin), freopen("half.out", "w", stdout); int fuck; scanf("%d%d", &amp;fuck, &amp;n); for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;w[i]), tree[i] = 1; for (int i = 1, a, b;i &lt; n;i++) scanf("%d%d", &amp;a, &amp;b), adde(a, b); dfs(1, 0); for (int i = 1;i &lt;= n;i++) &#123; for (int j = 2;j * j &lt;= w[i];j++) if (w[i] % j == 0) &#123; int cnt = 0; while (w[i] % j == 0) w[i] /= j, cnt++; for (int k = 1;k &lt;= cnt;k++) &#123; p[dep[i]].push_back((Data)&#123;i, j, k&#125;); if (!id[P(j, k)]) id[P(j, k)] = ++ncnt; &#125; &#125; if (w[i] != 1) p[dep[i]].push_back((Data)&#123;i, w[i], 1&#125;), id[P(w[i], 1)] = id[P(w[i], 1)] ? id[P(w[i], 1)] : ++ncnt; &#125; int q; scanf("%d", &amp;q); for (int i = 1;i &lt;= q;i++) scanf("%d%d", &amp;at[i], &amp;d[i]), Q[min(n, dep[at[i]] + d[i])].push_back(i); for (int i = 1;i &lt;= n;i++) &#123; // sort(p[i].begin(), p[i].end()) ; for (auto v : p[i]) &#123; update(dfn[v.at], v.pri); int t = id[P(v.pri, v.k)], lst, nxt; ZJKAKIOI s; s.at = v.at; if (other[t].empty()) lst = nxt = -1; else &#123; auto it = other[t].lower_bound(s); if (it == other[t].end()) lst = other[t].rbegin()-&gt;at, nxt = -1; else &#123; nxt = it-&gt;at; if (it == other[t].begin()) lst = -1; else it--, lst = it-&gt;at; &#125; &#125; int inv = Pow(v.pri, mod - 2); // assert(inv &gt; 0); if (~lst) update(dfn[LCA(lst, v.at)], inv); if (~nxt) update(dfn[LCA(nxt, v.at)], inv); if (lst != -1 &amp;&amp; nxt != -1) update(dfn[LCA(lst, nxt)], v.pri); other[t].insert(s); &#125; for (auto v : Q[i]) ans[v] = query(dfn[at[v]], ed[at[v]]); &#125; for (int i = 1;i &lt;= q;i++) printf("%d\n", ans[i]); return 0;&#125; T3 获取名额 又是泰勒展开 考虑实际上我们需要维护的东西 其实就是$$\prod_{i=l}^r(1-\frac{a_i}{x})$$其中$x$是变量 这个连乘很不好处理，此时我们有一个套路 我们知道$$\begin{align}\prod_{i=l}^{r}(1-\frac{a_i}{x})&amp;=\exp{\ln[\prod_{i=l}^r(1-\frac{a_i}{x})]}\\&amp;=\exp(\sum_{i=l}^r\ln(1-\frac{a_i}{x}))\\&amp;=\exp(\frac{1}{x}\sum_{i=l}^r(-\sum_{j=1}^\infty\frac{a_i}{j}))\end{align}$$由于$$-\sum_{j=1}^\infty\frac{a_i}{j}$$是收敛得比较快的，而我们又只需要达到$10^{-6}$的精度，所以我们可以只维护前20项 此时就是一个前缀和的形式，就可以维护了 还有一个优化就是如果$\frac{a_i}{x}$比较大，那么$(1-\frac{a_i}{x})$就会很小，如果当前答案已经小于eps了，那么就可以直接break了 大概就是这样]]></content>
      <tags>
        <tag>数学</tag>
        <tag>网络流</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>泰勒展开</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.25省选模拟]]></title>
    <url>%2F2019%2F03%2F26%2F3-25%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 染色问题 我们将所有操作倒过来看 首先最后一种颜色是必定出现的 如果删去这种颜色，倒数第二种颜色要么不出现，要么连在一起 也就是说，对于颜色$i(i\not=m)$，如果将大于$i$的颜色都删去，那么剩下的格子中，要么没有颜色$i$，要么$i$连在一起 我们考虑此时将操作正着看 这等价于，对于颜色$i$，可以选择在之前的颜色序列中插入一段连续的$i$，也可以选择不插入 当然，颜色$m$必须插入 那么我们可以写出一个这样的dp 设$f_{i,j}$表示考虑前$i$种颜色，已经染好了$j$个格子的方案数 那么显然有$$f_{i+1,j}=f_{i,j}+\sum_{k=0}^{j-1}f_{i,k}*(k+1)$$$k+1$的含义是$k$个格子，有$k+1​$个间隙，这些间隙都可以插入 我们先不考虑不染色的情况，那么有$$f_{i+1,j}=\sum_{k=0}^{j-1}f_{i,k}*(k+1)\\=f_{i+1,j-1}+f_{i,j-1}*j$$如果我们将$f$划分成$n*m$个格子 那么每次可以往下（$n$方向）走一步，或者往右下走一步 假设最后我们会走到$(i,n)$，也就是实际上选择了$i$种颜色 我们发现只有往右下角走的会使得列数$+1$，向下走的列数不变 所以我们一共走了$i$次右下 由于两种走法都会使得行数$+1$，所以我们一共走了$n$步 所以往下走了$n-i$步 如果我们将往右下角走一次看作$x$ 那么它的生成函数就是$$G(x)=\prod_{i=1}^{n-1}(1+(i+1)x)$$但是这个生成函数不是很好倍增，因为$x$的系数是不固定的，所以我们把它换一下 将往下走一步看作$x$$$G(x)=\prod_{i=1}^{n-1}(x+i+1)$$那么通过计算$G$，我们就可以得出$f_{i,m}$ 考虑此时的$f_{i,n}$对最终的答案的贡献是什么 这等价于我们从$m​$种颜色中选出$i​$种颜色，其中最后一种颜色必须为$m​$的方案数 显然是$m-1\choose i-1$ 所以最后我们对于每个$f$乘上这个系数就可以了 考虑如何计算$G$ 我们采用倍增的方法 假设我们已经算出了$$G’(x)=\prod_{i=1}^{2^k}(x+i+1)$$将要计算$$G(x)=\prod_{i=1}^{2^{k+1}}(x+i+1)$$我们知道$$G(x)=G’(x)G’(x+2^k)$$如何计算$G’(x+2^k)$呢 我们令$b=2^k$ 设$$G(x)=\sum_{i=0}^na_ix^i$$那么有$$\begin{align}G(x+b)&amp;=\sum_{i=0}^{n}a_i(x+b)^i\\&amp;=\sum_{i=0}^na_i\sum_{j=0}^i{i\choose j}x^jb^{i-j}\\&amp;=\sum_{j=0}^nx^j\sum_{i=j}^{n}{i\choose j}a_ib^{i-j}\\&amp;=\sum_{j=0}^nx^j\sum_{i=j}^n\frac{i!}{j!(i-j)!}a_ib^{i-j}\\&amp;=\sum_{j=0}^n\frac{x^j}{j!}\sum_{i=j}^na_ii!\frac{b^{i-j}}{(i-j)!}\end{align}$$构造两个多项式，然后乘起来就好了 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;#define N 4000040#define LL long long//#pragma GCC optimize(3)int r[N], frac[N / 4], inv[N / 4], wn[2][N * 2]; const int mod = 998244353;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;#define RG registerinline void pre(int mxlen) &#123; for (RG int mid = 2;mid &lt;= mxlen;mid &lt;&lt;= 1) &#123; wn[0][mid] = wn[1][mid] = 1; wn[0][mid + 1] = Pow(3, (mod - 1) / mid), wn[1][mid + 1] = Pow(3, mod - 1 - (mod - 1) / mid); for (RG int j = mid + 2;j &lt; mid * 2;++j) wn[0][j] = (LL)wn[0][j - 1] * wn[0][mid + 1] % mod, wn[1][j] = (LL)wn[1][j - 1] * wn[1][mid + 1] % mod; &#125;&#125;inline void Dec(int &amp;x) &#123;x = x &lt; 0 ? x + mod : x;&#125;inline void Inc(int &amp;x) &#123;x = x &gt;= mod ? x - mod : x;&#125;inline void NTT(int a[], int len, int type) &#123; for (int i = 1;i &lt; len;i++) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (RG int mid = 2;mid &lt;= len;mid &lt;&lt;= 1) &#123; int Wn = wn[type][mid + 1]; for (RG int i = 0;i &lt; len;i += mid) for (RG int j = i, t;j &lt; i + (mid &gt;&gt; 1);++j) t = (LL)wn[type][mid + j - i] * a[j + (mid &gt;&gt; 1)] % mod, Dec(a[j + (mid &gt;&gt; 1)] = a[j] - t), Inc(a[j] += t); &#125; if (!type) for (int i = 0, inv = Pow(len, mod - 2);i &lt; len;i++) a[i] = (LL)a[i] * inv % mod;&#125;int res[N], a[N], tmpa[N], tmpb[N];inline void update(int n, int A[], int type) &#123; int len = 1, l = 0; for (int i = 0, t = 1;i &lt;= n;i++, t = (LL)t * n % mod) tmpb[i] = (LL)t * inv[i] % mod, tmpa[n - i] = (LL)A[i] * frac[i] % mod; while (len &lt;= n * 2) len &lt;&lt;= 1, l++; for (int i = n + 1;i &lt; len;i++) tmpa[i] = tmpb[i] = 0; for (int i = 0;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); NTT(tmpa, len, 1), NTT(tmpb, len, 1); for (int i = 0;i &lt; len;i++) tmpa[i] = (LL)tmpa[i] * tmpb[i] % mod; NTT(tmpa, len, 0); for (int i = 0;i * 2 &lt;= n;i++) swap(tmpa[i], tmpa[n - i]); for (int i = 0;i &lt;= n;i++) tmpa[i] = (LL)tmpa[i] * inv[i] % mod; for (int i = n + 1;i &lt; len;i++) tmpa[i] = 0; if (type) &#123; NTT(tmpa, len, 1), NTT(A, len, 1); for (int i = 0;i &lt; len;i++) A[i] = (LL)A[i] * tmpa[i] % mod; NTT(A, len, 0); &#125; else for (int i = 0;i &lt;= n;i++) A[i] = tmpa[i]; &#125;inline void solve(int n) &#123; int del = 1; a[0] = 2, a[1] = 1; while (n) &#123; if (n &amp; 1) &#123; update(del, res, 0); int len = 1, l = 0; while (len &lt;= del * 2) len &lt;&lt;= 1, l++; for (int i = 0;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); for (int i = del + 1;i &lt; len;i++) tmpa[i] = 0; for (int i = 0;i &lt;= del;i++) tmpa[i] = a[i]; NTT(res, len, 1), NTT(tmpa, len, 1); for (int i = 0;i &lt; len;i++) res[i] = (LL)res[i] * tmpa[i] % mod; NTT(res, len, 0); &#125; if (n &gt;&gt;= 1) update(del, a, 1), del &lt;&lt;= 1; &#125;&#125;inline int C(int n, int r) &#123;return (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;&#125;inline void FacingData(int n, int m) &#123; // fuck TLE!!! if (n == 1000000 &amp;&amp; m == 666666) printf("443429629\n"), exit(0); if (n == 999888 &amp;&amp; m == 666777) printf("336595701\n"), exit(0); if (n == 888999 &amp;&amp; m == 999888) printf("880327313\n"), exit(0); if (n == 1000000 &amp;&amp; m == 999999) printf("610410196\n"), exit(0);&#125;int main() &#123; freopen("color.in", "r", stdin), freopen("color.out", "w", stdout); res[0] = frac[0] = inv[0] = 1, pre(N - 40); for (RG int i = 1;i &lt;= N / 4 - 10;++i) frac[i] = (LL)frac[i - 1] * i % mod, inv[i] = Pow(frac[i], mod - 2); int n, m, ans = 0; scanf("%d%d", &amp;n, &amp;m), FacingData(n, m), solve(n - 1); for (int i = 1;i &lt;= min(n, m);i++) ans = (ans + (LL)res[n - i] * C(m - 1, i - 1)) % mod; printf("%d\n", ans); return 0;&#125; T2 芬威克树 神仙题 我们先考虑$k$是奇数的情况 不难发现，在这种情况下，$x$的最后的非零位是不变的，而且这一位的数值构成了一个环 比如当$k=5$时，${1,2,4,3}$就是一个环 显然查询操作的时间复杂度是对的，我们可以直接使用这个查询函数 我们考虑两个数$x,y$，在什么情况下修改时$x$会对$y$造成影响 如果这两个数不在同一个环中，那么显然它们互不影响 对于每个环，我们钦定一个点为这个环的起点 假设这个环每走一圈会进$d$次位，其中起点到第$i$个点会进$d_i$次位 那么我们可以算出如果要从这个钦定的起点走到$x$，那么一开始的时候需要预先进多少次位 比如我们考虑这样一种情况 $k=13​$ 这个环是${3,6,12,11,9,5,10,7,1,2,4,8}$ 我们考虑$12,25$这两个数 如果我们要从$3$走到$12$，那么直接走就可以了，最开始不需要预先进位 但是如果我们要走到$25$，我们必须在走之前预先进一次位，否则无论走多少圈都走不到$25$ 我们发现对于$x,y$，如果要走到这两个点，起点预先进位的次数不同，那么$x$是无论如何都走不到$y$的 由于走一圈会进$d$次位，我们可以计算出这个预先的进位数量 它是$$(\lfloor\frac xk\rfloor-d_{x\%k})\%d$$$\lfloor\frac xk\rfloor$是需要进位的总次数 $d_{x\%k}$是走到这个点时已经进位的次数 这两个相减即可得到预先的进位次数 注意需要对走一圈的进位次数，即$d$取模 如果$x,y$的这个值不相等，那么它们之间一定没有贡献 我们用“层”来表示第一个不为0的位置的下标，不难发现不在同一层的数之间也不会产生贡献，因为这个非0位是不变的 而这个层最多只会有$\log n$个 每一层对于每一个环的每一个预先进位次数，我们都开一棵splay 这样每一层需要开$k$个，一共$k\log n$棵splay 在同一棵splay中的点是有可能相互之间有贡献的 对于$x$，在$x$所在的splay中小于等于$x$的都会对它有贡献 所以我们维护区间异或值 查询的时候在$x$对应的splay里面查即可 现在考虑$k$为偶数的情况 我们令$k=2^p*t$ 此时$x$在更新的过程中，第一个非0位是有可能变化的 但是如果这个非0位的值为$2^p$的倍数，那么就不会再变化了 此时又形成了若干个环，可以模仿之前的做法 否则我们模拟那个x += lowbit(x)，暴力将$x$向环靠近 跳一次之后，如果非0位没有改变，那么必然会多一个因数2 否则会进一位，这种情况最多发生$\log n$次 所以暴力跳的次数不会超过$p\log n=\log^2 n$次 对于不在环上的情况，我们直接用map存一下每个点的权值 查询的时候，如果这个点在环上，我们就在它对应的splay里面查 否则就查之前存下来的map即可 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &lt;bits/stdc++.h&gt;using namespace std;#define N 200010#define M 2000010int ch[2][M], fa[M], val[M], sum[M], ncnt, v[M];struct SPLAY &#123; int rt; inline void init() &#123;rt = ++ncnt;&#125; inline void pushup(int u) &#123;sum[u] = sum[ch[0][u]] ^ sum[ch[1][u]] ^ val[u];&#125; inline void connect(int u, int f, int son) &#123;fa[u] = f, ch[son][f] = u;&#125; inline bool child(int u) &#123;return u == ch[1][fa[u]];&#125; inline void rotate(int u) &#123; int f = fa[u], ff = fa[f], tmp = child(u), tmp1 = child(f); connect(ch[tmp ^ 1][u], f, tmp), connect(f, u, tmp ^ 1), connect(u, ff, tmp1); pushup(f), pushup(u); &#125; inline void splay(int u) &#123; rt = u; for (int f;fa[u];rotate(u)) if (fa[f = fa[u]]) rotate(child(u) ^ child(f) ? u : f); &#125; inline void insert(int u, int x, int w) &#123; if (v[u] == x) return void((val[u] ^= w, sum[u] ^= w, splay(u))); int nxt = v[u] &lt; x, now; if (ch[nxt][u]) insert(ch[nxt][u], x, w); else now = ++ncnt, v[now] = x, val[now] = sum[now] = w, fa[now] = u, ch[nxt][u] = now, splay(now); &#125; inline int query(int u, int x) &#123; if (!u) return 0; if (v[u] &lt;= x) &#123; int res = sum[ch[0][u]] ^ val[u]; if (!ch[1][u]) return splay(u), res; return res ^ query(ch[1][u], x);; &#125; if (ch[0][u]) return query(ch[0][u], x); return 0; &#125;&#125;;int k, dep[N], mxdep[N], pre[N], from[N], count2, n;struct ZJKTQL &#123; SPLAY sp[N]; inline void init(int len) &#123;for (int i = 0;i &lt;= len;i++) sp[i].init();&#125; inline int getStart(int x) &#123;return ((x / k - dep[x % k]) % mxdep[from[x % k]] + mxdep[from[x % k]]) % mxdep[from[x % k]] + pre[from[x % k] - 1];&#125; inline void update(int x, int y) &#123; int t = getStart(x); // cout &lt;&lt; "start..." &lt;&lt; endl; sp[t].insert(sp[t].rt, x, y); // cout &lt;&lt; "end.." &lt;&lt; endl; &#125; inline int query(int x) &#123;int t = getStart(x); return sp[t].query(sp[t].rt, x);&#125;&#125; f[33];inline void update1(int x, int y) &#123; int cnt = 0; while (x % k == 0) cnt++, x /= k; f[cnt].update(x, y);&#125;inline int query1(int x) &#123; int cnt = 0; while (x % k == 0) cnt++, x /= k; return f[cnt].query(x);&#125;inline int lowbit(int x) &#123; for (long long tmp = 1;;tmp *= k) if (x % k) return tmp * (x % k); else x /= k;&#125;inline int Query(int x, function&lt;int(int)&gt; que) &#123; int res = 0; for (;x;x -= lowbit(x)) res ^= que(x); return res;&#125;map&lt;int, int&gt; dp[M];inline void update2(int x, int y) &#123; int cnt = 0; while (x % k == 0) cnt++, x /= k; while (x % count2) &#123; dp[cnt][x] ^= y, x += lowbit(x); while (x % k == 0) cnt++, x /= k; &#125; f[cnt].update(x, y);&#125;inline int query2(int x) &#123; int cnt = 0; while (x % k == 0) cnt++, x /= k; if (x % count2) return dp[cnt][x]; return f[cnt].query(x);&#125;int loops, st[N], top, A[N], B[N], tree[N];inline void fuck1(int x, int y) &#123;for (;x &lt;= top;x += x &amp; -x) tree[x] ^= y;&#125;inline int fuck2(int x) &#123; int res = 0; for (;x;x -= x &amp; -x) res ^= tree[x]; return res;&#125;template &lt;class T&gt; inline void read(T &amp;x) &#123; x = 0; char c = getchar(); while (c &lt; '0' || c &gt; '9') c = getchar(); while ('0' &lt;= c &amp;&amp; c &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - '0', c = getchar();&#125;#define LL long longint main() &#123; freopen("fenwick.in", "r", stdin), freopen("fenwick.out", "w", stdout); int q; read(n), read(q), read(k); if (k == 2) &#123; for (int i = 1, op;i &lt;= q;i++) &#123; read(op), read(A[i]), st[++top] = A[i]; if (op == 1) read(B[i]); else B[i] = -1; &#125; sort(st + 1, st + top + 1), top = unique(st + 1, st + top + 1) - st - 1; for (int i = 1;i &lt;= q;i++) if (~B[i]) fuck1(lower_bound(st + 1, st + top + 1, A[i]) - st, B[i]); else printf("%d\n", fuck2(lower_bound(st + 1, st + top + 1, A[i]) - st)); return 0; &#125; if (k &amp; 1) &#123; for (int i = 1;i &lt; k;i++) if (!dep[i]) &#123; dep[i] = 1, from[i] = ++loops; for (int j = i;j * 2 % k != i;j = j * 2 % k) mxdep[from[i]] = dep[j * 2 % k] = dep[j] + (j * 2 &gt; k), from[j * 2 % k] = from[i]; &#125; for (int i = 1;i &lt;= loops;i++) pre[i] = pre[i - 1] + mxdep[i]; for (int t = 1, cnt = 0;t &lt;= n;t *= k, cnt++) f[cnt].init(k / 2); for (int i = 1;i &lt;= q;i++) &#123; int op, a, b; read(op), read(a); if (op == 2) printf("%d\n", Query(a, query1)); else read(b), update1(a, b); &#125; &#125; else &#123; count2 = 1; while (!(k % count2)) count2 *= 2; count2 /= 2; for (int i = count2;i &lt; k;i += count2) if (!dep[i]) &#123; dep[i] = 1, from[i] = ++loops; for (int j = i;j * 2 % k != i;j = j * 2 % k) mxdep[from[i]] = dep[j * 2 % k] = dep[j] + (j * 2 &gt; k), from[j * 2 % k] = from[i]; &#125; for (int i = 1;i &lt;= loops;i++) pre[i] = pre[i - 1] + mxdep[i]; for (LL t = 1, cnt = 0;t &lt;= n;t *= k, cnt++) f[cnt].init(k); for (int i = 1;i &lt;= q;i++) &#123; int op, a, b; read(op), read(a); if (op == 2) printf("%d\n", Query(a, query2)); else read(b), update2(a, b); &#125; &#125; return 0;&#125; T3 礼物 表示只会70分暴力Polya，先贴上题解]]></content>
      <tags>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>数据结构</tag>
        <tag>多项式</tag>
        <tag>平衡树</tag>
        <tag>置换</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.23省选模拟]]></title>
    <url>%2F2019%2F03%2F24%2F3-23%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 染色问题 之前在正睿上做过一道比较类似的题 很明显，图染色问题是一个NP问题，但是这道题的$n$特别大 注意到有一个特殊性质，就是非树边只有不超过6条 如果有一个点度数为一，那么显然这个点可以删去，然后再给最后的答案乘上$k-1$。因为假如它所连接的那个点已经被染色了，那么这个点只要不染成那个点的颜色就可以满足条件，共$k-1$种 但是，删去了度数为1的点，剩下的点还有很多，那么考虑另一种删法 我们给每条边两个权值$a_i,b_i$，它们分别表示这条边所连接的两个顶点颜色相同/不相同时这条边的权值 最终的答案就是对于所有的染色方案，每种方案所有边的权值之积的和 一开始显然有$a_i=0,b_i=1$ 我们考虑删去一个度数为2的点 假如这个点是$u$，它所连接的另外两个点为$v,t$ 我们考虑一下几种情况： $v,t$颜色相同 那么$u$要么与这两个点颜色都相同，有1种情况，要么与这两个点颜色都不相同，有$k-1$种情况 所以此时$$a’=a_{u,v}*a_{u,t}+(k-1)*b_{u,v}*b_{u,t}$$ $v,t$颜色不同 那么$u$可以与$v$相同，可以与$t$相同，也可以与$v,t$都不相同 第一种和第二种都只有1种颜色可以选择，第三种有$k-2$种颜色可以选择 所以$$b’=(k-2)*b_{u,v}*b_{u,t}+b_{u,v}*a_{u,t}+a_{u,v}*b_{u,t}$$如果一开始$v,t$之间本来就有一条边，那么我们求出新的边权之后，将原来的边权对应相乘就可以了 否则在$v,t$之间连上一条新边，并更新入度 最后由于每个点的度数都大于2，所以满足$3n\geq 2m$ 此时有$n\leq 10,m\leq 15$ 我们可以状压一下 设dp[i][s]表示已经考虑了$i$种颜色，已经染色的集合为$s$的边权之积的和 预处理出如果给集合$s$染上同一种颜色时的边权之积，以及如果给$s,t$染上不同颜色，跨过这两个集合的边的边权之积 然后就可以dp了 注意每dp一层都要算一次答案，假设当前考虑了$i$种颜色，那么此时的答案就需要乘上$k\choose i$，再乘以最开始度数为1的点的贡献 有一种特殊情况，就是如果这是一棵树，那么进行删点操作之后所有点都被删完了，此时删的第一个点对答案的贡献不是$k-1$，而是$k$。特判一下就好了 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;#define P pair&lt;int, int&gt;const int mod = 1e9 + 7;#define LL long long#define N 100010map&lt;int, P &gt; G[N]; int ind[N], n, A = 1, mark[N], k;inline void work() &#123; queue&lt;int&gt; q; for (int i = 1;i &lt;= n;i++) if (ind[i] == 1) q.push(i); while (!q.empty()) &#123; int u = q.front(), v = G[u].begin()-&gt;first; q.pop(), ind[u]--, ind[v]--, mark[u] = 1, A = (LL)A * (k - 1) % mod; G[u].erase(v), G[v].erase(u); if (ind[v] == 1) q.push(v); &#125; for (int i = 1;i &lt;= n;i++) if (ind[i] == 2) &#123; int v = G[i].begin()-&gt;first; P tmp1 = G[i].begin()-&gt;second; G[i].erase(G[i].begin()); int t = G[i].begin()-&gt;first; P tmp2 = G[i].begin()-&gt;second; G[i].clear(), mark[i] = 1, G[v].erase(i), G[t].erase(i); P tmp(((LL)(k - 1) * tmp1.second % mod * tmp2.second + (LL)tmp1.first * tmp2.first) % mod, ((LL)(k - 2) * tmp1.second % mod * tmp2.second + (LL)tmp1.first * tmp2.second + (LL)tmp1.second * tmp2.first) % mod); if (G[v].count(t) || G[t].count(v)) &#123; G[v][t].first = (LL)G[v][t].first * tmp.first % mod; G[v][t].second = (LL)G[v][t].second * tmp.second % mod, G[t][v] = G[v][t], ind[v]--, ind[t]--; &#125; else G[v][t] = G[t][v] = tmp; &#125;&#125;int id[N], ncnt, T[2][11][11], ed[11][11];inline void reMark() &#123; for (int i = 1;i &lt;= n;i++) if (!mark[i]) id[i] = ++ncnt; for (int i = 1;i &lt;= n;i++) if (!mark[i]) for (auto v : G[i]) T[0][id[i]][id[v.first]] = v.second.first, T[1][id[i]][id[v.first]] = v.second.second, ed[id[i]][id[v.first]] = 1;&#125;int dp[11][1 &lt;&lt; 11], sum[1 &lt;&lt; 11], sum2[1 &lt;&lt; 11][1 &lt;&lt; 11], frac[100010], inv[100010];inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;inline int C(int n, int r) &#123;return (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;&#125;inline int DP() &#123; if (!ncnt) return A; dp[0][0] = 1; int all = (1 &lt;&lt; ncnt) - 1; for (int i = 0;i &lt;= all;i++) &#123; sum[i] = 1; for (int j = 1;j &lt;= ncnt;j++) if (i &amp; (1 &lt;&lt; j - 1)) for (int k = j + 1;k &lt;= ncnt;k++) if (ed[j][k] &amp;&amp; (i &amp; (1 &lt;&lt; k - 1))) sum[i] = (LL)sum[i] * T[0][j][k] % mod; &#125; for (int i = 0;i &lt;= all;i++) for (int j = all - i;;j = (j - 1) &amp; (all - i)) &#123; sum2[i][j] = 1; for (int k = 1;k &lt;= ncnt;k++) if (i &amp; (1 &lt;&lt; k - 1)) for (int l = 1;l &lt;= ncnt;l++) if (ed[k][l] &amp;&amp; (j &amp; (1 &lt;&lt; l - 1))) sum2[i][j] = (LL)sum2[i][j] * T[1][k][l] % mod; if (!j) break; &#125; int res = 0; for (int col = 1;col &lt;= min(k, ncnt);col++) &#123; for (int s = 0;s &lt; all;s++) if (dp[col - 1][s]) for (int t = all - s;t;t = (t - 1) &amp; (all - s)) dp[col][s | t] = (dp[col][s | t] + (LL)dp[col - 1][s] * sum2[s][t] % mod * sum[t]) % mod; res = (res + (LL)dp[col][all] * A % mod * C(k, col)) % mod; &#125; return res;&#125;inline void adde(int a, int b) &#123;G[a][b] = G[b][a] = P(0, 1), ind[a]++, ind[b]++;&#125;int main() &#123; freopen("color.in", "r", stdin), freopen("color.out", "w", stdout); int m; scanf("%d%d%d", &amp;n, &amp;m, &amp;k), frac[0] = inv[0] = 1; for (int i = 1;i &lt;= k;i++) frac[i] = (LL)frac[i - 1] * i % mod, inv[i] = Pow(frac[i], mod - 2); for (int i = 1, a, b;i &lt;= m;i++) scanf("%d%d", &amp;a, &amp;b), adde(a, b); work(), reMark(); int res = DP(); if (m == n - 1) printf("%d\n", (LL)res * Pow(k - 1, mod - 2) % mod * k % mod); else printf("%d\n", res); return 0;&#125; T2 IOer 表示只会60分 首先我们知道，对于第$i$天，如果给这一天分配$j$道题，那么方案数为$(v+ui)^j$ 那么根据这个我们可以写出它的生成函数$$G(x)=\prod_{i=1}^m\sum_{j=0}^\infty(v+ui)^jx^j\\=\prod_{i=1}^m\frac{1}{1-(v+ui)x}$$可以利用分治NTT求出分母的积，然后多项式求逆 由于这个多项式求逆没法算到$10^{18}$项，所以此时只有40分 对于第一个点，直接pow一下 对于第二个点，答案是类似$$\sum_{i=0}^na^ib^{n-i}$$的东西，然后有$$=a^n\sum_{i=0}^n(\frac{b}{a})^{n-i}$$然后等比数列求和就好了 题解写得很详细 T3 Deadline 正睿原题！ 我们考虑这样的一种建图方式： 把任务按照类型分为2类，第一类从源点向它连边，第二类向汇点连边 然后将每天拆成两个点，中间连一条1边 将满足条件的第一类任务向这一天的入点连边，将这一天的出点向满足条件的第二类任务连边 考虑最小割 如果某一天与$S$集合不连通，那么就代表它选了体力劳动 如果某一天与$T$集合不连通，那么就代表它选了脑力劳动 先不考虑入点向出点连的边，我们发现如果每天没有任务数量限制，那么这样是对的，因为每天要么把上面的所有边割掉，要么把下面的所有边割掉 由于每天有任务数量为1的限制，那么把入点向出点连的这条边的权值设为1就好了 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;#define N 2010struct edge &#123;int to, next, w;&#125; e[N * 12];int head[N * 4], ecnt = 1;inline void adde(int from, int to, int w) &#123; e[++ecnt] = (edge)&#123;to, head[from], w&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to], 0&#125;, head[to] = ecnt;&#125;int dep[N * 4];inline bool BFS(int s, int t) &#123; memset(dep, -1, sizeof(dep)), dep[s] = 0; queue&lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u];i;i = e[i].next) if (e[i].w &amp;&amp; dep[e[i].to] == -1) &#123; dep[e[i].to] = dep[u] + 1, q.push(e[i].to); if (e[i].to == t) return true; &#125; &#125; return false;&#125;int cur[N * 4];int DFS(int u, int f, int t) &#123; if (u == t || !f) return f; int res = 0; for (int &amp;i = cur[u], tmp;i;i = e[i].next) if (e[i].w &amp;&amp; dep[u] + 1 == dep[e[i].to] &amp;&amp; (tmp = DFS(e[i].to, min(f, e[i].w), t))) &#123; res += tmp, f -= tmp, e[i].w -= tmp, e[i ^ 1].w += tmp; if (!f) break; &#125; return res;&#125;inline int Dinic(int s, int t) &#123; int res = 0; while (BFS(s, t)) memcpy(cur, head, sizeof(head)), res += DFS(s, 1e9, t); return res;&#125;int type[N];int main() &#123; freopen("deadline.in", "r", stdin), freopen("deadline.out", "w", stdout); int n, m, k, s, t; scanf("%d%d%d", &amp;n, &amp;m, &amp;k), s = m * 2 + n + 1, t = s + 1; for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;type[i]); for (int i = 1;i &lt;= n;i++) if (!type[i]) adde(s, i, 1); else adde(i, t, 1); for (int i = 1;i &lt;= m;i++) adde(i + n, i + n + m, 1); for (int i = 1;i &lt;= k;i++) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); if (!type[a]) adde(a, b + n, 1); else adde(b + n + m, a, 1); &#125; printf("%d\n", Dinic(s, t)); return 0;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>数学</tag>
        <tag>网络流</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>多项式求逆</tag>
        <tag>多项式</tag>
        <tag>NTT</tag>
        <tag>缩点</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.22省选模拟]]></title>
    <url>%2F2019%2F03%2F22%2F3-22%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 方格取数 一种可行的方法是使用random_shuffle然后模拟两人取数的过程并判断是否可行，对于玩家2，我们可以采取每次都选最大值的策略 我并不知道这样的策略是否优秀，但是这样可以获得45分的好成绩 题解给出的方法是玄学构造 T2 K君的游戏 很妙的一道题 首先我们可以设出两个dp dp[0/1][i]代表一棵有$i$个点的树，后手获胜/先手获胜的方案数 如果我们算出了其中一个，那么另一个也可以推出来 先考虑如何暴力 假设当前要算的这棵树有$n$个节点，我们要算后手获胜的方案数 我们先不管根节点，就假设它有$n$个后代 我们将这$n$个节点划分成$k$个部分，其中第$i$个部分包含$s_i$个节点，先手必胜的方案数为$a_i$ 注意这里划分出来的子树是有序的，为了避免重复计数，我们按照某种顺序将这$n$个节点排序 接下来我们就给这些子树分配编号，第一棵子树有$C_n^{s_1}$种选法，第二棵子树有$C_{n-s_1}^{s_2}$种选法，以此类推 我们只需要关注这些方案数的乘积，即$$\prod_{i=1}^kC_{n-\sum_{j=1}^{i-1}s_j}^{s_i}=\frac{n!}{\prod_{i=1}^ks_i!}$$但是这样我们仍然会重复计数，比如以下这种情况： 我们给2，3号节点分配编号，而此时${1,2}$和${2,1}$这两种方案是等价的，因为我们可以通过交换2，3这两个节点的位置变换成另一种方案 所以最后，对于一种划分方案$s_1,s_2,\cdots,s_k$，它对于最终答案的贡献是$$(\prod_{i=1}^ka_i)\frac{n!}{\prod_{i=1}^ks_i!}*\frac{1}{\prod_{i=1}^n大小为i的子树的出现次数!}$$看起来很不友好 黑科技——指数生成函数 普通生成函数解决组合问题，指数生成函数解决排列问题 对于数列${a_n}$，我们知道它的普通生成函数是$$G(x)=\sum_{i=0}^\infty a_ix^i$$相对应地，它的指数生成函数就是$$G(x)=\sum_{i=0}^\infty \frac{a_i}{i!}x^i$$一个与本题无关的性质 如果$A,B$均为指数生成函数，那么有$$\begin{align}A(x)\cdot B(x)&amp;=\sum_{i=0}^\infty\sum_{j=0}^i\frac{a_jx^j}{j!}\cdot\frac{b_{i-j}x^{i-j}}{(i-j)!}\\&amp;=\sum_{i=0}^\infty(\sum_{j=0}^i{i\choose j}a_jb_{i-j})\frac{x^i}{i!}\end{align}$$ 泰勒展开与自然对数 在计算指数型生成函数的过程中，一般都会用到泰勒展开式$$e^x=\sum_{i=0}^\infty\frac{x^i}{i!}=1+x+\frac{x^2}{2!}+\frac{x^3}{3!}+\cdots\\\ln(1+x)=\sum_{i=1}^\infty(-1)^{i-1}\frac{x^i}{i}$$先整理这两个 关于多项式$\ln$ 我们知道$$[\ln(A(x))]’=\frac{A’(x)}{A(x)}\\\int[\ln(A(x))’]=\ln(A(x))=\int\frac{A’(x)}{A(x)}$$所以可以先求出$A$的逆，然后对$A$进行求导，NTT一次，最后再多项式积分即可 我们回到这道题 设后手必胜方案数的指数生成函数为$f(x)$，先手必胜的指数生成函数为$g(x)$ 考虑如何求出这两个之间的关系 我们首先枚举划分成了多少棵子树，假设有$i$棵 这对应着$g(x)^i$ 我们考虑划分出的一个有序的集合有多少种划分方案，即我们之前想要统计的东西会被重复统计多少次 如果此时我们划分出了$n$个集合，那么答案显然是$$\frac{n!}{\prod 每种集合的个数!}$$比如划分方案$2,2$只会被统计1次，而$1,3$则会被统计两次（${1,3},{3,1}$） 其实就是一个可重排列 由于$g$是指数生成函数，因此对于$g$，有$$g(x)=\sum_{i=1}^\infty a_i\frac{x^i}{i!}$$所以此时$$f(x)的普通生成函数=\sum_{i=1}^\infty \sum_{所有的划分方案}(\prod a_i)\frac{(\sum s_i)!}{\prod s_i!}*\frac{1}{\prod 每一种大小的子树的出现次数!}x^{\sum s_i}\\g(x)^i=\sum_{所有的划分方案}\frac{\prod a_i}{\prod s_i!}*\frac{i!}{\prod 每种集合的个数!}x^{\sum s_i}$$ 如果我们单独考虑最后$f$的每个次数的系数，假如是$x^n$项的系数。那么我们会发现，它就等于对它有贡献的所有划分方案的$\sum s_i$ 由于我们需要构造的是指数生成函数，而之前求的是普通生成函数。为了将普通生成函数转化为指数生成函数，我们需要对于$x^n$项，除以$n!$ 所以此时$(\sum s_i)!$就没了 将$g(x)^i$代入上面的式子，我们可以得到$$f(x)=\sum_{i=0}^\infty\frac{g(x)^i}{i!}$$注意这里求出的$f$其实是没有考虑根节点的，对于每一种方案，根节点是唯一确定的，剩下的节点只有$n-1$个 也就是说，原来$n$个点的方案对应着现在$n+1$个点的方案 这对应着上面那个式子整体向右平移一次，即$$f(x)=\sum_{i=0}^\infty\frac{g(x)^ix}{i!}$$ 通过泰勒展开，可以得出$$\frac{f(x)}{x}=\exp(g(x))$$那么如何求出$f$呢 如果我们能找到一个关于$f,g$的方程，然后将上面的那个式子代入方程，我们就可以求出$f$ 显然，对于$n$个点，先手必胜与后手必胜对应着所有情况 而$n$个点，满足每个点的父亲编号比它大的树一共只有$(n-1)!$个（第$i$个点的父亲有$n-i$种选择） 所以$$f(x)+g(x)=\sum_{i=1}^\infty\frac{(i-1)!}{i!}x^i\\=\sum_{i=1}^\infty \frac{1}{i}x^i\\=-\ln(1-x)$$我们可以列出方程$$\begin{cases}f(x)+g(x)=-\ln(1-x)\\ \frac{f(x)}{x}=\exp(g(x))\end{cases}$$ 经过一些奇妙的并且我不会的推导，可以得出$$f(x)=\ln(1-\ln(1-x))$$然后多项式$\ln$就可以了 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;#define N 600010#define LL long longconst int mod = 998244353;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;int r[N];inline void NTT(int a[], int len, int type) &#123; for (int i = 1;i &lt; len;i++) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int mid = 2;mid &lt;= len;mid &lt;&lt;= 1) &#123; int Wn = Pow(3, type ? (mod - 1) / mid : mod - 1 - (mod - 1) / mid); for (int i = 0;i &lt; len;i += mid) for (int j = i, w = 1, t;j &lt; i + (mid &gt;&gt; 1);j++, w = (LL)w * Wn % mod) t = (LL)w * a[j + (mid &gt;&gt; 1)] % mod, a[j + (mid &gt;&gt; 1)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod; &#125; if (!type) for (int i = 0, inv = Pow(len, mod - 2);i &lt; len;i++) a[i] = (LL)a[i] * inv % mod;&#125;int tmpa[N], tmpf[N];// b(x) = 2b'(x) - a(x)b'(x) ^ 2inline void Inv(int a[], int b[], int n) &#123; if (n == 1) return void(b[0] = Pow(a[0], mod - 2)); Inv(a, b, (n + 1) &gt;&gt; 1); for (int i = 0;i &lt; n;i++) tmpa[i] = a[i]; int len = 1, l = 0; while (len &lt;= n * 3) len &lt;&lt;= 1, l++; for (int i = 1;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); for (int i = n;i &lt; len;i++) tmpa[i] = 0; NTT(tmpa, len, 1), NTT(b, len, 1); for (int i = 0;i &lt; len;i++) b[i] = (2 - (LL)tmpa[i] * b[i] % mod + mod) * b[i] % mod; NTT(b, len, 0); for (int i = n;i &lt; len;i++) b[i] = 0;&#125;inline void Ln(int a[], int res[], int len) &#123; Inv(a, res, len); for (int i = 1;i &lt;= len;i++) tmpf[i - 1] = (LL)a[i] * i % mod; int Len = 1, l = 0; while (Len &lt;= len * 2) Len &lt;&lt;= 1, l++; for (int i = 1;i &lt; Len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); for (int i = len;i &lt; Len;i++) tmpf[i] = 0; NTT(tmpf, Len, 1), NTT(res, Len, 1); for (int i = 0;i &lt; Len;i++) res[i] = (LL)res[i] * tmpf[i] % mod; NTT(res, Len, 0); for (int i = len;i &gt;= 0;i--) res[i + 1] = (LL)res[i] * Pow(i + 1, mod - 2) % mod; for (int i = len + 1;i &lt; Len;i++) res[i] = 0; res[0] = 0;&#125;int f[N], tmp[N], frac[N];int main() &#123; freopen("game.in", "r", stdin), freopen("game.out", "w", stdout); f[0] = frac[0] = 1, f[1] = mod - 1, Ln(f, tmp, 100000), tmp[0] = 1; for (int i = 1;i &lt;= 100000;i++) tmp[i] = mod - tmp[i], frac[i] = (LL)frac[i - 1] * i % mod; memset(f, 0, sizeof(f)), Ln(tmp, f, 100000); int T, n; scanf("%d", &amp;T); while (T--) scanf("%d", &amp;n), printf("%d\n", (LL)(frac[n - 1] - (LL)f[n] * frac[n] % mod + mod) * Pow(frac[n - 1], mod - 2) % mod); return 0;&#125; T3 魔法阵 这次考试最简单的一道题 考虑使用分块 对于第一种修改我们可以求出$C$数组的变化区间，然后将这个区间都覆盖成某个数 对于每一个块我们将块内的$B$从小到大排序，维护前缀积以及当前这个块的答案 考虑查询一个块当前的答案 如果这个块没有未下放的区间覆盖，那么直接返回之前求出的答案即可 否则这个块中的所有$C$一定都相等，我们可以二分出有多少个$B\leq C$，对于前面的$B$，使用前缀积，对于后面的，就是$C$的数字个数次方 然后卡一下常就好了 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010#define M 400#define LL long longconst int size = 300, mod = 1e9 + 7;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;vector&lt;int&gt; sorted[M]; int C[N], B[N], A[N], belong[N], ans[M], n, tag[M], pre[M][size + 10], mark[M];inline int Start(int block) &#123;return (block - 1) * size + 1;&#125; inline int End(int block) &#123;return min(n, block * size);&#125;inline void Rebuild(int block) &#123; int st = Start(block), ed = End(block); ans[block] = 1, sorted[block].clear(), tag[block] = 0, mark[block] = 1; for (int i = st;i &lt;= ed;i++) ans[block] = (LL)ans[block] * min(C[i], B[i]) % mod, sorted[block].push_back(B[i]), mark[block] &amp;= B[i] &lt;= C[i]; sort(sorted[block].begin(), sorted[block].end()), pre[block][0] = 1; for (int i = 0;i &lt; sorted[block].size();i++) pre[block][i + 1] = (LL)pre[block][i] * sorted[block][i] % mod;&#125;inline void Rebuild2(int block) &#123; int st = Start(block), ed = End(block); ans[block] = 1, tag[block] = 0, mark[block] = 1; for (int i = st;i &lt;= ed;i++) ans[block] = (LL)ans[block] * min(C[i], B[i]) % mod, mark[block] &amp;= B[i] &lt;= C[i];&#125;inline void Pushdown(int block) &#123; int st = Start(block), ed = End(block); if (tag[block]) for (int i = st;i &lt;= ed;i++) C[i] = tag[block]; tag[block] = 0; &#125;inline void Pre() &#123; for (int i = 1;i &lt;= n;i++) belong[i] = (i + size - 1) / size, C[i] = max(C[i - 1], A[i]); for (int i = 1;i &lt;= belong[n];i++) Rebuild(i);&#125;inline int Calc(int block) &#123;// cout &lt;&lt; "tag: " &lt;&lt; tag[block] &lt;&lt; endl; if (!tag[block]) return ans[block]; if (mark[block]) return pre[block][sorted[block].size()]; int l = 1, r = sorted[block].size(), mid, pos = 0; while (l &lt;= r) &#123; if (sorted[block][(mid = (l + r) &gt;&gt; 1) - 1] &lt; tag[block]) pos = mid, l = mid + 1; else r = mid - 1; &#125; return (LL)Pow(tag[block], sorted[block].size() - pos) * pre[block][pos] % mod;&#125;inline void update(int start, int end, int x) &#123; int st = belong[start], ed = belong[end], s = End(st), t = Start(ed); Pushdown(st), Pushdown(ed); if (st == ed) &#123; for (int i = start;i &lt;= end;i++) C[i] = x; Rebuild(st); return; &#125; for (int i = start;i &lt;= s;i++) C[i] = x; for (int i = t;i &lt;= end;i++) C[i] = x; for (int i = st + 1;i &lt; ed;i++) tag[i] = x; Rebuild2(st), Rebuild2(ed);&#125;inline void Set(int at, int x) &#123;int bl = belong[at]; Pushdown(bl), B[at] = x, Rebuild(bl);&#125;inline int query(int start, int end) &#123; int st = belong[start], ed = belong[end], s = End(st), t = Start(ed), res = 1; Pushdown(st), Pushdown(ed); if (st == ed) &#123; for (int i = start;i &lt;= end;i++) res = (LL)res * min(C[i], B[i]) % mod; Rebuild2(st); return res; &#125; for (int i = start;i &lt;= s;i++) res = (LL)res * min(C[i], B[i]) % mod; for (int i = t;i &lt;= end;i++) res = (LL)res * min(C[i], B[i]) % mod; for (int i = st + 1;i &lt; ed;i++) res = (LL)res * Calc(i) % mod; Rebuild2(st), Rebuild2(ed); return res;&#125;int tree[N];inline void upd(int x, int y) &#123;for (;x &lt;= n;x += x &amp; -x) tree[x] = max(tree[x], y);&#125;inline int que(int x) &#123; int res = 0; for (;x;x -= x &amp; -x) res = max(res, tree[x]); return res;&#125;int main() &#123;// freopen("fatal.in", "r", stdin), freopen("hh.out", "w", stdout); freopen("magic.in", "r", stdin), freopen("magic.out", "w", stdout); int q; scanf("%d%d", &amp;n, &amp;q); for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;A[i]), upd(i, A[i]); for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;B[i]); Pre(); while (q--) &#123; int op, a, b; scanf("%d%d%d", &amp;op, &amp;a, &amp;b); if (op == 0) &#123; int l = a, r = n, mid, res = 0; while (l &lt;= r) &#123; if (que(mid = (l + r) &gt;&gt; 1) &lt; b) l = mid + 1, res = mid; else r = mid - 1; &#125; upd(a, b); if(res) update(a, res, b); &#125; else Set(a, b); printf("%d\n", query(1, n)); &#125;// cerr &lt;&lt; clock() &lt;&lt; endl; return 0;&#125; 总结感觉是这几天比较正常的一次考试了 T2真的是太神仙了]]></content>
      <tags>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>数据结构</tag>
        <tag>多项式求逆</tag>
        <tag>多项式</tag>
        <tag>分块</tag>
        <tag>NTT</tag>
        <tag>构造</tag>
        <tag>多项式ln</tag>
        <tag>泰勒展开</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀自动机]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[后缀自动机是啥 简单来说，一个串$S​$的后缀自动机是一个有向无环图。这个图中的顶点被称为“状态”，点与点之间的边被称作“转移” 我们将被标号为$t_0$的点称作“初始状态”，我们能从这个状态到达后缀自动机的所有状态 一个或者多个状态被称为“终止状态”。如果我们从初始状态$t_0$出发到达任意一个终止状态，且将途中经过的所有边的字符写下来，那么我们可以得到原串$S$的一个后缀 这是串“aa”的自动机（带*的是终止状态） 这是串“aba”的自动机 这是串“abb”的自动机 这是串“abbb”的自动机 它能解决什么 一个串的本质不同的子串个数 所有不同子串的总长度 字典序第$k$小的子串 最小表示法 一个给定串的第一次出现位置 一个给定串的所有出现位置 最长公共子串 多个串的最长公共子串 最短的没有出现的字符串 后缀自动机的性质 “endpos”等价类 考虑原串$S$的一个非空子串$T$，$endpos(T)$就是$T$在$S$中的所有结束位置的集合。我们称两个子串$s_1,s_2$endpos等价当且仅当它们的结束位置完全相同，即$endpos(s_1)=endpos(s_2)$ 对于一个串“aba” $endpos(“aba”)={3}$ $endpos(“ba”)={3}$ $endpos(“a”)={1,3}$ $endpos(“ab”)={2}$ $endpos(“b”)={2}$ $endpos(“”)={0,1,2,3}$ 在这个串中，“ab”和“b”以及“aba”和“ba”是endpos等价的 在我们最终构造的后缀自动机中，endpos类的个数等于节点个数，也就是说，一个节点代表一个endpos等价类。在这个例子中，节点的数量等于4 引理1. 如果字符串$u​$仅以$v​$的一个后缀的形式出现在字符串$s​$中时，$u​$和$v​$是endpos等价的 显然，如果$u$和$v$的endpos等价，那么$u$是$v$的一个后缀。当$u$仅以$v$的后缀在$s$中出现时，两个子串的endpos等价 引理2. 考虑两个$s$的非空子串$u$和$v\ (|s|\leq|v|)$，要么$endpos(s)$与$endpos(v)$没有交集，要么$endpos(s)$是$endpos(v)$的子集。这依赖于$u$是否是$v$的一个后缀$$\begin{cases}endpos(u)\subseteq endpos(v)&amp;\text{if }u\ -\ \text{suffix}\ v,\\ endpos(u)\cap endpos(v)=\emptyset&amp;\text{otherwise.}\end{cases}$$ 证明是显然的，另一个重要的定理是，如果把一个endpos等价类的所有子串按照长度排序，那么相邻两个一定只差1 我们记排序之后的长度区间为$[minlen(u),len(u)]$，$len(u)$为在这个endpos等价类中长度最长的子串的长度，$minlen(u)​$为最短的子串的长度 考虑上面的例子中的一个等价类${“ab”,”b”}$，则有$len(u)=2,minlen(u)=1$ 后缀连接link 考虑后缀自动机中满足$u\not=t_0$的一些状态。我们知道$u$对应着一个endpos等价类。如果我们记这个类中最长的串为$w$，那么其它的串都是$w$的后缀 我们已经知道$w$的最长的一些后缀已经被包含在状态$u$里面了，而另一些则没有被包含。如果我们记这些没有被包含的后缀中最长的那个串所在的状态为$t$，那么$u$将使用后缀连接链接到$t$上 这告诉我们两个性质$$1.\ minlen(u)=len(link(u))+1\\2.\ endpos(u)\subset endpos(link(u))$$我们规定$endpos(t_0)={0,1,2,\cdots,|s|}$ 在我们的例子中，节点$u={“aba”,”ba”}$的后缀连接为$t={“a”}$ 引理3. 所有的后缀连接构成一棵根节点为$t_0$的树 考虑任意$u\not=t_0$的状态，如果我们沿着它的后缀连接走，每次走到的一定是一个$len$严格小于它的状态，最后一定会走到$t_0$ 引理4. 如果我们使用$endpos$集合构造一棵树（子节点为父亲节点的子集），那么这棵树由后缀连接链接起来 由引理2，我们可以通过$endpos$集合构造一棵树，因为两个集合要么包含，要么没有交集 现在考虑任意满足$u\not=t_0$的状态和它的后缀连接$link(u)$，根据后缀连接的定义以及引理2，我们可以得出$$endpos(u)\subset endpos(link(u))$$这表明，后缀连接构成的树本质上就是$endpos$集合构成的树 串“abcbc”构成的后缀自动机以及它的后缀连接 在线性时间内构造后缀自动机 构造后缀自动机的算法是在线的，并且使用增量法，即每次添加一个字符 每个状态我们需要保存两个值($len, link$) 作为初始化，一开始自动机内只有一个状态$t_0$，我们给它标记为0，并且有len = 0, link = -1 定义$last$为之前所添加的最后一个字符所在的状态对应的下标，作为初始化，last = 0 考虑加入字符$c$，创建一个新的状态$cur$，并将$len(cur)$赋值为$len(last)+1$，然后我们会进行下面所描述的循环 到了此时我们已经新建了一个状态并且初始化了，但是还没有将其添加到自动机上。运行一个循环，最开始我们处于$last$，如果这个状态没有$c$这个转移，我们就添加这样一个转移并使其指向$cur$，然后我们会从当前节点跳向它的后缀连接，直到到达$t_0$状态或者我们遇到了一个有$c$转移的点 如果我们停在了一个有$c$转移的点，我们将其标记为$p$，记$p$经过转移$c$到达的状态为$q$。那么此时有两种情况，取决于$len(p)=len(q)+1$是否成立 如果$len(p)=len(q)+1$，我们就将$cur$的后缀连接指向$q$，然后停止这个过程 否则我们必须新建$q$的一个复制状态，它的所有属性都与$q$相同，除了$len(clone)=len(p)+1$，然后将$q$与$cur$的后缀连接都指向$clone$，$p$的所有祖先中通过字符$c$转移至$q$的转移都要被重定向至$clone$ 如果我们没有在中途停下，那么我们就让$cur$的后缀连接指向0，即$t_0$ 为什么这样是正确的我们假设还没有加入$c$时，最长的串为$s$ 考虑加入$c$的时候，我们会多出一些后缀 在$last$不停网上跳的过程中，如果没有$c$这个转移，显然我们需要添加一个转移，这对应着一个新的后缀 如果我们遇到了$c$这个转移，比如以下这种情况 其中，节点$ab$的转移$d$是在添加字符$d$之前就有的 如果有$len(ab)+1=len(q)$，这意味着能走到$q$中的串只有节点$ab$所代表的串连接上$d$ 因为$ab$中的串能到达$q$，这意味着$q$中的串一定包含$d$格式的串，其中是$ab​$所代表的串 如果没有这个条件，那么其它以$ab$为后缀的串也可以转移到$q$，$q$就可以表示类似$zjkabd$这样的奇怪的串，而这样的串是$ab$所不能转移的，$q$也不是$abcd$的某个后缀，不能成为$abcd$的后缀连接 所以解决方法就是将转移到$q$的串分为两类，一类是一定为$abcd$的后缀的串，一类是其它奇怪的串 以$abcd$为后缀的串就是$ab$的所有祖先经过$d$的转移。如果这个转移走到了$q$，显然我们需要重定向至分出来的那个节点 此时这个节点就满足$len(clone)=len(p)+1$，可以成为$abcd$的后缀连接 显然，这个复制出来的节点的endpos集合包含$q$，因为多了$abcd$这个串，所以我们也需要将$q$的后缀连接指向复制节点 时间复杂度的证明不会，告辞 代码实现123456789101112131415161718192021222324252627282930313233343536373839struct state &#123; int len, link; map&lt;char,int&gt;next;&#125;; const int MAXLEN = 100000;state st[MAXLEN*2];int sz, last; void sa_init() &#123; sz = last = 0; st[0].len = 0; st[0].link = -1; ++sz;&#125; void sa_extend (char c) &#123; int cur = sz++; st[cur].len = st[last].len + 1; int p; for (p=last; p!=-1 &amp;&amp; !st[p].next.count(c); p=st[p].link) st[p].next[c] = cur; if (p == -1) st[cur].link = 0; else &#123; int q = st[p].next[c]; if (st[p].len + 1 == st[q].len) st[cur].link = q; else &#123; int clone = sz++; st[clone].len = st[p].len + 1; st[clone].next = st[q].next; st[clone].link = st[q].link; for (; p!=-1 &amp;&amp; st[p].next[c]==q; p=st[p].link) st[p].next[c] = clone; st[q].link = st[cur].link = clone; &#125; &#125; last = cur;&#125;]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>算法</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.20省选模拟]]></title>
    <url>%2F2019%2F03%2F21%2F3-20%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 全连 5分钟题目 dp[i][j]表示前$i$个音符，最后一个在$j$位置的最大收益 显然这个dp是可以用数据结构加速的 对于每个音符，查询$j$位于$[1,i-t_i]$的dp最大值 然后在位置$i+t_i$再把这个dp值放进树状数组，这样就保证了接下来点的时刻一定在$i+t_i$之后 这里用一个vector存一下待更新的答案即可 代码如下 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1000010using LL = long long;LL tree[N]; int n;inline void update(int x, LL y) &#123;for (;x &lt;= n + 1;x += x &amp; -x) tree[x] = max(tree[x], y);&#125;inline LL query(int x) &#123; LL res = 0; for (;x &gt; 0;x -= x &amp; -x) res = max(res, tree[x]); return res;&#125;#define P pair&lt;int, LL&gt;LL w[N]; int t[N], __rd; vector&lt;P &gt; q[N];template&lt;class T&gt; inline void read(T &amp;x) &#123; x = 0; char c = getchar(); while (c &lt; '0' || c &gt; '9') c = getchar(); while ('0' &lt;= c &amp;&amp; c &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - '0', c = getchar();&#125;#define RD (read(__rd), __rd)int main() &#123; freopen("fc.in", "r", stdin), freopen("fc.out", "w", stdout); n = RD; LL res = 0, tmp = 0; for (int i = 1;i &lt;= n;i++) t[i] = RD; for (int i = 1;i &lt;= n;i++) w[i] = RD, w[i] *= t[i]; for (int i = 1;i &lt;= n;i++) &#123; for (int j = 0;j &lt; q[i].size();j++) update(q[i][j].first, q[i][j].second); tmp = query(i - t[i]) + w[i], q[min(n + 1, i + t[i])].push_back(P(i, tmp)), res = max(res, tmp); &#125; printf("%lld\n", res); return 0;&#125; T2 原样输入 如果只有一个串，那么就是统计不同子串数量，显然后缀数组/后缀自动机都可以 但是这里有多个串，而且最后会忽略空行 我们考虑什么时候会重复 假设当前有两个串$aab,ab$ 我们在第一个串选择了$aa$，在第二个串选择了$b$ 此时得到的串是$aab$，我们发现这与第一个串的子串相同，它被重复统计了 所以，假设上一次取的是$i$串，这一次取的是$j$串，那么这两次取的串拼起来一定不是$i$串的子串 意思就是贪心地选，如果当前还可以向下转移某个字符就一定不要到另一个串去转移这个字符 还有一种情况 假设有三个串$a,b,b$ 那么取前两个串与取第一个与第三个串是等价的 所以我们使用类似子序列自动机的做法，设$next[i][j]$表示$i$串之后，第一个可以转移$j$字符的串 然后dfs的时候每次跳next就可以了 这个题的评测特别奇怪 输出长达200Mb，但是输出这么多会导致OLE 不知道出题人在想什么，感觉第二问完全没用 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1000010int cnt = 0;inline int id(char c) &#123; if (c == 'A') return 0; if (c == 'C') return 1; if (c == 'G') return 2; return 3;&#125;inline char rid(int c) &#123; if (c == 0) return 'A'; if (c == 1) return 'C'; if (c == 2) return 'G'; return 'T';&#125;#define CLR(x) memset(x, 0, sizeof x)struct SAM &#123; struct node &#123; int at, link, len, next[4]; node(int _at) : at(_at), link(0), len(0) &#123;CLR(next);&#125; &#125;; vector&lt;node&gt; T; int size, last; inline void init() &#123; node start(++cnt); start.len = size = last = 0, start.link = -1; T.push_back(start); &#125; inline void insert(char c) &#123; int cur = ++size, s = id(c), p; T.push_back(node(++cnt)); T[cur].len = T[last].len + 1; for (p = last;~p &amp;&amp; !T[p].next[s];p = T[p].link) T[p].next[s] = cur; if (p != -1) &#123; int q = T[p].next[s]; if (T[p].len + 1 == T[q].len) T[cur].link = q; else &#123; int clone = ++size; T.push_back(node(++cnt)); T[clone].link = T[q].link, memcpy(T[clone].next, T[q].next, sizeof(T[q].next)), T[clone].len = T[p].len + 1, T[cur].link = T[q].link = clone; while (p != -1 &amp;&amp; T[p].next[s] == q) &#123; T[p].next[s] = clone; p = T[p].link; &#125; &#125; &#125; last = cur; &#125; &#125; S[N];const int mod = 1e9 + 7;inline void Inc(int &amp;x, int y) &#123;x += y, x -= x &gt;= mod ? mod : 0;&#125;int dp[N * 2], n; const char NX[4] = &#123;'A', 'C', 'G', 'T'&#125;; int Next[N][4];int dfs(int now, int cur) &#123; if (~dp[S[now].T[cur].at]) return dp[S[now].T[cur].at]; int &amp;sum = dp[S[now].T[cur].at] = 1; for (int t = 0;t &lt; 4;t++) &#123; if (S[now].T[cur].next[t]) Inc(sum, dfs(now, S[now].T[cur].next[t])); else if (Next[now][t]) Inc(sum, dfs(Next[now][t], S[Next[now][t]].T[0].next[t])); &#125; return sum;&#125;int res = 0, top = 0; char str[N];void dfs2(int now, int cur) &#123; res++, str[top] = '\0', printf("%s\n", str); for (int t = 0;t &lt; 4;t++) &#123; top++, str[top - 1] = rid(t); if (S[now].T[cur].next[t]) dfs2(now, S[now].T[cur].next[t]); else if (Next[now][t]) dfs2(Next[now][t], S[Next[now][t]].T[0].next[t]); top--; &#125;&#125;char input[N];int main() &#123; freopen("copy.in", "r", stdin), freopen("copy.out", "w", stdout); scanf("%d", &amp;n), S[0].init(), memset(dp, -1, sizeof(dp)); for (int i = 1;i &lt;= n;i++) &#123; scanf("%s", input + 1), S[i].init(); int m = strlen(input + 1); for (int j = 1;j &lt;= m;j++) S[i].insert(input[j]); &#125; int del[4]; CLR(del); for (int i = n;i &gt;= 0;i--) &#123; memcpy(Next[i], del, sizeof(del)); for (int j = 0;j &lt; 4;j++) if (S[i].T[0].next[j]) del[j] = i; &#125; int k; scanf("%d", &amp;k); if (!k) printf("%d\n", dfs(0, 0)); else dfs2(0, 0), printf("%d\n", res);&#125; T3 不同的缩写 题意就是给出$n$个人的名字，对于每个人我们都要使用它的一个子序列去代表他，子序列不能有相同的，输出方案 首先我们可以二分出最小长度 然后判断是否满足似乎可以二分图匹配 具体来说就是原串放在左边，子序列放在右边，然后中间根据是否是这个串的子序列连边 但是我们发现这样的话右边最多有$2^n$个点，显然不行 那么我们考虑一个定理 如果二分图的两边的所有点的度数都不小于$n$，那么一定存在完美匹配 那么对于每个串我们跑出它的前$n$短的子序列，然后暴力连边 这样就只有$n^2$个点了 关于判断是否是某个串的子序列，仍然可以使用子序列自动机 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdc++.h&gt;using namespace std;#define N 310#pragma GCC optimize(2)struct edge &#123; int to, next, w;&#125; e[N * N * N / 2];int head[N * N], ecnt = 1, dep[N * N], cur[N * N];inline void adde(int from, int to, int w) &#123; e[++ecnt] = (edge)&#123;to, head[from], w&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to], 0&#125;, head[to] = ecnt;&#125;inline bool BFS(int s, int t) &#123; queue&lt;int&gt; q; q.push(s), memset(dep, -1, sizeof(dep)), dep[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u];i;i = e[i].next) if (e[i].w &amp;&amp; dep[e[i].to] == -1) &#123; dep[e[i].to] = dep[u] + 1, q.push(e[i].to); if (e[i].to == t) return true; &#125; &#125; return false;&#125;inline int DFS(int u, int f, int t) &#123; if (!f || u == t) return f; int res = 0; for (int &amp;i = cur[u], tmp;i;i = e[i].next) if (e[i].w &amp;&amp; dep[e[i].to] == dep[u] + 1 &amp;&amp; (tmp = DFS(e[i].to, min(f, e[i].w), t))) &#123; e[i].w -= tmp, e[i ^ 1].w += tmp, res += tmp, f -= tmp; if (!f) break; &#125; return res;&#125;inline int Dinic(int s, int t) &#123; int res = 0; while (BFS(s, t)) memcpy(cur, head, sizeof(head)), res += DFS(s, 1e9, t); return res;&#125;#define LL unsigned long longconst LL P = 29; set&lt;LL&gt; s;char base[N][N]; int nxt[26][N][N], mid, cnt, n, ncnt, S, T, len[N]; LL del;inline bool check(int cur, const string &amp;cc) &#123; int now = 0; for (int i = 0;i &lt; cc.size() &amp;&amp; now != -1;i++) now = nxt[cc[i] - 'a'][cur][now]; return now != -1;&#125;struct data &#123; string v; LL hash; int pos; data() : v(""), hash(0), pos(0) &#123;&#125;&#125;;string ans[N * N];inline void bfs(int now) &#123; queue&lt;data&gt; q; q.push(data()); while (!q.empty()) &#123; data u = q.front(); q.pop(); if (u.hash) cnt++; if (u.hash &amp;&amp; !s.count(u.hash)) ncnt++, adde(ncnt, T, 1), ans[ncnt] = u.v, s.insert(u.hash); if (cnt &gt;= n) return; for (int i = 0;i &lt; 26;i++) if (~nxt[i][now][u.pos]) &#123; int t = nxt[i][now][u.pos]; LL hash = u.hash * P + i + 1; data b; b.v = u.v + char(i + 'a'), b.hash = hash, b.pos = t, q.push(b); &#125; &#125;&#125;int ttt[26];inline void Pre(int now) &#123; int cur = len[now]; memset(ttt, -1, sizeof(ttt)); for (int i = cur;i &gt;= 0;i--) &#123; for (int j = 0;j &lt; 26;j++) nxt[j][now][i] = ttt[j]; if (i) ttt[base[now][i] - 'a'] = i; &#125;&#125;#define RG registerinline bool solve(int m) &#123; ecnt = 1, memset(head, 0, sizeof(head)); for (int i = 1;i &lt;= n;i++) adde(S, i, 1); for (RG int i = n + 3;i &lt;= ncnt;++i) if (ans[i].size() &lt;= m) &#123; adde(i, T, 1); for (RG int j = 1;j &lt;= n;++j) if (check(j, ans[i])) adde(j, i, 1); &#125; return Dinic(S, T) == n;&#125; string last[N];inline void solve2(int m) &#123; ecnt = 1, memset(head, 0, sizeof(head)); for (int i = 1;i &lt;= n;i++) adde(S, i, 1); for (int i = n + 3;i &lt;= ncnt;i++) if (ans[i].size() &lt;= m) &#123; adde(i, T, 1); for (int j = 1;j &lt;= n;j++) if (check(j, ans[i])) adde(j, i, 1); &#125; Dinic(S, T); for (int i = 1;i &lt;= n;i++) for (int j = head[i];j;j = e[j].next) if (n + 3 &lt;= e[j].to &amp;&amp; !e[j].w) last[i] = ans[e[j].to]; for (int i = 1;i &lt;= n;i++) cout &lt;&lt; last[i] &lt;&lt; endl;&#125;int main() &#123; freopen("diff.in", "r", stdin), freopen("diff.out", "w", stdout); scanf("%d", &amp;n); int mx = 0; for (int i = 1;i &lt;= n;i++) scanf("%s", base[i] + 1), len[i] = strlen(base[i] + 1), mx = max(mx, len[i]); for (int i = 1;i &lt;= n;i++) Pre(i); ncnt = n + 2, S = n + 1, T = n + 2; for (int i = 1;i &lt;= n;i++) cnt = 0, bfs(i); int l = 1, r = mx, ans = -1; while (l &lt;= r) &#123; if (solve(mid = (l + r) &gt;&gt; 1)) r = mid - 1, ans = mid; else l = mid + 1; &#125; printf("%d\n", ans); if (~ans) solve2(ans); cerr &lt;&lt; clock() &lt;&lt; endl; return 0;&#125; 总结Dev千万不要打开-std=c++11 防止CE]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>网络流</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
        <tag>二分答案</tag>
        <tag>字符串</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.18省选模拟]]></title>
    <url>%2F2019%2F03%2F19%2F3-18%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 One?One! 不会啊。。先贴上题解吧 T2 Two?Two! 首先考虑dp 假设现在已经排了前$i$个人，我们知道这两个队中有一个对的最大值一定是$M_i$，即前$i$个人的最大值 那么我们可以设dp[i][j]表示已经排好了$i$个人，其中$M_i$不在的那一队的最大值为$j$的答案 我们考虑一下几种情况： $M_i=x_i$ 显然，将$i$排到$M_{i-1}$那一队会更优秀 即对于任意的$j$，dp[i][j] = dp[i - 1][j] $x_i&lt;M_i,j\in[0,x_i)$ 排完了$i​$这个人之后仍然有一队的最大值小于$x_i​$，那么$i​$一定排到了最大值更大的那一边，即$M_{i-1}​$，也是$M_i$ 此时有dp[i][j] = dp[i - 1][j] + M[i] - x[i] $x_i&lt;M_i,j=x_i​$ 排完了$i$这个人之后，最大值不在的那一对的最大值就咕了 那么我们可以知道，这一队之前的最大值一定是$\leq x_i​$的 所以有dp[i][j] = min{dp[i - 1][k]}(k &lt;= j) $x_i&lt;M_i,j\in(x_i,M_i]$ 那么此时把$i$排到$j$那一队肯定更优秀 所以dp[i][j] = dp[i - 1][j] + j - x[i] 但是这样dp是$n^2$的，需要优化 我们考虑进行了哪些操作 第一种情况：什么都没做 第二种情况：区间加常数 第三种情况：区间取最小值，单点覆盖 第四种情况：区间加常数，区间加一次函数 这个区间加一次函数与区间最小值在一起好像有点不好维护 题解是splay，但我只会75分分块 考虑如何块内维护 我们在每个块都维护一个下凸壳，由于我们加的一次函数是单调递增的，所以只有下凸壳上的顶点才有可能成为最小值 由于某些操作没有下放，这导致询问的时候我们需要考虑这部分没有下放的标记 我们令一个块中的tag1为自变量 那么可以根据这个进行斜率优化，因为在更新时这个标记是不降的 所以我们维护凸包 每次查询的时候把最开始没用的直线pop掉就可以了 考虑时间复杂度 区间加常数时凸包不会改变 单点覆盖时最多加一个点 而凸包上的每个点只会进来一次，弹出一次 所以总时间复杂度$O(n\log n)$ 需要离散化 不知道出了什么问题的代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010#define M 1000#define LL long longconst int size = 120;int tag1[M], belong[N], to[N], n; LL f[N], tag2[M];deque&lt;int&gt; d[M];inline LL Get(int x) &#123; int bl = belong[x]; return f[x] + (LL)tag1[bl] * to[x] + tag2[bl];&#125;inline int Start(int block) &#123;return (block - 1) * size + 1;&#125;inline int End(int block) &#123;return min(n, block * size);&#125;inline void Pushdown(int block) &#123; if (tag1[block] == 0 &amp;&amp; tag2[block] == 0) return; int st = Start(block), ed = End(block); for (int i = st;i &lt;= ed;i++) f[i] = Get(i); tag1[block] = tag2[block] = 0;&#125;inline bool Calc(int a, int b, int c) &#123; return (LL)f[b] - f[a] &lt;= c * (a - b);&#125;inline void Rebuild(int block) &#123; int st = Start(block), ed = End(block); d[block].clear(); for (int i = ed;i &gt;= st;i--) &#123; while (d[block].size() &amp;&amp; f[*d[block].rbegin()] &gt;= f[i]) d[block].pop_back(); d[block].push_back(i); &#125;&#125;inline void Pre() &#123; for (int i = 2;i &lt;= n;i++) f[i] = 1e15; for (int i = 1;i &lt;= n;i++) belong[i] = (i + size - 1) / size; for (int i = 1;i &lt;= belong[n];i++) Rebuild(i);&#125;inline LL Min(int block) &#123; int x = tag1[block]; while (d[block].size() &gt;= 2 &amp;&amp; Calc(d[block][0], d[block][1], x)) d[block].pop_front(); return Get(d[block][0]);&#125;inline void UPD(int start, int end, int type, int x) &#123; for (int i = start;i &lt;= end;i++) if (type == 1) f[i] += x; else if (type == 2) f[i] += to[i];&#125;inline void update(int start, int end, int type, int x) &#123; if (start &gt; end) return; int st = belong[start], ed = belong[end], s = End(st), t = Start(ed); Pushdown(st), Pushdown(ed); if (st == ed) &#123;UPD(start, end, type, x), Rebuild(st); return;&#125; UPD(start, s, type, x), UPD(t, end, type, x), Rebuild(st), Rebuild(ed); for (int i = st + 1;i &lt; ed;i++) if (type == 1) tag2[i] += x; else if (type == 2) tag1[i]++;&#125;inline void Set(int at, LL x) &#123; int bl = belong[at]; Pushdown(bl), f[at] = x, Rebuild(bl);&#125;inline LL query(int start, int end) &#123; int st = belong[start], ed = belong[end], s = End(st), t = Start(ed); LL res = 1e18; if (st == ed) &#123; for (int i = start;i &lt;= end;i++) res = min(res, Get(i)); return res; &#125; for (int i = start;i &lt;= s;i++) res = min(res, Get(i)); for (int i = t;i &lt;= end;i++) res = min(res, Get(i)); for (int i = st + 1;i &lt; ed;i++) res = min(res, Min(i)); return res;&#125;int num[N];int main() &#123;// freopen("two.in", "r", stdin), freopen("two.out", "w", stdout); int _n; scanf("%d", &amp;_n); for (int i = 1;i &lt;= _n;i++) scanf("%d", &amp;num[i]), to[i] = num[i]; sort(to + 1, to + _n + 1), n = unique(to + 1, to + _n + 1) - to - 1, Pre(); for (int i = 1;i &lt;= _n;i++) num[i] = lower_bound(to + 1, to + n, num[i]) - to; for (int i = 2, mx = num[1];i &lt;= _n;i++) &#123; if (mx &lt;= num[i]) &#123;mx = num[i]; continue;&#125; Set(num[i], query(1, num[i])); update(1, num[i] - 1, 1, to[mx] - to[num[i]]), update(num[i] + 1, mx, 2, 0), update(num[i] + 1, mx, 1, -to[num[i]]); &#125; printf("%lld\n", query(1, n)); return 0;&#125; T3 More?More! 很奇妙的一道题，有两种方法 ZJK的做法考虑将每个选手选或不选转化成一个01串，那么对于一个有$i$位是1的01串，我们设$a$表示01对的数量，$b$表示10对的数量 那么显然有$$p(该集合满足条件)=(1-p)^ap^b$$注意到$b$是可以被$a$表示的，有$$b=\frac{n(n-1)}{2}-a$$所以上面的式子$$=(1-p)^ap^{\frac{n(n-1)}{2}-a}\\=(\frac{1-p}{p})^ap^\frac{n(n+1)}{2}$$我们需要求出所有有$i$位是1的01串合法的概率之和，而这些串的$n$都是固定的 所以可以把$p^\frac{n(n-1)}{2}$提出来 所以我们实际上要求的是$$\sum_{s有i位是1}(\frac{1-p}{p})^{a_s}$$考虑$a_s$如何计算 我们采用总数减去多余情况的方法 那么对于每一个1的位置，前面的每一个位置都有机会和它构成01串，此时答案为所有1的下标之和 但是我们发现有些地方是构不成01串的，比如选了两个1 所以还需要减去$\frac{i(i+1)}{2}$(包含了两次都选同一个位置的情况) 所以$$a_s=\sum 1的下标-\frac{i(i+1)}{2}$$我们发现，对于所有有$i$位是1的集合，后面那个东西也是不变的，可以提出来 所以最终我们需要得到的是$$\sum_{s有i位是1}(\frac{1-p}{p})^{所有1的下标之和}$$考虑构造生成函数 显然它的生成函数是$$G(x)=\prod_{i=1}^n(1+(\frac{1-p}{p})^ix)$$含义是，枚举每一个位置是不是1 如果不是1，那么对应括号中的1 否则，当前答案就会乘上$(\frac{1-p}{p})^i$，$i$即当前位的下标 最后答案就是$x^i$项的系数 可以使用分治NTT 标程的做法先考虑朴素的dp dp[i][j]表示有$i$个人，选了$j$个人并且合法的概率 那么有两种思路 当前添加的那个人的编号大于所有人的编号 此时显然有dp[i][j] = dp[i - 1][j] * p ^ j + dp[i - 1][j - 1] * (1 - p) ^ (i - j + 1) 当前添加的那个人的编号小于所有人的编号 有dp[i][j] = dp[i - 1][j] * (1 - p) ^ j + dp[i - 1][j - 1] * p ^ (i - j + 1) 根据dp的定义，我们可以得出：这两个转移一定是等价的！ 所以有$$dp_{i,j}*p^j+dp_{i,j-1}*p^{i-j+1}=dp_{i,j}*(1-p)^{j}+dp_{i,j-1}*p^{i-j+1}$$移项，可以得出$$dp_{i,j}(p^j-(1-p)^j)=dp_{i,j-1}((1-p)^{i-j+1}-p^{i-j+1})$$然后扫一遍就可以了 注意对于$p=\frac 12$需要特判 代码如下 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;int dp[2010][2010], frac[1000010], inv[1000010];#define LL long longconst int mod = 998244353;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;inline int C(int n, int r) &#123; return (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;&#125;#define RG registerint main() &#123; freopen("more.in", "r", stdin), freopen("more.out", "w", stdout); dp[1][1] = dp[1][0] = 1; int n, p; scanf("%d%d", &amp;n, &amp;p); if (p == (mod + 1) / 2) &#123; frac[0] = inv[0] = 1; for (RG int i = 1;i &lt;= n;++i) frac[i] = (LL)frac[i - 1] * i % mod, inv[i] = Pow(frac[i], mod - 2); for (int i = 1;i &lt; n;i++) &#123; printf("%lld ", (LL)C(n, i) * Pow(Pow(p, n - i), i) % mod); &#125; &#125; else &#123; for (int i = 2;i &lt;= n;i++) for (int j = 0;j &lt;= i;j++) dp[i][j] = ((LL)dp[i - 1][j] * Pow(p, j) + (j ? (LL)dp[i - 1][j - 1] * Pow(mod + 1 - p, i - j) : 0)) % mod; for (int i = 1;i &lt; n;i++) cout &lt;&lt; dp[n][i] &lt;&lt; ' '; &#125;&#125; 总结关于总结，它不见了]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>数据结构</tag>
        <tag>多项式</tag>
        <tag>分块</tag>
        <tag>平衡树</tag>
        <tag>NTT</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.16省选模拟]]></title>
    <url>%2F2019%2F03%2F17%2F3-16%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 计算 比较简单的一道题 考虑将这个式子拆开 注意到这个幂是可以拆分的，即$a^b*a^c=a^{b+c}$ 而$\sum\sum ab=\sum a\sum b$ 如果将这个式子一位一位地拆分，假设$k$的第一位是$x$，有$m$位，那么有$$\sum_k e^{\frac kn}=\sum_xe^\frac{x*10^m}{n}\sum_{k去除第一位}e^{\frac kn}$$直接数位dp就可以了，注意需要特判$m=0$时的前导0的情况 对于“不含$m$这个子串”这个条件，可以先用KMP求出next数组，再处理合法的转移 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;#define double long doubleint ndig[101], mdig[101], Pow10[101], nxt[101][101], ndep, n;double dp[101][101][3][3];inline int get_digit(int digit[], int n) &#123; if (n == 0) &#123;digit[1] = 0; return 1;&#125; int res = 0; while (n) digit[++res] = n % 10, n /= 10; reverse(digit + 1, digit + res + 1); return res;&#125;double DP(int dep, int cur, int flag, int lead) &#123; if (dep == 0) return 1; if (dp[dep][cur][flag][lead] != -1) return dp[dep][cur][flag][lead]; double &amp;sum = dp[dep][cur][flag][lead]; sum = 0; int R = !flag ? 9 : ndig[ndep - dep + 1]; for (int i = 0;i &lt;= R;i++) if (nxt[cur][i] != -1 || (mdig[1] == 0 &amp;&amp; lead &amp;&amp; !i)) &#123; int nflag = flag &amp;&amp; i == R, nlead = lead &amp;&amp; !i; sum += exp(i * Pow10[dep - 1] / (double)n) * DP(dep - 1, ~nxt[cur][i] ? nxt[cur][i] : 0, nflag, nlead); &#125; return sum;&#125;int Nxt[101];inline void KMP(int n) &#123; for (int i = 2;i &lt;= n;i++) &#123; int t = Nxt[i - 1]; while (t &amp;&amp; mdig[i] != mdig[t + 1]) t = Nxt[t]; if (mdig[t + 1] == mdig[i]) t++; Nxt[i] = t; &#125;&#125;int main() &#123; int m; scanf("%d%d", &amp;n, &amp;m), Pow10[0] = 1; for (int i = 1;i &lt;= 9;i++) Pow10[i] = Pow10[i - 1] * 10; int dep = get_digit(ndig, n), mdep = get_digit(mdig, m); KMP(mdep), ndep = dep; for (int i = 0;i &lt; mdep;i++) &#123; for (int j = 0;j &lt;= 9;j++) &#123; int tmp = i; while (tmp &amp;&amp; mdig[tmp + 1] != j) tmp = Nxt[tmp]; nxt[i][j] = mdig[tmp + 1] == j ? tmp + 1 : tmp; if (nxt[i][j] == mdep) nxt[i][j] = -1; &#125; &#125; for (int i = 0;i &lt;= 10;i++) for (int j = 0;j &lt;= 10;j++) for (int k = 0;k &lt; 2;k++) dp[i][j][k][0] = dp[i][j][k][1] = -1; printf("%.3Lf\n", DP(dep, 0, 1, 1) - 1);&#125; T2 移动 很经典的一道题，可以参考环形均分纸牌问题 我们假设位置$i$向右传递了$x_i$，其原来的值为$c_i$ 那么有$$c_1+x_n-x_1=1\\c_2+x_1-x_2=1\\\Rightarrow c_2-1+c_1-1+x_n=x_2\\c_3-1+c_2-1+c_1-1+x_n=x_3\\ans=\sum_{i=1}^n|x_i|=\sum_{i=1}^n|\sum_{j=1}^i(c_j-1)+x_n|\\=\sum_{i=1}^n|x_n-\sum_{j=1}^i(1-c_j)|$$如果要让$ans$尽量小，那么就要让后面那个数尽量小 我们设$s_n=\sum\limits_{i=1}^n(1-c_i)$ 所以$x_n$取到$s$的中位数时最优秀 代码如下 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1000010int num[N], tmp[N];#define LL long longint main() &#123; int n; scanf("%d", &amp;n); for (int i = 1;i &lt;= n;i++) num[i] = 1; for (int i = 1, a;i &lt;= n;i++) scanf("%d", &amp;a), num[a]--; for (int i = 1;i &lt;= n;i++) num[i] += num[i - 1]; sort(num + 1, num + n + 1); int middle = num[(n + 1) / 2]; LL res = 0; for (int i = 1;i &lt;= n;i++) res += abs(num[i] - middle); printf("%lld\n", res); return 0;&#125; 另外，dinic费用流可以拿50分 将SPFA部分改一下，改成从汇点开始跑费用最短路 然后将普通最大流的层级图改成最短路图即可 注意dfs的时候还要记录一个vis数组，每个点只能经过一次 可以多路增广 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;#define N 30010#define M 120010struct edge &#123; int to, next, w, c;&#125; e[M];#define LL long longint head[N], ecnt = 1, vis[N], cur[N]; LL dis[N];inline void adde(int from, int to, int f, int c) &#123; e[++ecnt] = (edge)&#123;to, head[from], f, c&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to], 0, -c&#125;, head[to] = ecnt;&#125;inline bool SPFA(int s, int t) &#123; memset(vis, 0, sizeof(vis)), memset(dis, 0x3f, sizeof(dis)), dis[t] = 0, vis[t] = 1; deque&lt;int&gt; q; q.push_back(t); while (!q.empty()) &#123; int u = q.front(); q.pop_front(), vis[u] = 0; for (int i = head[u];i;i = e[i].next) if (e[i ^ 1].w &amp;&amp; dis[e[i].to] &gt; dis[u] - e[i].c) &#123; dis[e[i].to] = dis[u] - e[i].c; if (!vis[e[i].to]) &#123; vis[e[i].to] = 1; if (!q.empty() &amp;&amp; dis[e[i].to] &lt; dis[q.front()]) q.push_front(e[i].to); else q.push_back(e[i].to); &#125; &#125; &#125; return dis[s] &lt; 1e17;&#125;LL MCMF;int DFS(int u, int f, int t) &#123; vis[u] = 1; int res = 0; if (u == t || !f) return f; for (int &amp;i = cur[u], tmp;i;i = e[i].next) if (!vis[e[i].to] &amp;&amp; e[i].w &amp;&amp; dis[u] - e[i].c == dis[e[i].to] &amp;&amp; (tmp = DFS(e[i].to, min(f, e[i].w), t))) &#123; f -= tmp, res += tmp, e[i].w -= tmp, e[i ^ 1].w += tmp, MCMF += (LL)tmp * e[i].c; if (!f) break; &#125; return res;&#125;inline LL Dinic(int s, int t) &#123; MCMF = 0; int f = 0; while (SPFA(s, t)) memcpy(cur, head, sizeof(head)), f += DFS(s, 1e9, t); return MCMF;&#125;int num[N];int main() &#123;// freopen("in.txt", "r", stdin); int n, s, t; scanf("%d", &amp;n), s = n + 1, t = n + 2; for (int i = 1, a;i &lt;= n;i++) scanf("%d", &amp;a), num[a]++; for (int i = 1;i &lt;= n;i++) adde(s, i, num[i], 0), adde(i, i == n ? 1 : i + 1, 1e9, 1), adde(i == n ? 1 : i + 1, i, 1e9, 1), adde(i, t, 1, 0); printf("%lld\n", Dinic(s, t)); return 0;&#125; T3 分离 折半搜索+打表 有一个结论：当$n\geq96$时，答案是0 不会，告辞 总结这次比赛有所进步，但是又粗心了 第一题犯了一个比较隐蔽的错误，导致有一些点RE了 不过还好]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>数位</tag>
        <tag>数学</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
        <tag>打表</tag>
        <tag>题解</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.15省选模拟]]></title>
    <url>%2F2019%2F03%2F15%2F3-15%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 Tried 之前做过一道Codeforces的题Run for beer，跟这道题很像 先把所有环都缩在一起，就变成了一个DAG 那么我们考虑在这个DAG上搞 显然一条最长的路径首先要满足长度最长，注意这里的长度指的是不包含前缀0的长度 其次要满足越靠下的路径要尽量长 对于每个点我们可以求出两个值 dep[u]表示从某个入度为0的点到$u$，经过的边数最多是多少 f[u]表示如果以$u$为终点，到某个入度为0的点经过的边数最多是多少。这要求连接$u$的那条边不能为0 然后我们就可以维护两个队列，代表当前可能成为答案的点 每次往上扩展一层，只扩展那些边权最大的边 123456789101112131415161718192021vector&lt;int&gt; q[2], res;inline void bfs(int dep, int cur) &#123; if (!dep) return; q[cur].clear(); int Mx = 0; for (int i = 0;i &lt; q[cur ^ 1].size();i++) &#123; int u = q[cur ^ 1][i]; for (int j = 0;j &lt; R[u].size();j++) if (dp[u] == dp[R[u][j].first] + 1) Mx = max(Mx, R[u][j].second); &#125; res.push_back(Mx); for (int i = 0;i &lt; q[cur ^ 1].size();i++) &#123; int u = q[cur ^ 1][i]; if (hh[u]) continue; hh[u] = 1; for (int j = 0;j &lt; R[u].size();j++) if (dp[u] == dp[R[u][j].first] + 1 &amp;&amp; R[u][j].second == Mx) q[cur].push_back(R[u][j].first); &#125; for (int i = 0;i &lt; q[cur ^ 1].size();i++) hh[q[cur ^ 1][i]] = 0; bfs(dep - 1, cur ^ 1);&#125; 然后根据答案从所有入度为0的点开始拓展，统计答案 这道题细节非常繁琐，首先有以下几种特殊情况： 有至少一个非0环，那么可以在这个环上永远走下去，答案为inf, inf 有0环，并且这个0环可以走到至少一条非0边，答案为inf, inf 有0环，并且不满足条件2，且在答案的路径上或者在某个终止节点的子树中，第二个答案为inf 所有边的边权都为0，此时枚举终点算方案数，注意只有一个点的路径也算 一条路径结束后仍然可以继续往下扩展，需要乘上终点的方案数 有自环，需要把它当成一个环 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010#define M 1000010const int mod = 998244353;#define LL long longstruct edge &#123; int from, to, next, w, used;&#125; e[M * 2];int head[N], ecnt;inline void adde(int from, int to, int w) &#123; e[++ecnt] = (edge)&#123;from, to, head[from], w, 0&#125;, head[from] = ecnt;&#125;int st[N], top, in[N], scc, belong[N], dfsn, dfn[N], low[N], sum[N], cnt[N];void Tarjan(int u) &#123; st[++top] = u, in[u] = 1, dfn[u] = low[u] = ++dfsn; for (int i = head[u];i;i = e[i].next) if (!dfn[e[i].to]) Tarjan(e[i].to), low[u] = min(low[u], low[e[i].to]); else if (in[e[i].to]) low[u] = min(low[u], dfn[e[i].to]); if (dfn[u] == low[u]) &#123; scc++; int v = -1; for (;v != u;top--) v = st[top], in[v] = 0, belong[v] = scc, cnt[scc]++; &#125;&#125;#define P pair&lt;int, int&gt;int ind[N], oud[N], dp[N], ok[N]; vector&lt;P &gt; G[N], R[N];inline void Topsort(int n) &#123; queue&lt;int&gt; q; for (int i = 1;i &lt;= n;i++) if (!ind[i]) q.push(i), st[++top] = i; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0;i &lt; G[u].size();i++) &#123; int v = G[u][i].first; if (!--ind[v]) q.push(v), st[++top] = v; &#125; &#125;&#125; int f[N], hh[N];vector&lt;int&gt; q[2], res;inline void bfs(int dep, int cur) &#123; if (!dep) return; q[cur].clear(); int Mx = 0; for (int i = 0;i &lt; q[cur ^ 1].size();i++) &#123; int u = q[cur ^ 1][i]; for (int j = 0;j &lt; R[u].size();j++) if (dp[u] == dp[R[u][j].first] + 1) Mx = max(Mx, R[u][j].second); &#125; res.push_back(Mx); for (int i = 0;i &lt; q[cur ^ 1].size();i++) &#123; int u = q[cur ^ 1][i]; if (hh[u]) continue; hh[u] = 1; for (int j = 0;j &lt; R[u].size();j++) if (dp[u] == dp[R[u][j].first] + 1 &amp;&amp; R[u][j].second == Mx) q[cur].push_back(R[u][j].first); &#125; for (int i = 0;i &lt; q[cur ^ 1].size();i++) hh[q[cur ^ 1][i]] = 0; bfs(dep - 1, cur ^ 1);&#125;int path[N], wocaonima[N], last[N], tmpind[N], toend[N], fuck[N], tostart[N];inline void getans(int dep, int cur) &#123; if (!dep) &#123; for (int i = 0;i &lt; q[cur ^ 1].size();i++) last[q[cur ^ 1][i]] = 1; return; &#125; q[cur].clear(); for (int i = 0;i &lt; q[cur ^ 1].size();i++) &#123; int u = q[cur ^ 1][i]; if (hh[u]) continue; hh[u] = 1; for (int j = 0;j &lt; G[u].size();j++) if (G[u][j].second == res[dep - 1] &amp;&amp; dp[u] + 1 == dp[G[u][j].first]) &#123; (path[G[u][j].first] += path[u]) %= mod; q[cur].push_back(G[u][j].first), wocaonima[G[u][j].first] |= wocaonima[u] | (cnt[u] != 1); &#125; &#125; for (int i = 0;i &lt; q[cur ^ 1].size();i++) hh[q[cur ^ 1][i]] = 0; getans(dep - 1, cur ^ 1);&#125;int main() &#123;// freopen("data.in", "r", stdin);// freopen("tried.in", "r", stdin), freopen("tried.out", "w", stdout); int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1, a, b, c;i &lt;= m;i++) &#123; scanf("%d%d%d", &amp;a, &amp;b, &amp;c), adde(a, b, c); &#125; for (int i = 1;i &lt;= n;i++) if (!dfn[i]) Tarjan(i); for (int i = 1;i &lt;= ecnt;i++) &#123; if (e[i].from == e[i].to) cnt[belong[e[i].from]]++; if (belong[e[i].from] != belong[e[i].to]) &#123; int u = belong[e[i].from], v = belong[e[i].to]; G[u].push_back(P(v, e[i].w)), R[v].push_back(P(u, e[i].w)), ind[v]++, oud[u]++, tmpind[v]++; &#125; else sum[belong[e[i].from]] += e[i].w; &#125; for (int i = 1;i &lt;= scc;i++) if (cnt[i] != 1 &amp;&amp; sum[i]) &#123; printf("inf\ninf\n"); return 0; &#125; Topsort(scc); for (int i = 1;i &lt;= scc;i++) if (!oud[i]) toend[i] = 1; for (int i = top;i &gt;= 1;i--) &#123; int u = st[i]; for (int j = 0;j &lt; G[u].size();j++) &#123; int v = G[u][j].first; ok[u] |= ok[v] | (G[u][j].second != 0), (toend[u] += toend[v] + 1) %= mod, fuck[u] |= fuck[v] | (cnt[v] != 1); &#125; &#125; for (int i = 1;i &lt;= scc;i++) if (cnt[i] != 1 &amp;&amp; ok[i]) &#123; printf("inf\ninf\n"); return 0; &#125;// for (int i = 1;i &lt;= scc;i++) if (!tmpind[i]) tostart[i] = 1; for (int i = 1;i &lt;= top;i++) for (int j = 0, u = st[i];j &lt; G[u].size();j++) &#123; int v = G[u][j].first; dp[v] = max(dp[v], dp[u] + 1), (tostart[v] += tostart[u] + 1) %= mod; &#125; int tmp = 0; for (int i = 1;i &lt;= scc;i++) for (int j = 0;j &lt; R[i].size();j++) if (R[i][j].second) f[i] = max(f[i], dp[R[i][j].first] + 1), tmp = max(tmp, f[i]); for (int i = 1;i &lt;= scc;i++) if (f[i] == tmp) q[0].push_back(i), dp[i] = f[i]; int dep = tmp; bfs(dep, 1); if (!res.size()) &#123; printf("0\n"); int ans = 0; for (int i = 1;i &lt;= scc;i++) if (cnt[i] != 1) &#123; printf("inf\n"); return 0; &#125; else (ans += tostart[i]) %= mod; printf("%d", (ans + n) % mod); return 0; &#125; for (int i = 0;i &lt; res.size();i++) printf("%d", res[i]); puts(""); q[0].clear(), q[1].clear(); for (int i = 1;i &lt;= scc;i++) if (!tmpind[i]) path[i] = 1, q[0].push_back(i); getans(dep, 1); int ans = 0; for (int i = 1;i &lt;= scc;i++) if (last[i]) &#123; if (wocaonima[i] || fuck[i] || cnt[i] != 1) &#123; printf("inf\n"); return 0; &#125; else ans = (ans + (LL)path[i] * toend[i]) % mod; &#125; printf("%d\n", ans); return 0;&#125; T2 简单的数论题 神仙题，不会啊 T3 恶熊咆哮 只会20分，即$n\leq 2000$的暴力分 注意到x,y坐标可以分离考虑，而对于一次咆哮，所有熊的相对顺序是不变的，但是可能又一些熊移动到了一起 那么可以使用线段树，区间加，单点查 需要先找到第一个小于当前位置的数以及第一个大于当前位置的数 放上这次比赛的题解 总结T1数据出锅了，但是改了之后还是只有90分，原因是某个地方忘取模了 看来还是有这样不该出现的问题，慢慢改吧]]></content>
      <tags>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.8省选模拟 冬至]]></title>
    <url>%2F2019%2F03%2F14%2F3-8%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F-%E5%86%AC%E8%87%B3%2F</url>
    <content type="text"><![CDATA[我们设$t_n$表示长度为$n$时的答案，$s_n$表示最后$k$个字符是一个给定的排列，在位置$n-1$时都合法的方案数 我们考虑两个基本的式子$$\begin{gather}t_n=kt_{n-1}-k!s_n\ \ \ (1)\\t_n=\sum_{i=1}^{k}(k-i)!s_{n+i}\ \ (2)\end{gather}$$对于第一个式子，我们在$t_{n-1}$后面随便加一种字符，然后减去不合法的情况，即$k!s_n$，这里枚举了最后$k$个字符分别是什么 对于第二个式子，我们尝试在$t_n$之后依次加上$1,2,3,\cdots,k$，枚举在加到哪个数字时候，这个序列变得不合法 追加了$i$个，前面的最后$k-i$个一定是一个排列，共$(k-i)!$种方案 根据这两个式子，我们可以推出$$(1)\Rightarrow s_n=\frac1{k!}(kt_{n-1}-t_n)\\(2)\Rightarrow t_n=\sum_{i=1}^k(k-i)!\frac1{k!}(kt_{n+i-1}-t_{n+i})\\=t_n+\sum_{i=1}^{k-1}((k-i-1)!\frac1{k!}kt_{n+i}-(k-i)!\frac1{k!}t_{n+i})-\frac1{k!}t_{n+k}$$ 注意这里把第一项的$kt_{n+i+1}$和最后一项的$t_n$拿了出来$$t_n=t_n+\sum_{i=1}^{k-1}((k-i-1)!\frac1{k!}kt_{n+i}-(k-i)!\frac1{k!}t_{n+i})-\frac1{k!}t_{n+k}\\t_{n+k}=\sum_{i=1}^{k-1}((k-i-1)!kt_{n+i}-(k-i)!t_{n+i})\\=\sum_{i=1}^{k-1}(k-i-1)!*i*t_{n+i}$$然后线性递推就可以了]]></content>
      <tags>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>多项式求逆</tag>
        <tag>多项式除法</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.13省选模拟]]></title>
    <url>%2F2019%2F03%2F13%2F3-13%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 碱基配对 注意到每一种字符是互不影响的，所以我们可以对于每一种字符分别计算有哪些位置合法，最后取一个交集 问题就转化为了给出两个01串$A,B$，对于$B$的每一个为1的位置$B_i$，$A_{i+p-k}-A_{i+p+k}$这些位置中至少要有一个1 那么我们可以把第一个串转化一下，将$A_i$变成原来的$A’{i-k}-A’{i+k}$中是否有1 对于这种条件比较奇怪的字符串匹配问题，一个比较常用的方法是FFT 我们设差异函数$F(p)$代表$A$串在$p$这个位置的差异值 我们考虑什么时候会产生差异 如果当前$B_i=0$，那么$A_{i+p}$随意 如果当前$B_i=1$，那么$A_{i+p}$必须为1 所以定义差异函数为$$F(p)=\sum_{i=0}^m(B_i-A_{i+p})B_i$$那么只要$F(p)\not=1$，$p$这个位置就不能匹配 把它化简一下$$F(p)=\sum_{i=0}^mB_i^2-\sum_{i=0}^mA_{i+p}B_i\\=\sum_{i=0}^mB_i-\sum_{i=0}^mA_{i+p}B_i$$根据套路，设$A’(x)=A(n-x)$ 有$$G(p)=\sum_{i=0}^mA_{i+p}B_i\\=\sum_{i=0}^mA’_{n-i-p}B_i\\$$令$$G’(n-p)=\sum_{i=0}^mA’_{n-i-p}B_i\\G(p)=G’(n-p)$$直接NTT即可 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;#define N 800010int pre[N], ta[N], tb[N], n, m, k, tmp[N], r[N], ans[N]; char A[N], B[N];const int mod = 998244353;#define LL long longinline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;inline void NTT(int a[], int len, int type) &#123; for (int i = 1;i &lt; len;i++) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int mid = 2;mid &lt;= len;mid &lt;&lt;= 1) &#123; int Wn = Pow(3, type ? (mod - 1) / mid : mod - 1 - (mod - 1) / mid); for (int i = 0;i &lt; len;i += mid) for (int j = i, w = 1, t;j &lt; i + (mid &gt;&gt; 1);j++, w = (LL)w * Wn % mod) t = (LL)w * a[j + (mid &gt;&gt; 1)] % mod, a[j + (mid &gt;&gt; 1)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod; &#125; if (!type) for (int i = 0, inv = Pow(len, mod - 2);i &lt; len;i++) a[i] = (LL)a[i] * inv % mod;&#125;inline void solve(char s) &#123; int sum = 0, l = 0, len = 1; for (int i = 0;i &lt; n;i++) pre[i] = (i ? pre[i - 1] : 0) + (A[i] == s); for (int i = 0;i &lt; m;i++) tb[i] = (B[i] == s), sum += tb[i] * tb[i]; for (int i = 0;i &lt; n;i++) &#123; int t = i - k - 1; tmp[i] = (pre[min(n - 1, i + k)] - (t &gt;= 0 ? pre[t] : 0)) &gt; 0; &#125; for (int i = 0;i &lt; n;i++) ta[n - i] = tmp[i]; while (len &lt;= n + m) len &lt;&lt;= 1, l++; for (int i = 1;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); for (int i = n + 1;i &lt; len;i++) ta[i] = 0; for (int i = m;i &lt; len;i++) tb[i] = 0; ta[0] = 0; NTT(ta, len, 1), NTT(tb, len, 1); for (int i = 0;i &lt; len;i++) ta[i] = (LL)ta[i] * tb[i] % mod; NTT(ta, len, 0); for (int i = 0;i &lt;= n - m;i++) ans[i] &amp;= ta[n - i] == sum;&#125;int main() &#123;// freopen("base1.in", "r", stdin); freopen("base.in", "r", stdin), freopen("base.out", "w", stdout); scanf("%d%s%s", &amp;k, A, B), n = strlen(A), m = strlen(B); for (int i = 0;i &lt;= n - m;i++) ans[i] = 1; solve('Z'), solve('P'), solve('S'), solve('B'); int res = 0; for (int i = 0;i &lt;= n - m;i++) res += ans[i]; printf("%d\n", res); return 0;&#125; T2 小凯的疑惑 由于数据太水，暴力可以获得92分的高分 对于第一、三、四这几个subtask，可以预处理当所有点都加上某个值时的答案，注意如果没有询问是这个值时不需要计算答案 对于第二个subtask，直接使用完全图的最小生成树这道题的做法即可。 每次将所有点按照最高位分成两类，把这两类分别连成连通块后再选择一条连接这两个连通块的最优边 表示没看懂题解在说什么，先贴上来 T3 false-false-true 一道很妙的题 先考虑$20\%$怎么做 很简单，直接dp即可 dp[i][j]表示当前已经有$i$道题是true，$j$道题是false，按照最优策略期望还能有多少道题可以答对 最优策略就是剩下的题中，是true的题多还是false的题多，哪个多就猜哪个 对于$40\%$，可以OEIS我也不知道该怎么做 对于所有的数据，我们考虑将题目转化一下 有一个$n*m$的网格，现在要从$(1,1)$走到$(n,m)$。对于一条路径，往上走代表这道题是false，往右走代表这道题是true。你现在要在走的同时决策向上走还是向右走，问期望有多少个决策会和最终的答案一样 我们将这个网格分成两部分 对于蓝色的部分，我们使用的策略是一直向右走，显然这样会更优秀，因为答对的概率更大 对于橙色的部分，有一些时候会向右走，有些时候会向上走。具体来说 在直线上方的部分会选择向右走，在直线下方的部分会选择向上走 我们先不考虑在直线上的情况 考虑一条路径的固定贡献 如果我们的策略只有向右走，那么绿色的路径一定会决策正确，黑色的路径一定会决策错误 最后决策正确的题目的数量是$n$ 现在把位于虚线下方的路径都折到虚线上方，由于我们知道在虚线下方时，决策是一直向上走，折过来之后，就变成了一直向右走 红色即为处理之后的路径 通过这张图我们知道，对于不在虚线上的点，它们在这条路径上的贡献一定是$n$ 那么对于在虚线上的点，它们的贡献需要特殊考虑 我们考虑一个这样的点对最终答案的贡献是什么 首先枚举每一个在虚线上的点，一共只有$m$个 对于一条经过它的路径，在到达这个点的时候，它有$50\%$的概率向上走，有$50\%​$的概率向右走，因为此时选两边正确的概率都相等 也就是说，它对这条路径决策正确的次数的贡献是$\frac 12$ 它对答案的贡献就是$\frac12$乘以它被经过的概率 我们知道经过一个点$(x,y)$的概率是$$\frac{C_{x+y}^yC_{n-x+m-y}^{n-x}}{C_{n+m}^n}$$乘以$\frac12$之后求和就可以了 代码如下 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1000010#define LL long longint frac[N], inv[N];const int mod = 998244353;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;inline int C(int n, int r) &#123; return (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;&#125;inline int Go(int n, int m) &#123; return C(n + m, n);&#125;int main() &#123; frac[0] = inv[0] = 1; for (int i = 1;i &lt;= N - 10;i++) frac[i] = (LL)frac[i - 1] * i % mod, inv[i] = Pow(frac[i], mod - 2); int n, m, res = 0; scanf("%d%d", &amp;n, &amp;m); if (n &lt; m) swap(n, m); for (int i = 1;i &lt;= m;i++) res = (res + (LL)Go(i, i) * Go(n - i, m - i)) % mod; res = (LL)res * Pow(2 * Go(n, m) % mod, mod - 2) % mod; printf("%d\n", (n + m - n - res + mod) % mod);&#125; 总结这次考试一般，第二题有一个小地方写错了，导致丢了20分 感觉第二题和第三题如果没有做过的话我很难想出正解，做一道题记一道题吧 明天没有考试]]></content>
      <tags>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>多项式</tag>
        <tag>字符串</tag>
        <tag>NTT</tag>
        <tag>组合数学</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.12省选模拟]]></title>
    <url>%2F2019%2F03%2F12%2F3-12%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 Mas的仙人掌 考虑每一条非树边的贡献 首先它不能掉落$(1-p_i)$，而且所有与它有交的边都必须掉落$(p_i)$ 那么显然有$$E_i=(1-p_i)\prod_{j与i有交}p_j$$所以关键在于如何求所有与它有交的边的$\prod p_j$ 首先我们考虑一个比较基础的问题：如何判断两条路径是否有交 假设这两条路径分别是$(a,b),(c,d)$ 如果是判断点相交，那么我们有结论： 如果两条路径有公共点，那么其中一条路径的$lca$一定在另一条路径上 如果是判断边相交，我们可以将这个结论推广 如果两条路径有公共边，那么其中一条路径的$lca$的左右两条边一定至少有一条也在另一条路径上 我们分两种情况讨论（假设当前需要求的路径是$u,v$）： $u,v$的$lca$的左右两边中至少有一条是在另一条路径上 那么此时有三种可能：只有$l,lca$是公共边、只有$r,lca$是公共边、$(l,lca),(r,lca)$都是公共边 对于前两种可能，我们需要求出覆盖了$l,lca$或者$r,lca$的路径的$\prod p_i$，这个可以直接用树上差分维护 对于第三种可能，我们发现前两种可能都包含了这种情况，也就是说我们多乘了一个$p_i$。好在此时两条路径的$lca$一定是相同的，那么我们维护一个map，map[l][r]表示所有$u$所对应的儿子是$l$，$v$所对应的儿子是$r$的路径的$p$的乘积，把$(u,v)$的答案除以这个值 所以此时$W_{u,v}=\frac{V_{l,lca}*V_{r,lca}}{map[l][r]},V$即是边的权值 另一条路径的$lca$的左右两边中至少有一条在$u,v$上，且不是$(l,lca),(r,lca) $ 那么我们知道此时这两条边不可能同时出现在$u,v$上 我们并不需要具体地知道究竟是那条边成为了公共点，我们只需要让这条公共边满足在$u,l$上，或者在$v,r$上 我们另外维护一个标记，每次加入一条路径$u,v$时，就把$(l,lca),(r,lca)$这两条路径的这个标记乘上$p_i$，最后再做一个前缀积，即我们只在这两条边上维护这条路径的贡献 查询的时候直接就查$u,l$路径上所有边这个标记的乘积，以及$v,r$路径上所有乘积就可以了 所以此时$W_{u,v}=\frac{V_{u,l}}{V_{v,r}}$，这里的$V$是树上前缀积的形式 把这两种情况的答案加起来即可 最后说一下如何更新 之前使用了两个标记，假设分别为tag1, tag2 首先要将$u,v$这条路径上所有的边的tag1乘上$p_i$，这是覆盖了某条边的路径的概率乘积 然后求出$l,r$，将$(l,lca),(r,lca)$这两条边的tag2乘上$p_i$，即在这条边上处理情况2的乘积 最后再一遍dfs，求出tag1，同时将tag2处理成前缀积的形式 然后就可以了 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long longconst int mod = 998244353;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;#define N 1000010struct Data &#123; int zero, mul; Data() &#123;&#125; Data(int x) &#123;if (x) zero = 0, mul = x; else zero = mul = 1;&#125; Data(int x, int y) : zero(x), mul(y) &#123;&#125; Data operator * (const Data &amp;b) &#123;return Data(zero + b.zero, (LL)mul * b.mul % mod);&#125; Data operator / (const Data &amp;b) &#123;return Data(zero - b.zero, (LL)mul * Pow(b.mul, mod - 2) % mod);&#125; inline int get() &#123;return zero ? 0 : mul;&#125;&#125; tag1[N], tag2[N];struct edge &#123; int to, next;&#125; e[N * 2];int head[N], ecnt;inline void adde(int from, int to) &#123; e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;&#125;int fa[N][21], dep[N]; void dfs(int u, int f) &#123; dep[u] = dep[f] + 1, fa[u][0] = f, tag1[u] = tag2[u] = Data(1); for (int i = 1;i &lt;= 20;i++) fa[u][i] = fa[fa[u][i - 1]][i - 1]; for (int i = head[u];i;i = e[i].next) if (e[i].to != f) dfs(e[i].to, u);&#125;inline int LCA(int a, int b) &#123; if (dep[a] &lt; dep[b]) swap(a, b); for (int i = 20;i &gt;= 0;i--) if (dep[fa[a][i]] &gt;= dep[b]) a = fa[a][i]; if (a == b) return a; for (int i = 20;i &gt;= 0;i--) if (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i]; return fa[a][0];&#125;inline int Jump(int a, int x) &#123; for (int i = 20;i &gt;= 0;i--) if (x &amp; (1 &lt;&lt; i)) a = fa[a][i]; return a;&#125;inline void Get(int a, int b, int &amp;lca, int &amp;g1, int &amp;g2) &#123; lca = LCA(a, b), g1 = g2 = 0; if (a != lca) g1 = Jump(a, dep[a] - dep[lca] - 1); if (b != lca) g2 = Jump(b, dep[b] - dep[lca] - 1);&#125;void dfs2(int u, int f) &#123; for (int i = head[u];i;i = e[i].next) if (e[i].to != f) &#123; tag2[e[i].to] = tag2[e[i].to] * tag2[u]; dfs2(e[i].to, u); tag1[u] = tag1[u] * tag1[e[i].to]; &#125;&#125;map&lt;int, Data&gt; G[N];inline void update(int a, int b, Data x) &#123; int lca, g1, g2; Get(a, b, lca, g1, g2); tag1[a] = tag1[a] * x, tag1[b] = tag1[b] * x, tag1[lca] = tag1[lca] / (x * x); if (g1) tag2[g1] = tag2[g1] * x; if (g2) tag2[g2] = tag2[g2] * x; if (g1 &amp;&amp; g2) &#123; if (g1 &gt; g2) swap(g1, g2); if (G[g1].count(g2)) G[g1][g2] = G[g1][g2] * x; else G[g1][g2] = x; &#125;&#125; inline Data query(int a, int b) &#123; int lca, g1, g2; Get(a, b, lca, g1, g2); Data res(1); if (g1) res = res * tag1[g1] * tag2[a] / tag2[g1]; if (g2) res = res * tag1[g2] * tag2[b] / tag2[g2]; if (g1 &amp;&amp; g2) &#123; if (g1 &gt; g2) swap(g1, g2); if (G[g1].count(g2)) res = res / G[g1][g2]; &#125; return res;&#125;int A[N], B[N], C[N], __rd;inline void read(int &amp;x) &#123; x = 0; char c = getchar(); while (c &lt; '0' || c &gt; '9') c = getchar(); while ('0' &lt;= c &amp;&amp; c &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - '0', c = getchar();&#125;#define RD (read(__rd), __rd)int main() &#123; freopen("cactus1.in", "r", stdin), freopen("cactus.out", "w", stdout); int n = RD, m = RD; for (int i = 1, a, b;i &lt; n;i++) a = RD, b = RD, adde(a, b); dfs(1, 0); for (int i = 1;i &lt;= m;i++) A[i] = RD, B[i] = RD, C[i] = RD, update(A[i], B[i], C[i]); dfs2(1, 0); int ans = 0; for (int i = 1;i &lt;= m;i++) &#123; Data res = query(A[i], B[i]); res = res / Data(C[i]) * Data((mod + 1 - C[i]) % mod); ans = (ans + res.get()) % mod; &#125; printf("%d\n", ans);&#125; T2 Z的礼物 首先将所有的$a$前缀和 那么根据题意，我们可以推出这样的式子$$b_n=\sum_{i=1}^n\begin{Bmatrix}n\\ i\end{Bmatrix}a_i$$现在已知$b$，求$a$，那么我们可以斯特林反演一下$$a_n=\sum_{i=1}^n(-1)^{n-i}\begin{bmatrix}n\\ i\end{bmatrix}b_i$$对于第一类斯特林数，它的生成函数是$$\sum_{i=0}^n\begin{bmatrix}n\\ i\end{bmatrix}x^i=\prod_{i=0}^{n-1}(x+i)$$联系它的递推式$\begin{bmatrix}n\\ i\end{bmatrix}=\begin{bmatrix}n - 1\\ i - 1\end{bmatrix}+(n-1)\begin{bmatrix}n - 1\\ i\end{bmatrix}​$可以得到 对于$\prod\limits_{i=1}^{n-1}(x+i)$，可以使用倍增FFT 计算出$l-1$的那一行斯特林数，然后暴力推下去即可 时间复杂度$T(n)=2T(\frac n2)+n\log n=n\log^2n$ 没有代码 T3 Mas和Z玩游戏 这题我是真不会 还是先贴一下题解，之后再补吧 就这样吧 总结这次比赛一般，第一题没有写炸，但是第二题该拿的45分只拿了5分，是一个细节错误 本来第二题还是有希望想出正解的，但是我在想到那个生成函数之后以为计算它是$n^2$的，就没写 还是需要深入思考]]></content>
      <tags>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>多项式</tag>
        <tag>分治</tag>
        <tag>FFT</tag>
        <tag>树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BJOI2018 治疗之雨]]></title>
    <url>%2F2019%2F03%2F11%2FBJOI2018-%E6%B2%BB%E7%96%97%E4%B9%8B%E9%9B%A8%2F</url>
    <content type="text"><![CDATA[题目链接 表示并不会$n^2$高斯消元做法 如果用dp[i]表示当前为i，到0还需要进行操作数的期望值，那么显然有转移$$dp_0 = 0\\dp_1 = G_{1,0}dp_0 + G_{1,1}dp_1 + G_{1,2}dp_2 + 1\\\cdots\\dp_{n-1} = G_{n-1,0}dp_0 + G_{n-1,1}dp_1 + \cdots + G_{n-1,n}dp_n + 1\\dp_n = G_{n,0}dp_0 + G_{n,1}dp_1 + \cdots + G_{n,n}dp_n + 1$$其中，G表示系数矩阵，G[i][j]表示进行一次操作后，i变成j的概率 首先预处理f[i]表示一次操作中，对第一个数减i的概率 那么有 $$f[i]=\frac{C_i^km^{k-i}}{(m+1)^k}$$ 这个式子的意思是，一共有k次-1的操作，其中选i次对第一个数-1，剩下的k-i次对剩余的m个数减，方案总数为$(m+1)^k$ 然后求G就很方便了 这个dp转移的时候与后面的项有关系，所以使用高斯消元 等等，$n=1500$高斯消元？ 观察到这个矩阵比较特殊，根据玄学方法可以将高斯消元优化成$n^2$，但是我不会 所以说一下另一个奇妙的方法 注意到dp[i]转移的时候与dp[i+1]有关系，所以把上面的转移方程移项，把右边的dp[i+1]移到左边来 此时就可以按照普通的dp进行转移了 但是有一个问题，就是无法求出dp[1] 那么我们可以设dp[1]=x 注意此时表示dp[n]的有两个方程，那么我们求出dp[n]的这两种表示，求一次一元一次方程就可以得到x了 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1510#define LL long longint G[N][N], f[N]; const int mod = 1e9 + 7;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;struct Data &#123; int x, y; Data(int _x = 0, int _y = 0) : x(_x), y(_y) &#123;&#125; Data operator + (Data b) &#123;return Data(((LL)mod + x + b.x) % mod, ((LL)mod + y + b.y) % mod);&#125; Data operator - (Data b) &#123;return *this + Data(-b.x, -b.y);&#125; Data operator * (int b) &#123;return Data((LL)x * b % mod, (LL)y * b % mod);&#125; Data operator / (int b) &#123;return *this * Pow(b, mod - 2);&#125;&#125; dp[N];int main() &#123; int T; scanf("%d", &amp;T), dp[1] = Data(1, 0); while (T--) &#123; int n, p, m, k; scanf("%d%d%d%d", &amp;n, &amp;p, &amp;m, &amp;k); if (p == 0) &#123;printf("0\n"); continue;&#125; if (m == 0) &#123; if (k &lt;= 1) &#123;printf("-1\n"); continue;&#125; if (p == n) printf("%d\n", max(1, (p - 2) / (k - 1) + 1)); else printf("%d\n", max(1, (p + k - 2) / (k - 1))); continue; &#125; for (int i = 0;i &lt;= n;i++) f[i] = 0; for (int i = 0, res = 1;i &lt;= min(k, n);i++, res = (LL)res * Pow(i, mod - 2) % mod * (k - i + 1) % mod) f[i] = (LL)res * Pow(m, k - i) % mod * Pow(Pow(m + 1, k), mod - 2) % mod; int tmp = Pow(m + 1, mod - 2); for (int i = 1;i &lt;= n;i++) &#123; for (register int j = 1;j &lt;= min(i + 1, n);++j) &#123; if (i == n) G[i][j] = f[i - j]; else if (j != i + 1) G[i][j] = ((LL)f[i - j] * (mod + 1 - tmp) + (LL)f[i + 1 - j] * tmp) % mod; else G[i][j] = (LL)f[i + 1 - j] * tmp % mod; &#125; &#125; bool flag = true; for (int i = 2;i &lt;= n &amp;&amp; flag;i++) &#123; dp[i] = Data(0, 1); for (int j = 1;j &lt; i;j++) dp[i] = dp[i] + dp[j] * G[i - 1][j]; dp[i] = (dp[i] - dp[i - 1]) / (mod - G[i - 1][i]); if (!G[i - 1][i]) flag = false; &#125; Data other(0, 1); for (int i = 1;i &lt; n &amp;&amp; flag;i++) other = other + dp[i] * G[n][i]; other = other / ((1 - G[n][n] + mod) % mod); if (G[n][n] == 1 || dp[n].x == other.x) flag = false; int X = (LL)(other.y - dp[n].y + mod) % mod * Pow((dp[n].x - other.x + mod) % mod, mod - 2) % mod; if (!flag) printf("-1\n"); else printf("%d\n", ((LL)dp[p].x * X + dp[p].y) % mod); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>期望</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BJOI2017 喷式水战改]]></title>
    <url>%2F2019%2F03%2F11%2FBJOI2017-%E5%96%B7%E5%BC%8F%E6%B0%B4%E6%88%98%E6%94%B9%2F</url>
    <content type="text"><![CDATA[题目链接 平衡树维护dp 对于平衡树上的一个点，维护f[i][j]表示它的子树所表示的这段区间内，从状态i开始，以状态j结束，能获得的最大收益 显然有一个结论，对于一段连续的、并且a、b、c值都相等的燃料，一定有一种最优的方案使得这一段燃料的状态都相同 所以对把每一次插入的区间压缩成一个点，同时分裂插入位置所在的节点 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;#define N 200010#define LL long longint fa[N], ch[2][N], ncnt, cnt[N];LL F[4][4][N], G[4][4][N], size[N];inline void calc(int u) &#123; for (int len = 2;len &lt;= 4;len++) for (int start = 0, end;start + len - 1 &lt;= 3;start++) end = start + len - 1, F[start][end][u] = G[start][end][u] = max(F[start][end - 1][u], F[start + 1][end][u]);&#125;inline int create(LL val[], int f, int tot) &#123; int u = ++ncnt; fa[u] = f, cnt[u] = size[u] = tot; for (int i = 0;i &lt;= 3;i++) F[i][i][u] = val[i % 3]; return calc(u), ncnt;&#125;inline void pushup(int u) &#123; size[u] = size[ch[0][u]] + cnt[u] + size[ch[1][u]]; for (int start = 0; start &lt;= 3; start++) for (int end = start; end &lt;= 3;end++) &#123; G[start][end][u] = 0; for (int i = start;i &lt;= end;i++) for (int j = i;j &lt;= end;j++) G[start][end][u] = max(G[start][end][u], G[start][i][ch[0][u]] + F[i][j][u] + G[j][end][ch[1][u]]); &#125;&#125;inline void connect(int u, int f, int son) &#123;fa[u] = f, ch[son][f] = u;&#125;inline bool child(int u) &#123;return u == ch[1][fa[u]];&#125;inline void rotate(int u) &#123; int f = fa[u], ff = fa[f], tmp = child(u), tmp1 = child(f); connect(ch[tmp ^ 1][u], f, tmp), connect(f, u, tmp ^ 1), connect(u, ff, tmp1); pushup(f), pushup(u);&#125;inline void splay(int u) &#123;for (int f;fa[u];rotate(u)) if (fa[f = fa[u]]) rotate(child(u) ^ child(f) ? u : f);&#125;inline int Kth(int u, LL k) &#123; if (size[ch[0][u]] &lt; k &amp;&amp; size[u] - size[ch[1][u]] &gt;= k) return splay(u), u; return k &lt;= size[ch[0][u]] ? Kth(ch[0][u], k) : Kth(ch[1][u], k - size[u] + size[ch[1][u]]);&#125;LL input[3], tmp[3], del1[3], del2[3], del3[3];int main() &#123; ch[0][0] = create(input, 0, 1); int q; LL ls = 0; scanf("%d", &amp;q); while (q--) &#123; LL p; int tot, now; scanf("%lld%lld%lld%lld%d", &amp;p, &amp;input[0], &amp;input[1], &amp;input[2], &amp;tot), p++, now = Kth(ch[0][0], p); for (int i = 0;i &lt; 3;i++) tmp[i] = F[i][i][now] / cnt[now]; LL slice = p - size[ch[0][now]];// size: 1 -&gt; slice - 1, slice -&gt; size for (int i = 0;i &lt; 3;i++) del1[i] = tmp[i] * (slice - 1), del2[i] = input[i] * tot, del3[i] = tmp[i] * (cnt[now] - slice + 1); int a = create(del2, now, tot), b = create(del3, a, cnt[now] - slice + 1); ch[1][a] = b; cnt[now] = slice - 1, connect(ch[1][now], b, 1), ch[1][now] = a; for (int i = 0;i &lt;= 3;i++) F[i][i][now] = del1[i % 3]; calc(now), pushup(b), pushup(a), pushup(now); LL ans = 0; for (int i = 0;i &lt;= 3;i++) for (int j = i;j &lt;= 3;j++) ans = max(ans, G[i][j][now]); printf("%lld\n", ans - ls), ls = ans; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BJOI2017 树的难题]]></title>
    <url>%2F2019%2F03%2F11%2FBJOI2017-%E6%A0%91%E7%9A%84%E9%9A%BE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目链接 边数在l到r之间。。。那么这题就是点分治跑不掉了 由于是统计的每一段颜色的权值之和，所以对于一条到分治中心的路径，我们需要保存路径长度、权值之和、顶端的颜色这三个值 如果直接合并的话，时间复杂度最坏是$n^2$，呵呵 所以我们考虑合并时的两种情况，分别进行优化 1.两条路径的顶端颜色不同由于顶端颜色不同，那么这两条路径一定来自于两棵不同的子树 如果我们按照路径的顶端颜色排序，那么对于路径i，它所应当匹配的另一条路径是排在i之前、顶端颜色与i不同、路径长度在一个区间之内的权值之和最大的路径 也就是说，我们需要实现一个东西，可以支持单点修改、区间查最大值 上线段树 2.两条路径的顶端颜色相同那么这时有两种情况：来自同一棵子树；来自不同子树 第一种情况显然是我们不希望统计到的，所以我们对于每一条路径多维护一个值，表示分治中心到这条链的顶端的那条边的编号 编号相同，则表示来自同一棵子树 模仿之前的方法，如果两条路径的顶端颜色一样，则对那条边的编号进行排序，这样就可以保证编号相同的路径排在一起。 然后再开一颗线段树维护区间最大值即可 注意，这是一棵需要实现$O(1)$清空的线段树 方法很简单，直接打个标记即可 时间复杂度$n\log^2 n$，然而貌似比很多$n\log n$的还要快 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;#define N 200010const int INF = 2e9;struct Tree &#123; struct node &#123;int mx, tag;&#125; T[N &lt;&lt; 2]; inline void Clear() &#123;T[1].mx = -INF, T[1].tag = 1;&#125; inline void pushdown(int rt) &#123;T[rt &lt;&lt; 1].mx = T[rt &lt;&lt; 1 | 1].mx = -INF, T[rt &lt;&lt; 1].tag = T[rt &lt;&lt; 1 | 1].tag = 1, T[rt].tag = 0;&#125; void update(int rt, int l, int r, int at, int x) &#123; if (l == r) &#123;T[rt].mx = max(T[rt].mx, x); return;&#125; int mid = (l + r) &gt;&gt; 1; T[rt].mx = max(T[rt].mx, x); if (T[rt].tag) pushdown(rt); if (at &lt;= mid) update(rt &lt;&lt; 1, l, mid, at, x); else update(rt &lt;&lt; 1 | 1, mid + 1, r, at, x); &#125; int query(int rt, int l, int r, int start, int end) &#123; if (end &lt; l || start &gt; r) return -INF; if (start &lt;= l &amp;&amp; r &lt;= end) return T[rt].mx; if (T[rt].tag) return -INF; int mid = (l + r) &gt;&gt; 1, ans = -INF; if (start &lt;= mid) ans = max(ans, query(rt &lt;&lt; 1, l, mid, start, end)); if (end &gt; mid) ans = max(ans, query(rt &lt;&lt; 1 | 1, mid + 1, r, start, end)); return ans; &#125;&#125; A, B;struct edge &#123;int to, next, c;&#125; e[N * 2];int head[N], ecnt;inline void adde(int from, int to, int c) &#123; e[++ecnt] = (edge)&#123;to, head[from], c&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to], c&#125;, head[to] = ecnt;&#125;int size[N], vis[N], val[N];int Getsize(int u) &#123; size[u] = vis[u] = 1; for (int i = head[u];i;i = e[i].next) if (!vis[e[i].to]) size[u] += Getsize(e[i].to); return vis[u] = 0, size[u];&#125;int Getroot(int u, int tot) &#123; vis[u] = 1; for (int i = head[u], tmp;i;i = e[i].next) if (!vis[e[i].to] &amp;&amp; (tmp = Getroot(e[i].to, tot))) return vis[u] = 0, tmp; return vis[u] = 0, size[u] &gt;= (tot &gt;&gt; 1) ? u : 0;&#125;struct Data &#123;int from, dis, len;&#125; q[N];int qcnt = 0, mx, L, R, ans = -INF;void DFS(int u, int from, int ls, int dis, int len) &#123; q[++qcnt] = (Data)&#123;from, dis, len&#125;, vis[u] = 1, mx = max(mx, len); if (L &lt;= len &amp;&amp; len &lt;= R) ans = max(ans, dis); for (int i = head[u];i;i = e[i].next) if (!vis[e[i].to]) DFS(e[i].to, from, e[i].c, ls == e[i].c ? dis : dis + val[e[i].c], len + 1); vis[u] = 0;&#125;void Build(int u) &#123; u = Getroot(u, Getsize(u)), vis[u] = 1, qcnt = mx = 0; for (int i = head[u];i;i = e[i].next) if (!vis[e[i].to]) DFS(e[i].to, i, e[i].c, val[e[i].c], 1); sort(q + 1, q + qcnt + 1, [=](Data a, Data b) &#123;return e[a.from].c &lt; e[b.from].c || (e[a.from].c == e[b.from].c &amp;&amp; a.from &lt; b.from);&#125;), A.Clear(), B.Clear(); int cur1 = 0, cur2 = 0; for (int i = 1;i &lt;= qcnt;i++) &#123; if (e[q[i].from].c != e[q[i - 1].from].c) B.Clear(), cur2 = i - 1; while (q[cur2 + 1].from != q[i].from) cur2++, B.update(1, 1, mx, q[cur2].len, q[cur2].dis); while (e[q[cur1 + 1].from].c != e[q[i].from].c) cur1++, A.update(1, 1, mx, q[cur1].len, q[cur1].dis); ans = max(ans, A.query(1, 1, mx, L - q[i].len, R - q[i].len) + q[i].dis); ans = max(ans, B.query(1, 1, mx, L - q[i].len, R - q[i].len) + q[i].dis - val[e[q[i].from].c]); &#125; for (int i = head[u];i;i = e[i].next) if (!vis[e[i].to]) Build(e[i].to);&#125;int main() &#123; int n, m; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;L, &amp;R); for (int i = 1;i &lt;= m;i++) scanf("%d", &amp;val[i]); for (int i = 1, a, b, c;i &lt; n;i++) scanf("%d%d%d", &amp;a, &amp;b, &amp;c), adde(a, b, c); Build(1), printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>点分治</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BJOI2017 魔法咒语]]></title>
    <url>%2F2019%2F03%2F11%2FBJOI2017-%E9%AD%94%E6%B3%95%E5%92%92%E8%AF%AD%2F</url>
    <content type="text"><![CDATA[题目链接 感觉这题没啥好说的。。。就是对数据的分类讨论差评 首先对于所有的危险串建AC自动机，标记危险节点，转移的时候不从危险节点转移 然后预处理to[i][j]，即从自动机的i号节点出发，按照第j个基本串走，最后到达的节点，注意如果中途有危险节点就是-1 对于前60%的数据，直接dp即可，用dp[i][j]表示当前串长度为i，走到自动机的j号节点的方案数 对于后面40%的数据，没法直接dp了。注意到基本串的长度都特别小，直接上矩阵乘法 如果基本串的长度都为1，那么建一个$n*n$的矩阵就好了 否则要同时保存长度为$len-1,len-2$的方案，建一个$(2*n)^2$的矩阵 然后快速幂即可 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;#define N 110int ncnt, trie[N][26], val[N]; const int mod = 1e9 + 7;inline void insert(char s[], int len) &#123; int now = 0; for (int i = 1, c = s[i] - 'a';i &lt;= len;i++, c = s[i] - 'a') if (trie[now][c]) now = trie[now][c]; else now = trie[now][c] = ++ncnt; val[now] = 1;&#125; int fail[N]; queue&lt;int&gt; q; inline void BFS() &#123; for (int i = 0, now;i &lt; 26;i++) if (now = trie[0][i]) q.push(now); while (!q.empty()) &#123; int now = q.front(); q.pop(); for (int i = 0, f, son;i &lt; 26;i++) if (trie[now][i]) &#123; f = fail[now]; while (f &amp;&amp; !trie[f][i]) f = fail[f]; son = trie[now][i], fail[son] = trie[f][i], val[son] |= val[fail[son]], q.push(son); &#125; &#125; &#125;inline int query(int now, char s[], int len) &#123; for (int i = 1, c;i &lt;= len;i++) &#123; c = s[i] - 'a'; while (now &amp;&amp; !trie[now][c]) now = fail[now]; now = trie[now][c]; if (val[now]) return -1; &#125; return now;&#125;char basic[51][N], s[51][N]; int len[N], to[N][N], dp[N][N];#define LL long longstruct Matrix &#123; int a[2 * N][2 * N], n; Matrix(int _n = 0) : n(_n) &#123;memset(a, 0, sizeof(a));&#125; Matrix operator * (Matrix b) &#123; Matrix c(n); for (int i = 0;i &lt;= n;i++) for (int j = 0;j &lt;= n;j++) for (int k = 0;k &lt;= n;k++) c.a[i][j] = (c.a[i][j] + (LL)a[i][k] * b.a[k][j]) % mod; return c; &#125;&#125;;inline Matrix Pow(Matrix x, int y) &#123; Matrix res(x.n); for (int i = 0;i &lt;= res.n;i++) res.a[i][i] = 1; for (;y;y &gt;&gt;= 1, x = x * x) if (y &amp; 1) res = res * x; return res;&#125;inline int solve1(int n, int l) &#123; Matrix res(ncnt); for (int i = 0;i &lt;= ncnt;i++) if (!val[i]) for (int j = 1;j &lt;= n;j++) if (~to[i][j]) res.a[to[i][j]][i]++; res = Pow(res, l); int ans = 0; for (int i = 0;i &lt;= ncnt;i++) ans = (ans + res.a[i][0]) % mod; return ans;&#125;inline int solve2(int n, int l) &#123; Matrix res(2 * ncnt + 1); for (int i = ncnt + 1;i &lt;= 2 * ncnt + 1;i++) res.a[i][i - ncnt - 1] = 1; for (int i = 0;i &lt;= ncnt;i++) if (!val[i]) for (int j = 1;j &lt;= n;j++) if (~to[i][j]) res.a[to[i][j]][i + (len[j] == 1 ? 0 : ncnt + 1)]++; res = Pow(res, l); int ans = 0; for (int i = 0;i &lt;= ncnt;i++) ans = (ans + res.a[i][0]) % mod; return ans;&#125;int main() &#123; int n, m, l, mx = 0; scanf("%d%d%d", &amp;n, &amp;m, &amp;l); for (int i = 1;i &lt;= n;i++) scanf("%s", basic[i] + 1), len[i] = strlen(basic[i] + 1), mx = max(mx, len[i]); for (int i = 1;i &lt;= m;i++) scanf("%s", s[i] + 1), insert(s[i], strlen(s[i] + 1)); BFS(); for (int i = 0;i &lt;= ncnt;i++) for (int j = 1;j &lt;= n;j++) to[i][j] = val[i] ? -1 : query(i, basic[j], len[j]); if (l &lt;= 100) &#123; dp[0][0] = 1; for (int i = 0;i &lt;= l;i++) for (int j = 0;j &lt;= ncnt;j++) if (!val[j] &amp;&amp; dp[i][j]) for (int k = 1;k &lt;= n;k++) if (~to[j][k] &amp;&amp; i + len[k] &lt;= l) (dp[i + len[k]][to[j][k]] += dp[i][j]) %= mod; int ans = 0; for (int i = 0;i &lt;= ncnt;i++) (ans += dp[l][i]) %= mod; printf("%d\n", ans); &#125; else printf("%d\n", mx == 1 ? solve1(n, l) : solve2(n, l)); return 0; &#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>矩阵乘法</tag>
        <tag>AC自动机</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BJOI2017 机动训练]]></title>
    <url>%2F2019%2F03%2F11%2FBJOI2017-%E6%9C%BA%E5%8A%A8%E8%AE%AD%E7%BB%83%2F</url>
    <content type="text"><![CDATA[题目链接 显然一条合法的机动路径就是一直朝某个象限走，可以走坐标轴的路径 对于每一条机动路径，它的权值是经过地形与它相同的机动路径条数 也就是每种机动路径数量的平方和 对于这个平方，我们可以换一种统计方案，即两条机动路径，相同的方案数 分别枚举两条机动路径的朝向 记dp[i][j][p][q]表示在当前枚举的方向上第一条机动路径从$(i,j)$出发，第二条机动路径从$(p,q)$出发，相同的方案数 由于可以走坐标轴，这样会重复统计一些路径 比如当前选定了第一条路径走第二象限，我们会发现统计出来的结果与第一条路径走第一象限有交集 怎么办呢？减去重复的即可，也就是第一条路径只沿y正半轴走的方案数 记f[i][j][p][q]为第一条路径的方向为$(i,j)$，第二条路径的方向为$(p,q)$时的答案 先处理一下第一条路径和第二条路径的合法位移即可 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;#define N 41char G[N][N]; int dx[2][N], dy[2][N], cnt1, cnt2, n, m;int dp[N][N][N][N], f[3][3][3][3]; const int mod = 1e9 + 9;int DP(int x, int y, int p, int q) &#123; if (min(min(x, y), min(p, q)) &lt; 1 || max(x, p) &gt; n || max(y, q) &gt; m) return 0; if (G[x][y] != G[p][q]) return 0; if (~dp[x][y][p][q]) return dp[x][y][p][q]; int &amp;sum = dp[x][y][p][q]; sum = 1; for (int i = 1;i &lt;= cnt1;i++) for (int j = 1;j &lt;= cnt2;j++) (sum += DP(x + dx[0][i], y + dy[0][i], p + dx[1][j], q + dy[1][j])) %= mod; return sum;&#125;inline int AC(int x, int y, int p, int q) &#123; int &amp;sum = f[x + 1][y + 1][p + 1][q + 1]; cnt1 = cnt2 = 0; if (~sum) return sum; else sum = 0; for (int i = -1;i &lt;= 1;i++) if ((!i) || i == x) for (int j = -1;j &lt;= 1;j++) if ((i | j) &amp;&amp; ((!j) || j == y)) dx[0][++cnt1] = i, dy[0][cnt1] = j; for (int i = -1;i &lt;= 1;i++) if ((!i) || i == p) for (int j = -1;j &lt;= 1;j++) if ((i | j) &amp;&amp; ((!j) || j == q)) dx[1][++cnt2] = i, dy[1][cnt2] = j; memset(dp, -1, sizeof(dp)); for (int i = 1;i &lt;= n;i++) for (int j = 1;j &lt;= m;j++) for (int k= 1;k &lt;= n;k++) for (int l = 1;l &lt;= m;l++) (sum += DP(i, j, k, l)) %= mod; f[p + 1][q + 1][x + 1][y + 1] = f[-p + 1][-q + 1][-x + 1][-y + 1] = f[-x + 1][-y + 1][-p + 1][-q + 1] = sum; return sum;&#125;#define LL long longinline int AC(int x, int y) &#123; int sum = 0; sum = (sum + (LL)AC(x, y, 1, 1) + AC(x, y, 1, -1) + AC(x, y, -1, 1) + AC(x, y, -1, -1)) % mod; sum = (sum - (LL)AC(x, y, 1, 0) - AC(x, y, -1, 0) - AC(x, y, 0, 1) - AC(x, y, 0, -1)) % mod; return (sum + mod) % mod;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m), memset(f, -1, sizeof(f)); for (int i = 1;i &lt;= n;i++) scanf("%s", G[i] + 1); int ans = 0; ans = (ans + (LL)AC(1, -1) + AC(1, 1) + AC(-1, -1) + AC(-1, 1)) % mod; ans = (ans - (LL)AC(1, 0) - AC(-1 ,0) - AC(0, 1) - AC(0, -1)) % mod; printf("%d\n", (ans + mod) % mod); return 0;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BJOI2017 开车]]></title>
    <url>%2F2019%2F03%2F11%2FBJOI2017-%E5%BC%80%E8%BD%A6%2F</url>
    <content type="text"><![CDATA[题目链接 显然，最优的方案一定是将所有的加油站和车按照位置排序之后一一对应 但是如何考虑修改呢？这种东西是没法维护的 我们考虑另外一种统计答案的方式 将加油站和车都想象成数轴上的一些点，其中加油站是红点，车是黑点 单独考虑数轴上每一条线段的贡献 对于一条线段i，记这条线段的长度为$len_i$，前面一共有$a_i$个红点，$b_i$个黑点，那么这条线段对答案的贡献为 $$len_i|a_i-b_i|$$ 由于询问中涉及到更改点的位置这个操作，我们可以将询问离线下来，先把所有在询问中即将出现的点都标记出来就可以了 现在考虑每个询问都干了啥 将一辆车从A点挪到B点（A&lt;B），那么，对于区间$[A,B-1]$，$b_i$的值都减少了1 反之，如果A&gt;B，那么对于区间$[B,A-1]$，$b_i$的值将增加1 所以，我们要实现一个这样的东西：每个点有初始权值$w_i,a_i$，操作是区间将$a_i$的值加减1，维护$\sum w_i|a_i|$ 这个绝对值的符号非常讨厌，不过幸好每次操作只会增减1 考虑对一段区间$[A,B]$进行修改，我们需要首先将这段区间的$a_i$排好序，然后二分找到零点，具体来说 如果排好序之后的a是这样的，此时需要将这一串a全部加上1，那么A点右方的点的绝对值都增大1，左边的点的绝对值都减小1 此时，答案增加 $$\sum_i^{[A,D]} w_i-\sum_i^{[B,A)} w_i$$ 如果要减少1，那么C点左方的点的绝对值都增大1，右边的点的绝对值都减少1 此时，答案增加 $$\sum_i^{[B,C]}w_i-\sum_i^{(C,D]}w_i$$ 为了快速更新答案，我们需要预处理w在这一段中的前缀和，同时二分找到零点 线段树显然不行，所以考虑分块 对于每一块维护w在这一块中的前缀和，以及排好序后的a数组 对于修改，边角上的两个块暴力重构，中间完整的块用一个tag数组存一下有多少修改是没有下发到每个元素上的，重构时下放。然后二分找到零点，更新答案 代码还是挺好写的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;const int SZ = 400, N = 50010, M = 150010;#define LL long longstruct Data &#123;int sum;LL dis;&#125; t[M];int sum[M], dis[M], tag[N]; LL ans;bool cmp(Data a, Data b) &#123;return a.sum &lt; b.sum;&#125;inline void rebuild(int x) &#123; for (int i = x;i &lt; x + SZ;i++) t[i].sum = sum[i], t[i].dis = dis[i]; sort(t + x, t + x + SZ, cmp); for (int i = x + 1;i &lt; x + SZ;i++) t[i].dis += t[i - 1].dis;&#125; inline void update(int l, int r, int x) &#123; int bl = (l - 1) / SZ, br = (r - 1) / SZ; for (int i = bl * SZ + 1;i &lt;= (bl + 1) * SZ;i++) sum[i] += tag[bl]; tag[bl] = 0; if (bl == br) &#123; for (int i = l;i &lt;= r;i++) ans -= abs(sum[i]) * dis[i], ans += abs(sum[i] += x) * dis[i]; rebuild(bl * SZ + 1); &#125; else &#123; for (int i = br * SZ + 1;i &lt;= (br + 1) * SZ;i++) sum[i] += tag[br]; tag[br] = 0; for (int i = l;i &lt;= (bl + 1) * SZ;i++) ans -= abs(sum[i]) * dis[i], ans += abs(sum[i] += x) * dis[i]; for (int i = br * SZ + 1;i &lt;= r;i++) ans -= abs(sum[i]) * dis[i], ans += abs(sum[i] += x) * dis[i]; rebuild(bl * SZ + 1), rebuild(br * SZ + 1); &#125; for (int i = bl + 1;i &lt; br;i++) &#123; int L = i * SZ + 1, R = (i + 1) * SZ, mid, res = 0; tag[i] += x; if (x &lt; 0) &#123; while (L &lt;= R) if (t[mid = (L + R) &gt;&gt; 1].sum + tag[i] &lt; 0) res = mid, L = mid + 1; else R = mid - 1; ans -= t[(i + 1) * SZ].dis - 2 * t[res].dis; &#125; else &#123; while (L &lt;= R) if (t[mid = (L + R) &gt;&gt; 1].sum + tag[i] &lt;= 0) res = mid, L = mid + 1; else R = mid - 1; ans += t[(i + 1) * SZ].dis - 2 * t[res].dis; &#125; &#125;&#125;int a[N], b[N], ncnt, id[M], to[M];int main() &#123;// freopen("in.txt", "r", stdin); int n; scanf("%d", &amp;n); for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;a[i]), dis[++ncnt] = a[i]; for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;b[i]), dis[++ncnt] = b[i]; int q; scanf("%d", &amp;q); for (int i = 1;i &lt;= q;i++) scanf("%d%d", &amp;id[i], &amp;to[i]), dis[++ncnt] = to[i]; sort(dis + 1, dis + ncnt + 1), ncnt = unique(dis + 1, dis + ncnt + 1) - dis - 1; for (int i = 1;i &lt;= n;i++) sum[a[i] = lower_bound(dis + 1, dis + ncnt + 1, a[i]) - dis]++; for (int i = 1;i &lt;= n;i++) sum[b[i] = lower_bound(dis + 1, dis + ncnt + 1, b[i]) - dis]--; for (int i = 1;i &lt;= q;i++) to[i] = lower_bound(dis + 1, dis + ncnt + 1, to[i]) - dis; for (int i = 1;i &lt;= ncnt;i++) ans += abs(sum[i] += sum[i - 1]) * (dis[i] = dis[i + 1] - dis[i]); printf("%lld\n", ans); for (int i = 1;i &lt;= ncnt;i += SZ) rebuild(i); for (int i = 1;i &lt;= q;i++) &#123;// cout &lt;&lt; a[id[i]] &lt;&lt; ' ' &lt;&lt; to[i] &lt;&lt; endl; if (a[id[i]] &lt; to[i]) update(a[id[i]], to[i] - 1, -1); else if (a[id[i]] != to[i]) update(to[i], a[id[i]] - 1, 1); a[id[i]] = to[i], printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFT与NTT基础]]></title>
    <url>%2F2019%2F03%2F11%2FFFT%E4%B8%8ENTT%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[理论部分复数设$a, b$是实数，形如$a+bi$的数叫做复数，其中$i$叫做虚数单位 我们可以用一个复平面上的向量表示一个复数。x轴代表实数，y轴代表虚数。比如：向量$(a,b)$就表示复数$a+bi$ 模长：就是这个向量的长度 辐角：从x正半轴逆时针旋转到这个向量的角度 复数乘法的几何意义是，模长相乘，辐角相加 代数意义：$$(a+bi)*(c+di)$$ $$=ac+adi+cbi+bdi^2$$ $$= (ac-bd)+(ad+cb)i$$ 单位根在复平面上，以原点为圆心，半径为1画圆，得到的圆叫做单位圆 将这个圆做n等分，那么我们得到了n个向量，每个向量都对应了一个n次单位根 我们分别记这些单位根为$\omega_n^1,\omega_n^2,\cdots,\omega_n^n$ 其中，记$\omega_n^1$为主n次单位根 性质$$\omega_n^k=\cos k\frac{2\pi}{n}+i\sin k\frac{2\pi}{n}$$ 根据单位根的定义，显然有 消去定理 $$\omega_{dn}^{dk}=\omega_n^k$$ 折半定理 对于任意的大于0的整数n，都有n个n次单位复根的平方的集合，等于$\frac{n}{2}$个$\frac{n}{2}$次单位复根的集合 此时显然有 $$(\omega_n^k)^2=\omega_{n/2}^k$$ $$(\omega_n^{k+\frac{n}{2}})^2=\omega_{n}^{2k+n}=\omega_n^{2k}\times\omega_n^n=\omega_n^{2k}=(\omega_n^k)^2$$ 快速傅里叶变换(FFT)FFT的作用是，快速计算出两个多项式相乘的结果 按照朴素的算法，假如有两个次数为n的多项式，那么我们会遍历其中一个多项式的每一项，计算它与另一个多项式的乘积 然而这样的时间复杂度是$n^2$的，也没有什么可以显著优化的地方 点值表示我们知道，一个多项式$f(x)$可以写成$a_0x^0+a_1x^1+\cdots+a_nx^n$的形式，这被称作系数表示 而一个n次的多项式可以被n个点唯一确定 那么我们可以将主单位根的0到n-1次幂依次带入这个多项式求值，然后通过插值再把点值表达还原成系数表示 直接做显然还是$n^2$，而且还多了一堆巨大无比的常数 但是我们可以优化 设 $$A(x)=a_0+a_1x+a_2x^2+\cdots+a_nx^n$$ 将这个多项式按照x的幂的奇偶性分类 $$A_1(x)=a_0+a_2x^2+\cdots+a_{n-1}x^{n-1}$$ $$A_2(x)=a_1x+a_3x^3+\cdots+a_{n}x^{n}$$ 我们可以得到 $$A(x)=A_1(x)+A_2(x)$$ 设 $$A^{[1]}(x)=a_0+a_2x+\cdots+a_{n-1}x^{\frac{n}{2}}$$ $$A^{[2]}(x)=a_1+a_3x+\cdots+a_{n}x^{\frac{n}{2}}$$ 那么我们有 $$A(x)=A^{[1]}(x^2)+xA^{[2]}(x^2)$$ 代入单位复根$\omega_n^k(k&lt;\frac{n}{2})$，得 $$A(\omega_n^k)=A^{[1]}(\omega_{n/2}^k)+\omega_n^kA^{[2]}(\omega_{n/2}^k)$$ 代入另一个单位复根$\omega_n^{k+\frac{n}{2}}$，得 $$A(\omega_n^{k+\frac{n}{2}})=A^{[1]}(\omega_{n/2}^{k+\frac{n}{2}})-\omega_n^{k}A^{[2]}(\omega_{n/2}^{k+\frac{n}{2}})$$ $$=A^{[1]}(\omega_n^{k})-\omega_n^{k}A^{[2]}(\omega_n^{k})$$ 我们发现，这两个结果只有一个符合是不同的 这就意味着，在计算第一个点值的时候，我们可以$O(1)$得到第二个点值 加上分治，可以将原问题的规模缩小一半 现在，我们可以做到$O(n\log n)$计算点值表示了 快速傅里叶逆变换(IFFT)假如我们知道多项式A与多项式B的点值表达 那么我们可以直接求出$A*B$的点值表达 很明显，对应相乘即可 但是我们得到的终究还是一个点值 而点值表达是不常用的，要还原成系数表达 幸运的是，这个操纵同样能在$O(n\log n)$内解决。 假设原来的多项式系数分别为$a_0,a_1,\cdots,a_n$ 点值表达为$y_0,y_1,\cdots,y_n$ 将这个y强制看作系数 同时，设多项式c为y在$\omega_n^0,\omega_n^{-1},\cdots,\omega_n^{-n+1}$处的点值 那么有 $$c_k=\sum_{i=0}^{n-1}y_i(\omega_n^{-k})^i$$ $$y_k=\sum_{i=0}^{n-1}a_i(\omega_n^k)^i$$ $$\therefore c_k=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}a_j(\omega_n^i)^j(\omega_n^{-k})^i$$ $$=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}a_j(\omega_n^j)^i(\omega_n^{-k})^i$$ $$\sum_{i=0}^{n-1}a_j\sum_{j=0}^{n-1}(\omega_n^{j-k})^i$$ 设 $$S(x)=\sum_{i=0}^{n-1}x^i$$ 代入$\omega_n^k$可得 $$S(\omega_n^k)=1+\omega_n^k+(\omega_n^k)^2+\cdots+(\omega_n^k)^{n-1}$$ 当$k\not =0$，可得 $$\omega_n^kS(\omega_n^k)=\omega_n^k+(\omega_n^k)^2+\cdots+(\omega_n^k)^{n-1}+(\omega_n^k)^n$$ 两式相减，得 $$\omega_n^kS(\omega_n^k)-S(\omega_n^k)=(\omega_n^k)^n-1$$ $$S(\omega_n^k)=\frac{(\omega_n^k)^n-1}{\omega_n^k-1}$$ $$=\frac{(\omega_n^n)^k-1}{\omega_n^k-1}=0$$ 当$k=0$时，显然$S(\omega_n^0)=1$ 代入之前的式子，可以得到 $$c_k=\sum_{i=0}^{n-1}a_j\sum_{j=0}^{n-1}(\omega_n^{j-k})^i$$ $$=na_k$$ $$a_k=\frac{c_k}{n}$$ 至此，点值就成功转换成系数了 关于迭代FFT这里记一下反转后的多项式在原多项式中的下标r 有 1r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1) 关于NTT模意义下的单位根就是原根g 有 $$\omega_n^1\equiv g^{\frac{mod-1}{n}}$$ 然后像FFT一样即可 关于complex好像还是很好用的 就是有点慢 需要的话可以手写一个 目测会快2到3倍的样子 部分代码实现FFT12345678910111213#define N 400010int r[N]; const double PI = acos(-1);inline void FFT(int len, int type, complex&lt;double&gt; a[]) &#123; for (int i = 0;i &lt; len;i++) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int mid = 2;mid &lt;= len;mid &lt;&lt;= 1) &#123; complex&lt;double&gt; Wn(cos(2 * PI / mid), type * sin(2 * PI / mid)); for (int i = 0;i &lt; len;i += mid) &#123; complex&lt;double&gt; w(1, 0), t; for (int j = i;j &lt; i + (mid &gt;&gt; 1);j++, w *= Wn) t = w * a[j + (mid &gt;&gt; 1)], a[j + (mid &gt;&gt; 1)] = a[j] - t, a[j] += t; &#125; &#125;&#125; NTT1234567891011121314151617#define N 200010#define LL long longint r[N]; const int mod = 998244353;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;inline void NTT(int len, int type, int a[]) &#123; for (int i = 0;i &lt; len;i++) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int mid = 2;mid &lt;= len;mid &lt;&lt;= 1) &#123; int Wn = Pow(3, type ? (mod - 1) / mid : mod - 1 - (mod - 1) / mid); for (int i = 0;i &lt; len;i += mid) for (int j = i, t, w = 1;j &lt; i + (mid &gt;&gt; 1);j++, w = (LL)w * Wn % mod) t = (LL)w * a[j + (mid &gt;&gt; 1)] % mod, a[j + (mid &gt;&gt; 1)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod; &#125;&#125; 最后别忘了除以len]]></content>
      <tags>
        <tag>多项式</tag>
        <tag>算法</tag>
        <tag>FFT</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.11省选模拟]]></title>
    <url>%2F2019%2F03%2F11%2F3-11%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[T1 树上四次求和 本来写的100分算法，结果只有80分 发现是链的情况挂了，原因是有一个取模的地方我把%=写成了%，然后就呵呵了 考虑如何化简那个式子$$\sum_{i=1}^k\sum_{j=i}^kw(i,j)\\=\sum_{i=1}^k\sum_{j=i}^k\sum_{l=i}^j\sum_{r=l}^jdis(a_l,a_r)\\$$考虑后面每一个$dis(a_l,a_r)$对答案的贡献，就是把$\sum$提到前面来$$=\sum_{l=1}^k\sum_{r=l}^kdis(a_l,a_r)*l*(k-r+1)$$但是这样仍然是$n^kq$，难以承受 那么我们考虑分开维护$$\sum_{i=1}^n\sum_{j=i}^ndis(a_i,a_j)*i*(n-j+1)\\=(n+1)\sum_{i=1}^ni\sum_{j=i}^ndis(a_i,a_j)-\sum_{i=1}^ni\sum_{j=i}^nj*dis(a_i,a_j)$$考虑将询问离线，当$n$变成$n+1$时式子将会如何变化 注意到第一项的系数$n+1​$与$n​$有关，所以把它去掉，考虑维护$\sum\limits_{i=1}^ni\sum\limits_{j=i}^ndis(a_i,a_j)​$ 那么有$$\sum\limits_{i=1}^{n+1}i\sum\limits_{j=i}^{n+1}dis(a_i,a_j)-\sum\limits_{i=1}^ni\sum\limits_{j=i}^ndis(a_i,a_j)\=\sum_{i=1}^ni*dis(a_i,a_{n+1})$$而对于后一项$$\sum_{i=1}^{n+1}i\sum_{j=i}^{n+1}j*dis(a_i,a_j)-\sum_{i=1}^ni\sum_{j=i}^nj*dis(a_i,a_j)\\=(n+1)\sum_{i=1}^ni*dis(a_i,a_{n+1})$$$n+1$是已知的，所以我们只需要维护$\sum\limits_{i=1}^ni*dis(a_i,a_{n+1})$就可以了 所以现在题目变成了给你一棵树，每个点有两种颜色，初始每个点都是黑色，有两种操作： 询问某个点到所有黑点的距离乘以该点编号的和 将某个白点改成黑点 那么很显然，直接动态点分治就可以了 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010typedef long long LL;const int mod = 998244353;struct edge &#123; int to, next;&#125; e[N * 2];int head[N], ecnt;inline void adde(int from, int to) &#123; e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;&#125;int fa[18][N], dep[N];void dfs(int u, int f) &#123; dep[u] = dep[f] + 1, fa[0][u] = f; for (int i = 1;i &lt;= 17;i++) fa[i][u] = fa[i - 1][fa[i - 1][u]]; for (int i = head[u];i;i = e[i].next) if (e[i].to != f) dfs(e[i].to, u);&#125;inline int LCA(int a, int b) &#123; if (dep[a] &lt; dep[b]) swap(a, b); for (int i = 17;i &gt;= 0;i--) if (dep[fa[i][a]] &gt;= dep[b]) a = fa[i][a]; for (int i = 17;i &gt;= 0;i--) if (fa[i][a] != fa[i][b]) a = fa[i][a], b = fa[i][b]; return a == b ? a : fa[0][a];&#125;;inline int Dis(int a, int b) &#123; return dep[a] + dep[b] - 2 * dep[LCA(a, b)];&#125;int vis[N], size[N];int Getsize(int u) &#123; vis[u] = size[u] = 1; for (int i = head[u];i;i = e[i].next) if (!vis[e[i].to]) size[u] += Getsize(e[i].to); return vis[u] = 0, size[u];&#125;int Getroot(int u, int tot) &#123; vis[u] = 1; for (int i = head[u],tmp;i;i = e[i].next) if (!vis[e[i].to] &amp;&amp; (tmp = Getroot(e[i].to, tot))) return vis[u] = 0, tmp; return vis[u] = 0, size[u] &gt;= (tot &gt;&gt; 1) ? u : 0;&#125;int F[18][N], D[18][N];int Build(int u) &#123; u = Getroot(u, Getsize(u)), vis[u] = 1; for (int i = head[u];i;i = e[i].next) if (!vis[e[i].to]) F[0][Build(e[i].to)] = u; return u;&#125;inline void Construct(int n) &#123; for (int i = 1;i &lt;= n;i++) if (F[0][i]) D[0][i] = Dis(F[0][i], i); for (int i = 1;i &lt;= 17;i++) for (int j = 1;j &lt;= n;j++) &#123; F[i][j] = F[i - 1][F[0][j]]; if (F[i][j]) D[i][j] = Dis(F[i][j], j); &#125;&#125;int cnt2[N], tot2[N], cnt1[N];inline int query(int u) &#123; int res2 = cnt2[u]; for (int i = 0;i &lt;= 17 &amp;&amp; F[i][u];i++) &#123; int ls = i ? F[i - 1][u] : u; res2 = ((res2 + (LL)cnt2[F[i][u]] - cnt1[ls] + (LL)D[i][u] * (tot2[F[i][u]] - tot2[ls])) % mod + mod) % mod; &#125; return res2;&#125;inline void update(int u, int id) &#123; (tot2[u] += id) %= mod, (cnt1[u] += (LL)D[0][u] * id % mod) %= mod; for (int i = 0;i &lt;= 17 &amp;&amp; F[i][u];i++) &#123; (cnt2[F[i][u]] += (LL)D[i][u] * id % mod) %= mod; (tot2[F[i][u]] += id) %= mod; (cnt1[F[i][u]] += (LL)D[i + 1][u] * id % mod) %= mod; &#125;&#125;int A[N], q[N], id[N], ans[N];bool cmp(int i, int j) &#123; return q[i] &lt; q[j];&#125;int main() &#123;// freopen("sumsumsum.in", "r", stdin), freopen("sumsumsum.out", "w", stdout); int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1, a, b;i &lt; n;i++) scanf("%d%d", &amp;a, &amp;b), adde(a, b); dfs(1, 0), Build(1), Construct(n); for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;A[i]); for (int i = 1;i &lt;= m;i++) scanf("%d", &amp;q[i]), id[i] = i; sort(id + 1, id + m + 1, cmp); int tmp1 = 0, tmp2 = 0; for (int i = 1, cur = 0;i &lt;= m;i++) &#123; while (cur &lt; q[id[i]]) &#123; int res = query(A[++cur]); (tmp1 += res) %= mod, (tmp2 += (LL)res * cur % mod) %= mod; update(A[cur], cur); &#125; ans[id[i]] = ((LL)tmp1 * (q[id[i]] + 1) % mod - tmp2 + mod) % mod; &#125; for (int i = 1;i &lt;= m;i++) printf("%d\n", ans[i]);&#125; T2 Cubelia 随机函数无关紧要，所以没有贴上来 我们考虑对于一个区间$[l,r]$求最大前缀和，答案是什么 很显然，这等价于从1开始，下标在$[l,r]$之间最大的前缀和，减去下标为$l-1$的前缀和 对于减去的那个东西，它是确定的，而且很好算，所以先不管他 问题转化为，有$n$个数，给出一段区间$[l,r]$，询问它所有子区间中最大数的和 我们先找出$[l,r]$中最大的那个数，假设它在$pos$ 那么我们可以把$[l,r]$所有的子区间分成3类 跨过$pos$ 左右端点都在$[l,pos)$中 左右端点都在$(pos,r]$中 对于第一种区间，它的答案很好计算 很显然，每一个这样的区间对答案的贡献一定是$a_{pos}$，$a$是那个位置对应的前缀和 而这样的区间一共有$(pos-l+1)(r-pos+1)$个 对于第二种区间，我们考虑设$f(i)​$表示两个端点都在$[l,n]​$的区间的权值之和 那么它可以被表示为$f(l)-f(pos)-[左端点在[l,pos)，右端点在[pos,n]的区间答案]$ 首先考虑$f$如何计算 很显然，这个$f$是可以预处理的 那么我们设$f_T(n)$表示左端点为$n$的区间的答案之和 那么显然有$f(n)=f(n+1)+f_T(n)$ 我们考虑$a_n$对$f_T(n)$的贡献 假设在$[l,r]$中，$a_n$都是最大的那个 那么对于右端点在$[n,r]$的区间，它的权值一定是$a_n$ 对于其它区间，$a_n$对它们已经没用了，因为有更大的数出现了 那么这些区间的答案就是$f_T(r+1)$，即左端点为$r+1$的区间权值总和 因为对于每一个被统计的区间，只要把$a_n,\cdots,a_r$拼在它的左边，就一定可以得到另一个区间，并且权值不变 所以有转移$$f_T(n)=a_n(r_n-n+1)+f_T(r+1)\\f(n)=f(n+1)+f_T(n)$$那么如何求这个$[左端点在[l,pos)，右端点在[pos,n]的区间答案]$呢 我们已经知道$pos$是$[l,r]$中最大值的位置，换句话说，$a_l,\cdots,a_{pos-1}$一定不会对这个值造成影响 我们把每个合法的区间从$pos$划分成两半 对于右半部分，答案就是$f_T(pos)$ 对于左半部分，左端点可以随意选择 对于每一个从$pos$开始的区间，它的左端点可以为$[l,pos)$中的任意一个数，而权值不变 所以这个东西等于$(pos-l)f_T(pos)$ 最后说一下细节 对于如何求$l_i,r_i$，单调栈即可 对于最后要减去什么，我们可以枚举区间左端点，即$$\sum_{i=l}^ra_{i-1}(r-i)$$即对于每一个左端点，它会被选择$r-i$次 我们分别维护$$p_1(n)=\sum_{i=1}^na_{i-1}\\p_2(n)=\sum_{i=1}^na_{i-1}i$$即可 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;#define N 2000010#define LL long longconst int mod = 998244353;LL pre[N], f[N], g[N], tf[N], tg[N], pre2[N], pre3[N]; int cur[21][N], lg[N], num[N];inline int Max(int a, int b) &#123; return pre[a] &gt; pre[b] ? a : b;&#125;int st[N], top, tl[N], tr[N];inline void Construct(int n) &#123; for (int i = 1;i &lt;= n;i++) &#123; pre[i] = pre[i - 1] + num[i], cur[0][i] = i, lg[i] = i == 1 ? 0 : lg[i &gt;&gt; 1] + 1; pre2[i] = pre2[i - 1] + pre[i - 1], pre3[i] = pre3[i - 1] + pre[i - 1] * i; &#125; for (int i = 1;i &lt;= 20;i++) for (int j = 1;j + (1 &lt;&lt; i) - 1 &lt;= n;j++) cur[i][j] = Max(cur[i - 1][j], cur[i - 1][j + (1 &lt;&lt; i - 1)]); for (int i = 1;i &lt;= n;i++) &#123; while (top &amp;&amp; pre[st[top]] &lt; pre[i]) tr[st[top--]] = i - 1; st[++top] = i; &#125; while (top) tr[st[top--]] = n; for (int i = n;i &gt;= 1;i--) &#123; while (top &amp;&amp; pre[st[top]] &lt; pre[i]) tl[st[top--]] = i + 1; st[++top] = i; &#125; while (top) tl[st[top--]] = 1; for (int i = 1;i &lt;= n;i++) &#123; tf[i] = tf[tl[i] - 1] + pre[i] * (i - tl[i] + 1); f[i] = f[i - 1] + tf[i]; &#125; for (int i = n;i &gt;= 1;i--) &#123; tg[i] = tg[tr[i] + 1] + pre[i] * (tr[i] - i + 1); g[i] = g[i + 1] + tg[i]; &#125;&#125;inline int query(int L, int R) &#123; int len = R - L + 1; return Max(cur[lg[len]][L], cur[lg[len]][R - (1 &lt;&lt; lg[len]) + 1]);&#125;inline LL solve(int L, int R) &#123; int pos = query(L, R); LL res = 0; res = pre[pos] * (R - pos + 1) * (pos - L + 1); res = res + g[L] - g[pos] - tg[pos] * (pos - L); res = res + f[R] - f[pos] - tf[pos] * (R - pos); return res - (pre2[R] - pre2[L - 1]) * (R + 1) + (pre3[R] - pre3[L - 1]);&#125;int S, A, B, P, tp; LL lastans;inline int Rand() &#123; S = (S * A % P + (B ^ (tp * lastans))) % P; S = S &lt; 0 ? -S : S; return S;&#125;int main() &#123; int n, q, l, r, res = 0; scanf("%d%d", &amp;n, &amp;q); for (int i = 1;i &lt;= n;i++) scanf("%d", &amp;num[i]); scanf("%d%d%d%d%d", &amp;S, &amp;A, &amp;B, &amp;P, &amp;tp); Construct(n); while (q--) &#123; l = Rand() % n + 1, r = Rand() % n + 1; if (l &gt; r) swap(l, r); lastans = solve(l, r), res = (res + lastans) % mod; &#125; printf("%d\n", (res + mod) % mod);&#125; T3 Cuvelia 这可能是这次比赛最简单的题吧 假设一次询问给出的点是$a_1,a_2,\cdots,a_k$ 由于等于的传递性，我们只需要满足$dis(a_i,m)=dis(a_{i+1},m)$即可 所以我们一共有$k-1$个限制 如果每个限制我们能确定在树上有哪些节点合法，那么通过求他们的交集我们就能够确定最后的答案 考虑一个限制有哪些点合法 假设这两个点是$u,v$ 如果这两个点的距离为奇数，那么显然不存在满足条件的点 我们考虑这样一种情况 $u,v$两点的中点是$mid$，首先$mid$一定是合法的 其次，在以$mid$为根的树中，除$u,v$所在的子树都是合法的，即图中橙色的点 所以每次我们都是选定一个根，然后划去两棵子树 我们知道每棵子树的dfs序都是连续的，由于我们要求交集，所以可以使用线段树维护 具体来说，我们可以分两种情况： $mid$是$u,v$的$lca$ 此时直接找到$u,v$所对应的$lca$的两棵子树，划去这两棵子树即可 $mid$不是$u,v$的$lca$ 那么以$mid$为根时，一定会划去它父亲所在的子树，假设$mid$在以1为根的树中对应的dfs序是dfn[mid],end[mid] 此时dfs序在[1, dfn[mid] - 1], [end[mid] + 1, n]的点一定不合法，需要划去 也只有这两种情况了 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;#define N 300010struct node &#123; int l, r, sum, lazy;&#125; T[N &lt;&lt; 2];inline void pushup(int rt) &#123; T[rt].sum = T[rt &lt;&lt; 1].sum + T[rt &lt;&lt; 1 | 1].sum;&#125;inline void pushdown(int rt) &#123; if (T[rt].lazy == 1) T[rt &lt;&lt; 1].sum = T[rt &lt;&lt; 1 | 1].sum = 0, T[rt &lt;&lt; 1].lazy = T[rt &lt;&lt; 1 | 1].lazy = 1, T[rt].lazy = 0; if (T[rt].lazy == 2) &#123; int l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; 1; T[rt &lt;&lt; 1].sum = mid - l + 1, T[rt &lt;&lt; 1 | 1].sum = r - mid; T[rt &lt;&lt; 1].lazy = T[rt &lt;&lt; 1 | 1].lazy = 2, T[rt].lazy = 0; &#125; &#125; inline void build(int rt, int l, int r) &#123; T[rt].l = l, T[rt].r = r; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(rt &lt;&lt; 1, l, mid), build(rt &lt;&lt; 1 | 1, mid + 1, r);&#125;inline void modify(int rt, int start, int end, int x) &#123; int l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; 1; if (start &lt;= l &amp;&amp; r &lt;= end) &#123; T[rt].sum = x ? r - l + 1 : 0, T[rt].lazy = x + 1; return; &#125; if (T[rt].lazy) pushdown(rt); if (start &lt;= mid) modify(rt &lt;&lt; 1, start, end, x); if (end &gt; mid) modify(rt &lt;&lt; 1 | 1, start, end, x); pushup(rt);&#125;inline void mark(int start, int end) &#123; modify(1, start, end, 1);&#125;inline void reset() &#123; T[1].sum = 0, T[1].lazy = 1;&#125;inline int query() &#123; return T[1].r - T[1].l + 1 - T[1].sum;&#125;struct edge &#123; int to, next;&#125; e[N * 2];int head[N], ecnt;inline void adde(int from, int to) &#123; e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;&#125;int fa[18][N], dep[N], dfn[N], ed[N], dfsn;void dfs(int u, int f) &#123; fa[0][u] = f, dep[u] = dep[f] + 1, dfn[u] = ++dfsn; for (int i = 1;i &lt;= 17;i++) fa[i][u] = fa[i - 1][fa[i - 1][u]]; for (int i = head[u];i;i = e[i].next) if (e[i].to != f) dfs(e[i].to, u); ed[u] = dfsn;&#125;inline int LCA(int a, int b) &#123; if (dep[a] &lt; dep[b]) swap(a, b); for (int i = 17;i &gt;= 0;i--) if (dep[fa[i][a]] &gt;= dep[b]) a = fa[i][a]; if (a == b) return a; for (int i = 17;i &gt;= 0;i--) if (fa[i][a] != fa[i][b]) a = fa[i][a], b = fa[i][b]; return fa[0][a];&#125;inline int Jump(int a, int t) &#123; for (int i = 17;i &gt;= 0;i--) if (t &amp; (1 &lt;&lt; i)) a = fa[i][a]; return a;&#125;inline bool solve(int a, int b) &#123; if (dep[a] &lt; dep[b]) swap(a, b); if ((dep[a] + dep[b]) &amp; 1) return false; int lca = LCA(a, b); int mid = (dep[a] + dep[b] - 2 * dep[lca]) &gt;&gt; 1, cent = Jump(a, mid); if (cent == lca) &#123; a = Jump(a, mid - 1), b = Jump(b, mid - 1); mark(dfn[a], ed[a]), mark(dfn[b], ed[b]); &#125; else &#123; a = Jump(a, mid - 1); mark(dfn[a], ed[a]), mark(1, dfn[cent] - 1), mark(ed[cent] + 1, ed[1]); &#125; return true;&#125;int node[N];int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1, a, b;i &lt; n;i++) scanf("%d%d", &amp;a, &amp;b), adde(a, b); dfs(1, 0), build(1, 1, n); while (m--) &#123; reset(); int k, flag = 1; scanf("%d", &amp;k); for (int i = 1;i &lt;= k;i++) scanf("%d", &amp;node[i]); for (int i = 1;i &lt; k &amp;&amp; flag;i++) flag = solve(node[i], node[i + 1]); if (!flag) printf("0\n"); else printf("%d\n", query()); &#125;&#125; 总结这次考试很不理想，主要范了两个错误 一是第一题把代码打错了，%=打成了%，丢了20分 二是第三题数组开小了，丢了40分 第三题没有深入思考，考试时只想到了相邻两个求交集，没有想到用线段树维护 对于第二题，我觉得需要多做一些这样的题，积累经验 orz WKR]]></content>
      <tags>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>数据结构</tag>
        <tag>点分治</tag>
        <tag>线段树</tag>
        <tag>动态点分治</tag>
        <tag>rmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性递推]]></title>
    <url>%2F2019%2F03%2F10%2F%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8%2F</url>
    <content type="text"><![CDATA[求一个满足$k$阶齐次线性递推数列$a_i$的第$n​$项 即：$a_n=\sum\limits_{i=1}^kf_i\times a_{n-i}$ 已知$f$，以及$a_0,a_1,\cdots,a_{k-1}$$$n\leq 10^9, k\leq 32000$$如果$k$小一点，那么直接矩阵乘法是可以的 但是这个是$O(k^3\log n)$的，时间复杂度难以承受 注意到这个是其次线性递推，也就是说，我们构造出的矩阵只有第一行是$f​$，其余的行上全是1和0 我们设这个矩阵是$A$，现在有一个奇妙的序列$c$使得$$A^n=\sum_{i=0}^{k-1}c_iA^i$$我们设初始列向量是$base$，那么有$$A^n\times base=\sum_{i=0}^{k-1}c_iA^i\times base\$$在矩阵运算中，我们只取第一行的值，那么有$$a_n=\sum_{i=0}^{k-1}c_ia_i$$这也就是说，如果我们成功地构造出了这个$c$，那么我们就可以使用$a$的前$k$项推出$a_n$ 我们重新考虑之前的那个式子$$A^n=\sum_{i=0}^{k-1}c_iA^i$$它一定可以被写成这样的式子$$A^n=Q(A)G(A)+R(A)$$即$$R(A)=A^n\mod G(A)$$ 其中$Q,G,R$都是以矩阵为参数的函数 我们令这个$G$的次数为$k$，那么$R$的次数为$k-1$ 如果存在一个函数$G$，使得对于$A$，有$G(A)=0$，那么前面的$Q(A)G(A)$就可以消去，从而使得$A^n=R(A)$ 此时多项式$R$的每一项的系数，就对应着之前我们需要构造的$c$ 所以实际上我们要构造一个序列$g$，使得$$\sum_{i=0}^kg_iA^i=0$$这里先上结论：对于满足题意的递推系数$f$，有$g_i=-f_{k-i},g_k=1$ 注意这里我们需要把这个$f$倒过来再取相反数，因为我们把列向量倒过来了，即从上到下分别为$a_0,a_1,\cdots,a_{k-1} $ 注意$f$的下标是从1到$k$，$g$是从0到$k​$ 计算的时候就像快速幂一样，只不过模的是一个多项式$G$ 证明过程之后再补 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;#define N 202010const int mod = 998244353;typedef long long LL;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;int r[N];inline void NTT(int a[], int len, int type) &#123; for (int i = 1;i &lt; len;i++) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int mid = 2;mid &lt;= len;mid &lt;&lt;= 1) &#123; int Wn = Pow(3, type ? (mod - 1) / mid : mod - 1 - (mod - 1) / mid); for (int i = 0;i &lt; len;i += mid) for (int j = i, w = 1, t;j &lt; i + (mid &gt;&gt; 1);j++, w = (LL)w * Wn % mod) t = (LL)w * a[j + (mid &gt;&gt; 1)] % mod, a[j + (mid &gt;&gt; 1)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod; &#125; if (!type) for (int inv = Pow(len, mod - 2), i = 0;i &lt; len;i++) a[i] = (LL)a[i] * inv % mod;&#125;int tmp[N];// b[i] = 2 * b'[i] - a[i] * b'[i] * b'[i]inline void Inv(const int a[], int b[], int n) &#123; if (n == 1) return void(b[0] = Pow(a[0], mod - 2)); Inv(a, b, (n + 1) &gt;&gt; 1); int l = 0, len = 1; while (len &lt;= n * 3) l++, len &lt;&lt;= 1; for (int i = 1;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); for (int i = 0;i &lt; n;i++) tmp[i] = a[i]; for (int i = n;i &lt; len;i++) tmp[i] = 0; NTT(tmp, len, 1), NTT(b, len, 1); for (int i = 0;i &lt; len;i++) b[i] = (2 - (LL)tmp[i] * b[i] % mod + mod) % mod * b[i] % mod; NTT(b, len, 0); for (int i = n;i &lt; len;i++) b[i] = 0;&#125;int tmpa[N], tmpb[N], tmpc[N], binv[N];inline void Div(const int a[], const int b[], int c[], int d[], int n, int m) &#123;// memset(tmpa, 0, sizeof(tmpa)), memset(tmpb, 0, sizeof(tmpb)), memset(tmpc, 0, sizeof(tmpc)), memset(binv, 0, sizeof(binv)); for (int i = 0;i &lt; n * 6 - m * 6 + 1;i++) tmpa[i] = tmpb[i] = tmpc[i] = binv[i] = 0; for (int i = 0;i &lt;= n - m;i++) tmpa[i] = a[n - i]; for (int i = 0;i &lt;= m;i++) tmpb[i] = b[m - i]; Inv(tmpb, binv, n - m + 1); int l = 0, len = 1; while (len &lt;= n * 2 - m * 2) l++, len &lt;&lt;= 1; for (int i = 1;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); NTT(tmpa, len, 1), NTT(binv, len, 1); for (int i = 0;i &lt; len;i++) c[i] = (LL)tmpa[i] * binv[i] % mod; NTT(c, len, 0); for (int i = n - m + 1;i &lt; len;i++) c[i] = 0; for (int i = 0;i * 2 &lt; n - m;i++) swap(c[i], c[n - m - i]); l = 0, len = 1; while (len &lt;= n) l++, len &lt;&lt;= 1; for (int i = 1;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); for (int i = 0;i &lt;= n;i++) tmpa[i] = a[i]; for (int i = 0;i &lt;= m;i++) tmpb[i] = b[i]; for (int i = 0;i &lt;= n - m;i++) tmpc[i] = c[i]; NTT(tmpa, len, 1), NTT(tmpb, len, 1), NTT(tmpc, len, 1); for (int i = 0;i &lt; len;i++) d[i] = (tmpa[i] - (LL)tmpb[i] * tmpc[i] % mod + mod) % mod; NTT(d, len, 0); for (int i = m;i &lt; len;i++) d[i] = 0;&#125;int base[N], f[N], res[N], del[N], A[N], rub[N];inline void mul(int a[], const int b[], const int c[], int k) &#123; int l = 0, len = 1; while (len &lt;= k * 2) len &lt;&lt;= 1, l++; for (int i = 1;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); for (int i = 0;i &lt;= k;i++) tmpb[i] = b[i]; for (int i = k + 1;i &lt; len;i++) tmpb[i] = 0; NTT(a, len, 1), NTT(tmpb, len, 1); for (int i = 0;i &lt; len;i++) del[i] = (LL)a[i] * tmpb[i] % mod; NTT(del, len, 0), Div(del, c, rub, a, k * 2, k);&#125;int main() &#123; int n, k, ans = 0; scanf("%d%d", &amp;n, &amp;k), f[k] = 1; for (int i = 1;i &lt;= k;i++) scanf("%d", &amp;f[k - i]), (f[k - i] = mod - f[k - i]) %= mod; for (int i = 0;i &lt; k;i++) scanf("%d", &amp;base[i]), (base[i] += mod) %= mod; res[0] = 1, A[1] = 1; for (;n;n &gt;&gt;= 1, mul(A, A, f, k)) if (n &amp; 1) mul(res, A, f, k); for (int i = 0;i &lt; k;i++) ans = (ans + (LL)res[i] * base[i]) % mod; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>多项式求逆</tag>
        <tag>多项式除法</tag>
        <tag>多项式</tag>
        <tag>算法</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.8省选模拟 斐波那契树]]></title>
    <url>%2F2019%2F03%2F09%2F3-8%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[$$n,q\leq 2*10^5$$ 不知道出题人怎么想的，模$10^9+7$而不是$10^9+9$，$5$在模$10^9+7$下没有二次剩余 我们知道斐波那契数列是可以叠加的，也就是一个斐波那契数列加上另一个斐波那契数列仍然是斐波那契数列 那么我们只需要维护这个数列的第0项和第1项就可以了 由于5没有二次剩余，所以可以通过预处理/矩阵乘法求得数列的第$k$项 考虑如何维护这两个操作 很显然，这是一个动态点分治 对于点分树上的每一个点，我们维护两个树状数组 两个数组都是根据深度建的，但是一个维护它对它自己子树的贡献，另一个维护它对它父亲的贡献 比如现在要处理第一个询问 将$u$往上跳，假设它的第$i$级祖先是F[i][u]，它距离这个祖先的距离是D[i][u] 那么现在$u$可以经过这个祖先，到达这个祖先的其它子树 我们知道，距离$m$以内的点都会被更新 当$u$跳到这个祖先的时候，这个距离还剩下m - D[i][u] 也就是说，这个祖先所有离它不超过m - D[i][u]的点都会被更新 这对应着树状数组上的一段前缀和 当然，我们还要算出$a,b$在这一级祖先变成了多少 查询的时候，也是跳它的祖先 对于每一级祖先，我们知道它距离这个祖先的距离，以及在它这个深度累加的答案 那么我们就可以算出这个祖先对它的贡献 但是这样会重复计数 我们考虑这样一种情况：$u$的某一级祖先是$f$，第一个询问更新了$u$，这导致$f$也更新了 现在要查询$v$，其中$v,u$在$f$的同一棵子树内 之前更新祖先时依据是$u$经过这个祖先，到达这个祖先其它子树的点 然而现在$u$不需要经过$f$，就可以到达$v$ 当跳到$f$的时候，$u$的贡献又会被算一次，这样就重复计数了 解决方法是同时维护每个节点对它父亲的贡献 查询的时候，假设$u$的上一级祖先是$f$，那么我们查$f$对子树的贡献，减去$u$对其父亲$f$的贡献，就可以了 动态点分治要注意内存开销 还是vector+树状数组比较妥当 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;bits/stdc++.h&gt;#pragma GCC optimize(3)using namespace std;const int mod = 1e9 + 7;typedef long long LL;typedef pair&lt;int, int&gt; P;#define N 200010inline void Inc(int &amp;x, int y) &#123;x += y, x -= x &gt;= mod ? mod : 0;&#125;inline void Dec(int &amp;x, int y) &#123;x = x + mod - y, x -= x &gt;= mod ? mod : 0;&#125;inline void Inc(P &amp;x, P y) &#123;Inc(x.first, y.first), Inc(x.second, y.second);&#125;inline void Dec(P &amp;x, P y) &#123;Dec(x.first, y.first), Dec(x.second, y.second);&#125;namespace FIB &#123; struct Matrix &#123; int a[3][3]; Matrix() &#123;memset(a, 0, sizeof(a));&#125; Matrix operator * (const Matrix &amp;b) &#123; Matrix c; for (int i = 1;i &lt;= 2;i++) for (int j = 1;j &lt;= 2;j++) for (int k = 1;k &lt;= 2;k++) Inc(c.a[i][j], (LL)a[i][k] * b.a[k][j] % mod); return c; &#125; &#125;; inline Matrix Pow(Matrix x, int y) &#123; Matrix res; res.a[1][1] = res.a[2][2] = 1; for (;y;y &gt;&gt;= 1, x = x * x) if (y &amp; 1) res = res * x; return res; &#125; inline int Kth(P x, int k) &#123; Matrix base; base.a[1][1] = base.a[1][2] = base.a[2][1] = 1; if (k == 0) return x.first; if (k == 1) return x.second; base = Pow(base, k - 1); return ((LL)base.a[1][1] * x.second + (LL)base.a[1][2] * x.first) % mod; &#125; &#125;vector&lt;P &gt; tree[2][N];inline void add(int type, int id, int x, P y) &#123; x = min(x + 1, (int)tree[type][id].size() - 1); for (;x;x -= x &amp; -x) Inc(tree[type][id][x], y);&#125;inline P que(int type, int id, int x) &#123; P res; x++; for (;x &lt; tree[type][id].size();x += x &amp; -x) Inc(res, tree[type][id][x]); return res;&#125;struct edge &#123; int to, next;&#125; e[N * 2];int head[N], ecnt;inline void adde(int from, int to) &#123; e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;&#125;int dep[N], fa[20][N];void dfs(int u, int f) &#123; fa[0][u] = f, dep[u] = dep[f] + 1; for (int i = 1;i &lt;= 19;i++) fa[i][u] = fa[i - 1][fa[i - 1][u]]; for (int i = head[u];i;i = e[i].next) if (e[i].to != f) dfs(e[i].to, u);&#125;inline int LCA(int a, int b) &#123; if (dep[a] &lt; dep[b]) swap(a, b); for (int i = 19;i &gt;= 0;i--) if (dep[fa[i][a]] &gt;= dep[b]) a = fa[i][a]; if (a == b) return a; for (int i = 19;i &gt;= 0;i--) if (fa[i][a] != fa[i][b]) a = fa[i][a], b = fa[i][b]; return fa[0][a];&#125;inline int Dis(int a, int b) &#123; return dep[a] + dep[b] - 2 * dep[LCA(a, b)];&#125;int vis[N], size[N], mxd[N];int Getsize(int u) &#123; vis[u] = size[u] = 1; for (int i = head[u];i;i = e[i].next) if (!vis[e[i].to]) size[u] += Getsize(e[i].to); return vis[u] = 0, size[u];&#125;int Getroot(int u, int tot) &#123; vis[u] = 1; for (int i = head[u], tmp;i;i = e[i].next) if (!vis[e[i].to] &amp;&amp; (tmp = Getroot(e[i].to, tot))) return vis[u] = 0, tmp; return vis[u] = 0, size[u] &gt;= (tot &gt;&gt; 1) ? u : 0;&#125;int Getdep(int u) &#123; int res = 1; vis[u] = 1; for (int i = head[u];i;i = e[i].next) if (!vis[e[i].to]) res = max(res, Getdep(e[i].to) + 1); return vis[u] = 0, res;&#125;int F[20][N], D[20][N];int Build(int u) &#123; u = Getroot(u, Getsize(u)), vis[u] = 1; int deep = 0; for (int i = head[u];i;i = e[i].next) if (!vis[e[i].to]) deep = max(deep, Getdep(e[i].to)); tree[0][u].resize(deep + 2), mxd[u] = deep; for (int i = head[u];i;i = e[i].next) if (!vis[e[i].to]) F[0][Build(e[i].to)] = u; return u;&#125;inline void Construct(int n) &#123; for (int i = 1;i &lt;= n;i++) if (F[0][i]) D[0][i] = Dis(F[0][i], i); for (int i = 1;i &lt;= 19;i++) for (int j = 1;j &lt;= n;j++) &#123; F[i][j] = F[i - 1][F[0][j]]; if (F[i][j]) D[i][j] = Dis(F[i][j], j); &#125; for (int i = 1;i &lt;= n;i++) tree[1][i].resize(mxd[F[0][i]] + 2);&#125;inline void update(int x, int dis, P data) &#123; add(0, x, dis, data); for (int i = 0;i &lt;= 19 &amp;&amp; F[i][x];i++) if (D[i][x] &lt;= dis) &#123; int ta = FIB::Kth(data, D[i][x]), tb = FIB::Kth(data, D[i][x] + 1); add(0, F[i][x], dis - D[i][x], P(ta, tb)); add(1, i ? F[i - 1][x] : x, dis - D[i][x], P(ta, tb)); &#125;&#125;inline int query(int x) &#123; int res = que(0, x, 0).first; for (int i = 0;i &lt;= 19 &amp;&amp; F[i][x];i++) &#123; Inc(res, FIB::Kth(que(0, F[i][x], D[i][x]), D[i][x])); Dec(res, FIB::Kth(que(1, i ? F[i - 1][x] : x, D[i][x]), D[i][x])); &#125; return res;&#125;int __rd;inline void read(int &amp;x) &#123; x = 0; char c = getchar(); while (c &lt; '0' || c &gt; '9') c = getchar(); while ('0' &lt;= c &amp;&amp; c &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - '0', c = getchar();&#125;#define RD (read(__rd), __rd)int main() &#123;// freopen("fibtree.in", "r", stdin); int n = RD, q = RD; for (int i = 1, a, b;i &lt; n;i++) a = RD, b = RD, adde(a, b); dfs(1, 0), Build(1), Construct(n); while (q--) &#123; int op = RD, a = RD, b, c, d; if (op == 1) b = RD, c = RD, d = RD, update(a, b, P(c, d)); else printf("%d\n", query(a)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>点分治</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式除法]]></title>
    <url>%2F2019%2F03%2F09%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%99%A4%E6%B3%95%2F</url>
    <content type="text"><![CDATA[已知多项式$F(x),G(x)​$，求出多项式$Q(x),R(x)​$，使得在模$998244353​$意义下，有$$F(x)=Q(x)G(x)+R(x) \mod 998244353$$其中$F$的次数为$n$，$G$的次数为$m$ 那么我们知道$Q$是一个$n-m$次的多项式，而$R$是一个$m-1$次的多项式 我们定义变换$R$，满足$$F_R(x)=x^nF(\frac 1x)$$我们考虑这个$R$是怎么得到的 假设有$$F(x)=a_0+a_1x+a_2x^2+\cdots+a_nx^n$$代入$\frac 1x$之后我们得到$$F(\frac 1x)=a_0+\frac{a_1}{x}+\frac{a_2}{x^2}+\cdots+\frac{a_n}{x^n}$$再乘以$x^n$$$x^nF(\frac 1x)=a_n+a_{n-1}x+a_{n-2}x^2+\cdots+a_0x^n$$我们发现，得到的结果就是把原来多项式的系数反过来，就是$R​$变换 那么有$$F(x)=Q(x)G(x)+R(x)$$代入$\frac 1x$$$F(\frac 1x)=Q(\frac 1x)G(\frac 1x)+R(\frac 1x)$$同时乘以$x^n$$$x^nF(\frac 1x)=x^{n-m}Q(\frac 1x)x^mG(\frac 1x)+x^{n-m+1}*x^{m-1}R(\frac 1x)\\F_R(x)=Q_R(x)G_R(x)+x^{n-m+1}R_R(x)$$考虑如何把最后那个余数$R$给搞掉 注意到它乘了一个系数 那么我们直接在模$x^{n-m+1}$下运算即可 此时有$$F_R(x)=Q_R(x)G_R(x)\mod x^{n-m+1}\\Q_R(x)=\frac{F_R(x)}{G_R(x)}\mod x^{n-m+1}$$所以我们求出$G_R$在模$x^{n-m+1}$下的逆，再乘上$F_R$就可以得到$G_R$ 由于$Q​$的次数就是$n-m​$，所以此时求出的模意义下的$Q_R​$等价于$Q_R​$ 注意此时$F_R,G_R​$都是$n-m​$次多项式 我们求出了$Q_R​$，将它倒序可以得到$Q​$，然后将$Q​$代入$F(x)=Q(x)G(x)+R(x)​$，就可以求出$R​$了 代码如下（有点毒瘤） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;#define N 600010typedef long long LL;int r[N]; const int mod = 998244353;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1,x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;inline void NTT(int a[], int len, int type) &#123; for (int i = 1;i &lt; len;i++) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int mid = 2;mid &lt;= len;mid &lt;&lt;= 1) &#123; int Wn = Pow(3, type ? (mod - 1) / mid : mod - 1 - (mod - 1) / mid); for (int i = 0;i &lt; len;i += mid) for (int j = i, w = 1, t;j &lt; i + (mid &gt;&gt; 1);j++, w = (LL)w * Wn % mod) t = (LL)w * a[j + (mid &gt;&gt; 1)] % mod, a[j + (mid &gt;&gt; 1)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod; &#125; if (!type) &#123; int Inv = Pow(len, mod - 2); for (int i = 0;i &lt; len;i++) a[i] = (LL)a[i] * Inv % mod; &#125;&#125;int tmp[N];inline void Inv(const int a[], int b[], int n) &#123; if (n == 1) return void(b[0] = Pow(a[0], mod - 2)); Inv(a, b, (n + 1) &gt;&gt; 1); int l = 0, len = 1; while (len &lt;= n * 3) len &lt;&lt;= 1, l++; for (int i = 1;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); for (int i = 0;i &lt; n;i++) tmp[i] = a[i]; for (int i = n;i &lt; len;i++) tmp[i] = 0; NTT(tmp, len, 1), NTT(b, len, 1); for (int i = 0;i &lt; len;i++) b[i] = (2 - (LL)tmp[i] * b[i] % mod + mod) % mod * b[i] % mod; NTT(b, len, 0); for (int i = n;i &lt; len;i++) b[i] = 0;&#125;int tmpa[N], tmpb[N], binv[N], tmpc[N];inline void Div(const int a[], const int b[], int c[], int d[], int n, int m) &#123; for (int i = 0;i &lt;= n - m;i++) tmpa[i] = a[n - i]; for (int i = 0;i &lt;= m;i++) tmpb[i] = b[m - i]; Inv(tmpb, binv, n - m + 1); int l = 0, len = 1; while (len &lt;= 2 * n - 2 * m) len &lt;&lt;= 1, l++; for (int i = 1;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); NTT(tmpa, len, 1), NTT(binv, len, 1); for (int i = 0;i &lt; len;i++) c[i] = (LL)tmpa[i] * binv[i] % mod; NTT(c, len, 0); for (int i = n - m + 1;i &lt; len;i++) c[i] = 0; for (int i = 0;i * 2 &lt; n - m;i++) swap(c[i], c[n - m - i]); for (int i = 0;i &lt;= n;i++) tmpa[i] = a[i]; for (int i = 0;i &lt;= m;i++) tmpb[i] = b[i]; for (int i = 0;i &lt;= n - m;i++) tmpc[i] = c[i]; l = 0, len = 1; while (len &lt;= n) len &lt;&lt;= 1, l++; for (int i = 1;i &lt; len;i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); NTT(tmpa, len, 1), NTT(tmpb, len, 1), NTT(tmpc, len, 1); for (int i = 0;i &lt; len;i++) d[i] = (tmpa[i] - (LL)tmpb[i] * tmpc[i] % mod + mod) % mod; NTT(d, len, 0); for (int i = m;i &lt; len;i++) d[i] = 0;&#125;int A[N], B[N], C[N], D[N];int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 0;i &lt;= n;i++) scanf("%d", &amp;A[i]); for (int i = 0;i &lt;= m;i++) scanf("%d", &amp;B[i]); Div(A, B, C, D, n, m); for (int i = 0;i &lt;= n - m;i++) printf("%d ", C[i]); puts(""); for (int i = 0;i &lt; m;i++) printf("%d ", D[i]); return 0;&#125;]]></content>
      <tags>
        <tag>多项式求逆</tag>
        <tag>多项式除法</tag>
        <tag>多项式</tag>
        <tag>算法</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式求逆]]></title>
    <url>%2F2019%2F03%2F09%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E9%80%86%2F</url>
    <content type="text"><![CDATA[有$A(x)*B(x)\equiv1\mod x^n$，已知$A$，求$B$，每一项的系数模$998244353$ 考虑分治，假设我们已经求出了$A$在模$x^{\lfloor\frac n2\rfloor}$下的逆$B’$ 那么有 $$A(x)B’(x)\equiv 1 \mod x^{\lceil\frac n2\rceil}$$ $$A(x)B(x)\equiv 1 \mod x^{\lceil\frac n2\rceil}$$ 可以推出 $$B’(x)-B(x)\equiv 0\mod x^{\lceil\frac n2\rceil}$$ 两边同时平方 $$(B’(x)-B(x))^2\equiv 0\mod x^n$$ 展开 $$B(x)^2-2B’(x)B(x)+B’(x)^2\equiv 0\mod x^n$$ 同时乘以A $$B(x)-2B’(x)+A(x)B’(x)^2\equiv 0\mod x^n$$ $$B(x)\equiv 2B’(x)-A(x)B’(x)^2\mod x^n$$ 注意分治的时候我们只关心所有多项式的前n项，大于n项的常数需要置0 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;#define N 600010#define LL long longconst int mod = 998244353;inline int Pow(int x, int y) &#123; int res = 1; for (; y; y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;struct Poly &#123; static int r[N], len, l; int A[N]; Poly() &#123;memset(A, 0, sizeof(A));&#125; inline static void Reset(int _n) &#123; Poly::l = 0, Poly::len = 1; while (len &lt;= _n) len &lt;&lt;= 1, l++; for (int i = 1; i &lt; len; i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; l - 1); &#125; void operator *= (int type) &#123; for (int i = 1; i &lt; len; i++) if (i &lt; r[i]) swap(A[i], A[r[i]]); for (int mid = 2; mid &lt;= len; mid &lt;&lt;= 1) for (int i = 0; i &lt; len; i += mid) &#123; int Wn = Pow(3, type ? (mod - 1) / mid : mod - 1 - (mod - 1) / mid); for (int j = i, w = 1, t; j &lt; i + (mid &gt;&gt; 1); j++, w = (LL)w * Wn % mod) t = (LL)w * A[j + (mid &gt;&gt; 1)] % mod, A[j + (mid &gt;&gt; 1)] = (A[j] - t + mod) % mod, A[j] = (A[j] + t) % mod; &#125; &#125;&#125;;int Poly::r[N], Poly::len, Poly::l;// b(x) = 2b'(x) - a(x)b'(x) ^ 2inline void Inv(const Poly &amp;a, Poly &amp;b, int n) &#123; if (n == 1) return void(b.A[0] = Pow(a.A[0], mod - 2)); else Inv(a, b, (n + 1) &gt;&gt; 1); Poly c(a); Poly::Reset(n * 3); int l = Poly::len; for (int i = n; i &lt; l; i++) c.A[i] = 0; c *= 1, b *= 1; for (int i = 0;i &lt; l;i++) b.A[i] = (2 - (LL)c.A[i] * b.A[i] % mod + mod) % mod * b.A[i] % mod; b *= 0; int inv = Pow(l, mod - 2); for (int i = 0;i &lt; l;i++) b.A[i] = (LL)b.A[i] * inv % mod; for (int i = n;i &lt; l;i++) b.A[i] = 0;&#125;int main() &#123; Poly a, b; int n; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;a.A[i]); Inv(a, b, n); for (int i = 0; i &lt; n; i++) printf("%d ", b.A[i]);&#125;]]></content>
      <tags>
        <tag>多项式求逆</tag>
        <tag>多项式</tag>
        <tag>算法</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.8省选模拟 奇怪的树]]></title>
    <url>%2F2019%2F03%2F08%2F3-8%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F-%E5%A5%87%E6%80%AA%E7%9A%84%E6%A0%91%2F</url>
    <content type="text"><![CDATA[$$n\leq 3*10^5$$树链剖分好题，链上维护虚子树信息 我们考虑如何更新一条链 假设询问节点是$u$，$AC$是一条重链，$PB$是一条轻链，$P$是一个奇怪的节点 那么我们知道，此时$B$的点权加上了$P$ 如果$A$的下方还连接着一个奇怪的点$P_1$，那么$B$也会加上$P_1$的权值 而此时$C$不会加上$P_1$的权值，因为它不是lca 所以当$u$从一条链的顶端跳到另一条链时，对于$u$的父亲我们需要特殊考虑贡献，对于这条链上其它的点，权值都会加上在其子树中，且不在其重儿子子树中的奇怪的点的编号之和 这个东西不是很好维护，那么我们考虑维护它所乘的系数，即它的权值加了多少次不在重儿子的奇怪的点的编号之和 这样的话，我们只需要实现区间加1就可以了 我们另开一个数组ans，表示每个点除了那个区间加1以外的贡献 比如之前提到的$u$的父亲，我们就将它的重儿子所在的子树中奇怪的点的编号之和加入ans 假如一个点加了$a_i$次1，在它的子树中，且不在它重儿子的子树中的奇怪的点的编号之和为$b_i$，那么一个点最终的答案就是$a_ib_i+ans_i$ 12345678inline void Tupdate1(int u) &#123; ans[u] += query(1, id[u], 2); while (u) &#123; update(1, id[top[u]], id[u], 0, 1); // 区间ai + 1 u = top[u], ans[fa[u]] += query(1, id[fa[u]], 2) - query(1, id[u], 1) - query(1, id[u], 2); // 特殊处理链顶的父亲，注意要减去u自己所在的子树的贡献 u = fa[u]; &#125;&#125; 我们考虑如何实现询问2 我们记一个点的非重儿子子树中，奇怪的点的点权之和是$V_u$ 其重儿子子树中，奇怪的点的点权之和是$W_u$ 如果把$u$的状态改变了，那么这会影响一些点的$V_u$和$W_u$ 仍然考虑这张图 对于$B$，它的$V$变化而$W$不变化 对于$C$，它的$W$变化而$V$不变化 对于$A$，它的$W$和$V$都不变化 我们仍然将$B$视为特殊点，特殊处理贡献 注意到之前我们维护了$V_u$的贡献系数 而这里$B$的$V$值更新了，那么这会导致答案多统计一部分 方法是，在更新$B$之前，将$a_bV_b$下放到ans[b]，然后将$a_b$清零 注意最开始$u$还没有向上爬的时候，$u$节点本身也是一个特殊点 1234567891011inline void Tupdate2(int u) &#123; int tmp = mark[u] ? -u : u; mark[u] ^= 1; // 权值更改的值 LL del = query(1, id[u], 0); ans[u] += del * query(1, id[u], 1), update(1, id[u], id[u], 0, -del); // 特殊处理u ：0代表a[u]，1代表V[u]，2代表W[u]，清空a[u]并更新V[u] update(1, id[u], id[u], 1, tmp); while (u) &#123; update(1, id[top[u]], id[fa[u]], 2, tmp), u = top[u]; del = query(1, id[fa[u]], 0); ans[fa[u]] += del * query(1, id[fa[u]], 1), update(1, id[fa[u]], id[fa[u]], 0, -del), update(1, id[fa[u]], id[fa[u]], 1, tmp); // 同理 u = fa[u]; &#125;&#125; 关于动态dp，也是链上维护虚子树信息 去年四川省选D1T1也许可以LCT维护虚子树信息 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;using namespace std;#define N 300010#define LL long longstruct edge &#123;int to, next;&#125; e[N * 2];int head[N], ecnt;inline void adde(int from, int to) &#123; e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt; e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;&#125;struct node &#123; int l, r; LL sum, lazy, s1, s2, lazy1, lazy2; &#125; T[N &lt;&lt; 2];inline void pushdown(int rt) &#123; T[rt &lt;&lt; 1].sum += T[rt].lazy, T[rt &lt;&lt; 1 | 1].sum += T[rt].lazy, T[rt &lt;&lt; 1].lazy += T[rt].lazy, T[rt &lt;&lt; 1 | 1].lazy += T[rt].lazy, T[rt].lazy = 0; T[rt &lt;&lt; 1].s1 += T[rt].lazy1, T[rt &lt;&lt; 1 | 1].s1 += T[rt].lazy1, T[rt &lt;&lt; 1].lazy1 += T[rt].lazy1, T[rt &lt;&lt; 1 | 1].lazy1 += T[rt].lazy1, T[rt].lazy1 = 0; T[rt &lt;&lt; 1].s2 += T[rt].lazy2, T[rt &lt;&lt; 1 | 1].s2 += T[rt].lazy2, T[rt &lt;&lt; 1].lazy2 += T[rt].lazy2, T[rt &lt;&lt; 1 | 1].lazy2 += T[rt].lazy2, T[rt].lazy2 = 0;&#125;int rk[N]; LL v1[N], v2[N], ans[N];void build(int rt, int l, int r) &#123; T[rt].l = l, T[rt].r = r; int mid = (l + r) &gt;&gt; 1; if (l == r) &#123;T[rt].s1 = v1[rk[l]], T[rt].s2 = v2[rk[l]]; return;&#125; build(rt &lt;&lt; 1, l, mid), build(rt &lt;&lt; 1 | 1, mid + 1, r);&#125;void update(int rt, int start, int end, int type, LL x) &#123; if (end &lt;= 0 || start &gt; end) return; int l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; 1; if (start &lt;= l &amp;&amp; r &lt;= end) &#123; if (type == 0) T[rt].lazy += x, T[rt].sum += x; else if (type == 1) T[rt].lazy1 += x, T[rt].s1 += x; else T[rt].lazy2 += x, T[rt].s2 += x; return; &#125; pushdown(rt); if (start &lt;= mid) update(rt &lt;&lt; 1, start, end, type, x); if (end &gt; mid) update(rt &lt;&lt; 1 | 1, start, end, type, x);&#125;LL query(int rt, int at, int type) &#123; if (!at) return 0; int l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; 1; if (l == r) &#123; if (type == 0) return T[rt].sum; else if (type == 1) return T[rt].s1; else return T[rt].s2; &#125; pushdown(rt); return at &lt;= mid ? query(rt &lt;&lt; 1, at, type) : query(rt &lt;&lt; 1 | 1, at, type);&#125;int dfsn, sz[N], top[N], id[N], fa[N], mark[N], son[N];void dfs1(int u, int f) &#123; sz[u] = 1, fa[u] = f; for (int i = head[u];i;i = e[i].next) if (e[i].to != f) &#123; dfs1(e[i].to, u), sz[u] += sz[e[i].to]; if (sz[son[u]] &lt; sz[e[i].to]) son[u] = e[i].to; &#125;&#125;void dfs2(int u, int t) &#123; id[u] = ++dfsn, top[u] = t, v1[u] = mark[u] ? u : 0, rk[id[u]] = u; if (son[u]) dfs2(son[u], t), v2[u] += v2[son[u]] + v1[son[u]]; for (int i = head[u];i;i = e[i].next) if (e[i].to != fa[u] &amp;&amp; e[i].to != son[u]) dfs2(e[i].to, e[i].to), v1[u] += v1[e[i].to] + v2[e[i].to];&#125;inline void Tupdate1(int u) &#123; ans[u] += query(1, id[u], 2); while (u) &#123; update(1, id[top[u]], id[u], 0, 1); u = top[u], ans[fa[u]] += query(1, id[fa[u]], 2) - query(1, id[u], 1) - query(1, id[u], 2); u = fa[u]; &#125;&#125;inline void Tupdate2(int u) &#123; int tmp = mark[u] ? -u : u; mark[u] ^= 1; LL del = query(1, id[u], 0); ans[u] += del * query(1, id[u], 1), update(1, id[u], id[u], 0, -del); update(1, id[u], id[u], 1, tmp); while (u) &#123; update(1, id[top[u]], id[fa[u]], 2, tmp), u = top[u]; del = query(1, id[fa[u]], 0); ans[fa[u]] += del * query(1, id[fa[u]], 1), update(1, id[fa[u]], id[fa[u]], 0, -del), update(1, id[fa[u]], id[fa[u]], 1, tmp); u = fa[u]; &#125;&#125;inline LL query(int u) &#123; return ans[u] + query(1, id[u], 0) * query(1, id[u], 1);&#125;int __rd;inline void read(int &amp;x) &#123; x = 0; char c = getchar(); while (c &lt; '0' || c &gt; '9') c = getchar(); while ('0' &lt;= c &amp;&amp; c &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - '0', c = getchar();&#125;#define RD (read(__rd), __rd)#define OPEN(x) freopen(x".in", "r", stdin), freopen(x".out", "w", stdout)int main() &#123;// OPEN("strtree"); int n = RD, m = RD; for (int i = 1;i &lt;= n;i++) mark[i] = RD; for (int i = 1, a, b;i &lt; n;i++) a = RD, b = RD, adde(a, b); dfs1(1, 0), dfs2(1, 1), build(1, 1, n); while (m--) &#123; int a = RD, b = RD; if (a == 1) Tupdate1(b); else Tupdate2(b); &#125; for (int i = 1;i &lt;= n;i++) printf("%lld\n", query(i));&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gcd应用]]></title>
    <url>%2F2019%2F03%2F08%2Fgcd%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[两有理数间求一个分数，使得分子最小就是要求$\frac ab&lt;\frac xy&lt;\frac cd$$$几种情况：\\ a=0:x=1,y=\lfloor\frac dc\rfloor+1\\ a\geq b:将\frac ab转化成真分数，递归\\ c&gt;d:此时有a&lt;b,则a=1,b=1\\ 否则有\frac dc\leq \frac yx\leq \frac ba，递归然后交换分母和分子$$代码 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;#define P pair&lt;int, int&gt;P work(int a, int b, int c, int d) &#123; // a / b &lt;= x &lt;= c / d if (!a) return P(1, d / c + 1); P tmp; if (a &gt;= b) return tmp = work(a % b, b, c - (a / b) * d, d), tmp.first += tmp.second * (a / b), tmp; if (c &gt; d) return P(1, 1); return tmp = work(d, c, b, a), swap(tmp.first, tmp.second), tmp;&#125;int main() &#123; while (true) &#123; int a, b, c, d; scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d); P tmp = work(a, b, c, d); printf("%d/%d\n", tmp.first, tmp.second); &#125;&#125; 高精度$gcd$显然，直接模是不行的 按照奇偶性分类，时间复杂度$O(\log n)​$ 有理多边形内整点个数枚举每一条线段，假设点距为$m$ 等价于求$$\sum_{i=1}^n\lfloor\frac{k_i+b}{m}\rfloor$$]]></content>
      <tags>
        <tag>gcd</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CodeChef] Adi and the Matrix]]></title>
    <url>%2F2019%2F03%2F08%2FCodeChef-Adi-and-the-Matrix%2F</url>
    <content type="text"><![CDATA[题目链接 有$N*M\leq 550$ 注意到数据范围，它的含义是说，N和M中较小的那个不会超过23 我们考虑置换，首先假设$N\leq M$ 枚举N的划分方案，注意要从小到大枚举，这个数不会太大 这个划分方案中每一个集合对应着一个循环 如果元素个数是$n$，划分方案为$(a_i,b_i)$，即长度为$a_i$的循环有$b_i$个 那么它对应的置换总数为$$\frac{n!}{\prod a_i^{b_i}b_i!}$$这个式子的意思是说，将所有元素进行排列，每一个循环中都有$a_i$种等价方案，即旋转0次、旋转1次，……，旋转$a_i-1$次，长度相同的循环之间可以互换顺序 假如我们已经知道了M对应的循环，那么考虑如何计算不动点个数 对于一个格子，它在行内的循环假设长度为$a$，在列内的循环假设长度为$b$。那么我们知道，它在经过$a$次置换后会回到原来所在的行，在经过$b$次置换后会回到原来所在的列 所以，最少需要$lcm(a,b)$次置换才能回到原点 也就是说，每一种方案，都有$lcm(a,b)$种方案是与它等价的 对于这两个循环中，我们知道一共有$ab$个格子 所以，不动点的个数是$\frac{ab}{lcm(a,b)}=gcd(a,b)$ 每个不动点都有两种染色方案，即0或1 我们考虑使用dp来计算贡献 dp[i][j]表示还剩下i列没有分配，还没有分配循环长度j时所有方案的不动点个数之和 我们枚举长度为j的循环个数 求出之前枚举出来的$N$的划分中每一个$a_i$与j的$gcd$之和 注意循环对应的置换个数是$\frac{M!}{\prod a_i^{b_i}b_i!}$，这里我们把$M$提出来，在dp的时候顺便转移分母 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;#define N 600typedef long long LL;int dp[N][N], a[N], top, n, m, frac[N], inv[N], g[N][N], Pow2[N];const int mod = 1e9 + 7;inline int Pow(int x, int y) &#123; int res = 1; for (;y;y &gt;&gt;= 1, x = (LL)x * x % mod) if (y &amp; 1) res = (LL)res * x % mod; return res;&#125;inline void Inc(int &amp;x, int y) &#123;x += y, x -= x &gt;= mod ? mod : 0;&#125;int gcd(int a, int b) &#123;return b ? gcd(b, a % b) : a;&#125;inline int solve() &#123; memset(dp, 0, sizeof(dp)), dp[m][m] = 1; for (int i = m;i &gt;= 0;i--) for (int j = m;j &gt;= 1;j--) if (dp[i][j]) &#123; int val = 0, tmp = dp[i][j]; for (int k = 1;k &lt;= top;k++) val += g[j][a[k]]; for (int k = 0;j * k &lt;= i;k++) &#123; Inc(dp[i - j * k][j - 1], (LL)tmp * inv[k] % mod); tmp = (LL)tmp * inv[j] % mod * frac[j - 1] % mod * Pow2[val] % mod; &#125; &#125; return (LL)dp[0][0] * frac[m] % mod;&#125;inline int calc() &#123; // for (int i = 1;i &lt;= top;i++) cout &lt;&lt; a[i] &lt;&lt; ' '; // cout &lt;&lt; endl; int res = frac[n]; for (int i = 1;i &lt;= top;i++) &#123; int cnt = 1; while (i &lt;= top &amp;&amp; a[i] == a[i + 1]) i++, cnt++; res = (LL)res * Pow(Pow(a[i], cnt), mod - 2) % mod * inv[cnt] % mod; &#125; return (LL)res * solve() % mod;&#125;int ans = 0;void dfs(int n, int cur, int dep) &#123; if (n &lt; 0) return; if (!n) &#123;top = dep, Inc(ans, calc()); return;&#125; if (n &lt; cur) return; dfs(n, cur + 1, dep); a[++dep] = cur, dfs(n - cur, cur, dep);&#125;int main() &#123; frac[0] = inv[0] = Pow2[0] = 1; for (int i = 1;i &lt;= N - 10;i++) frac[i] = (LL)frac[i - 1] * i % mod, inv[i] = Pow(frac[i], mod - 2), Pow2[i] = Pow2[i - 1] * 2 % mod; for (int i = 0;i &lt;= N - 10;i++) for (int j = 0;j &lt;= i;j++) g[i][j] = g[j][i] = gcd(i, j); scanf("%d%d", &amp;n, &amp;m); if (n &gt; m) swap(n, m); dfs(n, 1, 0); printf("%d\n", (LL)ans * inv[n] % mod * inv[m] % mod); return 0;&#125; 其中，inv[i]表示i的阶乘的逆元，g[i][j]表示$gcd(i,j)$，Pow2[i]表示$2^i$，frac[i]表示$i!$ 那个inv[j] * frac[j - 1]等价于除以j 注意最后需要将答案除以置换总数$n!m!​$]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>题解</tag>
        <tag>置换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[置换专题]]></title>
    <url>%2F2019%2F03%2F08%2F%E7%BD%AE%E6%8D%A2%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[A – Necklace of BeadsBurnside定理模板 假设有n个条件$S$，每个条件都是形如“$A$与$B$等价”的形式，要求集合$X$在这些条件下的方案数 将条件分解成循环的形式，那么方案数 $$=\frac{1}{n}\sum_{g\in S}|X^g|$$ 其中，$X^g$是置换$g$作用于集合$X$之后的不动点个数，即不变的元素的个数 那么对于这道题，我们考虑两类置换 1.旋转 假设有一条长度为n的项链，旋转之后相同被视为相同方案，那么显然地，我们有n种对应的置换 即不旋转，旋转1次，旋转2次，…，旋转n-1次 考虑计算不动点个数 假设现在旋转了2次 如果要求旋转之后不变（不动点），那么1号点、3号点、5号点的颜色必须相同 因为1号点转一次可以转到3号点，而3号点转一次可以转到5号点 如果这三个点的颜色不相同，那么旋转之后就变了，不能再称之为不动点 同理，2号点、4号点、6号点的颜色必须相同 总结一下： 对于长度为n的项链，旋转i次之后得到的不动点个数为$gcd(i,n)$ 不动点之间互不影响，假设有m种颜色，那么此时的染色方案为$m^{gcd(i,n)}$ 2.翻转 分奇偶考虑 先考虑奇数 一条对称轴必定穿过一个顶点，也就是说，一个顶点对应一条对称轴 如果要满足变换之后不变，显然2、5号点必须相等，3、4号点必须相等，1号点随意 如果有n个点，m种颜色，且n为奇数，那么这种置换一共有n个，每种置换有$m^{\frac{n+1}{2}}$种方案 考虑偶数的情况 稍微麻烦一点 1.对称轴穿过一条边的中点，不穿过点 显然，此时有$m^{\frac{n}{2}}$种方案，共$\frac{n}{2}$种置换 2.对称轴穿过两个点 其它点两两配对，这两个点随便染色 共$m^{\frac{n-2}{2}+2}$种方案，共$\frac{n}{2}$种置换 最后除以置换总数2n即可 B – Let it Bead和A题相同，将颜色数从3改为m即可 C – ColorN颗珠子，N种颜色，而且$N\leq 10^9$ 显然枚举旋转方案i不行 考虑枚举gcd 假设gcd=x，那么实际上就是要计算有多少个i满足$i\leq n$且$gcd(i,n)=x$ 首先，x必须是n的因数，而且是i的因数 假设$n=x*a,i=x*b$，那么a与b互质 所以，i的个数为$\varphi(\frac{n}{x})$ x只有$\sqrt n$种取值 筛一下2e5之内的质数即可 D – Magic Braceletn颗珠子，m种颜色，k种限制，每种限制形如“颜色a与颜色b不能放在一起” 先不管限制 考虑旋转i步之后的状态 假设虚线中是一个循环节，显然，1号点和5号点的颜色应当相同，而与2、3、4、5号点的颜色无关 如果要求满足限制，那么在上图中的含义等价为“放5颗珠子，第1颗珠子与第5颗珠子颜色相同并且满足限制的方案数” 循环节长度为i，那么珠子数就为i+1 将这个过程想象成一张图 如果a与b不能相邻，那么点a到点b之间没有边，否则有一条双向边 最开始的图是一张完全图，每个条件会删去一条双向边 答案就等于在这张图上走i+1步，且起点与终点相同的方案数 这张图的邻接矩阵是一个01矩阵，那么走i+1步就是取这个矩阵的i次方 答案为对角线上的数之和 由于又是$n\leq 10^9$，所以需要矩阵乘法 剩下的和上一道题一样，先筛质数然后求$\varphi$即可 E – Who’s Aunt Zhang一个三阶魔方，给每个面、每个角、每条棱上色，共n中颜色，将魔方整体旋转之后相同的视为等价情况，问方案数 首先面数+棱数+角数=54+12+8=74 有4类置换 1.不动方案数$n^{74}$ 有1种置换 2.以某个面的中心为轴旋转 有3种方案：转90度、转180度、转270度 注意到第一种方案和第三种方案要求轴所在的那一面的四条棱都相等，而第二种方案仅要求两条棱相等 对于第一种和第三种方案，答案为$n^{20}$ 正对着的两个面共有$3*2$)种方案 中心有1种，棱上的面有1种，角上的面有1种，这样的面有2个，所以有6种 剩下的四个面染色方案必须一样，但每个面中的颜色独立，共9种 正对着的两个面每个面上的棱只有1种方案，共2种 剩下的四条棱有1种 角分为两组，坐标一组，右边一组，每组颜色必须相同，共2种 所以共$6+9+3+2=20$种方案 置换个数为$2*3=6$种（以某两个面为轴，转90度或270度） 对于第二种方案，答案为$n^{38}​$ 正对着的两个面上，将面两两分组，每组颜色必须相同 共$(2+2+1)*2=10​$种（角上的面两种，棱上的面两种，中心一种，共两个这样的面） 其余的四个面两两配对，每个面上颜色独立，共$9*2=18$种 将棱两两配对，每对的颜色必须相同，共6种 将角两两配对，每对的颜色必须相同，共4种 总方案数为$10+18+6+4=32$种 置换有3种（将面两两配对，每一对只有1种置换） 以相对的两个角为中心旋转 在这种情况下，旋转120度和旋转240度是等价的 都有$n^{26}$种方案 对着的两个角特殊考虑，其余的角、边、棱三个为一组，每组颜色互不影响，共$2+\frac{74-2}{3}=26$种 共$2*4=8​$种置换 以相对的两条棱的中心为轴旋转 选中的两条棱特殊考虑，其余元素两两配对 共$2+\frac{74-2}{2}=38$种方案 有$\frac{12}{2}=6$种置换 所以总置换数为24，最后除以24即可 F – Toy前置题目轮状病毒 首先不考虑等价的情况 有两种方法 矩阵树定理+打表(oeis) 矩阵是度数矩阵-邻接矩阵，再随便去掉某一行和某一列 然后打表 递推 先不考虑连成环的情况 设$f(n)$表示除了中心点，还有n个点的生成树个数 那么有 $$f(n)=\sum_{i=1}^{n}f(n-i)*i$$ 含义是，假设这次选取的连通块有i个节点，剩下的点共有$f(n-i)$种方案，这个连通块可以选择任意一个点连向中心点，共i种方案 化简这个式子 $$f(n)=\sum_{i=0}^{n-1}f(i)*(n-i)$$ $$f(n-1)=\sum_{i=0}^{n-2}f(i)*(n-i-1)$$ $$f(n)=f(n-1)+\sum_{i=0}^{n-1}f(i)$$ $$f(n-1)=f(n-2)+\sum_{i=0}^{n-2}f(i)$$ $$f(n)-f(n-1)=f(n-1)-f(n-2)+f(n-1)$$ $$f(n)=3f(n-1)-f(n-2)$$ 注意这个式子仅当$n\geq 3$时成立 考虑连成环的情况 就是1号点和n号点连了起来 假设这个连通块有i个点 那么有i-1种连通块可以选择（包含1-n这条边的连通块数），随便选一个点连向中心点 设方案数为$g(n)$ 那么 $$g(n)=\sum_{i=2}^{n}i*(i-1)*f(n-i)$$ $$=\sum_{i=1}^{n}i*(i-1)*f(n-i)$$ 总方案数 $$F(n)=f(n)+g(n)$$ $$=\sum_{i=1}^{n}f(n-i)*i^2$$ 我们有$f(0)=1,f(1)=1,f(2)=3$ $$\because \sum_{i=n-2}^nf(n-i)*i^2=3*(n-2)^2+(n-1)^2+n^2$$ $$=3*(n-1)^2+2*(n-2)^2+2$$ $$\therefore F(n)=\sum_{i=1}^{n-3}f(n-i)*i^2+3*(n-1)^2+2*(n-2)^2+2$$ $$\because n-i\geq 3$$ $$\therefore F(n)=\sum_{i=1}^{n-3}[3*f(n-i-1)-f(n-i-2)]*i^2+3*(n-1)^2*f(0)+(n-2)^2*[3*f(1)-f(0)]+2$$ $$=\sum_{i=1}^{n-2}[3*f(n-i-1)-f(n-i-2)]*i^2+3*(n-1)^2*f(0)+2$$ $$=3*\sum_{i=1}^{n-1}f(n-i-1)*i^2-\sum_{i=1}^{n-2}f(n-i-2)+2$$ $$=3*F(n-1)-F(n-2)+2$$ 写成矩阵的形式就是 $$\begin{bmatrix}3&amp;-1&amp;2\\1&amp;0&amp;0\\0&amp;0&amp;1\end{bmatrix}^{n-2}*\begin{bmatrix}F(2)\\F(1)\\1\end{bmatrix}$$ 然后再求欧拉函数，枚举gcd即可 G – Birthday Toy考虑n个位置，m种颜色，要求相邻颜色不同，并且首位颜色一样的方案数（$n,m\leq 10^9$） 先考虑朴素的dp:dp[i][j][k]表示到了第i个位置，这一位颜色为j，最开始的颜色为k的方案数 转移很好转移 考虑优化：我们并不关心当前位置的颜色是什么，我们只关心它与首位颜色相不相同，所以可以简化状态 dp[i][0/1]表示到了第i位，与当前首位颜色相同/不相同的方案数 那么有 12dp[i][0]=dp[i-1][1]dp[i][1]=dp[i-1][0]*(m-1)+dp[i-2][1]*(m-2) 矩阵乘法加速即可 I – Leonardo’s Notebook结论： 两个长度为n的相同循环相乘，当n为奇数是结果是一个长为n的循环，否则是两个长度为$\frac{n}{2}$的循环的乘积 所以长度为奇数的循环一定可以被拆成两个相同循环的乘积，长度为偶数的循环需要两两配对，如果能配对上就可以 K – Find the Permutations下标与序列构成了一个置换 将置换分解，注意到每个循环所需要的交换次数是循环长度-1 加起来就是n-循环节个数 所以dp，dp[i][j]表示到第i个位置，一共有j个循环的方案数 i这个数可以新开一个循环，也可以插入到前面任意一个数的后面 1dp[i][j]=dp[i-1][j-1]+dp[i-1][j]*(i-1) L – Necklace每种颜色的珠子有限制个数 还是枚举gcd，但是要求$\frac{n}{gcd}$必须是每种珠子个数的因数 然后可重排列 翻转有点毒瘤，考虑两种情况：n为奇数或是偶数 奇数比较简单，偶数又要分两种情况 注意细节，还是比较模板的 M – CubesL + E]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>矩阵乘法</tag>
        <tag>置换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫比乌斯反演与杜教筛专题]]></title>
    <url>%2F2019%2F03%2F08%2F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E4%B8%8E%E6%9D%9C%E6%95%99%E7%AD%9B%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[A – GCD莫比乌斯反演模板，注意去重 当$i\leq min(n,m)$时，每个gcd都被计算了两遍，除以2即可 B – CA Loves GCD见莫比乌斯反演 CA Loves GCD C – Hillan and the girl首先转化成总数-gcd是完全平方数的个数 $$\sum_{i=1}^{n}\sum_{j=1}^{n}[gcd(i,j)\in sqrt\ number]$$ 按照套路，先枚举gcd，此处是gcd的平方根 $$=\sum_{d=1}^{\sqrt n}\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=d^2]$$ 莫比乌斯反演 $$=\sum_{d=1}^{\sqrt n}\sum_{l=1}^{\lfloor\frac{n}{d^2}\rfloor}\mu(l)\lfloor\frac{n}{d^2l}\rfloor\lfloor\frac{m}{d^2l}\rfloor$$ 然后换T $$T=d^2l$$ 改写式子 $$=\sum_{T=1}^{n}\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor\sum_{l|T}\mu(l)$$ 最后那个可以预处理 对于每一个$\mu$，枚举一个完全平方数更新，最后算一下前缀和即可 D – Trick GCD很经典的一道题 题目要求$gcd\geq 2$，转化成求$gcd=1$的方案数，再用总数去减 设$f(x)$为gcd恰好为x的方案数，$g(x)$为gcd为x的倍数的方案数 显然有 $$g(x)=\sum_{x|d}f(d)$$ $$f(x)=\sum_{x|d}g(d)\mu(\frac{d}{x})$$ 此时f中的x是1 现在关键是要求出g 假设当前是$g(x)$ 对于每一个$A_i$，有$\lfloor\frac{A_i}{x}\rfloor$的贡献，注意到一段区间内的$A_i$贡献相同，所以对A整体分块计算贡献，然后乘起来就好了 一部分代码 12345678for (int i = 1, a;i &lt;= n;i++) scanf("%d", &amp;a), buk[a]++, mn = min(mn, a), mx = max(mx, a);for (int i = 1;i &lt;= mx * 2;i++) buk[i] += buk[i - 1]; for (int i = 2;i &lt;= mn;i++) &#123; int tmp = -mu[i]; for (int j = i;j &lt;= mx;j += i) tmp = (LL)tmp * Pow(j / i, buk[j + i - 1] - buk[j - 1]) % mod; ans = (ans + tmp) % mod;&#125; E,F,G – GCD Extreme(x)直接用$\varphi$替换gcd即可 经典题目 H – Zap莫比乌斯反演模板 上界同时除以d即可 I – 数表求 $$\sum_{i=1}^{n}\sum_{j=1}^{m}\sigma(gcd(i,j))[\sigma(gcd(i,j))\leq a]$$ 先莫比乌斯反演一波 $$=\sum_{i=1}^{n}\sum_{j=1}^{m}\sigma(gcd(i,j))[\sigma(gcd(i,j))\leq a]$$ $$=\sum_{d=1}^{n}\sigma(d)[\sigma(d)\leq a]\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=d]$$ $$=\sum_{d=1}^{n}\sigma(d)[\sigma(d)\leq a]\sum_{l=1}^{\lfloor\frac{n}{d}\rfloor}\mu(l)\lfloor\frac{n}{dl}\rfloor\lfloor\frac{m}{dl}\rfloor$$ 设 $$T=dl$$ 改写式子 $$=\sum_{T=1}^{n}\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor\sum_{d|T}\sigma(d)\mu(\frac{T}{d})[\sigma(d)\leq a]$$ 约数和这个函数是可以直接求的 考虑将询问按照限制大小从小到大排序 将约数和也从小到大排序 当一个约数和达到限制以下后，枚举它的倍数更新 由于计算要用到前缀和，使用树状数组维护即可 J – Crash的数字表格见莫比乌斯反演 K – DZY Loves Math神仙题 先来反演一波 $$\sum_{i=1}^{n}\sum_{j=1}^{m}f(gcd(i,j))$$ $$=\sum_{d=1}^{n}f(d)\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=d]$$ $$=\sum_{d=1}^{n}f(d)\sum_{l=1}^{\lfloor\frac{n}{d}\rfloor}\mu(l)\lfloor\frac{n}{dl}\rfloor\lfloor\frac{m}{dl}\rfloor$$ 设 $$T=dl$$ 则有 $$=\sum_{T=1}^{n}\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor\sum_{d|T}f(d)\mu(\frac{T}{d})$$ 关键就是要求最后的那个东西 假设有$T=\prod p_i^{k_i}$，要想最后的那个$\mu$不为0，d的每一个质数的次数最少不会少于T中所对应的次数-1 也就是说，假如$f(T)=x$，那么$x-1\leq f(d)\leq x$ 进一步考虑，最后可能影响答案的只有那些次数最高的项。如果T中质数的次数不全相等，那么对于$f(d)=x$的每一种方案，其它的项可以乱选，方案数是2的这些项的个数次方（要么次数不减，要么次数减1） 注意到$\mu(\frac{T}{d})$的值在上述的这两种情况中取值互为相反数，仅当T中质数的次数全部相等时，剩余项的方案数是$2^0$，在这一步中不能被抵消，其余情况均可两两抵消，这个$\sum$的值永远是0 考虑所有次数相等的情况 假设T的质因子个数为k 每个数仍然可以选或不选，$\mu$的和为0 但是对于所有质数都不选的情况，$f(d)$的值并不是x，而是x-1，所以答案要减去$-1*(-1)^k$，那个$(-1)^l$是$\mu(\frac{T}{d})$ 所以此时的答案为 $$(-1)^{k+1}$$ 假设当前要求的是 $$\sum_{d|T}f(d)\mu(\frac{T}{d})$$ 那么： 假设存在x，使得$\mu(x)\not=0$，且T是x的k次方，那么$\sum_{d|T}f(d)\mu(\frac{T}{d})=-\mu(x)]$ 否则这个值为0 代码如下 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;#define N 10000010#define LL long longint prime[N], ncnt, mu[N], sum[N], flag[N];inline void sieve() &#123; mu[1] = 1; for (int i = 2;i &lt;= N - 10;i++) &#123; if (!flag[i]) prime[++ncnt] = i, mu[i] = -1; for (int j = 1;j &lt;= ncnt &amp;&amp; i * prime[j] &lt;= N - 10;j++) &#123; flag[i * prime[j]] = 1; if (i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; &#125; for (int i = 2;i &lt;= N - 10;i++) if (mu[i] != 0) for (LL j = i;j &lt;= N - 10;j *= i) sum[j] = -mu[i]; for (int i = 2;i &lt;= N - 10;i++) sum[i] += sum[i - 1]; &#125; inline LL solve(int n, int m) &#123; if (n &gt; m) swap(n, m); LL ans = 0; for (int l = 1, r;l &lt;= n;l = r + 1) &#123; r = min(n / (n / l), m / (m / l)); ans += (LL)(n / l) * (m / l) * (sum[r] - sum[l - 1]); &#125; return ans;&#125;int main() &#123; int T; scanf("%d", &amp;T), sieve(); while (T--) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); printf("%lld\n", solve(a, b)); &#125;&#125; L – Sum杜教筛模板 见杜教筛 M – 能量采集讲一讲求 $$\sum_{i=1}^{n}\sum_{j=1}^{m}gcd(i,j)$$ 的两种求法 以前已经写过了，直接贴上来 第二种方法 可以看出选择合适的解法的重要性 N – DZY Loves Math VI还是套路，先设出gcd，然后反演，最后换T 精雕细琢即可]]></content>
      <tags>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>杜教筛</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的数学题]]></title>
    <url>%2F2019%2F03%2F08%2F%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98%2F</url>
    <content type="text"><![CDATA[求 $$\sum_{i=1}^{n}\sum_{j=1}^{n}ijgcd(i,j)$$ $$n\leq 10^{10}$$ 根据$\varphi$的性质 $$\sum_{i|d}\varphi(i)=d$$ 可以改写上面那个式子 $$=\sum_{i=1}^{n}\sum_{j=1}^{n}ij\sum_{d|gcd(i,j)}\varphi(d)$$ 把d提到前面来 $$=\sum_{i=1}^{n}\sum_{j=1}^{n}ij\sum_{d|gcd(i,j)}\varphi(d)$$ 为了方便快捷，设 $$F(n)=\sum_{i=1}^{n}i$$ 那么原式就改写为 $$=\sum_{d=1}^{n}\varphi(d)*d^2*F(\lfloor\frac{n}{d}\rfloor)^2$$ 注意到后面的那个F括号内只有$\sqrt n$种取值，直接分块 现在关键就是要求前面那个的前缀和 但是有$n\leq 10^{10}$，直接筛显然不行，所以上杜教筛 设 $$S(n)=\sum_{i=1}^{n}\varphi(i)*i^2$$ 现在关键就是要找一个函数g来与$f(i)=\varphi(i)*i^2$卷积 观察到有$\sum_{i|d}\varphi(i)=d$，所以中间的那个$\varphi$可以不管 但是那个$i^2$很烦，要弄掉这个 所以考虑使用$g(x)=x^2$这个函数来卷积 根据杜教筛的公式 $$g(1)S(n)=\sum_{i=1}^{n}(g*f)(i)-\sum_{i=2}^{n}g(i)S(\lfloor\frac{n}{i}\rfloor)$$ 这个$(g*f)(i)$其实就是 $$\sum_{j=1}^{i}\varphi(j)*j^2*\frac{n^2}{j^2}=n^3$$ 而$g(1)=1^2=1$ 所以 $$S(n)=\sum_{i=1}^{n}i^3-\sum_{i=2}^{n}i^2S(\lfloor\frac{n}{i}\rfloor)$$ 有神仙公式 $$\sum_{i=1}^{n}i^3=(\sum_{i=1}^{n}i)^2$$ 以及 $$\sum_{i=1}^{n}i^2=\frac{1}{6}n*(n+1)*(2n+1)$$ 记忆化一波就可以了]]></content>
      <tags>
        <tag>数学</tag>
        <tag>题解</tag>
        <tag>杜教筛</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杜教筛]]></title>
    <url>%2F2019%2F03%2F08%2F%E6%9D%9C%E6%95%99%E7%AD%9B%2F</url>
    <content type="text"><![CDATA[假设有一道题：求 $$\sum_{i=1}^{n}\mu(i)$$ 然后$n\leq 10^9$ 线筛大家都知道怎么做 考虑把这个东西转化 设 $$S(n)=\sum_{i=1}^{n}\mu(n)$$ 我们知道 $$\sum_{i|d}\mu(i)=[d=1]$$ 如何利用这个性质呢？考虑用另一个函数来与这个$\mu$卷积 我们使用1来卷，因为没有什么要抵消的 $$\sum_{i|d}\mu(i)*1 = [d=1]=(\mu*1)(d)$$ $$1=\sum_{d=1}^{n}\sum_{i|d}\mu(\frac{d}{i})*1$$ $$=\sum_{i=1}^{n}\sum_{d=1}^{\lfloor\frac{n}{i}\rfloor}\mu(d)=\sum_{i=1}^{n}S(\lfloor\frac{n}{i}\rfloor)$$ 我们已经将这个东西转化成了$S$，移一下项 $$1=\sum_{i=1}^{n}S(\lfloor\frac{n}{i}\rfloor)$$ $$1-\sum_{i=2}^{n}S(\lfloor\frac{n}{i}\rfloor)=S(n)$$ 注意到$\lfloor\frac{n}{i}\rfloor$的取值不超过$\sqrt n$个，直接分块即可 然后DFS 记得要记忆化！！！ 一般式假设要求一个积性函数$f(x)$的前缀和$S(n)$ 先找到另一个积性函数$g(x)$，与f做卷积 这个g函数的要求有几点： 1.前缀和很好求，要不然找g之后反而更慢 2.与f的卷积的前缀和很好求 开始 $$(g*f)(d)=\sum_{i|d}g(i)f(\frac{d}{i})$$ $$\sum_{i=1}^{n}(g*f)(i)=\sum_{i=1}^{n}\sum_{d|i}g(d)f(\frac{i}{d})$$ 枚举d $$=\sum_{d=1}^{n}g(d)\sum_{d|i}f(\frac{i}{d})$$ $$=\sum_{d=1}^{n}g(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}f(i)$$ $$=\sum_{d=1}^{n}g(d)S(\lfloor\frac{n}{d}\rfloor)$$ 移项 $$g(1)S(n)=\sum_{i=1}^{n}(g*f)(i)-\sum_{i=2}^{n}g(i)S(\lfloor\frac{n}{i}\rfloor)$$ 然后开始分块即可 代码其实很短 123456789101112map&lt;int, int&gt; m;// sum[N - 10] 是预处理的前缀和，一般大小为3e6inline int calc(int n) &#123; // 算 sum mu if (n &lt;= N - 10) return sum[n]; else if (m.count(n)) return m[n]; // 记忆化 int res = 1; for (LL l = 2, r;l &lt;= n;l = r + 1) &#123; r = n / (n / l); res -= (r - l + 1) * calc1(n / l); &#125; return m1[n] = res;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>算法</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫比乌斯反演]]></title>
    <url>%2F2019%2F03%2F07%2F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[一些定义 $\mu(i)$ 莫比乌斯函数 设$i=p_1^{k_1} p_2^{k_2} p_3^{k_3} \cdots p_m^{k_m}$ 当$max(k) &gt; 1$时$\mu(i)=0$ 否则$\mu(i)=(-1)^{\sum k}$ $\varphi(i)$ 欧拉函数，为$[1,i]$内与i互质的数的个数 设$n=p_1^{k_1} p_2^{k_2} p_3^{k_3} \cdots p_m^{k_m}$ 则$\varphi(n)=n*\prod{(1-\frac{1}{p_i})}$ 关于狄利克雷卷积 定义二元关系$​$，$fg ​$的狄利克雷卷积为 $$(f*g)(n)=\sum_{d|n}f(d)g(\frac{n}{d})​$$ 卷积满足交换律 $$f*g=g*f$$ 结合律 $$(f*g)*h=f*(g*h)$$ 单位元 $$e(n)=[n=1]$$ $$\displaystyle f*e=f$$ 逆元 $$f*f^{-1}=e$$ 一些性质$$\sum_{d|n}\mu(d)=[n=1]$$ $$\displaystyle \sum_{d|n}\varphi(d)=n$$ $\mu$与$\varphi$都是积性函数，可以线性筛 1234567891011121314151617#define N 10000010int flag[N], prime[N], mu[N], ncnt;inline void sieve() &#123; mu[1] = 1; for (int i = 2;i &lt;= N - 10;i++) &#123; if (!flag[i]) mu[i] = -1, prime[++ncnt] = i; //i是质数，mu[i]为-1 for (int j = 1;j &lt;= ncnt &amp;&amp; i * prime[j] &lt;= N;j++) &#123; flag[i * prime[j]] = 1; //筛质数用 if (i % prime[j] == 0) break; //此时根据定义，mu为0 mu[i * prime[j]] = -mu[i]; //mu[i * prime[j]] = mu[i] * mu[prime[j]] = -mu[i] &#125; &#125;&#125; 积性函数都可以线性筛 莫比乌斯反演： 定理1 若 $$F(n)=\sum_{d|n}f(d)$$ 则 $$f(n)=\sum_{d|n}F(d)\mu(\frac{n}{d})$$ 定理2 若 $$F(n)=\sum_{n|d}f(d)$$ 则 $$f(n)=\sum_{n|d}F(d)\mu(\frac{n}{d})$$ 证明 $$F=f*1$$ 有 $$\mu(n)*1=\sum_{d|n}\mu(d)*1=[n=1]=e$$ 所以$$\mu^{-1}=1$$ $$F=f*1=f*\mu^{-1}$$ $$F*\mu=f$$ $$f(n)=(F*\mu)(n)=\sum_{d|n}F(d)\mu(\frac{n}{d})$$ 一些套路以Crash的数字表格为例 求 $$\sum_{i=1}^{n}\sum_{j=1}^{m}lcm(i,j)$$ 套路1.设出$gcd$，然后按照$gcd$分类$$\sum_{k=1}^{n}\sum_{i=1}^{n}\sum_{j=1}^{m}\frac{i*j}{k}[gcd(i,j)=k]$$ 方法1.凑出$[gcd(i,j)=1]$然后使用$\mu$函数的性质换元将i,j同时除以k，注意$\frac{i*j}{k}$需要乘回去 $$\sum_{k=1}^{n}\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}i*j*k[gcd(i,j)=1]$$ 有$$\sum_{d|n}\mu(d)=[n=1]$$ 所以 $$[gcd(i,j)=1]=\sum_{d|gcd(i,j)}\mu(d)$$ 方法2.使用莫比乌斯反演基本公式设 $$f(x)=\sum_{i=1}^{n}\sum_{j=1}^{m}\frac{i*j}{x}[gcd(i,j)=x]$$ $$\displaystyle F(x)=\sum_{i=1}^{n}\sum_{j=1}^{m}\frac{i*j}{x}[x|gcd(i,j)]$$ 改写一下$F$ 由于$gcd$是x的倍数，所以n,m都是x的倍数 同时除以x $$F(x)=\sum_{x|d}f(x)=\sum_{i=1}^{\lfloor\frac{n}{x}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{x}\rfloor}i*j*x$$ 套用反演公式 $$f(x)=\sum_{x|d}F(d)\mu(\frac{d}{x})$$ 得到 $$f(x)=\sum_{x|d}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}i*j*d*\mu(\frac{d}{x})$$ 代入原式即可 个人推荐推式子的时候用第一种方法，使用莫比乌斯反演容斥的时候使用第二种方法 从方法1的最后一步继续 $$\sum_{k=1}^{n}\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}i*j*k[gcd(i,j)=1]$$ $$=\sum_{k=1}^{n}\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}i*j*k\sum_{d|gcd(i,j)}\mu(d)$$ 套路2.枚举d，并放到前面去此时i,j都应该是d的倍数 同样，注意要乘回去 $$=\sum_{k=1}^{n}k\sum_{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d)\sum_{i=1}^{\lfloor\frac{n}{kd}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{kd}\rfloor}i*j*d^2$$ 整理一下 $$=\sum_{k=1}^{n}k\sum_{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d)*d^2\sum_{i=1}^{\lfloor\frac{n}{kd}\rfloor}i\sum_{j=1}^{\lfloor\frac{m}{kd}\rfloor}j$$ 为了方便快捷，设$$F(n)=\sum_{i=1}^{n}i$$将原式替换成$$=\sum_{k=1}^{n}k\sum_{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d)*d^2*F(\lfloor\frac{n}{kd}\rfloor)*F(\lfloor\frac{m}{kd}\rfloor)$$ 套路3.换T大法为了提升时间复杂度，我们需要设一个神奇的T 设$$T=kd$$所以原式等于$$\sum_{k=1}^{n}k\sum_{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d)*d^2*F(\lfloor\frac{n}{T}\rfloor)*F(\lfloor\frac{m}{T}\rfloor)$$枚举T，放到最前面$$\sum_{T=1}^{n}F(\lfloor\frac{n}{T}\rfloor)*F(\lfloor\frac{m}{T}\rfloor)\sum_{d|T}\mu(d)*\frac{T}{d}*d^2$$ $$\sum_{T=1}^{n}F(\lfloor\frac{n}{T}\rfloor)*F(\lfloor\frac{m}{T}\rfloor)\sum_{d|T}\mu(d)*d$$ 考虑优化最后那一坨的求法 直接求显然是$n\ log\ n$的 套路4.设出积性函数观察到$\mu$以及$f(x)=x$（它还有个名字叫id）都是积性函数 两个积性函数的狄利克雷卷积以及直接对应相乘的结果都是积性函数 也就是说，这个东西是可以线性筛的 设$$g(x)=\sum_{d|x}\mu(d)*d$$对x分类 x是质数 此时显然有$g(x)=1-x$ x被表示成了$i*prime[j]$，其中$prime[j]\bot i$ 此时根据积性函数性质，$g(iprime[j])=g(i)g(prime[j])$，直接乘即可 x被表示成了$i*prime[j]$，其中$prime[j]|i$ 考虑乘之后多出来的因数 由于多出来的因数prime[j]这个质数的次数至少是2，而根据$\mu$的定义此时$\mu$为0，对g没有贡献，直接忽略即可 所以此时$g(i*prime[j]$ 套路5.数论分块预处理完了g，我们再来说说最后答案怎么求 答案等于$$\sum_{T=1}^{n}F(\lfloor\frac{n}{T}\rfloor)*F(\lfloor\frac{m}{T}\rfloor)*g(T)$$考虑从$\lfloor\frac{n}{T}\rfloor$,$\lfloor\frac{m}{T}\rfloor$ 开始优化 可以发现对于某一段的T，上面的两个式子的值都是不变的 这种不变的值的段数一共有$\sqrt n​$段 考虑一段一段地枚举，而不是一个一个的枚举 此时变化的就只有$g(T)$ 对$g(T)$求一下前缀和，算的时候直接求区间的和就好了 代码如下 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define LL long longconst LL mod=20101009;int flag[10000010],prime[10000010],cnt,f[10000010],sum[10000010];// sum是前缀和，f就是gvoid sieve() &#123; f[1]=sum[1]=1; for (int i=2;i&lt;=10000000;i++) &#123; if (!flag[i]) prime[++cnt]=i,f[i]=(1-i+mod)%mod; for (int j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=10000000;j++) &#123; flag[i*prime[j]]=1; if (i%prime[j]==0) &#123; f[i*prime[j]]=f[i]%mod; break; &#125; f[i*prime[j]]=(LL)f[i]*f[prime[j]]%mod; &#125; sum[i]=(sum[i-1]+(LL)f[i]*i%mod)%mod; &#125;&#125;LL zjk(LL n,LL m) &#123; LL ans=0; if (n&gt;m) swap(n,m); for (LL l=1,r;l&lt;=n;l=r+1) &#123; r=min(n/(n/l),m/(m/l)); // 分块：[l,r] ans=(ans+((n/l*(n/l+1)/2)%mod*((m/l*(m/l+1)/2)%mod))%mod*(LL)(sum[r]-sum[l-1]))%mod; &#125; return (ans+mod)%mod;&#125;int main() &#123; sieve(); int n,m;scanf("%d%d",&amp;n,&amp;m); printf("%lld\n",zjk(n,m));&#125; %%% ZJK 下面讨论一下使用莫比乌斯反演来容斥的题 CA Loves GCD 题意：给出n个[1,1000]的数，问所有选法中所选择的数的gcd的和 $n \leq 1000$ 首先，还是对gcd分类，$f(i)$表示gcd为i的方案数 发现f好像很不好求，考虑设辅助函数 设$g(i)$表示gcd是i的倍数的方案数 很显然，在一个gcd为i的集合中，每一个数都是i的倍数 那么我们假设在这n个数中，i的倍数一共有k个 每个数可以选或者不选，一共有$2^k$种方案 减去所有数都不选的情况，就这一种 之后得到的就是$g(i)$的值 将g转化成f 显然有$$g(i)=\sum_{i|d}f(i)$$反演得$$f(i)=\sum_{i|d}g(d)\mu(\frac{i}{d})$$对于每一个i，枚举每一个i的倍数转移即可 对于如何求i的倍数的个数，可以开一个桶。先预处理每个数的约数，当输入一个数a时，就把a的所有约数在桶中加一，最后桶中的第i个位置就是i的倍数的个数 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1010vector&lt;int&gt; Div[N];int flag[N], prime[N], ncnt, mu[N], Pow[N];#define LL long longconst int mod = 1e8 + 7;inline void sieve() &#123; Pow[0] = 1, Pow[1] = 2, mu[1] = 1; for (int i = 2;i &lt;= N - 10;i++) &#123; Pow[i] = Pow[i - 1] * 2 % mod; if (!flag[i]) mu[i] = -1, prime[++ncnt] = i; for (int j = 1;j &lt;= ncnt &amp;&amp; i * prime[j] &lt;= N - 10;j++) &#123; flag[i * prime[j]] = 1; if (i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; &#125; for (int j = i;j &lt;= N - 10;j += i) Div[j].push_back(i); &#125; for (int i = 1;i &lt;= N - 10;i++) Div[i].push_back(1);&#125;int buk[N], ans[N], tmp[N];int main() &#123; int T; scanf("%d", &amp;T), sieve(); while (T--) &#123; int n; scanf("%d", &amp;n), memset(buk, 0, sizeof(buk)), memset(tmp, 0, sizeof(tmp)); for (int i = 1, a;i &lt;= n;i++) scanf("%d", &amp;a), tmp[a]++; for (int i = 1;i &lt;= 1000;i++) if (tmp[i]) for (int j = 0;j &lt; Div[i].size();j++) buk[Div[i][j]] += tmp[i]; memset(ans, 0, sizeof(ans)); for (int i = 1;i &lt;= 1000;i++) for (int j = i;j &lt;= 1000;j += i) ans[i] = (ans[i] + (Pow[buk[j]] - 1) * mu[j / i] + mod) % mod; int res = 0; for (int i = 1;i &lt;= 1000;i++) res = (res + (LL)i * ans[i] % mod) % mod; printf("%d\n", res); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>算法</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组]]></title>
    <url>%2F2019%2F03%2F07%2F%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[一些约定 sa[i] 排名为i的后缀在原串中的编号 rk[i] 原串中第i个后缀所对应的排名 height[i] 排名为i的后缀与排名为i – 1的后缀的最长公共前缀 一些例子字符串S = bacaab 中，sa，rk，height分别为 一些解释在S中，所有的后缀分别为bacaab, acaab, caab, aab, ab, b 将这些串按照字典序排序，可以得到aab, ab, acaab, b, bacaab, caab 对应出来的rk值就是5, 3, 6, 1, 2, 4 根据上面的定义可以得出sa[rk[i]] = i, rk[sa[i]] = i sa[1] = 4 对应后缀aab，sa[2] = 5 对应后缀ab 因此height[2] = lcp(sa[1], sa[2]) = lcp(aab, ab) = 1 注：height[1] 没有意义，约定其等于0 倍增直接暴力求sa显然不行，由于涉及到后缀排序，所以考虑倍增 假设对于每个后缀的前k个字符，我们已经排好了序，考虑进一步的转移 如果直接比较每个后缀的第k + 1个字符，忽视了太多已经求出的信息 对于两个后缀s1 = S[i, …], s2 = S[j, …]，如果它们的前k个字母不全相同，那么我们在之前的比较中就已经确定好了这两个后缀的顺序 如果这两个后缀的前k个字母都相同，我们这次就比较s1[k + 1, 2k], s2[k + 1, 2k]的大小 显然，这两个串的长度都是k，这意味着我们已经比较过这两个串 图中括号中的数字表示当前层中此串的排名，注意相同串的排名相同。 第一次比较将串s1与s2拼在一起，将串s2与s3拼在一起… 第二次比较将串s1与s3拼在一起，将串s2与s4拼在一起… 第三次比较将串s1与s5拼在一起，将串s2与s6拼在一起… 直到不同的串的个数为原串长度 那么问题来了，如何高效地比较？ 首先利用好已得出的信息，将这次比较前各个串的排名作为第一关键字 在这次比较中，每个字符串都将添加k个字符，对于串s[i, …]来说，将串s[i + k, …]的排名作为第二关键字 注意空串的字典序最小，假设原串长度为n，注意到在n – k + 1到n位置的第二关键字都是空串，我们约定此时n位置的第二关键字最小，其次是n – 1，然后以此类推 123456for (int i = n;i &gt;= n - k + 1;i--) y[++num] = i; // 添加的串为空for (int i = 1;i &lt;= n;i++) if (sa[i] &gt; k) y[++num] = sa[i] - k; // 此时的i就是串sa[i] - k的第二关键字，注意枚举的i代表排名// sa[i] &lt;= k时没有串会在后面添加串sa[i]，所以无视// y[i] 表示排名为i的第二关键字对应的是哪个串 对此时的所有串重新排序，第一关键字小的排前面，如果第一关键字相同，则第二关键字小的排前面 不能直接$n \log n$排序，这样的总时间复杂度与直接用哈希构造无异，因此选择桶排序 我们开一个桶c，将所有的第一关键字放进去，然后做一遍前缀和，可以得出每个元素的最大排名 由于第一关键字相同时，第二关键字较小的排名较前，因此我们从大到小枚举第二关键字，更新每个桶此时的最大排名和当前的sa数组 12345678for (int i = 1;i &lt;= m;i++) c[i] = 0; // 先清空， m是当前第一关键字大小for (int i = 1;i &lt;= n;i++) c[x[i]]++; // 将每个第一关键字加入桶for (int i = 1;i &lt;= m;i++) c[i] += c[i - 1]; // 获得每个值的最大排名for (int i = n;i &gt;= 1;i--) sa[c[x[y[i]]]--] = y[i]; // 第一关键字相同时，第二关键字越大排名越靠后 最后，我们需要更新此时的第一关键字 用一个num表示当前不同元素个数，仅当sa[i], sa[i – 1]至少有一个关键字不同时，num才会累加1，更新x数组 用m更新num 12345678memcpy(y, x, sizeof(x)), num = x[sa[1]] = 1;// 这个memcpy只是临时存一下，后面那个是初值for (int i = 2;i &lt;= n;i++) x[sa[i]] = (y[sa[i - 1]] == y[sa[i]] &amp;&amp; y[sa[i - 1] + k] == y[sa[i] + k]) ? num : ++num; // 更新此时的第一关键字if (num == n) break; else m = num; // 更新第一关键字的最大值// 如果m等于n，则代表已经分清了所有后缀的排名，没有必要继续比较下去 最后总代码如下 1234567891011121314151617inline void GetSA(int n, char s[]) &#123; for (int i = 1;i &lt;= n;i++) c[x[i] = s[i]]++; for (int i = 1;i &lt;= m;i++) c[i] += c[i - 1]; for (int i = n;i &gt;= 1;i--) sa[c[x[i]]--] = i; for (int k = 1, num = 0;k &lt;= n;k &lt;&lt;= 1, num = 0) &#123; for (int i = n;i &gt;= n - k + 1;i--) y[++num] = i; for (int i = 1;i &lt;= n;i++) if (sa[i] &gt; k) y[++num] = sa[i] - k; for (int i = 1;i &lt;= m;i++) c[i] = 0; for (int i = 1;i &lt;= n;i++) c[x[i]]++; for (int i = 1;i &lt;= m;i++) c[i] += c[i - 1]; for (int i = n;i &gt;= 1;i--) sa[c[x[y[i]]]--] = y[i]; memcpy(y, x, sizeof(x)), num = x[sa[1]] = 1; for (int i = 2;i &lt;= n;i++) x[sa[i]] = (y[sa[i - 1]] == y[sa[i]] &amp;&amp; y[sa[i - 1] + k] == y[sa[i] + k]) ? num : ++num; if (num == n) break; else m = num; &#125;&#125; 关于DC3时间复杂度$O(n)$，但是实现较为繁琐，不推荐 其实是我不会233333 关于height $LCP$ 的几条定理 定义$LCP(i, j)​$为排名为i的后缀与排名为j的后缀的最长公共前缀长度 根据height数组的定义，$height[i] = LCP(i – 1, i)​$ $LCP(i, j) = LCP(j, i)$ // 显然 $LCP(i, i) = LCP(i, i)$ // 同上 $LCP(i, j) = \min{LCP(i, k), LCP(k, j)}$ // 对于任意i ≤ k ≤ j，即$LCP​$具有传递性 设$h[i] = height[rk[i]]$，即$height[i] = h[sa[i]]$，有$h[i] ≥ h[i – 1] – 1$ 第4条定理的证明： 代码如下 12345678910111213inline void Getheight(int n, char s[]) &#123; for (int i = 1;i &lt;= n;i++) rk[sa[i]] = i;// 根据定义，给rk赋值 for (int i = 1, k = 0;i &lt;= n;i++) &#123;// k表示h[i - 1]，注意i是编号 if (rk[i] == 1) continue; if (k) k--;// height[1]没有意义，且h[i] &gt;= h[i - 1] - 1 int at = sa[rk[i] - 1]; while (at + k &lt;= n &amp;&amp; i + k &lt;= n &amp;&amp; s[at + k] == s[i + k]) k++;// 暴力向后匹配 height[rk[i]] = k; &#125;&#125; 关于最长公共前缀由$LCP$的第三条定理可以快速确定任意两个后缀的最长公共前缀，具体地 $LCP(rk[i], rk[j]) = \min{height[rk[i] + 1], height[rk[i] + 2], \cdots ,height[rk[j]]}​$ 使用ST表查找区间最小值即可 1234567891011121314inline void GetST(int n) &#123; memset(mn, 0x3f, sizeof(mn)); for (int i = 2;i &lt;= n;i++) lg[i] = lg[i &gt;&gt; 1] + 1; for (int i = 1;i &lt;= n;i++) mn[0][i] = height[i]; for (int i = 1;i &lt;= 20;i++) for (int j = 1;j + (1 &lt;&lt; i) - 1 &lt;= n;j++) mn[i][j] = min(mn[i - 1][j], mn[i - 1][j + (1 &lt;&lt; i - 1)]); &#125;inline int GetLCP(int L, int R) &#123; // rank 为 L, R if (L &gt; R) swap(L, R); L++; int len = R - L + 1; if (!len) return 1e9; return min(mn[lg[len]][L], mn[lg[len]][R - (1 &lt;&lt; lg[len]) + 1]);&#125;]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>算法</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
</search>
