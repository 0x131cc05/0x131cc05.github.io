<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>8.4 考试</title>
      <link href="/2020/08/07/8-4-%E8%80%83%E8%AF%95/"/>
      <url>/2020/08/07/8-4-%E8%80%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-Nim"><a href="#T1-Nim" class="headerlink" title="T1 Nim"></a>T1 Nim</h1><p><img src="https://cdn.jsdelivr.net/gh/0x131cc05/PicBed/images/20200807193348.png" alt="20200807193348"></p><p><img src="https://cdn.jsdelivr.net/gh/0x131cc05/PicBed/images/20200807193413.png" alt="20200807193413"></p><a id="more"></a><p>先考虑给出一种状态，如何判断这种状态是先手必胜还是后手必胜。</p><p>根据<code>k-nim</code>的结论，先手必败当且仅当所有石子的二进制下每一维之和模$k+1$都为$0$。</p><p>那么一种比较显然的暴力就是枚举有哪些堆小于$l$，然后进行数位$dp$，需要保证每一维的和模$3$都为$0$。</p><p>记$dp[i][s]$表示考虑了第$i$位以及更高维，此时$s$集合中的石头抵住了上界，并且前$i$位都满足条件的方案数。</p><p>状态转移需要枚举子集，复杂度很高，最多只能$83$分。</p><p>考虑将枚举的部分也写进$dp$里。设$dp[i][s_1][s_2]$表示考虑了第$i$位以及更高的位，$s_1$集合中的石头抵住了$l - 1$的上界，$s_2$集合中的石头抵住了$r$的上界的方案数。</p><p>注意$s_1, s_2$一定不交，因为实际上在给$dp$赋初值的时候，我们就已经确定好了哪些石头一定不能超过$l-1$。也就是说，如果我们也将容斥系数写进$dp$里的话，$dp[61][s_1][s_2]$的值为$(-1)^{c(s_1)}$，其中$c(x)$表示$x$二进制下$1$的个数。</p><p>转移的时候枚举$s_1|s_2$的子集，注意需要预处理$n$个数，每个数要么是$0$，要么是$1$，它们的和模$3$余$0$的方案数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">34</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">1</span> &lt;&lt; <span class="number">10</span>][<span class="number">1</span> &lt;&lt; <span class="number">10</span>], tmp[N][<span class="number">3</span>], one[N][<span class="number">1</span> &lt;&lt; <span class="number">10</span>][<span class="number">1</span> &lt;&lt; <span class="number">10</span>], fucked;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l[N], r[N], up, n, wkr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tmp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) <span class="keyword">if</span> (tmp[i - <span class="number">1</span>][j])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">1</span>; k++) tmp[i][(j + k) % <span class="number">3</span>] = (tmp[i][(j + k) % <span class="number">3</span>] + tmp[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (!l[i]) fucked |= <span class="number">1</span> &lt;&lt; i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s1 = <span class="number">0</span>; s1 &lt; <span class="number">1</span> &lt;&lt; n; s1++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1 &amp; fucked) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s2 = <span class="number">0</span>; s2 &lt; <span class="number">1</span> &lt;&lt; n; s2++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1 &amp; s2) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> A = s1 &amp; (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>), B = s2 &amp; (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (A || B) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= up; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (A &amp;&amp; ((l[i] - <span class="number">1</span>) &gt;&gt; j &amp; <span class="number">1</span>)) one[j][s1][s2] |= <span class="number">1</span> &lt;&lt; i - <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (B &amp;&amp; (r[i] &gt;&gt; j &amp; <span class="number">1</span>)) one[j][s1][s2] |= <span class="number">1</span> &lt;&lt; i - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> all = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s1 = <span class="number">0</span>; s1 &lt; <span class="number">1</span> &lt;&lt; n; s1++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1 &amp; fucked) <span class="keyword">continue</span>;</span><br><span class="line">        f[up + <span class="number">1</span>][s1][all ^ s1] = __builtin_popcount(s1) &amp; <span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = up; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s1 = <span class="number">0</span>; s1 &lt; <span class="number">1</span> &lt;&lt; n; s1++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1 &amp; fucked) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s2 = <span class="number">0</span>; s2 &lt; <span class="number">1</span> &lt;&lt; n; s2++) <span class="keyword">if</span> (f[i + <span class="number">1</span>][s1][s2]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s1 &amp; s2) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> full = (s1 | s2) &amp; one[i][s1][s2], w = f[i + <span class="number">1</span>][s1][s2], t = n - __builtin_popcount(s1 | s2);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> s = full; ; s = (s - <span class="number">1</span>) &amp; full) &#123;</span><br><span class="line">                    <span class="keyword">int</span> A = s1 ^ (s1 &amp; s), B = s2 ^ (s2 &amp; s);</span><br><span class="line">                    <span class="keyword">int</span> other = __builtin_popcount(one[i][A][B]) % <span class="number">3</span>;</span><br><span class="line">                    f[i][A][B] = (f[i][A][B] + (LL)w * tmp[t][other ? <span class="number">3</span> - other : <span class="number">0</span>]) % mod;</span><br><span class="line">                    <span class="keyword">if</span> (!s) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s1 = <span class="number">0</span>; s1 &lt; <span class="number">1</span> &lt;&lt; n; s1++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s2 = <span class="number">0</span>; s2 &lt; <span class="number">1</span> &lt;&lt; n; s2++) res = (res + f[<span class="number">0</span>][s1][s2]) % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l[i], &amp;r[i]), up = max(up, <span class="number">31</span> - __builtin_clz(r[i]));</span><br><span class="line">    pre(), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (solve() + mod) % mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-Subsequence"><a href="#T2-Subsequence" class="headerlink" title="T2 Subsequence"></a>T2 Subsequence</h1><p><img src="https://cdn.jsdelivr.net/gh/0x131cc05/PicBed/images/20200807195024.png" alt="20200807195024"></p><p><img src="https://cdn.jsdelivr.net/gh/0x131cc05/PicBed/images/20200807195039.png" alt="20200807195039"></p><p>很有意思的一道题。</p><p>先考虑给你$k$个序列，如何判断这$k$个序列是否合法（第一个序列为原序列）。</p><p>类似子序列自动机的方法，我们先贪心匹配第二个序列，接着只留下那些匹配上的位置，继续匹配第三个序列，又只留下那些匹配上的位置……以此类推。</p><p>我们给原序列的每个位置都记录$a_i$表示这个位置在$1\sim a_i$这些子序列中都出现了，问题转化为求出有多少种合法的$a$序列。</p><p>如果存在两个数字相同的位置$i,j$，使得$i<j, a_i<a_j$，那么$(i,j)$之间一定存在一个位置$k$，使得$a_k>a_i$，否则在选择第$a_i+1$个序列时，我们完全可以选择$i$这个位置而非$j$。容易发现这也是一组$a$序列合法的充要条件。</p><p>每次我们枚举当前区间的<strong>第一个</strong>最大值的位置，对于这个位置右边来说，左边的数一定影响不到它，因为我们枚举的是第一个位置。</p><p>对于区间左边的数，我们似乎需要在每一个“后缀最大值”处加以限制，问题变得有些棘手。由于$r+1$是上一次该区间被分到左边时整个区间的最大值，因此它一定比$[l,r]$中的任何$a_i$都要大。对于$[l,r]$的区间最大值来说，它右边的数全部都不超过它，因此若这个最大值位置上的数与$r+1$位置上的数相同的话就不合法。否则，$a_{r+1}&gt;a_i$，我们不需要考虑$r+1$右边的任何数。</p><p>因此可以$dp[l][r][k]$表示考虑区间$[l,r]$，它的最大值为$k$，且最大值位置上的数不能等于$r+1$的方案数。转移时枚举区间最大值的位置。</p><p>直接转移是$O(n^5)$的，加上前缀和可以优化到$n^4$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[N][N][N], num[N], g[N][N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> num[l] == num[r + <span class="number">1</span>] ? <span class="number">0</span> : k;</span><br><span class="line">    <span class="keyword">if</span> (g[l][r][k] != <span class="number">-1</span>) <span class="keyword">return</span> g[l][r][k];</span><br><span class="line">    <span class="keyword">int</span> &amp;res = g[l][r][k]; res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) res = (res + dfs(l, r, i)) % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[l][r][k] != <span class="number">-1</span>) <span class="keyword">return</span> dp[l][r][k];</span><br><span class="line">    <span class="keyword">int</span> &amp;res = dp[l][r][k]; res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) <span class="keyword">if</span> (num[i] != num[r + <span class="number">1</span>])</span><br><span class="line">        res = (res + (LL)sum(l, i - <span class="number">1</span>, k - <span class="number">1</span>) * sum(i + <span class="number">1</span>, r, k)) % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp)), <span class="built_in">memset</span>(g, <span class="number">-1</span>, <span class="keyword">sizeof</span>(g));</span><br><span class="line">    <span class="keyword">int</span> n, k; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dfs(<span class="number">1</span>, n, k)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-K-best-subsequence"><a href="#T3-K-best-subsequence" class="headerlink" title="T3 K-best-subsequence"></a>T3 K-best-subsequence</h1><p><img src="https://cdn.jsdelivr.net/gh/0x131cc05/PicBed/images/20200807201120.png" alt="20200807201120"></p><p><img src="https://cdn.jsdelivr.net/gh/0x131cc05/PicBed/images/20200807201136.png" alt="20200807201136"></p><p>300iq contest 的题。</p><p>先二分$w$，我们需要求出最多能够选择多少个数，使得它们满足题目中的条件。如果可以选取$a$个数，并且$a&gt;k$，那么我们可以通过每次删去选择的最大的数来得到一个选择恰好$k$个数的方案。</p><p>对于那些不超过$\frac w2$的数，它们一定会出现在最终的序列中。根据定理可以发现，对于两个相邻的不超过$\frac w2$的数，它们中间的所有数必定大于$\frac w2$，且这些数中至多只能选择一个数。</p><p>因此一种暴力是：先找出所有一定选的位置，对于两个相邻的位置，找出它们中间的最小值判断是否合法。</p><p>考虑对于一个位置$k$，在什么情况下它会成为中间那个被选的数。首先，如果它夹在$l,r$之间，那么$l$一定是它左边第一个比它小的数，否则它左边第一个小于它的数没有被选，并且比它小，这与假设矛盾。同理，$r$也一定是它右边第一个比它小的数。</p><p>另外，当区间有多个最小值的时候，我们默认选择最靠前的那个最小值。因此$(l, k)$的最小值不能等于$b_k$。</p><p>由于$l, r$要被选择，$k$是作为$l, r$区间中的点被选择的，这意味着如果$k$是中间那个被选的数，那么一定有$b_k+\max(b_l, b_r) \leq w\leq 2b_k-1$。</p><p>二分$w$之后，找到区间左端点右边第一个不超过$\frac w2$的数$l$，以及区间右端点左边第一个不超过$\frac w2$的数$r$，所有合法的$k$一定在$[l, r]$之间。</p><p>问题转化为二维数点，注意对于$l$左边$r$右边要特判。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ls[N * <span class="number">128</span>], rs[N * <span class="number">128</span>], sum[N * <span class="number">128</span>], ncnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nw = ++ncnt; ls[nw] = ls[rt], rs[nw] = rs[rt], sum[nw] = sum[rt] + x;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> nw;</span><br><span class="line">    <span class="keyword">int</span> mid = ((LL)l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) ls[nw] = update(ls[nw], l, mid, pos, x);</span><br><span class="line">    <span class="keyword">else</span> rs[nw] = update(rs[nw], mid + <span class="number">1</span>, r, pos, x);</span><br><span class="line">    <span class="keyword">return</span> nw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> rt1, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rt) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; l || start &gt; r || start &gt; end) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> sum[rt] - sum[rt1];</span><br><span class="line">    <span class="keyword">int</span> mid = ((LL)l + r) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) res += query(ls[rt], ls[rt1], l, mid, start, end);</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) res += query(rs[rt], rs[rt1], mid + <span class="number">1</span>, r, start, end);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> st[<span class="number">18</span>][N], st1[<span class="number">18</span>][N], lg[N], L[N], R[N], stk[N], rt[N], num[N], n, rt1[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">2e9</span>;</span><br><span class="line">    <span class="keyword">int</span> len = lg[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> min(st[len][l], st[len][r - (<span class="number">1</span> &lt;&lt; len) + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp[N]; <span class="keyword">int</span> Tl = <span class="number">1e9</span>, Tr = <span class="number">-1e9</span>, ok[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) st[<span class="number">0</span>][i] = st1[<span class="number">0</span>][i] = num[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">17</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= n; j++) </span><br><span class="line">            st[i][j] = min(st[i - <span class="number">1</span>][j], st[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> &lt;&lt; i; j &lt;= n; j++)</span><br><span class="line">            st1[i][j] = min(st1[i - <span class="number">1</span>][j], st1[i - <span class="number">1</span>][j - (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>; stk[top = <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &amp;&amp; num[stk[top]] &gt; num[i]) R[stk[top]] = i, top--;</span><br><span class="line">        stk[++top] = i; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (top) R[stk[top--]] = n + <span class="number">1</span>;</span><br><span class="line">    stk[top = <span class="number">1</span>] = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &amp;&amp; num[stk[top]] &gt; num[i]) L[stk[top]] = i, top--;</span><br><span class="line">        stk[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (L[i] &gt;= <span class="number">1</span> &amp;&amp; R[i] &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (get(L[i] + <span class="number">1</span>, i - <span class="number">1</span>) != num[i]) ok[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tl = num[i] + max(num[L[i]], num[R[i]]), tr = num[i] * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        Tl = min(Tl, tl), Tr = max(Tr, tr + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        rt[i] = rt[i - <span class="number">1</span>], rt1[i] = rt1[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (ok[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tl = num[i] + max(num[L[i]], num[R[i]]), tr = num[i] * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">            rt[i] = update(rt[i], Tl, Tr, tl, <span class="number">1</span>), rt[i] = update(rt[i], Tl, Tr, tr + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        rt1[i] = update(rt1[i], Tl, Tr, num[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((LL)get(l, r) * <span class="number">2</span> &gt; w) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> vl = l - <span class="number">1</span>, vr = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (vl + (<span class="number">1</span> &lt;&lt; i) &lt;= r &amp;&amp; st[i][vl + <span class="number">1</span>] * <span class="number">2</span> &gt; w) vl += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (vr - (<span class="number">1</span> &lt;&lt; i) &gt;= l &amp;&amp; st1[i][vr - <span class="number">1</span>] * <span class="number">2</span> &gt; w) vr -= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">    vl++, vr--;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; vl &lt;&lt; ' ' &lt;&lt; vr &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; vl &lt;&lt; ' ' &lt;&lt; vr &lt;&lt; ' ' &lt;&lt; w &lt;&lt; ' ' &lt;&lt; num[vl] &lt;&lt; ' ' &lt;&lt; num[vr] &lt;&lt; endl;</span></span><br><span class="line">    assert(vl &lt;= vr);</span><br><span class="line">    <span class="keyword">int</span> ct = query(rt1[r], rt1[l - <span class="number">1</span>], Tl, Tr, Tl, w / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (vl &lt; vr) ct += query(rt[vr - <span class="number">1</span>], rt[vl], Tl, Tr, Tl, w);</span><br><span class="line">    <span class="comment">// cout &lt;&lt; ct &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span> ((LL)min(get(l, vl - <span class="number">1</span>), get(vr + <span class="number">1</span>, r)) + max(num[vl], num[vr]) &lt;= w) ct++;</span><br><span class="line">    <span class="keyword">return</span> ct &gt;= k;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen("ex_C2.in", "r", stdin);</span></span><br><span class="line">    <span class="keyword">int</span> q, mx = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]), Tl = min(Tl, num[i]), Tr = max(Tr, num[i]);</span><br><span class="line">    mx = Tr, pre();</span><br><span class="line">    <span class="comment">// cout &lt;&lt; Tl &lt;&lt; ' ' &lt;&lt; Tr &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> L, R; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;L, &amp;R, &amp;k);</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = mx * <span class="number">2</span>, mid, res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            mid = ((LL)l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (check(L, R, mid)) res = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 状态压缩 </tag>
            
            <tag> 数位 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.3 考试</title>
      <link href="/2020/08/07/8-3-%E8%80%83%E8%AF%95/"/>
      <url>/2020/08/07/8-3-%E8%80%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-K-shortest-path-on-tree"><a href="#T1-K-shortest-path-on-tree" class="headerlink" title="T1 K shortest path on tree"></a>T1 K shortest path on tree</h1><p><img src="image-20200807170953720.png" alt="image-20200807170953720"></p><p><img src="image-20200807171002094.png" alt="image-20200807171002094"></p><a id="more"></a><p>由于树是随机的（随机父亲），因此所有节点的子树大小之和是$n\log n$级别的。</p><p>先二分，问题转化为求出距离$\leq k$的路径数量。</p><p>直接对原树<code>dfs</code>，开一棵树状数组维护子树外的所有节点的信息。由于两点的距离是$d_u+d_v-2d_{lca}$，因此树状数组中每个节点的权值为$d_v-2d_{lca}$。每次我们先将当前点的整棵子树都放入树状数组，并认为$lca$是当前点。接着我们依次遍历当前点的所有儿子，将这个儿子的子树从树状数组中删去，<code>dfs</code>返回后再加入。当所有儿子都遍历完毕之后再删去当前点的子树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">6000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from], w &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to], w &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tree[M], k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (x += M / <span class="number">2</span>; x &lt;= M - <span class="number">10</span>; x += x &amp; -x) tree[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (x += M / <span class="number">2</span>; x; x -= x &amp; -x) res += tree[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res, mid, dep[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= mid) res++;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; mid || res &gt; k) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) count(e[i].to, u, len + e[i].w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> len, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    upd(len, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) add(e[i].to, u, len + e[i].w, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">3e6</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>, res = qry(mid - dep[u]), count(u, f, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (res &gt;= k) ans[u] = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    add(u, f, -dep[u], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) </span><br><span class="line">            add(e[i].to, u, -dep[u] + e[i].w, <span class="number">-1</span>), dep[e[i].to] = dep[u] + e[i].w, dfs(e[i].to, u), add(e[i].to, u, -dep[u] + e[i].w, <span class="number">1</span>);</span><br><span class="line">    add(u, f, -dep[u], <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen("test1.in", "r", stdin), freopen("out.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b, c; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c), adde(a, b, c);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-Access"><a href="#T2-Access" class="headerlink" title="T2 Access"></a>T2 Access</h1><p><img src="image-20200807171546950.png" alt="image-20200807171546950"></p><p><img src="image-20200807171555291.png" alt="image-20200807171555291"></p><p>考虑一个点$u$向子树中连出的所有边中，哪条边是实边。如果$u$是$u$及其子树内最后一个被操作的点的话，那么$u$连出的边全是虚边，否则$u$的实边将会连向它最后一棵被操作的子树。</p><p>因此记$dp[u][i]$表示考虑$u$的子树，当前共进行了$i$次<strong>有效的</strong>的操作，树的形态总数。</p><p>也就是说，对于每一种树的形态，我们会在它需要进行的最少操作次数中统计到它，这样就避免了算重。</p><p>转移的时候需要再加一维$0/1$辅助转移，记录当前的最后一棵被操作的子树是否被选。</p><p>如果$u$的儿子$v$中只进行了一次操作，操作的点是$v$，并且这个儿子不是最后一棵被操作的子树，那么这次操作就没有用了。因为操作$v$会使得$u,v$的连边变为实边，而由于这个子树不是最后被操作的，因此$u,v$又将变为虚边。也就是说，这棵子树现在全是虚边，和不操作是等价的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from] &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to] &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">2</span>][M], sz[N], k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>, dp[u][<span class="number">0</span>][<span class="number">0</span>] = dp[u][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) &#123;</span><br><span class="line">            dfs(e[i].to, u); <span class="keyword">static</span> <span class="keyword">int</span> g[<span class="number">2</span>][M];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= min(sz[u] + sz[e[i].to], k); j++) g[<span class="number">0</span>][j] = g[<span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= min(sz[u], k); j++) <span class="keyword">if</span> (dp[u][<span class="number">0</span>][j] || dp[u][<span class="number">1</span>][j])</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt;= sz[e[i].to] &amp;&amp; t + j &lt;= k; t++) &#123;</span><br><span class="line">                    g[<span class="number">0</span>][j + t] = (g[<span class="number">0</span>][j + t] + (LL)dp[u][<span class="number">0</span>][j] * (dp[e[i].to][<span class="number">1</span>][t] - (t == <span class="number">1</span>))) % mod;</span><br><span class="line">                    g[<span class="number">1</span>][j + t] = (g[<span class="number">1</span>][j + t] + (LL)dp[u][<span class="number">1</span>][j] * (dp[e[i].to][<span class="number">1</span>][t] - (t == <span class="number">1</span>))) % mod;</span><br><span class="line">                    <span class="keyword">if</span> (t) g[<span class="number">1</span>][j + t] = (g[<span class="number">1</span>][j + t] + (LL)dp[u][<span class="number">0</span>][j] * dp[e[i].to][<span class="number">1</span>][t]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= min(sz[u] + sz[e[i].to], k); j++)</span><br><span class="line">                dp[u][<span class="number">0</span>][j] = g[<span class="number">0</span>][j], dp[u][<span class="number">1</span>][j] = g[<span class="number">1</span>][j];</span><br><span class="line">            sz[u] += sz[e[i].to];</span><br><span class="line">        &#125;</span><br><span class="line">    dp[u][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen("test2.in", "r", stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>); <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) res = (res + dp[<span class="number">1</span>][<span class="number">1</span>][i]) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="XOR-Problem"><a href="#XOR-Problem" class="headerlink" title="XOR Problem"></a>XOR Problem</h1><p><img src="image-20200807172400767.png" alt="image-20200807172400767"></p><p><img src="image-20200807172408249.png" alt="image-20200807172408249"></p><p>将每一位分开，同时将这六个数分为三对。对于每一对我们处理出$f[i][j][1/0]$表示这一对的两个数之差的绝对值为$i$，考虑第$j$位，这两个数在这一维异或为$1/0$的方案数。这个东西可以用<code>NTT</code>做差卷积算出来。</p><p>接着我们枚举最大值来自哪一对数，剩下的两对数就只能取不超过最大值的值，这个东西做一遍前缀和即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> uLL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetR</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, w = <span class="number">1</span>, t; j &lt; i + (mid &gt;&gt; <span class="number">1</span>); j++, w = (LL)w * Wn % mod)</span><br><span class="line">                t = (LL)a[j + (mid &gt;&gt; <span class="number">1</span>)] * w % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!type) <span class="keyword">for</span> (<span class="keyword">int</span> inv = Pow(len, mod - <span class="number">2</span>), i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        a[i] = (LL)a[i] * inv % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, mx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> res[][<span class="number">2</span>], <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> A[<span class="number">2</span>][N &lt;&lt; <span class="number">2</span>], B[<span class="number">2</span>][N &lt;&lt; <span class="number">2</span>], A0[N &lt;&lt; <span class="number">2</span>], A1[N &lt;&lt; <span class="number">2</span>]; </span><br><span class="line">    <span class="built_in">memset</span>(A, <span class="number">0</span>, <span class="keyword">sizeof</span>(A)), <span class="built_in">memset</span>(B, <span class="number">0</span>, <span class="keyword">sizeof</span>(B));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= a; i++) A[(i &gt;&gt; bit) &amp; <span class="number">1</span>][i]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= b; i++) B[(i &gt;&gt; bit) &amp; <span class="number">1</span>][mx - i]++;</span><br><span class="line">    <span class="keyword">int</span> len = GetR(mx * <span class="number">2</span>); NTT(A[<span class="number">0</span>], len, <span class="number">1</span>), NTT(A[<span class="number">1</span>], len, <span class="number">1</span>), NTT(B[<span class="number">0</span>], len, <span class="number">1</span>), NTT(B[<span class="number">1</span>], len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        A0[i] = ((LL)A[<span class="number">0</span>][i] * B[<span class="number">0</span>][i] + (LL)A[<span class="number">1</span>][i] * B[<span class="number">1</span>][i]) % mod;</span><br><span class="line">        A1[i] = ((LL)A[<span class="number">1</span>][i] * B[<span class="number">0</span>][i] + (LL)A[<span class="number">0</span>][i] * B[<span class="number">1</span>][i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    NTT(A0, len, <span class="number">0</span>), NTT(A1, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = -mx, t; i &lt;= mx; i++) </span><br><span class="line">        t = <span class="built_in">abs</span>(i), res[t][<span class="number">0</span>] += A0[i + mx], res[t][<span class="number">1</span>] += A1[i + mx];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[<span class="number">3</span>][<span class="number">16</span>][N][<span class="number">2</span>], num[<span class="number">6</span>]; uLL pre[<span class="number">3</span>][<span class="number">16</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]), mx = max(mx, num[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; i++)</span><br><span class="line">        solve(num[<span class="number">0</span>], num[<span class="number">3</span>], A[<span class="number">0</span>][i], i), solve(num[<span class="number">1</span>], num[<span class="number">4</span>], A[<span class="number">1</span>][i], i), solve(num[<span class="number">2</span>], num[<span class="number">5</span>], A[<span class="number">2</span>][i], i);</span><br><span class="line">    uLL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= mx; i++) &#123;</span><br><span class="line">        uLL w = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">15</span>; j++, w *= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = (i &gt;&gt; j) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> k1 = (k + <span class="number">1</span>) % <span class="number">3</span>, k2 = (k1 + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;= <span class="number">1</span>; a++) <span class="keyword">if</span> (A[k][j][i][a])</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= <span class="number">1</span>; b++) <span class="keyword">if</span> (pre[k1][j][b])</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt;= <span class="number">1</span>; c++) <span class="keyword">if</span> (pre[k2][j][c])</span><br><span class="line">                            <span class="keyword">if</span> (t ^ a ^ b ^ c) </span><br><span class="line">                                res += w * A[k][j][i][a] * pre[k1][j][b] * pre[k2][j][c];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;= <span class="number">1</span>; a++) pre[k][j][a] += A[k][j][i][a];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%llu"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> NTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.2 考试</title>
      <link href="/2020/08/07/8-2-%E8%80%83%E8%AF%95/"/>
      <url>/2020/08/07/8-2-%E8%80%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-Colorful-Tree"><a href="#T1-Colorful-Tree" class="headerlink" title="T1 Colorful Tree"></a>T1 Colorful Tree</h1><p><img src="image-20200807163938731.png" alt="image-20200807163938731"></p><p><img src="image-20200807163953363.png" alt="image-20200807163953363"></p><a id="more"></a><p>这个$k$次方看着就很斯特林数，拆开后问题转化为对于$0$到$k$，求出从所有关键点的颜色中选出$i$种颜色的方案数。</p><p>由于每种颜色的方案数是对称的，因此我们只需要求出所有关键点的颜色包含$1,2,\cdots.i$的方案数，再乘上${m\choose i}$就是答案。</p><p>考虑容斥，求出$1\cdots i$一定不被包含的方案数。记$dp[i][2]$表示已经考虑了$i$以及$i$子树中的点，$i$号节点的颜色是否是关键点不能选的颜色。注意如果$i$是关键点，那么它不能选择前$i$种颜色。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from] &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to] &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][N], mark[N], a, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mark[u]) dp[<span class="number">1</span>][u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) &#123;</span><br><span class="line">            dfs(e[i].to, u);</span><br><span class="line">            <span class="keyword">int</span> A = dp[<span class="number">0</span>][u], B = dp[<span class="number">1</span>][u];</span><br><span class="line">            dp[<span class="number">0</span>][u] = (LL)A * dp[<span class="number">1</span>][e[i].to] % mod * a % mod;</span><br><span class="line">            dp[<span class="number">0</span>][u] = (dp[<span class="number">0</span>][u] + (LL)A * dp[<span class="number">0</span>][e[i].to] % mod * (m - a - <span class="number">1</span>)) % mod;</span><br><span class="line">            dp[<span class="number">1</span>][u] = (LL)B * dp[<span class="number">0</span>][e[i].to] % mod * (m - a) % mod;</span><br><span class="line">            dp[<span class="number">1</span>][u] = (dp[<span class="number">1</span>][u] + (LL)B * dp[<span class="number">1</span>][e[i].to] % mod * (a - <span class="number">1</span>)) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[M], g[M], S[M][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen("A.in", "r", stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n, k, t; <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;k, &amp;t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a; i &lt;= t; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), mark[a] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt; n; i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = S[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            S[i][j] = (S[i - <span class="number">1</span>][j - <span class="number">1</span>] + (LL)S[i - <span class="number">1</span>][j] * j) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max(n, m); i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) </span><br><span class="line">        ::a = i, dfs(<span class="number">1</span>, <span class="number">0</span>), f[i] = ((LL)dp[<span class="number">1</span>][<span class="number">1</span>] * i + (LL)dp[<span class="number">0</span>][<span class="number">1</span>] * (m - i)) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = (LL)f[j] * C(i, j) % mod;</span><br><span class="line">            <span class="keyword">if</span> (j &amp; <span class="number">1</span>) res = (res + mod - w) % mod;</span><br><span class="line">            <span class="keyword">else</span> res = (res + w) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        g[i] = (LL)res * C(m, i) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) </span><br><span class="line">        res = (res + (LL)g[i] * S[k][i] % mod * frac[i]) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-2-cut"><a href="#T2-2-cut" class="headerlink" title="T2 2-cut"></a>T2 2-cut</h1><p><img src="image-20200807164717185.png" alt="image-20200807164717185"></p><p><img src="image-20200807164725261.png" alt="image-20200807164725261"></p><p>如果割去的两条边存在祖先与后继的关系，那么这两条边一定是相邻的两条边，否则不优秀。对于这种情况我们特殊考虑，假设选择的两条边分别为$u$与父亲的连边以及$v$与$u$的连边（$u$是$v$的父亲），那么还需要割的边数是$u$子树内的非树边数量减去$v$子树内的非树边数量。</p><p>接下来我们讨论割去的两条边不为祖先关系的情况。</p><p>割去这两条边会将整张图分为三个连通块，假如割去的两条边分别为$u,v$与父亲的连边，那么需要割去的总边数为$2+c_u+c_v-2\times c_{u,v}$。这里$c_u$表示$u$子树内的边数，$c_{u,v}$表示从$u$的子树连向$v$的子树的边数。</p><p>考虑枚举$u$，那么我们需要维护整棵树$c_v-2\times c_{u,v}$的最小值。$u$的信息可以由它的所有儿子继承过来，同时考虑从$u$连出去的所有非树边。假设有一条非树边$(u,v)$，那么我们需要给$v$以及$v$的父亲都减去$2$，同时需要维护区间最小值。</p><p>我们对每个点开一棵动态开点的线段树维护整棵树的树剖，需要支持区间$-2$，区间查询最小值。由于每个点一开始有权值（$c_u$），即线段树上所有为空的节点也是有权值的，因此我们需要再开一个st表维护区间内$c_u$的最小值，这样当我们新建一个节点的时候我们就可以直接通过查st表得到这个节点的初始信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from] &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to] &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N], top[N], son[N], dfn[N], sz[N], ed[N], dfsn, ct[N], rk[N], dep[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    fa[u] = f, sz[u] = <span class="number">1</span>, dep[u] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) &#123;</span><br><span class="line">            dfs(e[i].to, u), sz[u] += sz[e[i].to], ct[u] += ct[e[i].to];</span><br><span class="line">            <span class="keyword">if</span> (sz[e[i].to] &gt; sz[son[u]]) son[u] = e[i].to;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    top[u] = t, dfn[u] = ++dfsn, rk[dfsn] = u;</span><br><span class="line">    <span class="keyword">if</span> (son[u]) dfs1(son[u], t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != fa[u] &amp;&amp; e[i].to != son[u]) </span><br><span class="line">            dfs1(e[i].to, e[i].to);</span><br><span class="line">    ed[u] = dfsn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> st[<span class="number">16</span>][N], n, lg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) st[<span class="number">0</span>][i] = ct[rk[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">15</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= n; j++) </span><br><span class="line">            st[i][j] = min(st[i - <span class="number">1</span>][j], st[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = lg[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> min(st[len][l], st[len][r - (<span class="number">1</span> &lt;&lt; len) + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tag[N * <span class="number">32</span>], ncnt, ls[N * <span class="number">32</span>], rs[N * <span class="number">32</span>], mn[N * <span class="number">32</span>]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">apply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pool.size()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = pool.back(); pool.pop_back();</span><br><span class="line">        <span class="keyword">return</span> tag[u] = ls[u] = rs[u] = <span class="number">0</span>, u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ++ncnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    mn[rt] = <span class="number">1e9</span>; <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ls[rt]) mn[rt] = min(mn[rt], mn[ls[rt]] - tag[rt]);</span><br><span class="line">    <span class="keyword">else</span> mn[rt] = min(mn[rt], get(l, mid) - tag[rt]);</span><br><span class="line">    <span class="keyword">if</span> (rs[rt]) mn[rt] = min(mn[rt], mn[rs[rt]] - tag[rt]);</span><br><span class="line">    <span class="keyword">else</span> mn[rt] = min(mn[rt], get(mid + <span class="number">1</span>, r) - tag[rt]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rt) rt = apply(), mn[rt] = get(l, r);</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> tag[rt] += <span class="number">2</span>, mn[rt] -= <span class="number">2</span>, <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) update(ls[rt], l, mid, start, end);</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) update(rs[rt], mid + <span class="number">1</span>, r, start, end);</span><br><span class="line">    pushup(rt, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rt) <span class="keyword">return</span>;</span><br><span class="line">    pool.push_back(rt), del(ls[rt]), del(rs[rt]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">if</span> (!rt) <span class="keyword">return</span> get(max(l, start), min(r, end));</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> mn[rt];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, res = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) res = min(res, query(ls[rt], l, mid, start, end));</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) res = min(res, query(rs[rt], mid + <span class="number">1</span>, r, start, end));</span><br><span class="line">    <span class="keyword">return</span> res - tag[rt]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x |= y, <span class="keyword">void</span>();</span><br><span class="line">    tag[x] += tag[y];</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> mn[x] -= tag[y], <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    merge(ls[x], ls[y], l, mid), merge(rs[x], rs[y], mid + <span class="number">1</span>, r), pushup(x, l, r), pool.push_back(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[x]) update(rt, <span class="number">1</span>, n, dfn[top[x]], dfn[x]), x = fa[top[x]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rt[N], ans[N], fuck[N]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    ans[u] = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">            dfs2(v, u), merge(rt[u], rt[v], <span class="number">1</span>, n);</span><br><span class="line">            ans[v] = min(ans[v], ct[u] - ct[v] + <span class="number">2</span>), ans[u] = min(ans[u], ct[u] - ct[v] + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) update(rt[u], v);</span><br><span class="line">    ans[u] = min(ans[u], <span class="number">2</span> + ct[u] + min(query(rt[u], <span class="number">1</span>, n, <span class="number">1</span>, dfn[u] - <span class="number">1</span>), query(rt[u], <span class="number">1</span>, n, ed[u] + <span class="number">1</span>, n)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen("ex_B2.in", "r", stdin);</span></span><br><span class="line">    <span class="keyword">int</span> m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt;= m - n + <span class="number">1</span>; i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), G[a].push_back(b), G[b].push_back(a), ct[a]++, ct[b]++;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>), dfs1(<span class="number">1</span>, <span class="number">1</span>), pre();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[<span class="number">1</span>]; i; i = e[i].next)</span><br><span class="line">        dfs2(e[i].to, <span class="number">1</span>), del(rt[e[i].to]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; u++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">            <span class="keyword">if</span> (dep[e[i].to] &gt; dep[u]) </span><br><span class="line">                fuck[(i + <span class="number">1</span>) / <span class="number">2</span>] = ans[e[i].to];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, fuck[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-Palindrome"><a href="#T3-Palindrome" class="headerlink" title="T3 Palindrome"></a>T3 Palindrome</h1><p><img src="image-20200807165603094.png" alt="image-20200807165603094"></p><p><img src="image-20200807165609423.png" alt="image-20200807165609423"></p><p>将所有数从小到大排序之后可以得到回文浓度的上界，因为此时每对相同字母中间都是回文串。</p><p>通过观察可以发现只会有四种情况：</p><ol><li>一种数字全部挤在一起，构成完整的一段</li><li>出现次数为$n$的数字和出现次数为$n+1$或$n-1$的数字揉在一起，方案数唯一。比如<code>23232</code>。</li><li>出现次数为$n$的两种数字揉在一起，方案数为$2$。比如<code>2323</code>，也可以翻转得到<code>3232</code>。</li><li>第一种和第三种情况外可以套任意多个出现次数为$2$的数。比如<code>212</code>，<code>34121243</code>等。</li></ol><p>考虑按照出现次数从大到小$dp$，记$dp[i][j][k][l]$表示考虑出现次数大于等于$i$的数，形成了$j$段，此时外面能套任意多个出现次数为$2$的有$k$段，有$l$个出现次数为$i-1$数需要填入$i$的空位中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">90</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ct[N], a[<span class="number">6410</span>], dp[<span class="number">2</span>][N][N][N], C[N][N], match[N], frac[N], f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, mx = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), ct[a]++, mx = max(mx, a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mx; i++) a[ct[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N - <span class="number">10</span>; i++) &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            C[i][j] = (C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    LL fuck = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fuck += i * (i + <span class="number">1</span>) / <span class="number">2</span> * a[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld "</span>, fuck);</span><br><span class="line">    frac[<span class="number">0</span>] = match[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N - <span class="number">10</span>; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N - <span class="number">10</span>; i += <span class="number">2</span>) </span><br><span class="line">        match[i] = (LL)match[i - <span class="number">2</span>] * (i - <span class="number">1</span>) % mod * <span class="number">2</span> % mod;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">3</span>; i--) &#123;</span><br><span class="line">        cur ^= <span class="number">1</span>, <span class="built_in">memset</span>(dp[cur], <span class="number">0</span>, <span class="keyword">sizeof</span>(dp[cur]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= a[i + <span class="number">1</span>] &amp;&amp; j &lt;= a[i]; j++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= mx; k++) <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= k; b++) <span class="keyword">if</span> (dp[cur ^ <span class="number">1</span>][j][k][b]) &#123;</span><br><span class="line">                <span class="keyword">int</span> remain = a[i] - j, w1 = (LL)C[a[i]][j] * dp[cur ^ <span class="number">1</span>][j][k][b] % mod * frac[j] % mod;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt;= remain; t += <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> c = t / <span class="number">2</span> + remain - t, w = (LL)w1 * C[remain][t] % mod * match[t] % mod;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= remain - t; l++) </span><br><span class="line">                        dp[cur][l][c + k][b + remain - t] = (dp[cur][l][c + k][b + remain - t] + (LL)C[remain - t][l] * w) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mx; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= mx; j++) <span class="keyword">if</span> (f[i - <span class="number">1</span>][j]) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= mx - j; k++)</span><br><span class="line">                f[i][j + k] = (f[i][j + k] + (LL)f[i - <span class="number">1</span>][j] * C[j + k][k] % mod * frac[k]) % mod;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= mx &amp;&amp; i &lt;= a[<span class="number">2</span>]; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= mx; j++) <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= j; b++) <span class="keyword">if</span> (dp[cur][i][j][b]) &#123;</span><br><span class="line">            <span class="keyword">int</span> remain = a[<span class="number">2</span>] - i, w1 = (LL)C[a[<span class="number">2</span>]][i] * dp[cur][i][j][b] % mod * frac[i] % mod;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= remain; k++) </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; k + l &lt;= remain; l += <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> c = a[<span class="number">1</span>] + j + l / <span class="number">2</span> + k;</span><br><span class="line">                    res = (res + (LL)w1 * C[remain][k] % mod * match[l] % mod * f[b + a[<span class="number">1</span>] + k][remain - l - k] % mod * C[remain - k][l] % mod * frac[c]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.1 考试</title>
      <link href="/2020/08/07/8-1-%E8%80%83%E8%AF%95/"/>
      <url>/2020/08/07/8-1-%E8%80%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-Interstellar"><a href="#T1-Interstellar" class="headerlink" title="T1 Interstellar"></a>T1 Interstellar</h1><p><img src="image-20200807105613219.png" alt="image-20200807105613219"></p><p><img src="image-20200807105621796.png" alt="image-20200807105621796"></p><a id="more"></a><p>显然有$dp[u]=dp[v’]\times 2+\sum_{v\neq v’}dp[v’]$，这里$v’$是$u$的$dp$值最大的儿子。</p><p>每个点开个<code>set</code>维护$dp$值中所有为$1$的位置，需要支持比较两个点的$dp$值大小、将两个点的$dp$值相加以及给某个点乘$2$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next; LL w;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, LL w)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from], w &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to], w &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;LL&gt; one[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tag[N], rt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, LL x)</span> </span>&#123;</span><br><span class="line">    LL pos = x - tag[u];</span><br><span class="line">    <span class="keyword">while</span> (one[u].count(pos)) </span><br><span class="line">        one[u].erase(pos), pos++;</span><br><span class="line">    one[u].insert(pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : one[rt[u]]) res = (res + Pow(<span class="number">2</span>, (tag[rt[u]] + t) % (mod - <span class="number">1</span>))) % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123; <span class="comment">// u &gt; v</span></span><br><span class="line">    <span class="keyword">auto</span> p1 = one[u].rbegin(), p2 = one[v].rbegin();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">233</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1 == one[u].rend()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (p2 == one[v].rend()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (*p1 + tag[u] != *p2 + tag[v]) </span><br><span class="line">            <span class="keyword">return</span> *p1 + tag[u] &gt; *p2 + tag[v];</span><br><span class="line">        p1++, p2++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (one[rt[u]].size() &lt; one[rt[v]].size()) swap(rt[u], rt[v]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : one[rt[v]]) insert(rt[u], t + tag[rt[v]]);</span><br><span class="line">    one[rt[v]].clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, LL w)</span> </span>&#123;</span><br><span class="line">    rt[u] = u; <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) &#123;</span><br><span class="line">            dfs(e[i].to, u, e[i].w);</span><br><span class="line">            <span class="keyword">if</span> (!mx || cmp(rt[e[i].to], rt[mx])) mx = e[i].to;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (mx) tag[rt[mx]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) merge(u, e[i].to);</span><br><span class="line">    <span class="keyword">if</span> (f) insert(rt[u], w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; LL b; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, a; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>, &amp;a, &amp;b), adde(a, i, b);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, calc(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-K-bag-Sequence"><a href="#T2-K-bag-Sequence" class="headerlink" title="T2 K-bag Sequence"></a>T2 K-bag Sequence</h1><p><img src="image-20200807105848290.png" alt="image-20200807105848290"></p><p><img src="image-20200807105856929.png" alt="image-20200807105856929"></p><p>考虑这样一种暴力：</p><p>首先容斥一下，枚举从哪些位置开始匹配一定合法，从剩下的位置开始匹配可能合法，也可能不合法。</p><p><img src="image-20200807110158987.png" alt="image-20200807110158987"></p><p>黑色区间表示所有的限制，每个黑色区间内每种数只能出现一次，同一行的黑色区间表示同一种限制：即从某个位置开始匹配。根据定义，每一行的黑色区间中，除了第一个与最后一个区间长度可能小于$k$以外，剩下的区间长度一定等于$k$。</p><p>我们不妨将“区间内的数两两不同”称为一个排列，那么这些限制的端点将会把整个序列划分成若干段，每一段内都必须是一个排列，并且如图所示，构成蓝色的区间的数必须完全相同（顺序可以不同）。</p><p>考虑这些开始匹配的位置中最小的那一个（注意：对于第一段长度等于$k$的限制，我们认为它的开始匹配位置为$k$而不是$0$），假设这个位置为$i$，那么$[i+1,i+k]$这个区间将会被划分为若干段。</p><p><img src="image-20200807110905187.png" alt="image-20200807110905187"></p><p>这些段构成了$k$的一个划分，并且除了划分出的最后一段以外，$[1,i]$与$[i+1,k+1]$划分出的段的任意一个前缀都应是一个排列。另外，$[i+1,k+1]$也应是一个排列。</p><p>根据定义，$i$不能大于最后一个被划分出的段的长度，否则将出现一个限制的匹配位置大于$k$。</p><p>对于$[i+1,k+1]$，我们可以给它被划分出的每一段分配填入的数，方案数为一个组合数乘上阶乘。对于$k+1$之后的每一段，这个段内填的数必须与$[i+1,k+1]$中对应段填的数完全一致，因此对答案的贡献仅为一个阶乘。</p><p>注意最后的一段长度可能不到$k$，需要特殊考虑。</p><p>暴力枚举划分的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k, n, frac[<span class="number">16</span>], inv[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    assert(r &lt;= n &amp;&amp; r &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> mn, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; mn) <span class="keyword">return</span> A(k, n); </span><br><span class="line">    <span class="keyword">int</span> res = A(k, mn);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, l = mn + <span class="number">1</span>; i &lt; t.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = l + t[i] - <span class="number">1</span>, tmp = <span class="built_in">floor</span>((n - r) / (<span class="keyword">double</span>)k);</span><br><span class="line">        <span class="keyword">int</span> w = ((i + <span class="number">1</span>) == t.size()) ? frac[r - l + <span class="number">1</span>] : A(k - mn - (l - mn - <span class="number">1</span>), r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (tmp &gt;= <span class="number">0</span>) res = (LL)res * w % mod * Pow(frac[r - l + <span class="number">1</span>], tmp) % mod;</span><br><span class="line">        <span class="keyword">if</span> (l + (tmp + <span class="number">1</span>) * k &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">int</span> remain = n - l - (tmp + <span class="number">1</span>) * k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (tmp &lt; <span class="number">0</span>) res = (LL)res * ((i + <span class="number">1</span>) == t.size() ? A(r - l + <span class="number">1</span>, remain) : A(k - mn - (l - mn - <span class="number">1</span>), remain)) % mod;</span><br><span class="line">            <span class="keyword">else</span> res = (LL)res * A(r - l + <span class="number">1</span>, remain) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        l = r + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> nw)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nw == k) &#123;</span><br><span class="line">        <span class="keyword">int</span> w = <span class="number">0</span>, tmp = tp.back(); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tmp; i++)  </span><br><span class="line">            w = (w + solve(i, tp)) % mod;</span><br><span class="line">        <span class="keyword">if</span> (tp.size() &amp; <span class="number">1</span>) res = (res + w) % mod;</span><br><span class="line">        <span class="keyword">else</span> res = (res + mod - w) % mod;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k - nw; i++)</span><br><span class="line">        tp.push_back(i), dfs(nw + i), tp.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">15</span>; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k), res = <span class="number">0</span>;</span><br><span class="line">        dfs(<span class="number">0</span>), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将枚举划分改为$dp$即可，时间复杂度$k^3$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k, n, frac[<span class="number">65</span>], inv[<span class="number">65</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    assert(r &lt;= n &amp;&amp; r &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">65</span>][<span class="number">65</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">60</span>; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp)); <span class="keyword">int</span> n, k; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) dp[<span class="number">0</span>][i] = n &lt; i ? A(k, n) : A(k, i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; k; t++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= k; s++) <span class="keyword">if</span> (dp[t][s])</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; t + j &lt;= k; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t + j == k) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (j &lt; s) <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k - t - j &lt; s) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">int</span> res = mod - dp[t][s];</span><br><span class="line">                    <span class="keyword">if</span> (n &lt; s) &#123;</span><br><span class="line">                        dp[t + j][s] = (dp[t + j][s] + res) % mod;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> l = t + s + <span class="number">1</span>, r = l + j - <span class="number">1</span>, tmp = <span class="built_in">floor</span>((n - r) / (<span class="keyword">double</span>)k);</span><br><span class="line">                    <span class="keyword">int</span> w = t + j == k ? frac[r - l + <span class="number">1</span>] : A(k - s - (l - s - <span class="number">1</span>), r - l + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (tmp &gt;= <span class="number">0</span>) res = (LL)res * w % mod * Pow(frac[r - l + <span class="number">1</span>], tmp) % mod;</span><br><span class="line">                    <span class="keyword">if</span> (l + (tmp + <span class="number">1</span>) * k &lt;= n) &#123;</span><br><span class="line">                        <span class="keyword">int</span> remain = n - l - (tmp + <span class="number">1</span>) * k + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (tmp &lt; <span class="number">0</span>) res = (LL)res * (t + j == k ? A(r - l + <span class="number">1</span>, remain) : A(k - s - (l - s - <span class="number">1</span>), remain)) % mod;</span><br><span class="line">                        <span class="keyword">else</span> res = (LL)res * A(r - l + <span class="number">1</span>, remain) % mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[t + j][s] = (dp[t + j][s] + res) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) res = (res + dp[k][i]) % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mod - res);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-String-Cheese"><a href="#T3-String-Cheese" class="headerlink" title="T3 String Cheese"></a>T3 String Cheese</h1><p><img src="image-20200807111503019.png" alt="image-20200807111503019"></p><p><img src="image-20200807111511943.png" alt="image-20200807111511943"></p><p>建出后缀树，显然最终我们一定会在一个点上走到它的$mxlen$，然后选择是往前添加字符还是往后添加字符。因为串越长，它在$s$中的出现次数就越少，而同一个点中的串的出现次数是相同的。</p><p>向前添加字符对应在后缀树上往子树走，向右添加字符对应在<code>DAG</code>上走。记$dp[i]$表示当前串为$i$号节点能代表的最长的串，进行若干次操作能得到的最大值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch[N][<span class="number">26</span>], len[N], link[N] = &#123; <span class="number">-1</span> &#125;, tot, lst;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nw = ++tot, p = lst; len[nw] = len[lst] + <span class="number">1</span>, lst = nw;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="number">-1</span> &amp;&amp; !ch[p][c - <span class="string">'a'</span>]) ch[p][c - <span class="string">'a'</span>] = nw, p = link[p];</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">-1</span>) <span class="keyword">return</span> lst;</span><br><span class="line">    <span class="keyword">int</span> q = ch[p][c - <span class="string">'a'</span>];</span><br><span class="line">    <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>) <span class="keyword">return</span> link[nw] = q, lst;</span><br><span class="line">    <span class="keyword">int</span> clone = ++tot; <span class="built_in">memcpy</span>(ch[clone], ch[q], <span class="keyword">sizeof</span>(ch[q])), len[clone] = len[p] + <span class="number">1</span>;</span><br><span class="line">    link[clone] = link[q], link[q] = link[nw] = clone;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="number">-1</span> &amp;&amp; ch[p][c - <span class="string">'a'</span>] == q) ch[p][c - <span class="string">'a'</span>] = clone, p = link[p];</span><br><span class="line">    <span class="keyword">return</span> lst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> appear[N], id[N]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; wkr[N];</span><br><span class="line"></span><br><span class="line">LL dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>); <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) appear[insert(s[i])]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) id[i] = i;</span><br><span class="line">    sort(id + <span class="number">1</span>, id + tot + <span class="number">1</span>, [&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> len[a] &gt; len[b]; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) appear[link[id[i]]] += appear[id[i]], wkr[link[i]].push_back(i);</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">        LL t = <span class="number">0</span>; <span class="keyword">int</span> u = id[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : wkr[u]) t = max(t, dp[v] + (LL)(len[v] - len[u]) * appear[v]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) <span class="keyword">if</span> (ch[u][j]) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = ch[u][j];</span><br><span class="line">            t = max(t, dp[v] + (LL)(len[v] - len[u]) * appear[v]);</span><br><span class="line">        &#125; </span><br><span class="line">        dp[u] = t, res = max(res, dp[u] + (LL)appear[u] * len[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>7.31 考试</title>
      <link href="/2020/08/07/7-31-%E8%80%83%E8%AF%95/"/>
      <url>/2020/08/07/7-31-%E8%80%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-Alternating-Paths"><a href="#T1-Alternating-Paths" class="headerlink" title="T1 Alternating Paths"></a>T1 Alternating Paths</h1><p><img src="image-20200807102803087.png" alt="image-20200807102803087"></p><p><img src="image-20200807102810855.png" alt="image-20200807102810855"></p><a id="more"></a><p>考虑这样一种建图方式：</p><p>对于每个关键点，我们新建三个点：黑点、白点和第三个点。对于每个非关键点，我们只建两个点：黑点和白点。</p><p>每个点的黑点和白点之间连了一条边，如果这条边被选则代表这个点不在最终的路径中。黑点向与它通过黑边相连的点的黑点连边；白点向与它通过白边相连的点的白点连边。这样可以保证路径一定是黑白交错的。</p><p>关键点的第三个点向黑点和白点连边，边权为关键点的点权。如果这条边被选了，代表关键点是某一条路径的起点或者终点。</p><p>最后，将所有的关键点的第三个点两两相连，用于将剩下未匹配的第三个点匹配。</p><p>跑一遍最大权完美匹配就是答案。</p><h1 id="T2-Dispatch-Money"><a href="#T2-Dispatch-Money" class="headerlink" title="T2 Dispatch Money"></a>T2 Dispatch Money</h1><p><img src="image-20200807104710706.png" alt="image-20200807104710706"></p><p>每一段的代价为这一段中的逆序对数量，这个东西看起来就满足四边形不等式，因此决策点是单调的。</p><p>先分治一下，考虑用左半边的值更新右半边的答案，首先套一个决策单调性的分治，然后我们需要快速计算一个区间的逆序对数。</p><p>类似Yet another Minimization Problem的做法，像莫队那样维护两个指针，每次询问时暴力移动两个指针，可以证明移动次数是均摊$O(1)$的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tree[N], n, num[N], x; LL dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">for</span> (; x &lt;= n; x += x &amp; -x) tree[x] += y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">int</span> res = <span class="number">0</span>; <span class="keyword">for</span> (; x; x -= x &amp; -x) res += tree[x]; <span class="keyword">return</span> res; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">return</span> qry(r) - qry(l - <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">move</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>; <span class="keyword">static</span> LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &gt; L) l--, res += qry(<span class="number">1</span>, num[l]), upd(num[l], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (r &lt; R) r++, res += qry(num[r], n), upd(num[r], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (l &lt; L) upd(num[l], <span class="number">-1</span>), res -= qry(<span class="number">1</span>, num[l]), l++;</span><br><span class="line">    <span class="keyword">while</span> (r &gt; R) upd(num[r], <span class="number">-1</span>), res -= qry(num[r], n), r--;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = l, mid = (l + r) &gt;&gt; <span class="number">1</span>; LL res = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tl; i &lt;= tr; i++) &#123;</span><br><span class="line">        LL t = move(i + <span class="number">1</span>, mid) + x + dp[i];</span><br><span class="line">        <span class="keyword">if</span> (t &lt; res) res = t, pos = i;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[mid] = min(dp[mid], res), CDQ(l, mid - <span class="number">1</span>, tl, pos), CDQ(mid + <span class="number">1</span>, r, pos, tr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    CDQ(l, mid), CDQ(mid + <span class="number">1</span>, r, l, mid), CDQ(mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> val[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]), val[i] = num[i];</span><br><span class="line">    sort(val + <span class="number">1</span>, val + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) num[i] = lower_bound(val + <span class="number">1</span>, val + n + <span class="number">1</span>, num[i]) - val;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp)), dp[<span class="number">0</span>] = <span class="number">0</span>, CDQ(<span class="number">0</span>, n), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-Exercise"><a href="#T3-Exercise" class="headerlink" title="T3 Exercise"></a>T3 Exercise</h1><p><img src="image-20200807105042696.png" alt="image-20200807105042696"></p><p>取一个$500$左右的质数$p$，枚举这两个点坐标模$p$的值，判断是否在模意义下等于$k$。此时我们只需要枚举前三个坐标，第四个坐标可以直接算出来。</p><p>由于所有点的坐标是随机的，因此这样一来可以筛掉大部分情况。对于筛出来的每一类的所有点，$n^2$暴力判断即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">331</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> inv[P], X[N], Y[N]; LL x; </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; wkr[P][P];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((LL)X[a] * X[b] + (LL)Y[a] * Y[b] == x) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, a, b), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen("T3.in", "r", stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>, &amp;n, &amp;x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; P; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; P; j++) <span class="keyword">if</span> (i * j % P == <span class="number">1</span>) &#123;</span><br><span class="line">            inv[i] = j, inv[j] = i; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;X[i], &amp;Y[i]);</span><br><span class="line">        wkr[X[i] % P][Y[i] % P].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = x % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; P; a++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; P; b++) <span class="keyword">if</span> (wkr[a][b].size()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; P; c++) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = t - a * c % P; r += (r &gt;&gt; <span class="number">31</span>) &amp; P;</span><br><span class="line">                <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (r) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; P; d++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">auto</span> u : wkr[c][d]) <span class="keyword">for</span> (<span class="keyword">auto</span> v : wkr[a][b]) </span><br><span class="line">                            chk(u, v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> d = r * inv[b] % P;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> u : wkr[c][d]) <span class="keyword">for</span> (<span class="keyword">auto</span> v : wkr[a][b])</span><br><span class="line">                        chk(u, v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.30 考试</title>
      <link href="/2020/08/07/7-30-%E8%80%83%E8%AF%95/"/>
      <url>/2020/08/07/7-30-%E8%80%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-Good-Subsegments"><a href="#T1-Good-Subsegments" class="headerlink" title="T1 Good Subsegments"></a>T1 Good Subsegments</h1><p><img src="image-20200807093507918.png" alt="image-20200807093507918"></p><a id="more"></a><p>如果我们确定了整个区间的最大值$mx$，那么这段区间的和只有可能是$2^{mx}$到$2^{mx+18}$中的一个数。</p><p>先分治，每次拿出最大值的位置，考虑那些跨过最大值的区间，此时我们可以枚举这个区间的和，然后多找几个质数取模就可以判断一个区间是否合法。如果最大值在区间中点的右边，那么枚举右半边的所有位置作为右端点；否则枚举左半边的所有位置作为左端点。</p><p>模数可以取大一点，这样基本不会冲突。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">194910010019260817l</span>l;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL x, LL y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((x * y - (LL)((<span class="keyword">long</span> <span class="keyword">double</span>)x / mod * y + <span class="number">0.5</span>) * mod) % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Pow</span><span class="params">(LL x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = mul(x, x)) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = mul(res, x);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wen</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">2017925</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;LL&gt; val[mod], hh[mod];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">count</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = x % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : val[t]) <span class="keyword">if</span> (v == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qry</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = x % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; val[t].size(); i++) <span class="keyword">if</span> (val[t][i] == x) <span class="keyword">return</span> hh[t][i];</span><br><span class="line">    assert(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(LL key, LL x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = key % mod;</span><br><span class="line">    val[t].push_back(key), hh[t].push_back(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; mp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos[N]; </span><br><span class="line"></span><br><span class="line">LL h[N], pw[N]; <span class="keyword">int</span> num[N], st[<span class="number">18</span>][N], lg[N], n, tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num[a] &gt; num[b] ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tot = <span class="number">1</span>, mp.push(<span class="number">0</span>, <span class="number">1</span>), pos[<span class="number">1</span>].push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        pw[i] = Pow(<span class="number">2</span>, num[i]), h[i] = (h[i - <span class="number">1</span>] + pw[i]) % mod, st[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="keyword">int</span> id = mp.count(h[i]) ? mp.qry(h[i]) : (mp.push(h[i], ++tot), tot);</span><br><span class="line">        pos[id].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">17</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= n; j++) </span><br><span class="line">            st[i][j] = Max(st[i - <span class="number">1</span>][j], st[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = lg[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> Max(st[len][l], st[len][r - (<span class="number">1</span> &lt;&lt; len) + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(LL x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mp.count(x)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> id = mp.qry(x);</span><br><span class="line">    <span class="keyword">return</span> upper_bound(pos[id].begin(), pos[id].end(), r) - lower_bound(pos[id].begin(), pos[id].end(), l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span>;</span><br><span class="line">    res++;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">int</span> mid = get(l, r); LL t = pw[mid] * <span class="number">2</span> % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">18</span>; i++, t = t * <span class="number">2</span> % mod) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mid - l &lt; r - mid) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= mid; i++) </span><br><span class="line">                res += count((t + h[i - <span class="number">1</span>]) % mod, mid, r);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &lt;= r; i++)</span><br><span class="line">                res += count((h[i] - t + mod) % mod, l - <span class="number">1</span>, mid - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    solve(l, mid - <span class="number">1</span>), solve(mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">    pre(), solve(<span class="number">1</span>, n), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-Easy-Sum"><a href="#T2-Easy-Sum" class="headerlink" title="T2 Easy Sum"></a>T2 Easy Sum</h1><p><img src="image-20200807095930119.png" alt="image-20200807095930119"></p><p>考虑答案关于$k$的生成函数$F(x)$，有</p><script type="math/tex; mode=display">F(x)=\sum_{i=1}^n\sum_{j=0}^{n-1}{a_i+b_i-j\choose a_i}x^j</script><p>单独考虑第二个$\sum$，可以得到</p><script type="math/tex; mode=display">\begin{aligned}\sum_{j=0}^{n-1}{a_i+b_i-j\choose a_i}x^j&=\sum_{j=0}^{b_i}{a_i+j\choose j}x^{b_i-j}\\&=x^{b_i}\sum_{j\geq 0}{a_i+j\choose j}x^{-j}\\&=x^{b_i}\times\frac{1}{(1-x^{-1})^{a_i+1}}\\&=x^{b_i}\times\frac{x^{a_i+1}}{(x-1)^{a_i+1}}\end{aligned}</script><p>也就是说，我们最终要求的是</p><script type="math/tex; mode=display">\sum_{i=1}^n\frac{x^{b_i+a_i+1}}{(x-1)^{a_i+1}}</script><p>注意：这里的除法不是简单的多项式求逆，因为此时多项式的每一项次数不一定是非负整数，这与普通域下的多项式不一样，因此我们必须避免求逆。</p><p>考虑用$y=x-1$替换$x$，可以得到</p><script type="math/tex; mode=display">\sum_{i=1}^n\frac{(y+1)^{b_i+a_i+1}}{y^{a_i+1}}</script><p>记$t=\max a_i+1$，那么通分之后可以得到</p><script type="math/tex; mode=display">\sum_{i=1}^n\frac{(y+1)^{b_i+a_i+1}y^{t-a_i-1}}{y^t}</script><p>也就是说，我们只需要求出分子的和，然后将多项式整体向左平移$t$即可，由于最终我们只需要知道$k=0$到$n-1$的值，因此只需要保留次数非负的项。</p><p>考虑对$b_i+a_i+1$分段计算，我们每$\sqrt n$个分为一段，即用$A\sqrt n+B$来表示$a_i+b_i+1$。此时对于段内的$(y+1)^{b_i+a_i+1}$，我们可以暴力计算$(y+1)^{B}y^{t-a_i-1}$，这个多项式只有至多$\sqrt n$项不为$0$。当整段的这个东西计算完毕之后，我们再给它乘上$(y+1)^{A\sqrt n}$即可。</p><p>最后记得将$y$换为$x-1$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getlen</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Wn[<span class="number">2</span>][<span class="number">18</span>][N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getwn</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>, step = <span class="number">0</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>, step++) &#123;</span><br><span class="line">        <span class="keyword">int</span> w0 = Pow(<span class="number">3</span>, (mod - <span class="number">1</span>) / mid), w1 = Pow(<span class="number">3</span>, mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        Wn[<span class="number">1</span>][step][<span class="number">0</span>] = Wn[<span class="number">0</span>][step][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (mid &gt;&gt; <span class="number">1</span>); i++) &#123;</span><br><span class="line">            Wn[<span class="number">1</span>][step][i] = (LL)Wn[<span class="number">1</span>][step][i - <span class="number">1</span>] * w0 % mod;</span><br><span class="line">            Wn[<span class="number">0</span>][step][i] = (LL)Wn[<span class="number">0</span>][step][i - <span class="number">1</span>] * w1 % mod;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>, step = <span class="number">0</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>, step++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, t; j &lt; i + (mid &gt;&gt; <span class="number">1</span>); j++)</span><br><span class="line">                t = (LL)Wn[type][step][j - i] * a[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    <span class="keyword">if</span> (!type) <span class="keyword">for</span> (<span class="keyword">int</span> inv = Pow(len, mod - <span class="number">2</span>), i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        a[i] = (LL)a[i] * inv % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = getlen(n);</span><br><span class="line">    NTT(A, len, <span class="number">1</span>), NTT(B, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) A[i] = (LL)A[i] * B[i] % mod;</span><br><span class="line">    NTT(A, len, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shift</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> B[N &lt;&lt; <span class="number">1</span>]; <span class="built_in">memset</span>(B, <span class="number">0</span>, <span class="keyword">sizeof</span>(B));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) A[i] = (LL)A[i] * frac[i] % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) </span><br><span class="line">        B[n - i] = i &amp; <span class="number">1</span> ? mod - inv[i] : inv[i];</span><br><span class="line">    Mul(A, B, n * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) A[i] = (LL)A[n + i] * inv[i] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen("test1.in", "r", stdin), freopen("out.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n, mx = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a[i], &amp;b[i]), a[i]++, mx = max(mx, a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] += b[i], b[i] = mx - (a[i] - b[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n * <span class="number">4</span>) len &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    getwn(len);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">1500</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> wkr[N &lt;&lt; <span class="number">2</span>]; <span class="built_in">memset</span>(wkr, <span class="number">0</span>, <span class="keyword">sizeof</span>(wkr));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= n * <span class="number">2</span>; l += step) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = l + step - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[N &lt;&lt; <span class="number">1</span>]; <span class="built_in">memset</span>(A, <span class="number">0</span>, <span class="keyword">sizeof</span>(A));</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (l &lt;= a[i] &amp;&amp; a[i] &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = a[i] - l; flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= t; j++) </span><br><span class="line">                A[j + b[i]] = (A[j + b[i]] + C(t, j)) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> B[N &lt;&lt; <span class="number">1</span>]; <span class="built_in">memset</span>(B, <span class="number">0</span>, <span class="keyword">sizeof</span>(B));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= l; i++) B[i] = C(l, i);</span><br><span class="line">        Mul(A, B, n * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mx; i &lt;= n + mx; i++) wkr[i - mx] = (wkr[i - mx] + A[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    Shift(wkr, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, wkr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-Funny-Cost"><a href="#T3-Funny-Cost" class="headerlink" title="T3 Funny Cost"></a>T3 Funny Cost</h1><p><img src="image-20200807101713885.png" alt="image-20200807101713885"></p><p>对于一个确定的排列来说，它的最大匹配一定是将$1$与$\frac{n+1}{2}$匹配，$2$与$\frac{n+1}{2}+1$匹配，以此类推，与排列长啥样是无关的，因为此时每条边的覆盖次数都达到了它的上界，一定是最优方案。</p><p>知道这个结论就很简单了，单独考虑每对匹配对答案的贡献，显然每一对匹配对答案的贡献是一样的。接着我们枚举第一对匹配中的最大值即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N], frac[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    sort(num + <span class="number">1</span>, num + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> half = (n + <span class="number">1</span>) / <span class="number">2</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = half; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> w = (LL)C(i - <span class="number">1</span>, half - <span class="number">1</span>) * frac[half] % mod * frac[n - half] % mod;</span><br><span class="line">        res = (res + (LL)w * num[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    res = (LL)res * half % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希 </tag>
            
            <tag> 分治 </tag>
            
            <tag> 分块 </tag>
            
            <tag> NTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.29 考试</title>
      <link href="/2020/08/06/7-29-%E8%80%83%E8%AF%95/"/>
      <url>/2020/08/06/7-29-%E8%80%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-Stars"><a href="#T1-Stars" class="headerlink" title="T1 Stars"></a>T1 Stars</h1><p><img src="image-20200806205659331.png" alt="image-20200806205659331"></p><p><img src="image-20200806205707539.png" alt="image-20200806205707539"></p><a id="more"></a><p>先考虑对于对于一个给定的区间，如何求出它是否是奇妙的。</p><p>如果我们从左往右地遍历这个区间，同时维护$P$的坐标，一开始$P$的每一维都是空的。当我们遇到一个点时，如果这个点已经有一维坐标与$P$相同了，那么我们就跳过这个点。否则，我们必须从这个点的$K$维坐标中，选出一维填入$P$中。</p><p>我们可以$K!$地枚举这$K$维被填入$P$的顺序，每次填的时候填上对应的那一维即可。</p><p>我们无法快速地找到下一个需要填的位置，考虑分治，即考虑右区间对左区间的贡献。对于一个跨过中点的区间，我们考虑这样一种判断其是否合法的方式：类似与上面从左往右遍历的过程，这里我们先从中点开始遍历，遍历到左端点后再接着从中点之后开始遍历。</p><p>先$K!$枚举顺序，接着左区间根据$P$有几维被确定了可以被分为$K$段，显然每一段的最靠右的右端点是相同的。我们拿出这$K$段，每一段都放到右半边的区间暴力跑出最靠右的右端点即可。</p><p>时间复杂度$O(k^2\times k!n\log n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[<span class="number">5</span>][N], pos[N], k, nw[<span class="number">5</span>], id[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ct)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> tp[<span class="number">5</span>]; <span class="built_in">memcpy</span>(tp, nw, <span class="keyword">sizeof</span>(nw));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) <span class="keyword">if</span> (p[j][i] == tp[j]) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ct &gt;= k) <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">            tp[id[ct]] = p[id[ct]][i], ct++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos[l] &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt;= k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) pos[i] = max(pos[i], r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) id[i] = i;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">memset</span>(nw, <span class="number">-1</span>, <span class="keyword">sizeof</span>(nw)); <span class="keyword">int</span> ct = <span class="number">0</span>, ls = mid; <span class="keyword">bool</span> fg = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mid, ls = mid; i &gt;= l; i--) &#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) <span class="keyword">if</span> (p[j][i] == nw[j]) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                <span class="keyword">int</span> wkr = process(mid + <span class="number">1</span>, r, ct);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= ls; j++) pos[j] = max(pos[j], wkr);</span><br><span class="line">                <span class="keyword">if</span> (ct &gt;= k) &#123; fg = <span class="literal">true</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">                nw[id[ct]] = p[id[ct]][i], ct++, ls = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!fg) &#123;</span><br><span class="line">            <span class="keyword">int</span> wkr = process(mid + <span class="number">1</span>, r, ct);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= ls; i++) pos[i] = max(pos[i], wkr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (next_permutation(id, id + k));</span><br><span class="line">    solve(l, mid), solve(mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen("ex_stars1.in", "r", stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[j][i]);</span><br><span class="line">    solve(<span class="number">1</span>, n); LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        res += (LL)(pos[i] - i + <span class="number">2</span>) * (pos[i] - i + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-Decode"><a href="#T2-Decode" class="headerlink" title="T2 Decode"></a>T2 Decode</h1><p><img src="image-20200806210901238.png" alt="image-20200806210901238"></p><p><img src="image-20200806210909255.png" alt="image-20200806210909255"></p><p>对于一个给定的区间，我们可以随机找出一些模数，求出这个区间代表的数模过这些模数之后的值。如果模出来的每个数都是对应模数的二次剩余，那么这个区间有极大概率是完全平方数。</p><p>显然，如果$[i,j]$是最终答案，那么$j+1,j+2$这两个位置都不能是$0$，否则$[i,j+2]$也是完全平方串，并且比$[i,j]$长。</p><p>首先我们判掉那些长度不超过$10$的区间，接着我们求出有哪些位置满足可能存在以此位置结尾，并且长度大于$10$的完全平方串，条件就是以这个位置结尾、长度为$10$的二进制串是模$1024$下的二次剩余。</p><p>将这些结尾拎出来，从小到大排好序，对于每个为$1$的位置，对于每个模数我们求出有哪些结尾满足这个位置到结尾的串是模这个模数的二次剩余，用<code>bitset</code>存下来，那么最终我们求出若干个<code>bitset</code>的交就可以得到一个起点开始的所有可能的合法结尾。</p><p>这里推荐的实现方法是，筛出除$2$以外的前$39$个质数，然后我们三个三个地配对：第一个、第$14$个、第$27$个配成一对，剩下的以此类推，使用$13$个模数来检查一个区间是否合法，即每一对质数的乘积构成一个模数。</p><p>对于一个区间$[l,r]$，考虑从右往左<code>hash</code>，此时这个区间的权值为$\frac{h_l-h_{r+1}}{2^{n-r}}$。如果$n-r$是偶数，这个区间是二次剩余等价于$h_l-h_{r+1}$是二次剩余；否则等价于$h_l-h_{r+1}$是某个二次剩余的两倍。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LIM = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> TAIL = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> uLL = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pri, mod, r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; pri.size() &lt; LIM * <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j * j &lt;= i &amp;&amp; flag; j++)</span><br><span class="line">            <span class="keyword">if</span> (!(i % j)) flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag) pri.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AiAe</span> &#123;</span></span><br><span class="line"></span><br><span class="line">uLL v[(N &gt;&gt; <span class="number">6</span>) + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">AiAe() &#123; <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span>(v)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; v[x &gt;&gt; <span class="number">6</span>] |= <span class="number">1u</span>ll &lt;&lt; (x &amp; <span class="number">63</span>); &#125;</span><br><span class="line"></span><br><span class="line">uLL&amp; <span class="keyword">operator</span> [] (<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> v[x]; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tester</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mod;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t0, t1;</span><br><span class="line"><span class="built_in">vector</span>&lt;AiAe&gt; ok;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">bool</span> t = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">    mod = x, t0.resize(mod), t1.resize(mod);</span><br><span class="line">    <span class="keyword">if</span> (t) ok.resize(mod);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mod; i++)</span><br><span class="line">        t0[(LL)i * i % mod] = <span class="number">1</span>, t1[(LL)i * i * <span class="number">2</span> % mod] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> t0[x]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> t1[x]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WelcomeToOSU</span><span class="params">(<span class="keyword">int</span> h[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; zenith;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mod; i++) <span class="keyword">if</span> (t0[i]) zenith.push_back(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r.size(); i++) <span class="keyword">for</span> (<span class="keyword">auto</span> v : zenith) </span><br><span class="line">        ok[(v * (<span class="number">1</span> + ((n - r[i]) &amp; <span class="number">1</span>)) + h[r[i] + <span class="number">1</span>]) % mod].<span class="built_in">set</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; wkr[LIM + <span class="number">1</span>], hh[LIM + <span class="number">1</span>], base;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> h[], <span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n, w = <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) </span><br><span class="line">        h[i] = (h[i + <span class="number">1</span>] + w * (s[i] &amp; <span class="number">1</span>)) % mod, w = w * <span class="number">2</span> % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> hsh[LIM + <span class="number">1</span>][N], h2[LIM + <span class="number">1</span>][N], res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= LIM; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> mod = ::mod[i - <span class="number">1</span>], w = (hsh[i][l] - hsh[i][r + <span class="number">1</span>] + mod) % mod;</span><br><span class="line">        <span class="keyword">if</span> ((n - r) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!wkr[i].chk2(w)) <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!wkr[i].chk1(w)) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res = max(res, r - l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen("ex_decode2.in", "r", stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%s"</span>, &amp;n, s + <span class="number">1</span>), sieve();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LIM; i++) mod.push_back(pri[i] * pri[i + LIM] * pri[i + LIM * <span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= LIM; i++) </span><br><span class="line">        wkr[i].init(mod[i - <span class="number">1</span>]), pre(hsh[i], mod[i - <span class="number">1</span>]);</span><br><span class="line">    base.init(<span class="number">1</span> &lt;&lt; TAIL);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = TAIL; i &lt;= n; i++) <span class="keyword">if</span> (s[i + <span class="number">1</span>] != <span class="string">'0'</span> || s[i + <span class="number">2</span>] != <span class="string">'0'</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> w = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - TAIL + <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            w = w * <span class="number">2</span> + (s[j] == <span class="string">'1'</span>);</span><br><span class="line">        <span class="keyword">if</span> (base.chk1(w)) r.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(r.begin(), r.end()); <span class="keyword">int</span> all = r.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= LIM; i++) &#123;</span><br><span class="line">        hh[i].init(pri[i - <span class="number">1</span>], <span class="literal">true</span>);</span><br><span class="line">        pre(h2[i], pri[i - <span class="number">1</span>]);</span><br><span class="line">        hh[i].WelcomeToOSU(h2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (s[i] == <span class="string">'1'</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + res; j &lt; i + TAIL &amp;&amp; j &lt;= n; j++) judge(i, j);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (s[i] == <span class="string">'1'</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (r.size() &amp;&amp; r.back() &lt; i + TAIL - <span class="number">1</span>) r.pop_back();</span><br><span class="line">        <span class="keyword">if</span> (!r.size()) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> top = (r.size() &gt;&gt; <span class="number">6</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= top; j++) &#123;</span><br><span class="line">            uLL tmp = hh[<span class="number">1</span>].ok[h2[<span class="number">1</span>][i]][j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= LIM &amp;&amp; tmp; k++) tmp &amp;= hh[k].ok[h2[k][i]][j];</span><br><span class="line">            <span class="keyword">for</span> (; tmp; tmp -= tmp &amp; (-tmp)) &#123;</span><br><span class="line">                <span class="keyword">int</span> id = (j &lt;&lt; <span class="number">6</span>) + __builtin_ctzll(tmp);</span><br><span class="line">                <span class="keyword">if</span> (id &gt; r.size()) <span class="keyword">break</span>;</span><br><span class="line">                judge(i, r[id]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-03colors"><a href="#T3-03colors" class="headerlink" title="T3 03colors"></a>T3 03colors</h1><p><img src="image-20200806212023148.png" alt="image-20200806212023148"></p><p>首先我们给每个点随机一个颜色，比如全部设成$0$，接着定义一种状态的代价为同色边的数量，我们的目的是要让同色边的数量减少到$0$。</p><p>然后。。。开始模拟退火</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> col[N]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> fin = <span class="number">1e-14</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ct = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) <span class="keyword">if</span> (col[u] == col[v]) ct--;</span><br><span class="line">    col[u] = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) <span class="keyword">if</span> (col[u] == col[v]) ct++;</span><br><span class="line">    <span class="keyword">return</span> ct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen("03colors7.in", "r", stdin); freopen("03colors7.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n, m, ct = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m), srand(clock() + (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)(<span class="keyword">new</span> <span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v), col[i] = <span class="number">1</span>, ct++;</span><br><span class="line">        G[u].push_back(v), G[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> T = <span class="number">1</span>, step = <span class="number">0.999999</span>;</span><br><span class="line">    <span class="keyword">while</span> (T &gt; fin) &#123;</span><br><span class="line">        T *= step;</span><br><span class="line">        <span class="keyword">int</span> u = rand() % n + <span class="number">1</span>, tmp = col[u], nw = rand() % <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (tmp == nw) nw = rand() % <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> wkr = ct + upd(u, nw);</span><br><span class="line">        <span class="keyword">if</span> (wkr &lt;= ct) ct = wkr;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">exp</span>((ct - wkr) / T) &gt; <span class="built_in">fabs</span>((<span class="keyword">double</span>)(rand() % <span class="number">1000</span>) / <span class="number">1000.</span>)) ct = wkr;</span><br><span class="line">        <span class="keyword">else</span> col[u] = tmp;</span><br><span class="line">        <span class="keyword">if</span> (!ct) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!ct);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, col[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希 </tag>
            
            <tag> 分治 </tag>
            
            <tag> 提交答案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.28 考试</title>
      <link href="/2020/08/06/7-28-%E8%80%83%E8%AF%95/"/>
      <url>/2020/08/06/7-28-%E8%80%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-H2O"><a href="#T1-H2O" class="headerlink" title="T1 H2O"></a>T1 H2O</h1><p><img src="image-20200806203216494.png" alt="image-20200806203216494"></p><p><img src="image-20200806203236397.png" alt="image-20200806203236397"></p><a id="more"></a><p>如果$m=1$，也就是整个网格图只由一行格子构成，那么此时如果只有$i$号格子有海绵猫，那么$j$号格子最终的水量就是$h_i$至$h_j$中的最大值。</p><p>这启发我们当$m\neq 1$时，如果只有某个格子$(x,y)$有海绵猫，那么每个格子最终的水量就是所有从这个点到$(x,y)$的路径中，路径上$h_i$的最大值的最小值。</p><p>这个东西看着很像<code>Kruskal</code>重构树，我们给所有相邻的格子都连上一条边，边权为这两个格子$h$的最大值。建出<code>Kruskal</code>重构树，那么如果我们选定了若干只海绵猫的位置，那么每个位置最终的水量就是它在重构树上与所有海绵猫的最深的$lca$的点权。</p><p>由于权值只与$lca$有关，那么根据套路，将<code>Kruskal</code>重构树的点权差分一下，令每个点的权值为它原来的权值减去它父亲的权值。那么此时如果只考虑一直海绵猫$i$对位置$j$的贡献，那么等价于将根到$i$路径上的所有点都加上自己的点权，同时查询根到$j$路径上的点权之和。</p><p>由于最终我们要求的是所有格子的水位之和，那么一个点的权值会被它子树中的每个叶子都统计一遍。因此我们认为一个点最终的权值为差分后的权值乘上子树中的叶子个数。</p><p>问题转化为选择$k$条从根出发，到达叶子的路径，使得被至少一条路径覆盖的点权之和尽量大。长链剖分即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">e[++ecnt] = (edge)&#123; to, head[from] &#125;, head[from] = ecnt;</span><br><span class="line">e[++ecnt] = (edge)&#123; from, head[to] &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sz[N], son[N], w[N]; <span class="built_in">vector</span>&lt;LL&gt; tmp; LL len[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">sz[u] = u &lt;= n; <span class="keyword">int</span> t = w[f] - w[u];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line"><span class="keyword">if</span> (e[i].to != f) &#123;</span><br><span class="line">dfs(e[i].to, u), sz[u] += sz[e[i].to];</span><br><span class="line"><span class="keyword">if</span> (len[e[i].to] &gt; len[u]) len[u] = len[e[i].to], son[u] = e[i].to;</span><br><span class="line">&#125;</span><br><span class="line">len[u] += (LL)t * sz[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == t) tmp.push_back(len[u]);</span><br><span class="line"><span class="keyword">if</span> (son[u]) push(son[u], u, t);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line"><span class="keyword">if</span> (e[i].to != f &amp;&amp; e[i].to != son[u])</span><br><span class="line">push(e[i].to, u, e[i].to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WEN</span> &#123;</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> from, to, w;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> WEN &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;WEN&gt; wkr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N], nw[N], h[<span class="number">510</span>][<span class="number">510</span>], _n, _m, nxt[<span class="number">2</span>][<span class="number">2</span>] = &#123; &#123; <span class="number">1</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, <span class="number">1</span> &#125; &#125;, val[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x == fa[x] ? x : fa[x] = find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ID</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x - <span class="number">1</span>) * _m + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m, k; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k), _n = n, _m = m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;h[i][j]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">2</span>; t++) &#123;</span><br><span class="line"><span class="keyword">int</span> tx = i + nxt[t][<span class="number">0</span>], ty = j + nxt[t][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (tx &gt; n || ty &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">wkr.push_back((WEN)&#123; ID(i, j), ID(tx, ty), max(h[i][j], h[tx][ty]) &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(wkr.begin(), wkr.end()), ::n = ID(n, m); <span class="keyword">int</span> tot = ::n, mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) fa[i] = i, nw[i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">       w[ID(i, j)] = h[i][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> t : wkr) &#123;</span><br><span class="line"><span class="keyword">int</span> a = find(t.from), b = find(t.to);</span><br><span class="line"><span class="keyword">if</span> (a == b) <span class="keyword">continue</span>;</span><br><span class="line">fa[a] = b, tot++, adde(tot, nw[a]), adde(tot, nw[b]), nw[b] = tot, mx = w[tot] = t.w;</span><br><span class="line">&#125;</span><br><span class="line">LL res = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) res += mx - h[i][j];</span><br><span class="line">dfs(tot, tot), push(tot, tot, tot), sort(tmp.rbegin(), tmp.rend());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt;= tmp.size()) res -= tmp[i - <span class="number">1</span>];</span><br><span class="line">        ans ^= res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-W2B"><a href="#T2-W2B" class="headerlink" title="T2 W2B"></a>T2 W2B</h1><p><img src="image-20200806204606205.png" alt="image-20200806204606205"></p><p><img src="image-20200806204613141.png" alt="image-20200806204613141"></p><p>将矩阵看作二分图，每行每列都对应一个点，行的点在左边，列的点在右边。</p><p>如果$(i,j)$是黑色，我们认为是第$i$行向第$j$列连了一条有向边，否则认为是第$j$行第$i$列连了一条有向边。</p><p>在这张二分图中，对于任意的位于两侧的点$i,j$，要么$i$向$j$有边，要么$j$向$i$有边。</p><p>那么条件相当于不存在一张其它的二分图，使得左边的出度、右边的入度不变。</p><p>大胆猜想满足这个性质的充要条件是不存在环，因为将环反向之后仍然合法。</p><p>问题转化为，统计所有不存在环的竞赛二分图数量。</p><p>将整个二分图分层，每一层的所有点位于同侧。由于是竞赛二分图，因此每一层必须向它前面的所有层连边，同一层由于点位于同侧，因此内部不能有变。并且，相邻两层一定位于异侧。</p><p>枚举最终有多少层，此时左侧的点有多少层、右边的点有多少层已经固定了，显然它们对答案的贡献是独立的，而方案数为斯特林数。</p><p>因此只需要用<code>NTT</code>求出第$n$行、第$m$行的斯特林数即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetR</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (len &lt;= n) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(vec &amp;a, <span class="keyword">int</span> len, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">a.resize(len);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += mid)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i, w = <span class="number">1</span>, t; j &lt; i + (mid &gt;&gt; <span class="number">1</span>); j++, w = (LL)w * Wn % mod)</span><br><span class="line">t = (LL)a[j + (mid &gt;&gt; <span class="number">1</span>)] * w % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!type) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, inv = Pow(len, mod - <span class="number">2</span>); i &lt; len; i++)</span><br><span class="line">a[i] = (LL)a[i] * inv % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vec <span class="title">Mul</span><span class="params">(vec a, vec b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = a.size() - <span class="number">1</span> + b.size() - <span class="number">1</span>, len = GetR(n);</span><br><span class="line">NTT(a, len, <span class="number">1</span>), NTT(b, len, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) a[i] = (LL)a[i] * b[i] % mod;</span><br><span class="line">NTT(a, len, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> a.resize(n + <span class="number">1</span>), a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">if</span> (n &lt; m) swap(n, m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">vec A(n + 2, 0), B(n + 2, 0), C(n + 2, 0);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">A[i] = inv[i], B[i] = (LL)Pow(i, n) * inv[i] % mod, C[i] = (LL)Pow(i, m) * inv[i] % mod;</span><br><span class="line"><span class="keyword">if</span> (i &amp; <span class="number">1</span>) A[i] = mod - A[i];</span><br><span class="line">&#125;</span><br><span class="line">B = Mul(A, B), C = Mul(A, C);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) B[i] = (LL)B[i] * frac[i] % mod, C[i] = (LL)C[i] * frac[i] % mod;</span><br><span class="line">B[n + <span class="number">1</span>] = C[m + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">res = (res + (LL)<span class="number">2</span> * B[i] * C[i] % mod + (LL)B[i + <span class="number">1</span>] * C[i] + (LL)B[i] * C[i + <span class="number">1</span>]) % mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 长链剖分 </tag>
            
            <tag> NTT </tag>
            
            <tag> 考试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.25图论</title>
      <link href="/2020/07/25/7-25%E5%9B%BE%E8%AE%BA/"/>
      <url>/2020/07/25/7-25%E5%9B%BE%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<div class="pdfobject-container" data-target="nin.pdf" data-height="500px"></div><a id="more"></a><h1 id="Heidi-and-Library-Codeforces-802C"><a href="#Heidi-and-Library-Codeforces-802C" class="headerlink" title="Heidi and Library (Codeforces 802C)"></a>Heidi and Library (Codeforces 802C)</h1><p><img src="image-20200725203326904.png" alt="image-20200725203326904"></p><p>如果每本书的费用为$1$，一种贪心策略就是每次扔掉下次出现时间最靠后的一本书。</p><p>单独考虑每本书购买或者被扔掉的情况，假设对于第$i$本书，要求在$t_1,t_2,\cdots,t_k$这些时间点时书架上必须有这本书，那么我们就可以将其看作$k-1$个时间段：$(t_1,t_2],(t_2,t_3],\cdots,(t_{k-1},t_k]$，对于每个时间段我们都可以将其看作可以选择这一段区间，同时领取$c_i$的奖励。因为一旦有一个时间段被完整地选择了，那么就意味着这个时间段结束时，我们不再需要重新购买第$i$本书了。</p><p>因此我们先提前扣除$\sum c_{a_i}$的代价，然后看看最多能够拿到多少奖励，使得任意一个时间点至多被$k$条选择的区间覆盖，问题转化为经典的区间$k$覆盖问题。</p><p><img src="{D8C914A4-CAA8-D09B-D177-64EE234E2F60}.jpg" alt="img"></p><h1 id="Colored-Graph"><a href="#Colored-Graph" class="headerlink" title="Colored Graph"></a>Colored Graph</h1><p><img src="image-20200725204158705.png" alt="image-20200725204158705"></p><p>实际上的题意是给一个函数$P(i,j)$，它的返回值是$0$或者$1$，表示$i,j$间的边是红色还是蓝色的，但是有$m$个例外。（因为输入也不可能将$n^2$条边全部给你）</p><p>我们考虑$(1,2)$，$(2,3)$，$(3,4)$，……，$(n,1)$这些边。如果它们的颜色全部相同，显然此时我们随便断开一条边就能得到一棵生成树。否则一定存在一个异色角，即存在一个点$k$，使得$(k-1,k),(k,k+1)$这两条边颜色不同。</p><p>将$k$这个点从图中删去，我们得到了一个$n-1$个点的图，递归解决这个子问题。如果最终得到的生成树是红色的，那么连上从$k$点出发的红色的那条边，否则连上从$k$点出发的蓝色的那条边。</p><h1 id="Gardening-Lesson"><a href="#Gardening-Lesson" class="headerlink" title="Gardening Lesson"></a>Gardening Lesson</h1><p><img src="image-20200725205041550.png" alt="image-20200725205041550"></p><p>我们先考虑这样一个问题：如何判断两棵树是否同构。</p><p>先随便找一个函数$h(x)$，比如$ax^2+bx+c$之类的，然后对于每个点，我们定义它的权值$w_u$等于$\sum_v h(w_v)$，这里$v$是$u$的儿子。显然这个随机函数是与儿子的顺序无关的，同时，它可以很方便地合并两个儿子，从而用类似树形$dp$的方式求出来。</p><p>对于第二棵树，可以通过树形$dp$求出每个点的$w$的值。对于第一棵树，可以求出删去每个叶子之后该叶子的父亲的$w$的值。对于第二棵树上的每个叶子我们都询问一遍它的$w$是否在第一棵树的$w$集合中出现过，如果出现过就说明我们找到了一组匹配。</p><h1 id="Dev-please-add-this"><a href="#Dev-please-add-this" class="headerlink" title="Dev, please add this"></a>Dev, please add this</h1><p><img src="image-20200725205500812.png" alt="image-20200725205500812"></p><p>考虑将球在当前行来回滚动，那么球的活动范围就构成了一个水平的长条，并且球只能在这个长条最左边或者最右边的地方停下。对于这个长条上的任意一个有奖励的空格子都能到达。接着，球可以开始在竖直方向滚动，形成一个竖着的长条。大概长这样</p><p><img src="image-20200725211242471.png" alt="image-20200725211242471"></p><p>将每个长条看作一个点，比如图中横着的长条为$h_i$，它的左右两侧分别为$v_j$和$v_k$，我们就从$h_i$往$v_j,v_k$连一条边。</p><p>考虑<code>2-SAT</code>。对于一个有奖励的格子，它所在的$h_i,v_i$中至少有一个点被到达。因此限制如下：</p><ul><li>如果起点不能到达节点$i$，那么$i=false$。</li><li>如果$a,b$不能相互到达，那么$a \and b=false$。</li><li>对于每个奖励格子，$v_i\or h_i=true$。</li></ul><p>不难看出这些是有解的必要条件，对于任意两个点，它们之间都存在可传递的偏序关系（或者没有限制），接下来我们证明它是充分条件。</p><p>对于任意的一个竞赛图，一定存在一条链$v_1,v_2,\cdots, v_k$使得$(v_1,v_2),(v_2,v_3),\cdots$均有连边，也就是说，我们一定能够找到一条合法的经过所有长条的路径，这条路径满足我们给出的偏序关系。因此它也是充分的。</p><h1 id="染色"><a href="#染色" class="headerlink" title="染色"></a>染色</h1><p><img src="image-20200725211921882.png" alt="image-20200725211921882"></p><p>注意这道题中并没有要求$S$联通。</p><p>对于给定的一张图，假设边集为$E$，那么可以发现它的合法的$S$的数量为$2^{|E|-n+k}$。这里$k$是连通块的数量。</p><p>任意求出这张图的一棵生成树（或者生成森林），显然这个森林上一共有$n-k$条边。对于那些非树边，它们可以任意选择是否出现在$S$集合中，剩下的树边一定唯一存在一种方案满足所有点的度数都是偶数的要求。</p><p>由于贡献为$S$大小的平方，我们不妨认为是枚举两条边$E_1,E_2$，求出包含$E_1,E_2$的合法的$S$的数量，接着我们分类讨论：</p><p>当$E_1=E_2$时，如果$E_1$是整张图的桥，那么删去$E_1$之后图的连通块数量会增加，原来某个连通块会分裂成两个新的连通块，而$E_1$在两个连通块中对总度数都有$1$的贡献，因此这两个连通块内部的度数之和无论如何也不可能是偶数，因此方案为$0$。</p><p>否则，找到剩下的图中的某个生成森林，方案数为$2^{|E|-n+k-1}$。</p><p>当$E_1\neq E_2$时，如果它们不在同一个连通块内，显然仅当$E_1,E_2$都不是桥的时候方案数为$2^{|E|-n+k-2}$，否则方案数为$0$。</p><p>如果它们在同一个连通块内，且删去$E_1$和$E_2$之后图中的连通块数量不变，那么方案数为$2^{|E|-n+k-2}$。</p><p>否则如果$E_1,E_2$是割集</p><p><img src="image-20200725213036702.png" alt="image-20200725213036702"></p><p>它们对两个集合度数的贡献都为$2$，我们可以看作是两个集合都在这两个点之间连了一条边，且这条边被选了，可以看出方案数为$2^{|E|-n+k-1}$，因为连通块数量多了一个。同时此时$E_1,E_2$不可能是桥。</p><p>问题转化为统计有多少对边$E_1,E_2$，使得它们是割集。</p><p>如果$E_1,E_2$都是非树边，那么它们显然不可能是割集。</p><p>如果$E_1$是树边，$E_2$是非树边，那么$E_2$一定覆盖了$E_1$，且只有$E_2$覆盖了$E_1$。</p><p>如果它们都是树边，那么覆盖它们的非树边集合应当相同，且不能为空。</p><p>因此我们给每条非树边一个随机的权值，然后给这条非树边覆盖的所有边加上这个权值，两条树边被覆盖的集合相同当且仅当这两条边最终的权值相同。</p><h1 id="Airlines-Bytedance-Camp-2020"><a href="#Airlines-Bytedance-Camp-2020" class="headerlink" title="Airlines (Bytedance Camp 2020)"></a>Airlines (Bytedance Camp 2020)</h1><p><img src="image-20200725214026335.png" alt="image-20200725214026335"></p><p>将每个点的所有出边拿出来匹配，要求匹配的两条边颜色不同，可以每次拿出出现次数最多的和出现次数第二多的匹配。</p><p>匹配完了之后形成了若干个环，我们每次可以将两个有公共点的环拼起来。</p><h1 id="Cipher-SGU-307"><a href="#Cipher-SGU-307" class="headerlink" title="Cipher (SGU 307)"></a>Cipher (SGU 307)</h1><p><img src="image-20200725220939414.png" alt="image-20200725220939414"></p><script type="math/tex; mode=display">\begin{aligned}a(2,2)&=b(1,1)-a(1,1)-a(1,2)-a(2,1)\\a(2,3)&=b(1,2)-a(1,2)-a(1,3)-a(2,2)\\&=b(1,2)-b(1,1)+a(1,1)-a(1,2)+a(1,2)-a(1,3)-a(2,1)\\&=[b(1,2)-b(1,1)]+a(1,1)-a(1,3)-a(2,1)\end{aligned}</script><p>因此每个$a(i,j)$最终都能被表示为$C+(-1)^{i+j}a(1,1)+(-1)^{i-1}a(1,j)+(-1)^{j-1}a(i,1)$。这里$C$是一个很好递推的常数。</p><p><code>2-SAT</code>即可。</p><h1 id="Dynamic-Shortest-Path-Codeforces-843D"><a href="#Dynamic-Shortest-Path-Codeforces-843D" class="headerlink" title="Dynamic Shortest Path (Codeforces 843D)"></a>Dynamic Shortest Path (Codeforces 843D)</h1><p><img src="image-20200725221415072.png" alt="image-20200725221415072"></p><p>无视所有的操作2，先从1开始跑一遍最短路。</p><p>将每条边的权值改为$w_u+d_u-d_v$，此时1到每个点的最短路为$0$。</p><p>一共只有$10^6$次操作2，因此任意时刻1到每个点的最短路不会超过$10^6$。</p><p>用桶来跑<code>Dijkstra</code>，可以去掉一个$\log$。</p><h1 id="New-Year-and-Forgotten-Tree-Codeforces-611H"><a href="#New-Year-and-Forgotten-Tree-Codeforces-611H" class="headerlink" title="New Year and Forgotten Tree (Codeforces 611H)"></a>New Year and Forgotten Tree (Codeforces 611H)</h1><p><img src="image-20200725221642279.png" alt="image-20200725221642279"></p><p>集训队作业。</p><p>爆搜$6$个点$(1,10,100,\cdots,10^6)$的生成树，然后让每条边挂在这些点下面。</p><p>网络流。</p><h1 id="Roundtrip-GYM-100218I"><a href="#Roundtrip-GYM-100218I" class="headerlink" title="Roundtrip (GYM 100218I)"></a>Roundtrip (GYM 100218I)</h1><p><img src="image-20200725221807227.png" alt="image-20200725221807227"></p><p>先用网络流求出$a$到$b$的三条不交的路径，接着求出两条$a$到$c$的不交的路径。</p><p><img src="image-20200726191735265.png" alt="image-20200726191735265"></p><p>找到$a$到$c$的路径中，最后一个与$a$到$b$的这三条路径的交点$p$，显然我们可以将$a$到$c$的这条路径改成先从$a$到$p$，再从$p$到$c$，这样只会占去三条路径中的一条。同理，$b$到$c$的路径也可以进行类似的修改，由于一共有三条路径，而最多只会占去两条路径，因此一定至少剩下一条路径没有被占。</p><p><img src="image-20200726192010117.png" alt="image-20200726192010117"></p><h1 id="James-and-the-Chase-Codeforces-1361E"><a href="#James-and-the-Chase-Codeforces-1361E" class="headerlink" title="James and the Chase (Codeforces 1361E)"></a>James and the Chase (Codeforces 1361E)</h1><p><img src="image-20200726193035371.png" alt="image-20200726193035371"></p><p>题面中的无向连通图应该改为有向图。</p><p>对于这张图的任意一棵$dfs$树中的某个点$u$，$u$的子树内必然至少有一条返祖边，否则$u$无法到达其父亲。如果返祖边多于两条，那么$u$到$u$的父亲就至少有两种路径，因此不合法。假设这条返祖边到达的祖先是$p$，那么$u$是否是好的取决于$p$是否是好的（即$u$的答案与$p$的答案完全相同）。</p><h1 id="Jiry-Matchings-300iq-Contest-2-J"><a href="#Jiry-Matchings-300iq-Contest-2-J" class="headerlink" title="Jiry Matchings (300iq Contest 2 J)"></a>Jiry Matchings (300iq Contest 2 J)</h1><p><img src="image-20200726193833419.png" alt="image-20200726193833419"></p><p>由于$dp$是凸的，因此合并两个$dp$的过程实际上就是做他们的闵可夫斯基和，这个复杂度可以做到$O(n+m)$。进行链分治，对于从每个点出发的轻链，递归下去求之后分治合并，最后再对重链做一次分治合并。</p><h1 id="TreePuzzle-TCO-2014-2A"><a href="#TreePuzzle-TCO-2014-2A" class="headerlink" title="TreePuzzle (TCO 2014 2A)"></a>TreePuzzle (TCO 2014 2A)</h1><p><img src="image-20200726194059543.png" alt="image-20200726194059543"></p><p>为啥我感觉直接算一下有标记的点到目标点的路径上其它子树的和就行了啊。。。可能看错题了。</p><h1 id="KazHackStan-IZhO-2020-Day2"><a href="#KazHackStan-IZhO-2020-Day2" class="headerlink" title="KazHackStan (IZhO 2020 Day2)"></a>KazHackStan (IZhO 2020 Day2)</h1><p><img src="image-20200726194148721.png" alt="image-20200726194148721"></p><p>点分治，每次我们求出分治中心$u$被$[l,r]$中的哪个病毒感染的时间最晚，假设为$p$。找到$p$所在的子树，对于$u$的其它子树中的点，它们被感染的最晚时间等于$u$被感染的时间加上这两点间的距离。因此，我们只需要接着考虑$p$所在的子树。</p><p>求出其它子树中感染$u$的时间次晚的病毒，以及这个病毒感染到$p$的子树中的时刻$t’$。假设$v$是这个子树中的点，且$u,v$有边相连，我们可以认为在$v$放置了一个从$t’$时刻开始感染的病毒。递归下去做即可。</p><h1 id="THUWC-19-Day1T3"><a href="#THUWC-19-Day1T3" class="headerlink" title="THUWC 19 Day1T3"></a>THUWC 19 Day1T3</h1><p><img src="image-20200726194717418.png" alt="image-20200726194717418"></p><p>连通块的数量不好直接统计，由于每个连通块内都有一个编号最小的点，我们不妨统计$u$的数量，满足$u$是所在的连通块中编号最小的点。</p><p>建出原图的BFS树，按照BFS到的顺序给所有点进行重标号。如果$x,y$是$u$所在的连通块，且$x<u,y<u$，它们的距离小于等于$X$，同样也有$u$到这两个点的距离都小于$X$。记$id(x)$表示$x$点原来的编号，那么我们要统计的是所有的$u$，满足对于任意的$v<u,id(v)\in[l,r]$，都有$dis(u,v)>X$。</p><p>求出对于每个$u$，在到它的距离不超过$X$，且编号比它小的所有点中，$id(x)$不超过$r$的最大的点的$id$，以及$id(x)$不小于$l$的最小的点的$id$。这是一个二维偏序问题。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>7.24数据结构</title>
      <link href="/2020/07/24/7-24%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2020/07/24/7-24%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<div class="pdfobject-container" data-target="wkr.pdf" data-height="500px"></div><a id="more"></a><h1 id="热身小练习"><a href="#热身小练习" class="headerlink" title="热身小练习"></a>热身小练习</h1><p><img src="image-20200724190408590.png" alt="image-20200724190408590"></p><p>首先枚举$L$，根据平方串的套路，将序列每$L$个位置设置一个关键点，求出相邻两个关键点开始的最长公共前后缀，那么我们可以得到$n\log n$条形如$[l_1,r_1]$到$[l_2,r_2]$对应点有一条权值为$w_L$的边的信息。</p><p>此时有两种做法。第一种是考虑用Kruskal求最小生成树，首先将所有信息按照边权从小到大排序，此时我们只需要求出此次合并会合并多少个连通块。接着类似萌萌哒的做法，维护$\log n$个并查集，第$i$层的第$j$个点代表$[j, j+2^i-1]$这整个区间的点。每次合并的时候如果当前合并的两个点已经连起来了，那么就<code>return</code>，否则递归向下合并。可以发现每次递归到最后一层并查集时必然会合并两个原来没有连通的并查集，而一共只有$n\log n$个点，因此复杂度为$O(n\log^2 n)$。</p><p>第二种是温爷的做法，我们同样建出$\log$排点，但是此时我们并不用在线地求出此次连接了多少个连通块，而是将当前的边存入每一层中。也就是说，如果第$i$层第$a$个点与第$b$个点有连边，那么它等价于$[a,a+2^i-1]$到$[b,b+2^i-1]$的对应点均有连边。</p><p>对于每一层我们将这一层的所有边拿出来跑一遍最小生成树，只留下那些在最小生成树上的边，接着下放到下一层并查集。如果$a$与$b$的连边得以保留，那么我们会在下一层添加两条边：$a,b$与$a+2^{i-1},b+2^{i-1}$。合并到最后一层时就是答案。</p><h1 id="LOJ-2092-「ZJOI2016」大森林"><a href="#LOJ-2092-「ZJOI2016」大森林" class="headerlink" title="LOJ 2092 「ZJOI2016」大森林"></a>LOJ 2092 「ZJOI2016」大森林</h1><p><img src="image-20200724192338509.png" alt="image-20200724192338509"></p><p>可以发现实际上第一种操作的$[l,r]$并没有什么用，我们完全可以将第二个操作的$[l,r]$与对应的一操作的区间求交，然后就可以将一操作当成每棵树的生长节点都会长一个叶子。接下来我们默认二操作的$l,r$是求交之后的$l,r$。</p><p>接着，由于生长是往原来的节点上挂节点，因此所有的询问都可以放到二操作之后。</p><p>将所有询问离线，将二操作的所有区间按照$r$从小到大排序，接着扫描线。</p><p>可以发现的是，如果一段连续的区间中都只有一操作，考虑这些操作加入的点，显然无论之前的二操作怎么改，在某一棵树中，这些节点的父亲一定是相同的。也就是说，对于某一棵树，它们是从同一个生长节点长出来的。</p><p>因此，我们可以将每一段连续的一操作加入的点看作一个单元，接着我们考虑这样一件事：一开始有一个二操作$[l,r]$，在这个二操作之前编号为$l$的树的生长节点为$x$，然后被改为了$y$。考虑$l$这棵树相对于$l-1$这棵树的变化：$l-1$没有受到这个二操作的影响，因此这个二操作之前的单元被挂在了$x$点下方。$l$受到了二操作的影响，因此这个单元的点被挂在了$y$点下方。因此，我们只需要将$x$点的这个单元$cut$掉，再$link$到$y$点下方即可。对于$r,r+1$这两棵树的变化类似，将这棵子树挂回去就行了。</p><h1 id="BZOJ-2959-长跑"><a href="#BZOJ-2959-长跑" class="headerlink" title="BZOJ 2959 长跑"></a>BZOJ 2959 长跑</h1><p><img src="image-20200724194021159.png" alt="image-20200724194021159"></p><p>通过观察可以发现，对于一个边双连通分量，从它内部的任意点出发一定可以遍历内部的所有点，最终停在任意的终点（注意每个点可以被经过多次），原理是边双连通分量一定可以通过给边定向得到一个强连通分量。</p><p>因此我们只需要动态地将每个边双缩起来，这样会形成一个森林，缩起来之后的点为其代表的边双的所有点权之后，最后我们只需要查询路径和就好了。</p><p>关于缩点的实现方式，可以整一个并查集，维护每个点现在变成了啥，然后$lct$中只要涉及$fa$就丢进并查集查一下。</p><h1 id="一道例题"><a href="#一道例题" class="headerlink" title="一道例题"></a>一道例题</h1><p><img src="image-20200724194546350.png" alt="image-20200724194546350"></p><p>结论：$w$的祖先为，将当前BST中的所有点按照权值从小到大排序之后，从$w$开始向左向右关于插入时间的单调栈。</p><p>线段树维护单调栈。</p><h1 id="LOJ-2472-「九省联考-2018」IIIDX"><a href="#LOJ-2472-「九省联考-2018」IIIDX" class="headerlink" title="LOJ 2472 「九省联考 2018」IIIDX"></a>LOJ 2472 「九省联考 2018」IIIDX</h1><p><img src="image-20200724194719934.png" alt="image-20200724194719934"></p><p>序列可以看作是一棵树，我们希望第一层中的所有点、第二层中的所有点……它们构成序列的字典序尽量大。</p><p>一种错误的贪心是将所有数从大到小排序之后给每个子树塞$sz$个，当存在相同的$d$时这样是错的。</p><p>将所有数去重之后从小到大排序（注意也要记录下出现次数），我们关心的是每个数以及它右边权值不小于它的所有数中，还没有被用的数有多少个。只要这个没有被用的数$f_i$不小于$sz_u$，我们就能让$u$的权值等于$i$，接着在不小于$i$的数中选$sz_u$个塞入子树中。</p><p>我们是一层一层考虑的，因此考虑到当前层的$u$时我们要帮它的子树中的点占好位置。如果我们确定了$u$最终的权值为$i$，那么线段树上$i$以及$i$左边所有比$i$小的数的$f$值都应当减去$sz_u$，表示它右边有$sz_u$个位置被占了，对于$i$右边的数则不需要修改它们的$f$。</p><p>需要保证的是如果当前点的权值要取$i$，那么$i$以及小于$i$的所有点的$f$都不能小于$sz_u$。否则代表那个点右边的数被用完了，显然不合法。这同时也意味着$u$的子树一定存在一种方案使得能放下那些比$i$大的还没有被占过的数。</p><p>另外，如果$u$的父亲$v$权值为$p$，我们应当在处理$v$的所有儿子时，给$1,\cdots, p$这些位置的$f$加上$sz_v-1$，否则父亲占的那$sz_v$个位置就白占了。</p><p>我好像写得很不清楚。</p><h1 id="另一道例题"><a href="#另一道例题" class="headerlink" title="另一道例题"></a>另一道例题</h1><p>在想上一道题，结果没听到……</p><h1 id="又一道例题"><a href="#又一道例题" class="headerlink" title="又一道例题"></a>又一道例题</h1><p><img src="image-20200724200620552.png" alt="image-20200724200620552"></p><p>很有意思的一道题。</p><p>先差分一下，求出最小值小于等于$R$的答案减去最小值小于$L$的答案。问题转化为统计存在同色点对的距离小于$r$的染色方案的数量。再转化一下可以变成，任意距离不超过$r$的点都是不同色的。</p><p>考虑这棵树的BFS序（注意不是DFS），现在我们加入一个点$u$。BFS有一个很优秀的性质：如果$u$到$x$的距离不超过$r$，$u$到$y$的距离也不超过$r$，那么$x,y$的距离同样不超过$r$。这里$x,y$都是当前已遍历到的点。</p><p>这意味着当前考虑的所有与$u$距离不超过$r$的点，它们的颜色一定两两不同。如果这样的点有$k$个，那么$u$的染色方案就有$m-k$种。这个数量可以通过点分治简单统计。</p><h1 id="HDU-6368-Variance-MST"><a href="#HDU-6368-Variance-MST" class="headerlink" title="HDU 6368 Variance-MST"></a>HDU 6368 Variance-MST</h1><p><img src="image-20200724201135444.png" alt="image-20200724201135444"></p><p>我们要求的东西可以写成：找到一棵生成树$T$，同时找到一个实数$A$，使得</p><script type="math/tex; mode=display">\sum_{e\in T} (w_e-A)^2</script><p>尽量小。</p><p>注意这里是任意一个实数$A$而不是所有边权的平均数，因为当$A$取到平均数时在固定$T$的条件下一定最优，$A$随便取得到的答案一定不会优于取平均数得到的答案。</p><p>如果$A$确定了，我们就能求出每条边真正的边权，求一遍普通的最小生成树就可以得到答案。</p><p>可以发现最小生成树上会有哪些边只与边按照权值从小到大排序之后的顺序有关，而与$A$无关。考虑两条边$a,b$，它们的权值分别为$w_a,w_b$。如果$A&lt;\frac{w_a+w_b}{2}$，那么$a$会排在$b$的前面，否则$b$会排在$a$的前面。</p><p>这样的$(a,b)$对共有$m^2$对，它们的平均数也构成了$m^2$个关键点。如果我们将所有的关键点从小到大排序，那么对于相邻的两个关键点之间的$A$，最小生成树上的边是不会变的，由于知道边的大小顺序，因此我们也知道最小生成树上有哪些边，此时我们只需要令$A$等于这些边的平均数就好了。</p><p>我们现在得到了一个$m^2\log n$的做法，使用$lct$维护当前的生成树，每次我们会交换排序后<strong>相邻</strong>的两条边$a,b$的位置。如果$a,b$都在或都不在最小生成树上，那么答案不会收到影响，否则如果加上$b$后生成树形成的环中包含$a$，我们就$cut$掉$a$，$link$上$b$。维护生成树上所有边边权的一次方和二次方和即可。</p><p>可以发现上面的做法有大量的情况都是$a,b$同时在或者同时不在最小生成树上，考虑优化。</p><p>一开始我们直接求出所有边的最小生成树，接着我们从小到大考虑不在生成树上的一条边$a$。找到$a$形成的环中，权值最小的边$b$，那么在$\frac{w_a+w_b}{2}$之后$a$就会替换$b$。同时$b$也是$a$能替换的边中权值最小的一条，接着我们断开$b$，连上$a$。因为这是当前会发生的所有替换中替换时刻最小的。</p><p>现在事件总数由$m^2$变为了$m$，再沿用之前的方法即可。</p><h1 id="双一道例题"><a href="#双一道例题" class="headerlink" title="双一道例题"></a>双一道例题</h1><p><img src="image-20200724202907552.png" alt="image-20200724202907552"></p><p>首先我们通过扫描线和线段树求出每个人最终（而非操作之后）拥有的部分中有多少个正方形。</p><p>具体来说，我们需要求出每个人往下走到哪里会被挡住。将所有人按照$x$从大到小排序之后扫描线</p><p><img src="image-20200724203822470.png" alt="image-20200724203822470"></p><p>维护有哪些边界伸到了当前的$x$坐标，考虑加入一个人$(x,y)$，我们挨个考虑他可能会撞到的那些边界。如果这个人的加入时刻小于那个边界的加入时刻，那么这个人就会将此边界顶掉，我们就删除掉这个边界，因为它不可能再往左延伸了，直到最后这个人遇到了一个出现时刻小于这个人的加入时刻的边界。</p><p>接着我们从左往右扫描线，用线段树维护当前每个$y$坐标还剩多少个正方形，只需要支持区间清零、区间求和即可。</p><p>如何从最终的答案推到操作之后的答案呢，考虑如下情况：</p><p><img src="image-20200724204331714.png" alt="image-20200724204331714"></p><p>此时$a$在$b$的内部，$b$最终的答案不会包含$a$。但是如果$a$比$b$后出现，那么$b$操作时的答案就应当累加上$a$的答案。扫描线的同时记录下最终框住每个人的是谁（最内一层），记为$next_i$。</p><p>将所有人按照时刻从大到小排序，我们维护一个并查集，一开始每个人的$fa$是自己。每次我们查询$next_i$的祖先，将此祖先的答案加上$i$这个人的答案，接着将$i$与$next_i$合并为一个集合。这样并查集查出来的结果就是在$i$操作时最内一层框住$i$的人。注意$next_i$为$0$时我们将父亲设为$0$即可。可以理解为在求子树和。</p><h1 id="叒一道例题"><a href="#叒一道例题" class="headerlink" title="叒一道例题"></a>叒一道例题</h1><p><img src="image-20200724205358986.png" alt="image-20200724205358986"></p><p>将每个小区间看作一条二维平面上平行于$y$轴的一条线段，$x$坐标为下标$i$，$y$坐标分别为$l_i$和$r_i$。</p><p><img src="image-20200724205904875.png" alt="image-20200724205904875"></p><p>我们从左往右考虑每条线段，对于某条线段来说，我们只考虑当前那些“露出来”的每一条小线段，将当前的线段划分为若干条小线段，接着用当前线段覆盖掉这些小线段。</p><p>对于划分出的每一条小线段，对于所有包含$i$的区间来说，小线段中每个点在这个区间中的出现情况都是相同的。故我们可以分别考虑每一条小线段的贡献。</p><p>如果对于一条小线段，它是区间$j$在区间$i$上某个部分的投影，即来自$j$的一条小线段，那么我们将所有左端点在$(j,i]$，右端点在$[i,n]$的区间全部加上这条小线段的长度。</p><p>问题转化为矩形加、矩形查，可以通过CDQ分治解决。</p><h1 id="UOJ-418-【集训队作业-2018】三角形"><a href="#UOJ-418-【集训队作业-2018】三角形" class="headerlink" title="UOJ 418 【集训队作业 2018】三角形"></a>UOJ 418 【集训队作业 2018】三角形</h1><p><img src="image-20200724210410253.png" alt="image-20200724210410253"></p><p>问题等价于：一开始$i$号节点有$w_i$个石子，每次你可以选择一个有石子的点，将它的儿子全部放上石子，再移除这个节点的石子，直到树上没有剩下的石子。整个过程中树上石子个数和的最大值的最小值就是答案。</p><p>可以看作每个点有两个值$a_i,b_i$，一个点被选的前提是它的父亲被选了，你有一个一开始为$0$的变量，每次你会给这个变量先减去$b_i$，再加上$a_i$，要求整个过程中变量的最大值尽可能小。</p><p>如果我们只需要求出$1$号点为根时的答案，这就是一个经典问题，类似于集训队作业<a href="https://planarg.top/2020/03/12/agc023f-01-on-tree/" target="_blank" rel="noopener">01 on tree</a>。</p><p>具体来说，我们优先选择$a_i&lt;b_i$的点，将这些点按照$b_i$从小到大选。接着选择$a_i\geq b_i$的点，按照$a_i-b_i$从小到大选。</p><p>如果根不固定的话可以线段树合并。我们求出以最浅点为根时整棵树的答案，接着对于任意一棵子树，只考虑这棵子树时的答案一定是整棵树的答案的子序列，我们只需要记录最终每个点是第几个被选的，就可以直接线段树维护答案。</p><h1 id="CREC-2017-I-Intrinsic-Interval"><a href="#CREC-2017-I-Intrinsic-Interval" class="headerlink" title="CREC 2017 I Intrinsic Interval"></a>CREC 2017 I Intrinsic Interval</h1><p><img src="image-20200724211450210.png" alt="image-20200724211450210"></p><p>建出析合树，看一下$l,r$的$lca$是啥，如果是合点就是$l,r$所在的那两个儿子构成的连续段，否则就是$lca$所代表的连续段。</p><h1 id="UOJ-451-【集训队作业-2018】世界是个动物园"><a href="#UOJ-451-【集训队作业-2018】世界是个动物园" class="headerlink" title="UOJ 451 【集训队作业 2018】世界是个动物园"></a>UOJ 451 【集训队作业 2018】世界是个动物园</h1><p><img src="image-20200724211600654.png" alt="image-20200724211600654"></p><p>竞赛图的一个很好的性质是，按照强连通分量缩点之后得到的是一条链，链上的每个点往它之后的所有点均有连边。另外，最终的联盟就是强连通分量。</p><p>因此，我们只需要知道当前点连出的所有边中最靠前的一条，以及连向当前点的所有边中最靠后的一条。这两条边中间夹的所有点都会被缩为一个强连通分量，接着将当前点插入连出的所有边中最靠前的一条之前。</p><p>我们给每个点分配一个实数的坐标，插入时当前点的坐标等于它坐标和右边两个坐标的平均值。如果误差小于$10^{-9}$则重构一段区间，线段树上按照编号维护每个点的坐标即可，只需要支持单点修改，区间查询最大值。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>7.22动态规划</title>
      <link href="/2020/07/22/7-22%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2020/07/22/7-22%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<div class="pdfobject-container" data-target="slide.pdf" data-height="500px"></div><a id="more"></a><h1 id="All-Kill"><a href="#All-Kill" class="headerlink" title="All Kill"></a>All Kill</h1><p><img src="image-20200722185043836.png" alt="image-20200722185043836"></p><p>不妨设$t’=t-\sum b_i$，表示做完这$n$道题之后剩下的空余时间。我们将$t$分钟分为$n+t’$个时间段，接着按照编号从小到大考虑每道题目。</p><p>对于第一道题来说，它可以选择这$n+t’$个时间段中的任意一个，然后将其撑到$a_1$分钟，因此方案数为$n+t’$。对于第二道题，它有两种选择：要么选择一个新的时间段，要么在做第一道题的时候就被想出来，然后在第一道题做完之后立刻做第二道题。两种选择都会占去一个新的时间段，方案数为$n+t’-1+a_1$。</p><p>也就是说，对于第$i$道题来说，它会有两种选择：要么占去一个新的时间段，要么在做之前任意一道题的时候被想出来，然后一直等待直到有一个可用的时间段。当我们将这$n$道题都插入完毕的时候，剩下的那些时间段就是空闲时间，每段持续一分钟。</p><p>直接在序列上做会有一个问题：假设任务$j$在做任务$i$的时候被想出来了，但是任务$i$之后的每个时间段都被占满了，那么$j$就无法“顺延”到下一个没有用过的时间段。因此我们将序列当作一个环，同时在最后加入一个空闲时间段（为了方便计算答案）。可以看出，环上的任意一种方案都可以选择一个空闲位置作为最后添加的那个段断开。为了避免重复计数，我们约定在环上距离第一个位置最近的空闲段断开即可。因此，答案为</p><script type="math/tex; mode=display">\prod_{i=1}^n (n+t'+1-(i-1)+\sum_{j<i}a_j)</script><h1 id="Amidakuji"><a href="#Amidakuji" class="headerlink" title="Amidakuji"></a>Amidakuji</h1><p><img src="image-20200722190504065.png" alt="image-20200722190504065"></p><p>考虑如下构造：</p><p>当$n$是奇数的时候，令$p_{i,j}=j+2^i\bmod n$。可以看作每次要么不动，要么往左走$2^{i+1}$步。如果终点到起点距离为偶数那么可以直接走过去，否则这个距离加上$n$之后是偶数。</p><p>如果$n\bmod 4=0$，构造$p_0=(2,3,1,0,6,7,5,4,\cdots)$，接着套用奇数的构造。在第一步中，你可以选择将当前的下标变为奇数还是偶数，从而使得接下来到终点的距离一定是偶数。</p><p>如果$n\bmod 4=2$，构造$p_0=(2,3,1,0,\cdots, n-2, n-1),p_1=(0,1,2,\cdots, n-6, n-5,n-2,n-1,n-3,n-4)$，原理与$n\bmod 4=0$类似。</p><h1 id="Arcs-on-a-Circle"><a href="#Arcs-on-a-Circle" class="headerlink" title="Arcs on a Circle"></a>Arcs on a Circle</h1><p><a href="https://planarg.top/2020/03/04/agc020f-arcs-on-a-circle/" target="_blank" rel="noopener">这里</a></p><h1 id="Classic-Towers"><a href="#Classic-Towers" class="headerlink" title="Classic Towers"></a>Classic Towers</h1><p><img src="image-20200722191609528.png" alt="image-20200722191609528"></p><p>将这个过程倒过来，从终止状态推到初始状态。设$f(a,b,c,p)$表示最大的$a+b+c$个盘子已经放好了，并且此时剩下的所有盘子都堆在第$p$根柱子上是否可行。转移的时候考虑$k$在二进制下的这一位，如果此时剩下的盘子中最大的盘子已经归位，那么这个最大的盘子不需要移动，否则需要花费$2^t$步移动这个盘子。根据$k$的这一位来决定是否归位。</p><h1 id="Clique"><a href="#Clique" class="headerlink" title="Clique"></a>Clique</h1><p><img src="image-20200722192114999.png" alt="image-20200722192114999"></p><p>选中的圆弧中最短的圆弧是哪个，那么剩下可能被选的圆弧只有以下几种</p><p><img src="image-20200722192845416.png" alt="image-20200722192845416"></p><p>黑色的圆弧代表被选中的圆弧，由于这段圆弧是最短的，因此不存在被它完全包含的圆弧。</p><p>显然$D$这种圆弧一定满足条件，因此所有的$B$都会被选。</p><p>$C$同时与所有的$A$有交，也与所有的$B$有交，因此$C$也一定会被选。</p><p>因此，我们只需要考虑$A,B$这两种圆弧的选择情况。</p><p>我们给$A,B$圆弧的左右端点分别分配一个坐标$x_i,y_i$，那么问题转化为选择尽可能多的$A$类和$B$类圆弧，使得不存在一个$A$类圆弧$i$，一个$B$类圆弧$j$，使得$x_j&lt;x_i$，同时$y_j&lt;y_i$。</p><p>将所有圆弧按照$x$坐标排序之后线段树就可以了。</p><h1 id="DFS-Count"><a href="#DFS-Count" class="headerlink" title="DFS Count"></a>DFS Count</h1><p><img src="image-20200722193238202.png" alt="image-20200722193238202"></p><p>记$f(S,i)$表示$S$集合中的点已经访问过了，现在在$i$号点，仅考虑剩下能走到的点的DFS序个数。</p><p>记$g(S,i)$表示$S$集合中的点已经访问过了，现在在$i$号点，还能走到的点集。</p><p>倒着转移$f$，枚举与$i$相连的点$j$，有$f(S,i)=f(S,i)+f(S|j,j)\times f(S|g(S|j,j),j)$。</p><h1 id="Evacuation"><a href="#Evacuation" class="headerlink" title="Evacuation"></a>Evacuation</h1><p><img src="image-20200722193555239.png" alt="image-20200722193555239"></p><p>比较容易读错题，需要注意的是求的是$f$的最大值，以及$f$是对$1$到$n$的所有$b$求和而不是$l$到$r$。</p><p>当$x$在区间中点右侧时，可以发现$l$是没有用的，我们不妨设新的函数为$g(r,x)$。</p><p>将所有询问离线下来，对于一组询问，它要求的东西形如$\max\limits_{L\leq x\leq R}g(r,x)$，我们进行线段树分治。观察到$g$满足四边形不等式，我们对于线段树上的每个节点，将挂到这个节点上的所有$r$拿来做决策单调性就好了。</p><h1 id="Games-on-DAG"><a href="#Games-on-DAG" class="headerlink" title="Games on DAG"></a>Games on DAG</h1><p><img src="image-20200722193951596.png" alt="image-20200722193951596"></p><p>若两个点相连，那么它们的SG值一定不同，因此$1$和$2$之间一定没有边。</p><p>一种暴力的方法是枚举$n$的集合划分，$SG$相同的点被划分到同一个集合中，每个集合必须往每个比它SG值小的集合至少连一条边。</p><p>不妨考虑分层$dp$。记$f(S)$表示只考虑$S$集合时，$SG(1)=SG(2)$的方案数。枚举$U$，满足$U$中没有任何边，显然此时$U$中的所有点的$SG$都为$0$。接着我们将$S$集合中的点的$SG$值整体抬高$1$，即每个点会向$U$集合中至少一个点有连边。</p><h1 id="Giant-Penguin"><a href="#Giant-Penguin" class="headerlink" title="Giant Penguin"></a>Giant Penguin</h1><p><img src="image-20200722194433033.png" alt="image-20200722194433033"></p><p><a href="http://zhengruioi.com/contest/557/problem/1287" target="_blank" rel="noopener">正睿10联测day10</a></p><h1 id="Graph-Coloring"><a href="#Graph-Coloring" class="headerlink" title="Graph Coloring"></a>Graph Coloring</h1><p><img src="image-20200722194634134.png" alt="image-20200722194634134"></p><p>注意到${14\choose 7}&gt;3000$，我们给每个点都分配一个不同的$14$位的二进制编号，满足恰有$7$个位置为$1$。对于两个点$i,j$，我们在$i$的编号中随便找到一位使得$i$这一位为$1$，但$j$这一位为$0$，将$i\rightarrow j$边染上此颜色即可。</p><h1 id="Horrible-Cycles"><a href="#Horrible-Cycles" class="headerlink" title="Horrible Cycles"></a>Horrible Cycles</h1><p><img src="image-20200722194837706.png" alt="image-20200722194837706"></p><p><a href="http://zhengruioi.com/contest/552/problem/1278" target="_blank" rel="noopener">正睿10联测day9</a></p><h1 id="Inversions"><a href="#Inversions" class="headerlink" title="Inversions"></a>Inversions</h1><p><img src="image-20200722194926083.png" alt="image-20200722194926083"></p><p>容易发现实际上要求的是，有$n$个数，第$i$个数不能大于$i-1$，求它们的和为$n$的方案数。</p><p>此时有两种方法，第一种是考虑生成函数，答案的生成函数为</p><script type="math/tex; mode=display">\prod_{i=1}^n\frac{x^i-1}{x-1}</script><p>$x-1$的$\ln$是调和级数，将这个式子$\ln$后再$\exp$回去即可。</p><p>另一种方法是考虑容斥，枚举哪些数不满足条件，问题转化为选出$i$个不同的数，使得它们的和为$j$的方案数，剩下的贡献是一个组合数。可以发现$i$不能大于$\sqrt j$。</p><p>将这个过程想象为一个序列，一开始为空，每次操作会将序列整体加上$1$，并选择是否要在序列的最后接上一个$1$，由于$i$不会超过$\sqrt n$，因此复杂度为$n\sqrt n$，实际上比$\exp$跑得快。</p><h1 id="Jealous-Split"><a href="#Jealous-Split" class="headerlink" title="Jealous Split"></a>Jealous Split</h1><p><img src="image-20200722195523408.png" alt="image-20200722195523408"></p><p>考虑任意一种不合法方案，我们通过移动划分点来使得它变得合法，可以发现调整之后每段的和的平方之和一定变小了。问题转化为将序列划分为$k$段，使得每段的和的平方之和尽量小。wqs二分即可。</p><h1 id="LIS-vs-LDS"><a href="#LIS-vs-LDS" class="headerlink" title="LIS vs. LDS"></a>LIS vs. LDS</h1><p><img src="image-20200722195704599.png" alt="image-20200722195704599"></p><p><img src="image-20200722195742115.png" alt="image-20200722195742115"></p><p>维护一棵线段树，下标为所选择的最后一个数的值。维护区间内最大的LIS以及其对应的两种$f$之和。</p><h1 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h1><p><img src="image-20200722195911527.png" alt="image-20200722195911527"></p><p><img src="image-20200722195944446.png" alt="image-20200722195944446"></p><h1 id="Policeman-and-a-Tree"><a href="#Policeman-and-a-Tree" class="headerlink" title="Policeman and a Tree"></a>Policeman and a Tree</h1><p><img src="image-20200722200006898.png" alt="image-20200722200006898"></p><p>可以发现当前的状态只与警察上一步走的边、子树内的小偷个数、子树外的小偷个数有关。</p><p><img src="image-20200722200051600.png" alt="image-20200722200051600"></p><h1 id="RPS-Robots"><a href="#RPS-Robots" class="headerlink" title="RPS Robots"></a>RPS Robots</h1><p><img src="image-20200722200109938.png" alt="image-20200722200109938"></p><p>考虑对于两个人，如何判断这两个人之间是否有边。</p><p>我们将这两个人的序列看作一个多项式，$x^i$系数表示在第$i$轮这个人会出什么。</p><p>对于第一个人，我们记$R=1,S=\omega,P=\omega^2$，这里$\omega$表示三次单位根。</p><p>对于第二个人，我们记$R=1,S=\omega^2,T=\omega$。当两种状态相乘为$1$时代表平局，相乘为$\omega$时表示第一个人赢了，相乘为$\omega^2$时表示第二个人赢了。</p><p>因此本质上我们是将这两个多项式进行循环差卷积，即卷积之后第$i$项表示第一个人轮换$i$步之后的结果。</p><p>因此，两个人之间有边当且仅当$A(x)$与$B(x)^R$的循环卷积处处相等。这里$A(x)$表示第一个人的多项式，$B(x)$表示第二个人的多项式，$R$表示翻转，因为我们要做差卷积。</p><p>考虑IDFT的本质，实际上它是将$n$个点值代入了原多项式。由于最终求出来的多项式要处处相等，这意味着代入$n$个点值之后求出来的值也相等，满足条件的多项式必然为一个常数多项式，即只有常数项有值，其它项都为$0$。</p><p>设$B(x)=\sum\frac{1}{b_i}x^i$，即$b_i$表示第$i$项的系数的共轭，注意到</p><script type="math/tex; mode=display">\begin{aligned}B(\omega_k^j)^R&=\sum\frac{1}{b_{k-i-1}}\omega_{k}^{ij}\\&=\mathrm{conj}\,\sum b_{k-i-1}\omega_{k}^{j(k-i)}\\&=\mathrm{conj}\,\omega_{k}^j\sum b_i\omega_{k}^{ij} \end{aligned}</script><p>由于我们只需要判断此多项式DFT后每一项是否为$0$，因此可以忽略最开始的$\omega_k^j$，可以发现我们可以直接将第二个人的多项式使用第一个人的系数，即$R=1,S=\omega,P=\omega^2$，同时也不用进行翻转。</p><p>对于每个人我们都代入此系数，然后做一遍DFT，将除开常数项以外的每一位都看作二进制下的$1$或$0$，$1$表示这个数不为$0$，$0$表示这个数为$0$。此时两个人有边当且仅当这两个人的二进制数与起来之后是$0$。</p><p>问题转化为选择尽可能多的数，使得它们与起来之后为$0$。记$f(S)$表示所选数或起来为$S$时能选的最多的数的数量，转移时枚举下一个数$T$使得$S$和$T$与起来为$0$即可。</p><h1 id="Search-Engine"><a href="#Search-Engine" class="headerlink" title="Search Engine"></a>Search Engine</h1><p><img src="image-20200722201939299.png" alt="image-20200722201939299"></p><p>如果是往前添加字符，要么是在后缀树上不动（当前串的$len$小于当前节点的$maxlen$），要么是走向某个儿子。如果是往后添加字符，就是走DAG上的边。</p><p>如果我们能在当前节点待下去，那么一定会一直待着，因为这样出现次数一定不会更劣，可以发现没走一步都必然会导致$len$的增加，因此它是无环的，直接$dp$即可。</p><h1 id="Simple-Counting-Problem"><a href="#Simple-Counting-Problem" class="headerlink" title="Simple Counting Problem"></a>Simple Counting Problem</h1><p><img src="image-20200722202240191.png" alt="image-20200722202240191"></p><p><img src="image-20200722202348807.png" alt="image-20200722202348807"></p><p>本质上我们需要计算的是$n-\sum_{j\in S}(b^j-c+1)+m-1$的$0$到$m$次方之和，由于$c$是常数，因此枚举$|S|$之和就可以将$-c+1$从$\sum$里面提出来。问题转化为求$\sum_S(\sum_{j\in S}b^j)^k$。只需要满足$b^j$的和小于$n+|S|(c-1)$即可。这个可以通过数位$dp$求出来。</p><p><del>瞎胡的</del></p><h1 id="The-Karting"><a href="#The-Karting" class="headerlink" title="The Karting"></a>The Karting</h1><p><img src="image-20200722203717914.png" alt="image-20200722203717914"></p><p>线头dp，设$f(i,j,k)$表示前$i$个点中选择了$j$个点，此时还有$k$条路径未匹配时的最大收益。</p><p><img src="image-20200722203833302.png" alt="image-20200722203833302"></p><h1 id="Tree-Nesting"><a href="#Tree-Nesting" class="headerlink" title="Tree Nesting"></a>Tree Nesting</h1><p><img src="image-20200722203848813.png" alt="image-20200722203848813"></p><p>设$f(i,j,s)$表示考虑了$S$中$i$号点的子树，其中$i$对应$T$的$j$号点，$i$的子树对应$T$的$s$集合中的点的方案数。转移的时候需要子集卷积。注意答案需要除掉$T$自同构的方案数，因为我们默认$T$有根，并且子树有顺序。</p><h1 id="Unicyclic-Graph-Counting"><a href="#Unicyclic-Graph-Counting" class="headerlink" title="Unicyclic Graph Counting"></a>Unicyclic Graph Counting</h1><p><img src="image-20200722204429603.png" alt="image-20200722204429603"></p><p><img src="image-20200722204507897.png" alt="image-20200722204507897"></p><p>如果$a$点在环上，并且是最后一个填过的数，那么它对答案的贡献为</p><script type="math/tex; mode=display">\frac{(len-1)!}{2}\times \frac{(n-len)!}{\prod_b (d_b-1)!\times \prod_c(d_c-2)!\times(d_a-3)!}</script><p>这里环长为$len$，注意环可以翻转。$b$代表所有环外的点，$c$表示所有环上的点。分治NTT即可。</p><h1 id="Wise-Man"><a href="#Wise-Man" class="headerlink" title="Wise Man"></a>Wise Man</h1><p><img src="image-20200722204824777.png" alt="image-20200722204824777"></p><p>记$g(k,t,x)$表示当前数为$x(&lt;10)$，每一次会给$x$加上$\max(k,f(x))$，超过$10^t$时进行的操作次数以及个位数是多少。</p><p>从低位到高位一步步地将$x$变为$\cdots00\cdots0x$的形式，最后再从最高位到最低位依次确定答案即可。</p><h1 id="Yet-Another-Minimization-Problem"><a href="#Yet-Another-Minimization-Problem" class="headerlink" title="Yet Another Minimization Problem"></a>Yet Another Minimization Problem</h1><p><img src="image-20200722205552235.png" alt="image-20200722205552235"></p><p>决策单调性，难点在于如何计算一段区间的答案。</p><p>可以使用类似莫队的方法，维护两个全局指针$l,r$，需要计算$[l,r]$的时候直接将上一次计算之后的$l,r$暴力用类似莫队的方法移过来即可，复杂度可以证明是对的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AGC035E Develop</title>
      <link href="/2020/07/09/AGC035E-Develop/"/>
      <url>/2020/07/09/AGC035E-Develop/</url>
      
        <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>黑板上写着$-10^{18}\sim 10^{18}$间的所有整数，每一个整数都出现了一次。你可以进行任意多次如下操作：</p><ul><li>选择一个$1$到$n$之间，并且出现在黑板上的整数$x$，擦去这个整数。</li><li>如果$x-2$不在黑板上，写下$x-2$。</li><li>如果$x+k$不在黑板上，写下$x+k$。</li></ul><p>问最终黑板上剩下的整数集合可能有多少种。</p><script type="math/tex; mode=display">k\leq n\leq 150</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>将每个整数看作一个点，$x$向$x-2$以及$x+k$连一条有向边。每个点一开始都是黑色的，每次你可以选择一个点，将其变为白色，然后将其连接的两个点变为黑色。</p><p>通过大胆猜想可以得出一个结论：一种情况合法当且仅当每个环上都至少有一个点被染黑。</p><p>证明不难，每一条边$a\rightarrow b$都代表着，如果$a,b$最终都是白色，那么$a$节点一定比$b$先变白，如果一个环上一个黑色点都没有自然不满足条件。</p><p>一种合法的构造方式是将所有白色的点按照拓扑序的逆序排序，然后依次染过去。</p><p>接下来我们分两种情况讨论：$k$是奇数还是偶数。</p><p>当$k$是偶数的时候，显然此时所有的奇数和偶数是独立的。我们可以将$k$除以$2$，然后问题转化为每次写下$x-1$以及$x+\frac{k}{2}$。</p><p>此时整张图连成了一个这样的结构</p><p><img src="AGC035E-Develop/image-20200711145310104.png" alt="image-20200711145310104"></p><p>转化一下限制，原来的限制等价于对于任意两个相邻的黑色节点，它们的距离不能超过$\frac{k}{2}-1$。</p><p>当$k$是奇数时，情况变得有点复杂，因为奇数和偶数连起来了。</p><p><img src="AGC035E-Develop/image-20200711150900645.png" alt="image-20200711150900645"></p><p>问题转化为，先在奇数所在的链上走，走到某个点时通过中间的边跳到偶数上继续走，需要满足不出现黑色点的路径长度$\leq k$。</p><p>记$dp[i][j][k]$表示考虑到了第$i$列，从第$i$列奇数编号的节点开始，上述路径的长度为$j$，此时第$i$列偶数编号的点往左能走$k$步的方案数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">160</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mod;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x += y, x -= x &gt;= mod ? mod : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve1</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> f[N]; <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)), f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k &amp;&amp; i - <span class="number">1</span> - j &gt;= <span class="number">0</span>; j++) </span><br><span class="line">            Inc(f[i], f[i - <span class="number">1</span> - j]);</span><br><span class="line">    <span class="keyword">return</span> f[n + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[N][N][N], type[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve2</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * <span class="number">2</span> - k &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = i * <span class="number">2</span>, b = i * <span class="number">2</span> - k; tot++;</span><br><span class="line">        <span class="keyword">if</span> (a &lt;= n) type[tot] |= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (b &gt; <span class="number">0</span>) type[tot] |= <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i * <span class="number">2</span> &amp;&amp; j &lt;= k + <span class="number">1</span>; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= i; k++) <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j][k]) &#123;</span><br><span class="line">                Inc(dp[i][<span class="number">0</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][k]);</span><br><span class="line">                <span class="keyword">if</span> (type[i] &amp; <span class="number">1</span>) Inc(dp[i][j ? j + <span class="number">1</span> : <span class="number">0</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][k]);</span><br><span class="line">                <span class="keyword">if</span> (type[i] &amp; <span class="number">2</span>) Inc(dp[i][<span class="number">0</span>][k + <span class="number">1</span>], dp[i - <span class="number">1</span>][j][k]);</span><br><span class="line">                <span class="keyword">if</span> (type[i] == <span class="number">3</span>) Inc(dp[i][j ? j + <span class="number">1</span> : k + <span class="number">2</span>][k + <span class="number">1</span>], dp[i - <span class="number">1</span>][j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k + <span class="number">1</span>; j++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= tot; k++) Inc(res, dp[tot][j][k]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;k, &amp;mod);</span><br><span class="line">    <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ((LL)solve1(n / <span class="number">2</span>, k / <span class="number">2</span>) * solve1((n + <span class="number">1</span>) / <span class="number">2</span>, k / <span class="number">2</span>)) % mod);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve1(n, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve2(n, k));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC032D Rotation Sort</title>
      <link href="/2020/07/09/AGC032D-Rotation-Sort/"/>
      <url>/2020/07/09/AGC032D-Rotation-Sort/</url>
      
        <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定一个$1\sim n$的排列，你每次可以选择一个区间，然后花费$A$的代价使区间最右边的数挪动到最左边，或者花费$B$的代价使区间最左边的数挪动到最右边，问将整个排列还原成升序的最小代价。</p><script type="math/tex; mode=display">n\leq 5\times 10^3</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>显然对于每个数我们最多只会操作一次，我们将所有数分为两类：操作过的数以及没有操作过的数。</p><p>所有没有操作过的数一定形成了一个上升序列，并且对于两个相邻的没有操作过的数$a,b$，它们之间一定不存在一个位置$c$，使得$c$的权值介于$a,b$之间，否则这个数完全可以不动，当前方案一定不优秀。</p><p>对于$a,b$之间的所有数，如果这个数小于$a$，那么它只能往左移；如果这个数大于$b$，那么它只能往右移。</p><p>记$dp[i]$表示最后一个固定的位置为$i$时前面对答案的贡献，我们可以往排列的末尾添加一个$n+1$，那么答案就是$dp[n+1]$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N]; LL dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, A, B; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;A, &amp;B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp)), dp[<span class="number">0</span>] = <span class="number">0</span>, num[n + <span class="number">1</span>] = n + <span class="number">1</span>, n++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>, l = <span class="number">0</span>, r = <span class="number">0</span>, mx = <span class="number">0</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[j] &lt; num[i] &amp;&amp; num[j] &gt; mx) mx = num[j];</span><br><span class="line">            <span class="keyword">if</span> (mx &lt;= num[j] &amp;&amp; num[j] &lt; num[i]) </span><br><span class="line">                dp[i] = min(dp[i], dp[j] + (LL)l * B + (LL)r * A);</span><br><span class="line">            <span class="keyword">if</span> (num[j] &lt; num[i]) l++;</span><br><span class="line">            <span class="keyword">else</span> r++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>7.8联测</title>
      <link href="/2020/07/08/7-8%E8%81%94%E6%B5%8B/"/>
      <url>/2020/07/08/7-8%E8%81%94%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-咕"><a href="#T1-咕" class="headerlink" title="T1 咕"></a>T1 咕</h1><p>有一个长度为$n$的随机排列，你并不知道这个排列的每一位是多少。一开始你的位置为$1$，每次你会询问当前位置是否是前缀最小值，然后选择两种行动之一：</p><ul><li>移动到下一个位置</li><li>拿走当前位置的数，结束游戏。</li></ul><p>你想要知道，如果你执行最优策略，拿走$1$的概率有多大。</p><p>多组数据。</p><script type="math/tex; mode=display">n\leq 10^6, T\leq 10^5</script><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>你的最优策略一定是：在游戏开始之前选定一个位置$pos$，当位于$pos$左边的位置时，无论当前位置是否是前缀最小值都继续移动，在$pos$以及$pos$后第一个前缀最小值位置取走这个位置的数。</p><p>我们尝试将$pos$往右移动，同时计算此时取到$1$的概率。</p><p>对于一个选定的$pos$，答案为</p><script type="math/tex; mode=display">\begin{aligned}ans_{pos}&=\frac{1}{n!}\sum_{i=pos}^n{n-1\choose i-1}(pos-1)(n-i)!(i-2)!\\&=\frac{pos-1}{n}\sum_{i=pos}^{n}\frac{1}{i-1}\\ans_{pos+1}-ans_{pos}&=\frac{pos}{n}\sum_{i=pos}^{n-1}\frac{1}{i}-\frac{pos-1}{n}\sum_{i=pos-1}^{n-1}\frac{1}{i}\\&=\frac{\sum\limits_{i=pos}^{n-1}\frac{1}{i}-1}{n}\end{aligned}</script><p>也就是说，只要最后一个式子的分母大于$0$，$pos$就能继续往右挪动。</p><p>显然分母是单调的，我们可以二分找到这个位置。事实上$pos$的一个很精确的估计是$\frac{n}{e}$，我们只需要在这个基础上进行调整即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> e = <span class="built_in">exp</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> wkr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T), inv[<span class="number">1</span>] = frac[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N - <span class="number">10</span>; i++) inv[i] = (LL)(mod - mod / i) * inv[mod % i] % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N - <span class="number">10</span>; i++) wkr[i] = wkr[i - <span class="number">1</span>] + <span class="number">1.</span> / i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N - <span class="number">10</span>; i++) inv[i] = (inv[i - <span class="number">1</span>] + inv[i]) % mod, frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123; <span class="built_in">puts</span>(<span class="string">"1"</span>); <span class="keyword">continue</span>; &#125; </span><br><span class="line">        <span class="keyword">int</span> pos = <span class="built_in">ceil</span>(n / e), res;</span><br><span class="line">        <span class="keyword">if</span> (wkr[n - <span class="number">1</span>] - wkr[pos - <span class="number">1</span>] &lt; <span class="number">1</span>) pos--;</span><br><span class="line">        res = (LL)pos * (inv[n - <span class="number">1</span>] - inv[pos - <span class="number">1</span>] + mod) % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL)res * (inv[n] - inv[n - <span class="number">1</span>] + mod) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-凋朱颜"><a href="#T2-凋朱颜" class="headerlink" title="T2 凋朱颜"></a>T2 凋朱颜</h1><p>有一个$m^n\times m^n$大小的网格，横坐标和纵坐标分别为$0\sim m^n-1$。</p><p>$(i, j)$格子的权值为$i\bigoplus_m j$，其中$\bigoplus_m$为$m$进制下的不进位加法。你一开始可以选定任意一个格子，每次可以走到与当前格子四联通的格子，同时满足目标格子的权值是当前格子的权值$+1$，问合法路径总数。</p><script type="math/tex; mode=display">n,m\leq 10^9</script><!-- more --><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>按照最高位将网格分为$m\times m$个小块，并给每一行每一列编号$0\sim m-1$。那么第$i$行第$j$列的格子的最高位就是$i\bigoplus_mj$。</p><p><img src="image-20200709092229525.png" alt="image-20200709092229525"></p><p>可以看出，浅色的格子只能往更深一层的格子走，当$m&gt;2$时只能往右或者往下，当$m=2$时有些时候可以往左。</p><p>这$m\times m$个块每个块都是一个$m^{n-1}\times m^{n-1}$的方格，并且第$i$行第$j$列的方格内的数的取值范围为$[m^{n-1}(i\bigoplus_m j),m^{n-1}[(i\bigoplus_m j) + 1])$。同时权值最大的方格一定分布在每个小块的对角线上。</p><p>也就是说，从一个块走到另一个块时，必然是从这个块的左下角或者右上角走出去，走到下一个块的左上角。</p><p>考虑对于每一个块，从这个块的左上角走到左下角或者右上角的方案数，不难发现这两个方案数是对称的，同时可以归纳证明只存在一种方案。如果是往左下角走的话只能一直往下走，否则只能一直往右走。</p><p>考虑如何计算答案，可以发现合法的路径只有两种：</p><ul><li>每个小块内的路径条数，由于一共有$m\times m$个小块，因此这种情况对答案的贡献系数为$m\times m$。</li><li>任选一个块出发，到达任意一个除开起点外的能到达的块，同时乘上每个小块内任选一个点走到左下角/右上角的方案数，再乘以从左上角走到任意一个点的方案数。</li></ul><p>考虑“每个小块内任选一个点走到左下角/右上角的方案数”如何计算，由于每次只能往下或者往右走，因此如果是走到左下角的话，只有最左边这一列的点能够走到，并且每个点的路径条数是唯一的。因此当这个小块的大小为$m^n\times m^n$时，方案数为$m^n$。</p><p>对于“左上角走到任意一个点的方案数”，不难发现最多只能走$m-1$步，每一步要么往右走，要么往下走，因此方案数为$2^0+2^1+\cdots +2^{m-1}=2^m-1$。</p><p>如果固定了起点块到终点块的路径，那么中间经过的所有块内部的路径都是唯一的，因为左上角到达右上角/左下角的路径是唯一的。</p><p>这意味着我们只需要考虑有多少种至少经过了两个块的路径，观察可以发现这个路径条数为</p><script type="math/tex; mode=display">\sum_{i=1}^{m}(2^{m-i+1}-1)\times (2i-1)</script><p>将这个式子拆成四项，每一项都可以直接计算。</p><p>由于计算答案的时候要用到上一项的答案，可以考虑矩乘。建出一个$2\times 2$的矩阵，维护每一项的答案以及每一小块到左上角/右上角的方案数乘以从左上角到达块内一个点的方案数即可。</p><p>注意当$m=2$的时候需要特判，因为此时右下角的点可以走到左下角。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, base, base1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="number">2</span>) &#123;</span><br><span class="line">        base = Pow(<span class="number">2</span>, m) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//      for (int i = 1; i &lt;= m; i++) </span></span><br><span class="line"><span class="comment">//      base1 = (base1 + (LL)(Pow(2, m - i + 1) - 1) * (2 * i - 1)) % mod;</span></span><br><span class="line">        <span class="keyword">int</span> tp = Pow(<span class="number">2</span>, m + <span class="number">1</span>);</span><br><span class="line">        base1 = (LL)(tp - m - <span class="number">2</span> + mod) % mod * <span class="number">4</span> % mod;</span><br><span class="line">        base1 = (base1 - tp + <span class="number">2</span> + mod) % mod;</span><br><span class="line">        base1 = (base1 - (LL)<span class="number">2</span> * m * m % mod + mod) % mod;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        base = <span class="number">3</span>, base1 = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">Matrix() &#123; <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">operator</span> [] (<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> a[x]; &#125;</span><br><span class="line"></span><br><span class="line">Matrix <span class="keyword">operator</span> * (Matrix &amp;b) &#123;</span><br><span class="line">    Matrix c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">                c[i][j] = (c[i][j] + (LL)a[i][k] * b[k][j]) % mod;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Matrix <span class="title">Pow</span><span class="params">(Matrix x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    Matrix res; res[<span class="number">0</span>][<span class="number">0</span>] = res[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = x * x) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = res * x;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Matrix G;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">2</span>) G[<span class="number">0</span>][<span class="number">0</span>] = (LL)base * <span class="number">3</span> % mod; </span><br><span class="line">    <span class="keyword">else</span> G[<span class="number">0</span>][<span class="number">0</span>] = (LL)base * m % mod;</span><br><span class="line">    G[<span class="number">1</span>][<span class="number">1</span>] = (LL)m * m % mod;</span><br><span class="line">    G[<span class="number">0</span>][<span class="number">1</span>] = base1;</span><br><span class="line">    G = Pow(G, n);</span><br><span class="line">    <span class="keyword">return</span> (G[<span class="number">0</span>][<span class="number">1</span>] + G[<span class="number">1</span>][<span class="number">1</span>]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int F(int n) &#123;</span></span><br><span class="line"><span class="comment">//    return Pow(base, n);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//int G(int n) &#123;</span></span><br><span class="line"><span class="comment">//    return Pow(m, n);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//int solve(int n) &#123;</span></span><br><span class="line"><span class="comment">//    if (n == 0) return 1;</span></span><br><span class="line"><span class="comment">//    int res = (LL)m * m % mod * solve(n - 1) % mod;</span></span><br><span class="line"><span class="comment">//    int t = (LL)base1 * G(n - 1) % mod * F(n - 1) % mod;</span></span><br><span class="line"><span class="comment">//    return (res + t) % mod;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m), pre();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-简单题"><a href="#T3-简单题" class="headerlink" title="T3 简单题"></a>T3 简单题</h1><p>定义两点间的距离为所有从$u$到$v$的路径中最大边最小的路径的最大边权。</p><p>给定两张点数相同的无向图，定义$D_1(u,v)$为$u,v$在第一张图中的距离，$D_2(u,v)$为$u,v$在第二张图中的距离，求</p><script type="math/tex; mode=display">\sum_{u}\sum_{v}D_1(u,v)D_2(u,v)</script><script type="math/tex; mode=display">n\leq 2\times 10^5, m\leq 5\times 10^5</script><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>建出两张图的<code>Kruskal</code>重构树，那么$u,v$两点的距离就是它们的$lca$的点权。考虑对第二棵树$dfs$，同时启发式合并，那么$u,v$两点会在它们的$lca$处合并，换言之当前合并的所有点在第二张图上的距离我们是知道的。</p><p>对于第一棵树，我们将其差分，每个点的权值等于它原来的权值减去其父亲的权值。当插入一个点$u$时我们将其所有祖先全部加上这个祖先自己的权值，那么查询$v$点时我们只需要知道$v$到根路径上的权值之和，此时$u$对$v$的贡献就是它们的$lca$的点权。</p><p>因此对于第二棵树上的每个点我们都开一棵线段树，就是树剖的那种，当插入一个点时更新这个点到根的所有点，合并的时候就是普通的线段树合并。</p><p>需要注意的是<code>Kruskal</code>重构树的点数是$2n$，以及如果不回收内存会MLE。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N * <span class="number">80</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b &gt;= mod ? a + b - mod : a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ls[M], rs[M], sum[N], res[M], tg[M], ncnt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; buff;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">apply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!buff.size()) <span class="keyword">return</span> ++ncnt;</span><br><span class="line">    <span class="keyword">int</span> u = buff.back(); buff.pop_back();</span><br><span class="line">    <span class="keyword">return</span> ls[u] = rs[u] = res[u] = tg[u] = <span class="number">0</span>, u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Add(sum[r], mod - sum[l - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rt) rt = apply();</span><br><span class="line">    res[rt] = Add(res[rt], get(max(l, start), min(r, end)));</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> tg[rt]++, <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) update(ls[rt], l, mid, start, end);</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) update(rs[rt], mid + <span class="number">1</span>, r, start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rt) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> res[rt];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, ans = (LL)tg[rt] * get(max(l, start), min(r, end)) % mod;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) ans = Add(ans, query(ls[rt], l, mid, start, end));</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) ans = Add(ans, query(rs[rt], mid + <span class="number">1</span>, r, start, end)); </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x |= y, <span class="keyword">void</span>();</span><br><span class="line">    tg[x] += tg[y], res[x] = Add(res[x], res[y]), buff.push_back(y);</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    merge(ls[x], ls[y], l, mid), merge(rs[x], rs[y], mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> son[N], sz[N], top[N], id[N], fa[N], w[N], dfsn, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>, fa[u] = f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) <span class="keyword">if</span> (v != f) &#123;</span><br><span class="line">        dfs(v, u), sz[u] += sz[v];</span><br><span class="line">        <span class="keyword">if</span> (sz[v] &gt; sz[son[u]]) son[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    top[u] = t, id[u] = ++dfsn, sum[id[u]] = Add(w[u], mod - w[fa[u]]);</span><br><span class="line">    <span class="keyword">if</span> (son[u]) dfs1(son[u], t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) <span class="keyword">if</span> (v != fa[u] &amp;&amp; v != son[u]) dfs1(v, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[u]) update(rt, <span class="number">1</span>, dfsn, id[top[u]], id[u]), u = fa[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top[u]) res = Add(res, query(rt, <span class="number">1</span>, dfsn, id[top[u]], id[u])), u = fa[top[u]];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> L[N], R[N], RT[N], T[N], ans, val[N]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= n) <span class="keyword">return</span> RT[u] = u, p[u].push_back(u), push(T[u], u), <span class="keyword">void</span>();</span><br><span class="line">    dfs(L[u]), dfs(R[u]); <span class="keyword">int</span> a = L[u], b = R[u];</span><br><span class="line">    <span class="keyword">if</span> (p[RT[a]].size() &gt; p[RT[b]].size()) swap(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : p[RT[a]]) </span><br><span class="line">        ans = (ans + (LL)val[u] * query(T[b], t)) % mod, p[RT[b]].push_back(t);</span><br><span class="line">    RT[u] = RT[b], p[RT[a]].clear(), merge(T[b], T[a], <span class="number">1</span>, dfsn), T[u] = T[b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _fa[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == _fa[x] ? x : _fa[x] = find(_fa[x]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FuckThisProblem</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> from, to, w;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> FuckThisProblem &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; fuck[N * <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T, typename... Tail&gt; inline void read(T &amp;t1, Tail&amp;... tail) &#123;</span><br><span class="line">    read(t1), read(tail...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bel[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m; read(n, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) read(fuck[i].from, fuck[i].to, fuck[i].w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) _fa[i] = bel[i] = i;</span><br><span class="line">    sort(fuck + <span class="number">1</span>, fuck + m + <span class="number">1</span>); <span class="keyword">int</span> ncnt = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = find(fuck[i].from), b = find(fuck[i].to);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="keyword">continue</span>;</span><br><span class="line">        _fa[a] = b, ncnt++, G[ncnt].push_back(bel[a]), G[ncnt].push_back(bel[b]), bel[b] = ncnt, w[ncnt] = fuck[i].w; </span><br><span class="line">    &#125; </span><br><span class="line">    dfs(ncnt, <span class="number">0</span>), dfs1(ncnt, ncnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dfsn; i++) sum[i] = Add(sum[i - <span class="number">1</span>], sum[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) read(fuck[i].from, fuck[i].to, fuck[i].w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) _fa[i] = bel[i] = i;</span><br><span class="line">    sort(fuck + <span class="number">1</span>, fuck + m + <span class="number">1</span>), ncnt = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = find(fuck[i].from), b = find(fuck[i].to);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="keyword">continue</span>;</span><br><span class="line">        _fa[a] = b, ncnt++, L[ncnt] = bel[a], R[ncnt] = bel[b], bel[b] = ncnt, val[ncnt] = fuck[i].w; </span><br><span class="line">    &#125;</span><br><span class="line">    dfs(ncnt), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 启发式合并 </tag>
            
            <tag> Kruskal重构树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC032E Modulo Pairing</title>
      <link href="/2020/07/07/AGC032E-Modulo-Pairing/"/>
      <url>/2020/07/07/AGC032E-Modulo-Pairing/</url>
      
        <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定$2n$个正整数$a_1,\cdots a_{2n}$，你要将它们两两配对，使得每一对之和模$m$的最大值尽量小。</p><script type="math/tex; mode=display">n\leq 10^5, m\leq 10^9</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>将所有数从小到大排序。</p><p>首先有一个结论：一定存在一种最优方案，使得存在一个划分点$x$，$x$左边的数一头一尾配对，$x$右边的数一头一尾配对，并且左边的每一对之和都小于$m$，右边的每一对之和都大于等于$m$。</p><p><img src="image-20200707200524084.png" alt="image-20200707200524084"></p><p>蓝色的边代表匹配的两个数之和$&lt;m$，红色的边代表匹配的两个数之和$\geq m$，我们可以证明，上图中左边的方案一定没有右边的方案优秀。</p><p>以第二列第一种情况为例，我们设这四个数分别为$a,b,c,d$，并且$a\leq b\leq c\leq d$，由于这四个数都不超过$m$，因此$a+c\geq c,b+d-m&lt;b$，故较大的匹配是$a+c$。当这种情况调整到右边的情况之后，蓝色变为了$a+b$，红色变为了$c+d-m\leq c$，可以发现这个值一定不会劣于调整之前的值。</p><p>同时，当划分点向左移动时，可以发现左右两边的匹配最大值都在变小，因此我们可以二分出最优的左端点，即最靠左的左端点满足匹配之后右边的每一对匹配都不小于$m$。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N], n, m, ans = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mid; i++) res = max(res, num[i] + num[mid * <span class="number">2</span> - i + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - mid; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = num[mid * <span class="number">2</span> + i] + num[n * <span class="number">2</span> - i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (t &lt; m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        res = max(res, t - m);</span><br><span class="line">    &#125;</span><br><span class="line">    ans = min(ans, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">    sort(num + <span class="number">1</span>, num + n * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF571E Geometric Progressions</title>
      <link href="/2020/07/07/CF571E-Geometric-Progressions/"/>
      <url>/2020/07/07/CF571E-Geometric-Progressions/</url>
      
        <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定$n$以及$n$个正整数对$a_i,b_i$，第$i$对$a_i,b_i$表示一个序列$\{a_i,a_ib_i,a_ib_i^2,a_ib_i^3,\cdots\}$，问最小的出现在这$n$个序列中的公共元素，或判断不存在。</p><script type="math/tex; mode=display">n\leq 100, a_i,b_i\leq 10^9</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>考虑一个类似中国剩余定理的过程，每次合并两个序列直到最后只剩下一个序列，这个序列的第一个元素就是答案。</p><p>考虑合并两个位置$i,j$，我们不妨设第一个公共元素出现在$i$的第$x$项，出现在$j$的第$y$项。</p><p>对于每个$a,b$的质因子我们分开考虑，显然公共元素的指数应该相等。即对于任意的指数$p$，如果记$s(a,p)$表示$a$中$p$的指数，那么有</p><script type="math/tex; mode=display">s(a_i,p)+xs(b_i,p)=s(a_j,p)+ys(b_j,p)</script><p>每个质因子我们都可以列出这样的一个方程，如果去掉本质相同的方程之后至少有两个，那么我们就能唯一确定$x,y$，换句话说，公共元素是唯一的。</p><p>关于二元一次方程组，有一个奇妙的行列式解法。</p><p>对于方程</p><script type="math/tex; mode=display">\begin{cases}a_1x+b_1y=c_1\\a_2x+b_2y=c_2\end{cases}</script><p>有</p><script type="math/tex; mode=display">x=\frac{\begin{vmatrix}c_1&b_1\\c_2&b_2\end{vmatrix}}{\begin{vmatrix}a_1&b_1\\a_2&b_2\end{vmatrix}},y=\frac{\begin{vmatrix}a_1&c_1\\a_2&c_2\end{vmatrix}}{\begin{vmatrix}a_1&b_1\\a_2&b_2\end{vmatrix}}</script><p>如果解出了$x,y$的值，直接代入其它序列里面验证就行了，否则我们需要继续合并。</p><p>考虑这样一个方程</p><script type="math/tex; mode=display">ax+by=c</script><p>它等价于$ax\equiv c\pmod b$。</p><p>解出这个方程的最小非负整数解，那么合并之后的$s(a’,p)=s(a,p)+s(b,p)\times x, s(b’,p)=s(b,p)\times b$</p><p>需要注意的是一些边界情况，一开始要判一下$1$和每个序列的$a_i$是否满足条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">210</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FUCK</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;LL, P&gt; wkr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="comment">// b Âú×ã a </span></span><br><span class="line">    LL cur = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : wkr[b]) <span class="keyword">if</span> (!wkr[a].count(t.fir)) FUCK();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : wkr[a]) <span class="keyword">if</span> (wkr[b].count(t.fir)) &#123;</span><br><span class="line">        <span class="keyword">auto</span> A = t.sec, B = wkr[b][t.fir]; </span><br><span class="line">        <span class="keyword">if</span> (A.sec != B.sec) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!B.fir) FUCK();</span><br><span class="line">            <span class="keyword">if</span> (A.sec &lt; B.sec || (A.sec - B.sec) % B.fir) FUCK();</span><br><span class="line">        &#125;</span><br><span class="line">        LL hh = B.fir ? (A.sec - B.sec) / B.fir : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="number">-1</span>) cur = hh;</span><br><span class="line">        <span class="keyword">if</span> (cur != hh) FUCK();</span><br><span class="line">    &#125; <span class="keyword">else</span> FUCK();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, tot;</span><br><span class="line"></span><br><span class="line">LL A, B, C; <span class="comment">// Ax + By = C</span></span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span> </span>&#123; <span class="keyword">return</span> b ? gcd(b, a % b) : a; &#125;</span><br><span class="line"></span><br><span class="line">LL G[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Det</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> G[<span class="number">0</span>][<span class="number">0</span>] * G[<span class="number">1</span>][<span class="number">1</span>] - G[<span class="number">0</span>][<span class="number">1</span>] * G[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">push</span><span class="params">(LL tA, LL tB, LL tC)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; "push: " &lt;&lt; tA &lt;&lt; ' ' &lt;&lt; tB &lt;&lt; ' ' &lt;&lt; tC &lt;&lt; endl;</span></span><br><span class="line">    LL g = gcd(tA, tB); assert(g);</span><br><span class="line">    <span class="keyword">if</span> (tC % g) FUCK();</span><br><span class="line">    tA /= g, tB /= g, tC /= g;</span><br><span class="line">    <span class="keyword">if</span> (!A) <span class="keyword">return</span> A = tA, B = tB, C = tC, <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (A == tA &amp;&amp; B == tB) &#123;</span><br><span class="line">        <span class="keyword">if</span> (C != tC) FUCK();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    G[<span class="number">0</span>][<span class="number">0</span>] = A, G[<span class="number">0</span>][<span class="number">1</span>] = B, G[<span class="number">1</span>][<span class="number">0</span>] = tA, G[<span class="number">1</span>][<span class="number">1</span>] = tB;</span><br><span class="line">    LL base = Det(); assert(base);</span><br><span class="line">    G[<span class="number">0</span>][<span class="number">0</span>] = C, G[<span class="number">0</span>][<span class="number">1</span>] = B, G[<span class="number">1</span>][<span class="number">0</span>] = tC, G[<span class="number">1</span>][<span class="number">1</span>] = tB;</span><br><span class="line">    LL t1 = Det(); <span class="keyword">if</span> (t1 % base) FUCK();</span><br><span class="line">    G[<span class="number">0</span>][<span class="number">0</span>] = A, G[<span class="number">0</span>][<span class="number">1</span>] = C, G[<span class="number">1</span>][<span class="number">0</span>] = tA, G[<span class="number">1</span>][<span class="number">1</span>] = tC;</span><br><span class="line">    LL t2 = Det(); <span class="keyword">if</span> (t2 % base) FUCK();</span><br><span class="line">    LL x = t1 / base, y = t2 / base;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) FUCK();</span><br><span class="line">    A = x, B = y; <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL x, y;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a, LL b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> x = <span class="number">1</span>, y = <span class="number">0</span>, a;</span><br><span class="line">    LL d = exgcd(b, a % b), t = x; x = y, y = t - a / b * y;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    A = B = C = <span class="number">0</span>, tot++; <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : wkr[a]) <span class="keyword">if</span> (wkr[b].count(t.fir)) &#123;</span><br><span class="line">        <span class="keyword">auto</span> A = t.sec, B = wkr[b][t.fir];</span><br><span class="line">        <span class="keyword">if</span> (push(A.fir, -B.fir, B.sec - A.sec)) &#123; flag = <span class="literal">true</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> FUCK();</span><br><span class="line"><span class="comment">//    cout &lt;&lt; A &lt;&lt; ' ' &lt;&lt; B &lt;&lt; ' ' &lt;&lt; C &lt;&lt; ' ' &lt;&lt; flag &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : wkr[b]) <span class="keyword">if</span> (!wkr[a].count(t.fir)) FUCK();</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t : wkr[a]) &#123;</span><br><span class="line"><span class="comment">//            cout &lt;&lt; t.fir &lt;&lt; ' ' &lt;&lt; t.sec.fir &lt;&lt; ' ' &lt;&lt; t.sec.sec &lt;&lt; endl;</span></span><br><span class="line">            LL tmp = t.sec.fir * A + t.sec.sec;</span><br><span class="line">            wkr[tot][t.fir] = P(<span class="number">0</span>, tmp);</span><br><span class="line">            ans = (LL)ans * Pow(t.fir, tmp % (mod - <span class="number">1</span>)) % mod;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) test(tot, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!A) FUCK();</span><br><span class="line">    <span class="keyword">if</span> (B &lt; <span class="number">0</span>) A = -A, B = -B, C = -C;  </span><br><span class="line"><span class="comment">//    cout &lt;&lt; A &lt;&lt; ' ' &lt;&lt; B &lt;&lt; ' ' &lt;&lt; C &lt;&lt; endl; </span></span><br><span class="line">    LL g = exgcd(A, B); x *= C / g, x = (x % B + B) % B;</span><br><span class="line"><span class="comment">//    if (A * x &lt;= C) &#123;</span></span><br><span class="line"><span class="comment">//        LL tmp = (C - A * x + B - 1) / B;</span></span><br><span class="line"><span class="comment">//        x += tmp * B;   </span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : wkr[a]) </span><br><span class="line">        wkr[tot][t.fir] = P(B * t.sec.fir, t.sec.sec + t.sec.fir * x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fuck[N], zjk[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % fuck[i]) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = x / fuck[i];</span><br><span class="line">        <span class="keyword">while</span> (tmp &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp % zjk[i]) <span class="keyword">return</span>;</span><br><span class="line">            tmp /= zjk[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="number">0</span>) <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), fuck[i] = a, zjk[i] = b;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; (j * j &lt;= a) || (j * j &lt;= b); j++) <span class="keyword">if</span> (a % j == <span class="number">0</span> || b % j == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> ct = <span class="number">0</span>, ct1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (a % j == <span class="number">0</span>) ct++, a /= j;</span><br><span class="line">            <span class="keyword">while</span> (b % j == <span class="number">0</span>) ct1++, b /= j;</span><br><span class="line">            wkr[i][j] = P(ct1, ct);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="number">1</span> || b != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == b) wkr[i][a] = P(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (a != <span class="number">1</span>) wkr[i][a] = P(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (b != <span class="number">1</span>) wkr[i][b] = P(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    test(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) test(fuck[i]);</span><br><span class="line">    tot = n, merge(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) merge(tot, i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) test(tot, i);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : wkr[tot]) </span><br><span class="line">        ans = (LL)ans * Pow(t.fir, t.sec.sec % (mod - <span class="number">1</span>)) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF666E Forensic Examination</title>
      <link href="/2020/07/07/CF666E-Forensic-Examination/"/>
      <url>/2020/07/07/CF666E-Forensic-Examination/</url>
      
        <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给出一个串$s$和若干个字符串$t_1\cdots t_m$，现在有$q$次询问，每次询问$s$的子串$s[p_l\cdots p_r]$在$t_l\cdots t_r$中的哪个串里的出现次数最多，并输出出现次数。</p><script type="math/tex; mode=display">|s|\leq 5\times 10^5, m\leq 5\times 10^4, \sum|t_i|\leq 5\times 10^4</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>先建出$s$和所有$t$的广义后缀自动机。</p><p>将询问离线，先在后缀树上定位到$s[p_l\cdots p_r]$所在的节点$u$，那么所有以这个串作为后缀的串就是$u$子树中的节点所代表的所有串以及$u$中所有长度不小于$p_r-p_l+1$的串。</p><p>在后缀树上$dfs$，同时线段树合并记录当前子树中每种$t$串的出现次数。</p><p>将挂在$u$上的串以及询问按照长度从大到小排序，需要注意的是如果长度相等的话那么串要排在询问前面。</p><p>接着我们依次枚举排完序之后的东西，如果是串的话就加入线段树，否则就查区间最大值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">600010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> link[N * <span class="number">2</span>] = &#123;<span class="number">-1</span>&#125;, ch[N * <span class="number">2</span>][<span class="number">26</span>], len[N * <span class="number">2</span>], ncnt, last;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ch[last][c - <span class="string">'a'</span>] &amp;&amp; len[ch[last][c - <span class="string">'a'</span>]] == len[last] + <span class="number">1</span>) <span class="keyword">return</span> last = ch[last][c - <span class="string">'a'</span>];</span><br><span class="line">    <span class="keyword">int</span> nw = ++ncnt, p = last; len[nw] = len[p] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (~p &amp;&amp; !ch[p][c - <span class="string">'a'</span>]) ch[p][c - <span class="string">'a'</span>] = nw, p = link[p];</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">-1</span>) <span class="keyword">return</span> last = nw;</span><br><span class="line">    <span class="keyword">int</span> q = ch[p][c - <span class="string">'a'</span>];</span><br><span class="line">    <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>) <span class="keyword">return</span> link[nw] = q, last = nw;</span><br><span class="line">    <span class="keyword">int</span> clone = p == last ? nw : ++ncnt; <span class="built_in">memcpy</span>(ch[clone], ch[q], <span class="keyword">sizeof</span>(ch[q])), len[clone] = len[p] + <span class="number">1</span>;</span><br><span class="line">    link[clone] = link[q], link[q] = clone;</span><br><span class="line">    <span class="keyword">if</span> (clone != nw) link[nw] = clone;</span><br><span class="line">    <span class="keyword">while</span> (~p &amp;&amp; ch[p][c - <span class="string">'a'</span>] == q) ch[p][c - <span class="string">'a'</span>] = clone, p = link[p];</span><br><span class="line">    <span class="keyword">return</span> last = nw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N * <span class="number">2</span>], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; "adde: " &lt;&lt; from &lt;&lt; ' ' &lt;&lt; to &lt;&lt; endl;</span></span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from] &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to] &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N * <span class="number">2</span>][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">19</span>; i++) fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) </span><br><span class="line">            dfs(e[i].to, u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (len[fa[u][i]] &gt;= l) u = fa[u][i];</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ls[N * <span class="number">16</span>], rs[N * <span class="number">16</span>], tot, n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WEN</span> &#123;</span> <span class="keyword">int</span> val, pos; &#125; wkr[N * <span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> WEN <span class="title">merge</span><span class="params">(WEN a, WEN b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.val &gt;= b.val ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; buff;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">apply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">if</span> (buff.size()) t = buff.front(), buff.pop();</span><br><span class="line">    <span class="keyword">else</span> t = ++tot;</span><br><span class="line">    <span class="keyword">return</span> wkr[t] = (WEN)&#123; <span class="number">0</span>, <span class="number">0</span> &#125;, ls[t] = rs[t] = <span class="number">0</span>, t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rt) rt = apply();</span><br><span class="line"><span class="comment">//    if (l == 1 &amp;&amp; r == n) cout &lt;&lt; "insert: " &lt;&lt; rt &lt;&lt; ' ' &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> wkr[rt] = (WEN)&#123; wkr[rt].val + <span class="number">1</span>, l &#125;, <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) insert(ls[rt], l, mid, x);</span><br><span class="line">    <span class="keyword">else</span> insert(rs[rt], mid + <span class="number">1</span>, r, x);</span><br><span class="line">    wkr[rt] = merge(wkr[ls[rt]], wkr[rs[rt]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">WEN <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rt) <span class="keyword">return</span> (WEN)&#123; <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> wkr[rt];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (end &lt;= mid) <span class="keyword">return</span> query(ls[rt], l, mid, start, end);</span><br><span class="line">    <span class="keyword">if</span> (start &gt; mid) <span class="keyword">return</span> query(rs[rt], mid + <span class="number">1</span>, r, start, end);</span><br><span class="line">    <span class="keyword">return</span> merge(query(ls[rt], l, mid, start, end), query(rs[rt], mid + <span class="number">1</span>, r, start, end));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x |= y, <span class="keyword">void</span>();</span><br><span class="line">    buff.push(y);</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> wkr[x] = (WEN)&#123; wkr[x].val + wkr[y].val, l &#125;, <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    merge(ls[x], ls[y], l, mid), merge(rs[x], rs[y], mid + <span class="number">1</span>, r), wkr[x] = merge(wkr[ls[x]], wkr[rs[x]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt; q[N * <span class="number">2</span>], appear[N * <span class="number">2</span>]; <span class="keyword">int</span> RT[N * <span class="number">2</span>], L[N], R[N]; WEN ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    sort(q[u].rbegin(), q[u].rend()), sort(appear[u].rbegin(), appear[u].rend());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) </span><br><span class="line">            dfs1(e[i].to, u), merge(RT[u], RT[e[i].to], <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; "dfs: " &lt;&lt; u &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//    for (auto t : appear[u]) printf("(%d, %d) ", t.first, t.second);</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : q[u]) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; appear[u].size() &amp;&amp; appear[u][cur].first &gt;= t.first) </span><br><span class="line">            insert(RT[u], <span class="number">1</span>, n, appear[u][cur].second), cur++;</span><br><span class="line">        ans[t.second] = query(RT[u], <span class="number">1</span>, n, L[t.second], R[t.second]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; appear[u].size()) </span><br><span class="line">        insert(RT[u], <span class="number">1</span>, n, appear[u][cur].second), cur++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> zjk[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>); <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        zjk[i] = insert(s[i]);</span><br><span class="line">    <span class="keyword">int</span> m; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m), ::n = m + <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        last = <span class="number">0</span>, <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>), n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            appear[insert(s[j])].push_back(P(j, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ncnt; i &gt;= <span class="number">1</span>; i--) adde(link[i], i);</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r; <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;L[i], &amp;R[i], &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">int</span> p = jump(zjk[r], r - l + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//        cout &lt;&lt; "at: " &lt;&lt; p &lt;&lt; endl;</span></span><br><span class="line">        q[p].push_back(P(r - l + <span class="number">1</span>, i));</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i].val == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, L[i], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, ans[i].pos, ans[i].val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 后缀自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC031E Snuke the Phantom Thief</title>
      <link href="/2020/07/07/AGC031E-Snuke-the-Phantom-Thief/"/>
      <url>/2020/07/07/AGC031E-Snuke-the-Phantom-Thief/</url>
      
        <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>在二维平面上$n$个点，第$i$个点的坐标为$(x_i,y_i)$，权值为$v_i$。</p><p>你要从这$n$个点中选择若干个点，但必须满足$m$个限制</p><p>每个限制有如下四种：</p><ul><li>横坐标小于等于$a_i$的点最多选$b_i$个</li><li>横坐标大于等于$a_i$的点最多选$b_i$个</li><li>纵坐标小于等于$a_i$的点最多选$b_i$个</li><li>纵坐标大于等于$a_i$的点最多选$b_i$个</li></ul><p>问最大价值和。</p><script type="math/tex; mode=display">n\leq 80, m\leq 320</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>一开始想暴力线性规划搞过去，<code>WA</code>了一发之后才发现这道题单纯型求出来的可能是小数…</p><p>直接建图很困难，考虑枚举最终选了多少个点，假设有$k$个。我们将选择的点按照$x$坐标从小到大排序，那么对于“横坐标小于等于$a_i$的点最多选$b_i$个”这一限制就可以转化为排在第$b_i+1$以及之后的点的横坐标必须大于$a_i$。</p><p>这$m$个限制都可以像这样转化为每个点$x$坐标的范围，那么问题就转化为：选择$k$个点，其中第$i$个点的$x$坐标必须在一定范围之内，问最大价值之和。</p><p>同时考虑$y$坐标的限制，可以得出如下的建图方法：</p><p>左边建$k$个点，分别代表$x$坐标的限制，源点向这些点连容量为$1$，费用为$0$的边。</p><p>$k$个点连向中间的$n$个点的入点，每个点只连向$x$坐标在其范围内的点，容量为$1$，费用为$0$。</p><p>中间$n$个点的入点连向其对应的出点，容量为$1$，费用为这个点的权值。流就代表选这个点。</p><p>中间$n$个点的出点连向右边的$k$个点，同样，右边的每个点只连向$y$坐标在其范围内的点。</p><p>右边的$k$个点向汇点连容量为$1$，费用为$0$的边。</p><p>如果跑出来的最小费用流的流量恰好为$k$，那么可以更新答案。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">410</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w; LL c;</span><br><span class="line">&#125; e[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt = <span class="number">1</span>, vis[N], cur[N]; LL dis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> f, LL c)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from], f, c&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to], <span class="number">0</span>, -c&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis)), <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis)), dis[t] = <span class="number">0</span>, vis[t] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q; q.push_back(t);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop_front(), vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">            <span class="keyword">if</span> (e[i ^ <span class="number">1</span>].w &amp;&amp; dis[e[i].to] &gt; dis[u] - e[i].c) &#123;</span><br><span class="line">                dis[e[i].to] = dis[u] - e[i].c;</span><br><span class="line">                <span class="keyword">if</span> (!vis[e[i].to]) &#123;</span><br><span class="line">                    vis[e[i].to] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!q.empty() &amp;&amp; dis[e[i].to] &lt; dis[q.front()]) q.push_front(e[i].to);</span><br><span class="line">                    <span class="keyword">else</span> q.push_back(e[i].to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[s] &lt; <span class="number">1e17</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL MCMF;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>; <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (u == t || !f) <span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u], tmp; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to] &amp;&amp; e[i].w &amp;&amp; dis[u] - e[i].c == dis[e[i].to] &amp;&amp; (tmp = DFS(e[i].to, min(f, e[i].w), t))) &#123;</span><br><span class="line">            f -= tmp, res += tmp, e[i].w -= tmp, e[i ^ <span class="number">1</span>].w += tmp, MCMF += (LL)tmp * e[i].c;</span><br><span class="line">            <span class="keyword">if</span> (!f) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    MCMF = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (SPFA(s, t)) <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span>(head)), f += DFS(s, <span class="number">1e9</span>, t);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[N], y[N]; <span class="keyword">char</span> s[N][<span class="number">5</span>]; <span class="keyword">int</span> a[N], b[N]; LL c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>, &amp;x[i], &amp;y[i], &amp;c[i]);</span><br><span class="line">    <span class="keyword">int</span> m; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>, s[i] + <span class="number">1</span>, &amp;a[i], &amp;b[i]);</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head)), ecnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> xl[N], xr[N], yl[N], yr[N]; </span><br><span class="line">        <span class="built_in">memset</span>(xl, <span class="number">0</span>, <span class="keyword">sizeof</span>(xl)), <span class="built_in">memset</span>(yl, <span class="number">0</span>, <span class="keyword">sizeof</span>(yl)), <span class="built_in">memset</span>(xr, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(xr)), <span class="built_in">memset</span>(yr, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(yr));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="keyword">if</span> (b[j] &lt; i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j][<span class="number">1</span>] == <span class="string">'L'</span>) <span class="keyword">for</span> (<span class="keyword">int</span> k = b[j] + <span class="number">1</span>; k &lt;= i; k++) xl[k] = max(xl[k], a[j] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (s[j][<span class="number">1</span>] == <span class="string">'R'</span>) <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= i - b[j]; k++) xr[k] = min(xr[k], a[j] - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (s[j][<span class="number">1</span>] == <span class="string">'D'</span>) <span class="keyword">for</span> (<span class="keyword">int</span> k = b[j] + <span class="number">1</span>; k &lt;= i; k++) yl[k] = max(yl[k], a[j] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (s[j][<span class="number">1</span>] == <span class="string">'U'</span>) <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= i - b[j]; k++) yr[k] = min(yr[k], a[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">2</span> * n + <span class="number">2</span> * i + <span class="number">1</span>, t = s + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) adde(s, j, <span class="number">1</span>, <span class="number">0</span>), adde(j + i + <span class="number">2</span> * n, t, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) adde(i + j, i + j + n, <span class="number">1</span>, -c[j]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) <span class="keyword">if</span> (xl[j] &lt;= x[k] &amp;&amp; x[k] &lt;= xr[j]) adde(j, k + i, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) <span class="keyword">if</span> (yl[j] &lt;= y[k] &amp;&amp; y[k] &lt;= yr[j]) adde(k + i + n, j + i + <span class="number">2</span> * n, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (Dinic(s, t) == i) res = max(res, -MCMF);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC026E Synchronized Subsequence</title>
      <link href="/2020/07/07/AGC026E-Synchronized-Subsequence/"/>
      <url>/2020/07/07/AGC026E-Synchronized-Subsequence/</url>
      
        <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>有一个长度为$2n$的$ab$串，其中$a,b$都各出现了$n$次。</p><p>你需要保留一些字符，将剩下的字符删掉。对于一个$i$，你可以同时保留从左往右数的第$i$个$a$和第$i$个$b$。你需要使得最终的串的字典序尽量大。</p><script type="math/tex; mode=display">n\leq 3\times 10^3</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>将$a,b$分为若干对，记$dp[i]$表示只考虑后$i$对$a,b$构成的串时，保留若干对$ab$能得到的字典序最大的串。</p><p>记$a_i,b_i$分别表示第$i$个$a$的下标以及第$i$个$b$的下标，接下来我们分三种情况讨论</p><ul><li><p>不保留这一对$a,b$，那么$dp[i]=dp[i+1]$</p></li><li><p>$a_i&lt;b_i$，如果仅考虑后$i$对$a,b$的话，在这一对$ab$之间的字符全是$a$，为了让字典序尽量大，这些$a$都不能保留。记$j$为最后一对出现位置在$b_i$之后的$a,b$，那么有$dp[i]=ab+dp[j]$</p></li><li>$a_i&gt;b_i$，在这一对$ab$之间的字符全是$b$，都应该保留。需要注意的是，此时有可能会产生连锁反应。举个例子</li></ul><p><img src="image-20200707112514935.png" alt="image-20200707112514935"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6010</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> dp[N]; <span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], b[N], bel[N], mark[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d%s"</span>, &amp;n, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, ct1 = <span class="number">0</span>, ct2 = <span class="number">0</span>; i &lt;= n * <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'a'</span>) a[++ct1] = i, bel[i] = ct1;</span><br><span class="line">        <span class="keyword">else</span> b[++ct2] = i, bel[i] = ct2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        dp[i] = dp[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (b[i] &gt; a[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (pos &lt;= n &amp;&amp; min(a[pos], b[pos]) &lt;= b[i]) pos++;</span><br><span class="line">            dp[i] = max(dp[i], <span class="string">"ab"</span> + dp[pos]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> r = a[i]; <span class="built_in">string</span> tmp; <span class="built_in">memset</span>(mark, <span class="number">0</span>, <span class="keyword">sizeof</span>(mark));</span><br><span class="line">            mark[b[i]] = mark[r] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = b[i] + <span class="number">1</span>; j &lt; r; j++) <span class="keyword">if</span> (s[j] == <span class="string">'b'</span>) </span><br><span class="line">                r = max(r, a[bel[j]]), mark[j] = mark[a[bel[j]]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = b[i]; j &lt;= n * <span class="number">2</span>; j++) <span class="keyword">if</span> (mark[j]) tmp += s[j];</span><br><span class="line">            <span class="keyword">int</span> pos = bel[r] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (pos &lt;= n &amp;&amp; min(a[pos], b[pos]) &lt;= r) pos++;</span><br><span class="line">            dp[i] = max(dp[i], tmp + dp[pos]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC022D Shopping</title>
      <link href="/2020/07/07/AGC022D-Shopping/"/>
      <url>/2020/07/07/AGC022D-Shopping/</url>
      
        <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>有$n$个商场，第$i$个商场的坐标为$x_i$，你需要在这个商场花费连续的$t_i$时间购物。现在有一辆或者会在$0$到$L$处不停地往返，行驶一单位距离要花费一单位时间。你在$0$时刻从$0$处上车，问最少花费多少时间能在每一个商场购物且最终返回$0$处。</p><script type="math/tex; mode=display">n\leq 3\times 10^5, 0<x<L\leq 10^9</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>将每个$t_i$对$2L$取模，同时将$\lfloor\frac{t_i}{2L}\rfloor\times 2L$累加进答案，此时$t_i&lt;2L$。</p><p>首先显然有这样的一种方案：将所有商场按照坐标从小到大排序之后重新分配编号，从$0$出发，到达第一个商场，下车购物，在列车到$2L$且从$2L$返回$0$之后第三次经过此商场时上车。由于$t_i&lt;2L$，因此此时一定可以上车，接着到第二个商场购物，以此类推。</p><p>如果第$n$个商场需要的购物时间满足$t_n\leq 2(L-x_n)$，这意味着当列车到达$L$，返回时经过$n$号商场时可以上车，没有必要专门花两个周期再跑一次。</p><p>因此我们知道，答案的上界为$(n+1)\times 2L-[t_n\leq 2(L-x_n)]\times 2L$。</p><p>考虑进一步缩小这个上界。</p><p>我们将前$n-1$个商场分为四类</p><ul><li>$t_i\leq 2x_i$，即当列车从右往左开过来时，下车购物之后能够在列车返回时搭上列车。</li><li>$t_i\leq 2(L-x_i)$，即当列车从左往右开过来时，下车购物之后能够在列车返回时搭上列车。</li><li>同时满足上面两个条件。</li><li>上面两个条件都不满足。</li></ul><p>我们将前三种情况称为$A,B,C$类。</p><p>可以发现，所有的$A$类商场一定有$x_i&gt;\frac{L}{2}$，所有的$B$类商场一定有$x_i&lt;\frac{L}{2}$，因此，可能的优化只有如下三种情况：</p><ul><li>列车从右往左开，在第一次路过$C$类商场时不下车，接着路过一个$A$类商场，下车购物。当列车到达$0$之后返回时搭上列车，接着到达$C$类商场，下车购物，在列车从$L$返回时搭上列车。我们将这种情况称为$A,C$间的一次匹配。</li><li>列车从左往右开，在第一次路过$C$类商场时不下车，接着路过一个$B$类商场，下车购物。当列车到达$L$之后返回时搭上列车，接着到达$C$类商场，下车购物，在列车从$0$返回时搭上列车。我们将这种情况称为$B,C$间的一次匹配。</li><li>两个$C$匹配。</li></ul><p>匹配结束之后，将前两种匹配按照$A$或$B$的坐标从小到大排序之后依次执行即可，最后再执行所有的第三类匹配。</p><p>可以发现，每匹配上一组，都会使得答案减去$2L$。</p><p>最后需要注意的是可能出现$t_i=0$的情况，此时需要特判，因为到达这个商场之后可以立即上车，不需要再等$2L$时刻。</p><p>代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; A, B, C; <span class="keyword">int</span> X[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, L; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;L); LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;X[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = X[i], t; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t), res += t / (<span class="number">2</span> * L) * (<span class="number">2</span> * L), t %= <span class="number">2</span> * L;</span><br><span class="line">        <span class="keyword">int</span> t1 = x * <span class="number">2</span> &gt;= t, t2 = (L - x) * <span class="number">2</span> &gt;= t;</span><br><span class="line">        <span class="keyword">if</span> ((i == n &amp;&amp; t2) || !t) &#123; res -= <span class="number">2</span> * L; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (t1 &amp;&amp; t2) C.insert(x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t1) A.insert(-x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t2) B.insert(x);</span><br><span class="line">    &#125;</span><br><span class="line">    res += (LL)(n + <span class="number">1</span>) * <span class="number">2</span> * L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : B) <span class="keyword">if</span> (C.size() &amp;&amp; *C.begin() &lt; t) C.erase(C.begin()), res -= <span class="number">2</span> * L;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : A) <span class="keyword">if</span> (C.size() &amp;&amp; *C.rbegin() &gt; -t) C.erase(*C.rbegin()), res -= <span class="number">2</span> * L;</span><br><span class="line">    res -= (LL)(C.size() / <span class="number">2</span>) * <span class="number">2</span> * L;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF708D Incorrect Flow</title>
      <link href="/2020/07/07/CF708D-Incorrect-Flow/"/>
      <url>/2020/07/07/CF708D-Incorrect-Flow/</url>
      
        <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定一张$n$个点$m$条边的网络，源点为$1$，汇点为$n$。对于每条边，容量为$c$，当前流量为$f$。</p><p>这个网络可能是不合法的，可能存在$c&lt;f$，或者流量不守恒的情况，你每次可以选择一条边，将这条边的$c$或$f$加$1$或减$1$，要使得图合法，求最小操作次数。</p><script type="math/tex; mode=display">n,m\leq 100, c,f\leq 10^6</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>正解似乎是有源汇上下界最小费用流…其实有一个暴力的线性规划做法，跑得还比正解快</p><p>对于每条边我们开三个变量$a_i,b_i,t_i$，表示让这条边的实际流量加上$a_i$，减去$b_i$，让这条边的容量加上$t_i$</p><p>显然我们应最小化的是$\sum a_i+b_i+t_i$，其实也就是最大化$-\sum a_i+b_i+t_i$。</p><p>对于每条边，它的流量不能超过容量，因此</p><script type="math/tex; mode=display">\begin{aligned}f_i+a_i-b_i&\leq c_i+t_i\\f_i+a_i-b_i&\geq 0\end{aligned}</script><p>同时，除去源点、汇点以外的每个点应满足流量守恒</p><script type="math/tex; mode=display">\sum_{i\rightarrow u}f_i+a_i-b_i=\sum_{u\rightarrow j}f_j+a_j-b_j</script><p>将等号拆成一个小于等于、一个大于等于即可</p><p>最后是一个需要初始化的线性规划</p><p>由于最优方案中，每条边的实际流量和容量上界一定是正整数，因此可以保证线性规划的正确性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> s[N][N], c[N]; <span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pivot</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> tmp = s[y][x]; s[y][x] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) s[y][i] /= -tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">if</span> (i != y) &#123;</span><br><span class="line">        tmp = s[i][x], s[i][x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (-eps &lt;= tmp &amp;&amp; tmp &lt;= eps) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n + <span class="number">1</span>; j++) s[i][j] += s[y][j] * tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = c[x], c[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n + <span class="number">1</span>; j++) c[j] += s[y][j] * tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">LP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pos = <span class="number">0</span>, cur = <span class="number">0</span>; ; pivot(pos, cur), pos = cur = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (c[i] &gt; eps) pos = i;</span><br><span class="line">        <span class="keyword">if</span> (!pos) <span class="keyword">return</span> c[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">double</span> mn = <span class="number">1e100</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">if</span> (s[i][pos] &lt; -eps) &#123;</span><br><span class="line">            <span class="keyword">double</span> t = s[i][n + <span class="number">1</span>] / -s[i][pos];</span><br><span class="line">            <span class="keyword">if</span> (t &lt; mn) mn = t, cur = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!cur) <span class="keyword">return</span> <span class="number">1e100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">233</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">if</span> (s[i][n + <span class="number">1</span>] &lt; -eps &amp;&amp; (!r || rand() &amp; <span class="number">1</span>)) r = i;</span><br><span class="line">        <span class="keyword">if</span> (!r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (s[r][i] &gt; eps &amp;&amp; (!c || rand() &amp; <span class="number">1</span>)) c = i;</span><br><span class="line">        <span class="keyword">if</span> (!c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pivot(c, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> from[N], to[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, tp = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, c; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;from[i], &amp;to[i], &amp;c, &amp;f[i]);</span><br><span class="line">        tp++, s[tp][<span class="number">3</span> * m + <span class="number">1</span>] = c - f[i], s[tp][i] = <span class="number">-1</span>, s[tp][i + m] = <span class="number">1</span>, s[tp][i + m * <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        tp++, s[tp][<span class="number">3</span> * m + <span class="number">1</span>] = f[i], s[tp][i + m] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span> * m; i++) c[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) </span><br><span class="line">            <span class="keyword">if</span> (to[j] == i) tot -= f[j], s[tp + <span class="number">1</span>][j]--, s[tp + <span class="number">1</span>][j + m]++, s[tp + <span class="number">2</span>][j]++, s[tp + <span class="number">2</span>][j + m]--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (from[j] == i) </span><br><span class="line">                tot += f[j], s[tp + <span class="number">1</span>][j]++, s[tp + <span class="number">1</span>][j + m]--, s[tp + <span class="number">2</span>][j]--, s[tp + <span class="number">2</span>][j + m]++;</span><br><span class="line">        s[tp + <span class="number">1</span>][<span class="number">3</span> * m + <span class="number">1</span>] = tot, s[tp + <span class="number">2</span>][<span class="number">3</span> * m + <span class="number">1</span>] = -tot, tp += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ::m = tp, ::n = <span class="number">3</span> * m, assert(init());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">int</span>)(-LP() + <span class="number">0.5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 线性规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF526G Spiders Evil Plan</title>
      <link href="/2020/07/07/CF526G-Spiders-Evil-Plan/"/>
      <url>/2020/07/07/CF526G-Spiders-Evil-Plan/</url>
      
        <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定一棵$n$个点的树，每条边有一个正的边权。有$q$次询问，每次询问给出$x,y$，你需要选择$y$条不交的树上路径，使得这些路径形成一个包含$x$的连通块，同时连通块内的边权之和要尽量大。强制在线。</p><script type="math/tex; mode=display">n,q\leq 10^5</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>一棵有$2y$个叶子的树可以被$y$条路径完全覆盖，因此我们可以看作选择$2y$个叶子，使得$x$与这$2y$个叶子构成的虚树大小尽量大。</p><p>如果只有一组询问，我们可以将$x$提做根，然后套用<a href="https://darkbzoj.tk/problem/3252" target="_blank" rel="noopener">BZOJ3252 攻略</a>的做法。将整棵树长链剖分，然后选择$2y$次，每次选取一条没有被选过的最长链即可。</p><p>可以发现，第一次选择的叶子必然是直径的某个端点，因此我们可以将直径的两个端点分别尝试作为根，问题转化为寻找$2y-1$个叶子，满足$x$在这些叶子与此端点的虚树上，同时要求虚树大小尽量大。</p><p>如果选出的这$2y-1$条链包含$x$，那么显然此时是最优的。</p><p>否则有两种情况，第一种是强制加上$x$所在的这一条链，同时删去权值最小的一条链；第二种是将$x$往上碰到的第一条选择过的链强行扳过来。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from], w &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to], w &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WEN</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N][<span class="number">18</span>], len[N], son[N], dis[N], top[N], val[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = f, dis[u] = dis[f] + w, val[u] = w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">17</span>; i++) fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) &#123;</span><br><span class="line">            dfs(e[i].to, u, e[i].w);</span><br><span class="line">            <span class="keyword">if</span> (len[e[i].to] &gt; len[u]) </span><br><span class="line">                son[u] = e[i].to, len[u] = len[son[u]];</span><br><span class="line">        &#125;</span><br><span class="line">    len[u] += w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; "dfs1: " &lt;&lt; u &lt;&lt; ' ' &lt;&lt; f &lt;&lt; ' ' &lt;&lt; t &lt;&lt; endl;</span></span><br><span class="line">    top[u] = t;</span><br><span class="line">    <span class="keyword">if</span> (son[u]) dfs1(son[u], u, t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f &amp;&amp; e[i].to != son[u]) dfs1(e[i].to, u, e[i].to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rk[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> lim)</span> </span>&#123; <span class="comment">// rk[top[v]] &lt;= lim</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (rk[top[fa[u][i]]] &gt; lim) u = fa[u][i];</span><br><span class="line">    <span class="keyword">return</span> rk[top[u]] &lt;= lim ? u : fa[u][<span class="number">0</span>]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id[N], sum[N], ct;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    dfs(rt, <span class="number">0</span>, <span class="number">0</span>), dfs1(rt, <span class="number">0</span>, rt), ct = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (top[i] == i) id[++ct] = i;</span><br><span class="line">    sort(id + <span class="number">1</span>, id + ct + <span class="number">1</span>, [&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> len[a] &gt; len[b];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ct; i++) </span><br><span class="line">        rk[id[i]] = i, sum[i] = sum[i - <span class="number">1</span>] + len[id[i]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = min(ct, <span class="number">2</span> * y - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (rk[top[x]] &lt;= t) <span class="keyword">return</span> sum[t];</span><br><span class="line">    <span class="keyword">int</span> F = fa[top[x]][<span class="number">0</span>], T = jump(F, t - <span class="number">1</span>), T1 = jump(F, t);</span><br><span class="line">    <span class="keyword">int</span> a = sum[t - <span class="number">1</span>] + len[top[x]] + dis[F] - dis[T];</span><br><span class="line">    <span class="keyword">int</span> b = sum[t] + dis[F] - dis[T1] - len[T1] + val[T1] + len[top[x]];</span><br><span class="line">    <span class="comment">// cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> max(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; A, B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mx, p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d &gt; mx) mx = d, p = u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u, d + e[i].w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b, c; i &lt; n; i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c), adde(a, b, c);</span><br><span class="line">    <span class="keyword">int</span> rt1, rt2;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), rt1 = p, mx = <span class="number">0</span>, dfs(rt1, <span class="number">0</span>, <span class="number">0</span>), rt2 = p;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; rt1 &lt;&lt; ' ' &lt;&lt; rt2 &lt;&lt; endl;</span></span><br><span class="line">    A.pre(rt1), B.pre(rt2);</span><br><span class="line">    <span class="keyword">int</span> lastans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        x = (x + lastans - <span class="number">1</span>) % n + <span class="number">1</span>, y = (y + lastans - <span class="number">1</span>) % n + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lastans = max(A.solve(x, y), B.solve(x, y)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 长链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF566C Logistical Questions</title>
      <link href="/2020/07/07/CF566C-Logistical-Questions/"/>
      <url>/2020/07/07/CF566C-Logistical-Questions/</url>
      
        <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给出一棵$n$个节点的数，点有点权，边有边权。两点间的距离定义为两点间边权之和的$\frac 32$次方，求加权重心。</p><script type="math/tex; mode=display">n\leq 2\times 10^5</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>单独考虑每个点对重心的贡献，可以发现这是一个下凸函数。将所有点的贡献叠加起来之和仍然是一个下凸函数，因此只有一个重心，从这个重心向外距离的加权和逐渐扩大。</p><p>考虑点分治，枚举到点$u$时，计算以$u$为重心时的答案。接着考虑求导，即求出将$u$往每棵子树移动一个极小的距离$\Delta$时答案的变化量，找到变化量为正的那颗子树递归下去即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from], w &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to], w &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sz[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getsz</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    sz[u] = vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to]) sz[u] += Getsz(e[i].to);</span><br><span class="line">    <span class="keyword">return</span> vis[u] = <span class="number">0</span>, sz[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getrt</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tot)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], tmp; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to] &amp;&amp; (tmp = Getrt(e[i].to, tot)))</span><br><span class="line">            <span class="keyword">return</span> vis[u] = <span class="number">0</span>, tmp;</span><br><span class="line">    <span class="keyword">return</span> vis[u] = <span class="number">0</span>, sz[u] &gt;= (tot &gt;&gt; <span class="number">1</span>) ? u : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> sum[N], res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> val[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> t, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    sum[t] += <span class="number">1.5</span> * <span class="built_in">sqrt</span>(d) * val[u], res += <span class="built_in">pow</span>(d, <span class="number">1.5</span>) * val[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u, t, d + e[i].w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> ans = <span class="number">1e20</span>; <span class="keyword">int</span> pos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Divide</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    u = Getrt(u, Getsz(u));</span><br><span class="line">    <span class="keyword">if</span> (vis[u] == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    vis[u] = <span class="number">1</span>; <span class="keyword">double</span> tot = <span class="number">0</span>; res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next) </span><br><span class="line">        sum[e[i].to] = <span class="number">0</span>, dfs(e[i].to, u, e[i].to, e[i].w), tot += sum[e[i].to];</span><br><span class="line">    <span class="keyword">if</span> (res &lt; ans) ans = res, pos = u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to] &amp;&amp; tot - <span class="number">2</span> * sum[e[i].to] &lt;= <span class="number">0</span>)</span><br><span class="line">            Divide(e[i].to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b, c; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c), adde(a, b, c);</span><br><span class="line">    Divide(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %.7lf\n"</span>, pos, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 点分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF538H Summer Dichotomy</title>
      <link href="/2020/07/07/CF538H-Summer-Dichotomy/"/>
      <url>/2020/07/07/CF538H-Summer-Dichotomy/</url>
      
        <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>你需要将至少$t$名、至多$T$名学生分为两组，有$n$名老师，每名老师要被分配到两个小组之一。对于第$i$名老师，要求所在的小组中的学生人数在$[l_i,r_i]$之间。</p><p>此外，有$m$对老师不能在同一个小组中。要求构造方案，或判断无解。</p><script type="math/tex; mode=display">t\leq T\leq 10^9,n,m\leq 10^5</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先有如下结论：最优策略是，取第一组的人数$x$为所有老师$r_i$的最小值，取第二组的人数$y$为所有老师$l_i$的最大值。如果$x+y<t$则增加$y$，如果$x+y>T$则减小$x$。</p><p>先忽略不能在同一个小组中的限制，如果对于任意两名老师，他们的$[l,r]$的交都不为空，那么这种构造方法显然是正确的。</p><p>否则，有$x&lt;y$。我们拿掉$x,y$对应的那两个区间，对于剩下的每个区间来说，它要么与第一个区间有交，要么与第二个区间有交，否则一定无解。</p><p>如果它与第一个区间，也就是$x$所在的区间有交，那么必然有$r_j\geq r_i$，即$x$必然在这个区间内；如果它与第二个区间有交，那么$y$必然在这个区间内。</p><p>确定了两组学生的人数之后就很简单了，将所有老师的限制看作是一张二分图，对于每个连通块我们可以处理出黑点和白点对人数的限制，然后尝试是将黑点放入第一组还是将白点放入第一组即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from] &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to] &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l1, r1, l2, r2, col[N], l[N], r[N], vis[N], rt, type[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FUCK</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"IMPOSSIBLE"</span>), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    vis[u] = rt;</span><br><span class="line">    <span class="keyword">if</span> (col[u] == <span class="number">1</span>) l1 = max(l1, l[u]), r1 = min(r1, r[u]);</span><br><span class="line">    <span class="keyword">else</span> l2 = max(l2, l[u]), r2 = min(r2, r[u]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (col[e[i].to]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (col[e[i].to] == col[u]) FUCK();</span><br><span class="line">        &#125; <span class="keyword">else</span> col[e[i].to] = <span class="number">3</span> - col[u], dfs(e[i].to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L, R; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R);</span><br><span class="line">    <span class="keyword">int</span> n, m, a = <span class="number">0</span>, b = <span class="number">1e9</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l[i], &amp;r[i]), a = max(a, l[i]), b = min(b, r[i]);</span><br><span class="line">    <span class="keyword">if</span> (a + b &lt; L) a = L - b;</span><br><span class="line">    <span class="keyword">if</span> (a + b &gt; R) b = R - a;</span><br><span class="line">    <span class="keyword">if</span> (a + b &lt; L || a + b &gt; R || a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span>) FUCK();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (!col[i]) &#123;</span><br><span class="line">        l1 = <span class="number">0</span>, r1 = <span class="number">1e9</span>, l2 = <span class="number">0</span>, r2 = <span class="number">1e9</span>, col[i] = <span class="number">1</span>, rt = i, dfs(i);</span><br><span class="line">        <span class="keyword">if</span> (l1 &lt;= a &amp;&amp; a &lt;= r1 &amp;&amp; l2 &lt;= b &amp;&amp; b &lt;= r2) type[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l2 &lt;= a &amp;&amp; a &lt;= r2 &amp;&amp; l1 &lt;= b &amp;&amp; b &lt;= r1) type[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> FUCK();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"POSSIBLE"</span>); <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">putchar</span>(<span class="string">'1'</span> + (type[vis[i]] ^ (col[i] - <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF639E Bear and Paradox</title>
      <link href="/2020/07/07/CF639E-Bear-and-Paradox/"/>
      <url>/2020/07/07/CF639E-Bear-and-Paradox/</url>
      
        <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>有$n$个问题，第$i$个问题的初始得分为$p_i$，需要花费的时间为$t_i$。</p><p>设$T=\sum t_i$，你可以任意安排完成每个问题的顺序，如果在时刻$x$完成了问题$i$，可以得到$p_i\times (1-\frac{cx}{T})$的得分，其中$c$是一个$[0,1]$的实数。</p><p>可以看出，对于任意一个$c$，都存在至少一个可以使得分数最大的最佳做题顺序。</p><p>你需要求出最大的$c$，使得它对应的任意最佳做题顺序都不存在$i,j$满足$p_i&lt;p_j$，但$i$的得分严格大于$j$的得分。</p><script type="math/tex; mode=display">n\leq 1.5\times 10^5, p_t, t_i\leq 10^8</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>考虑相邻的两个位置$i,j$，这两个位置原来对答案的贡献为</p><script type="math/tex; mode=display">p_i\times(1-\frac{cx}{T})+p_j\times(1-\frac{cx+ct_i}{T})</script><p>如果交换这两个位置，贡献变为</p><script type="math/tex; mode=display">p_i\times(1-\frac{cx+ct_j}{T})+p_j\times(1-\frac{cx}{T})</script><p>贡献的变化量为</p><script type="math/tex; mode=display">p_j\times \frac{ct_i}{T}-p_i\times\frac{ct_j}{T}</script><p>可以发现，相邻两个位置的优劣与$c$的取值没有关系，因此我们可以直接将所有问题按照$\frac{p_i}{t_i}$从大到小排序，此时的方案就是一种最佳做题顺序。</p><p>排完序之后，我们可以求出每个问题的最早完成时间以及最晚完成时间。即如果有多个问题的$\frac{p_i}{t_i}$相同，那么这些问题是可以随便排列的。</p><p>二分$c$，判断是否存在$p_j&lt;p_i$，使得$i$最晚完成时间的得分小于$j$最早完成时间的得分即可。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">150010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WEN</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p, t; LL l, r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> WEN &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)p * b.t &gt; (LL)b.p * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; wkr[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n; LL tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> mx = <span class="number">0</span>, nw = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (wkr[i].p != wkr[i - <span class="number">1</span>].p) mx = nw;</span><br><span class="line">        <span class="keyword">if</span> (wkr[i].p * (<span class="number">1</span> - mid * wkr[i].r / tot) &lt; mx) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        nw = max(nw, wkr[i].p * (<span class="number">1</span> - mid * wkr[i].l / tot));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;wkr[i].p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;wkr[i].t), tot += wkr[i].t;</span><br><span class="line">    sort(wkr + <span class="number">1</span>, wkr + n + <span class="number">1</span>); LL s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i; LL sum = wkr[i].t;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; (LL)wkr[i].p * wkr[j + <span class="number">1</span>].t == (LL)wkr[j + <span class="number">1</span>].p * wkr[i].t) j++, sum += wkr[j].t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; k++) </span><br><span class="line">            wkr[k].l = s + wkr[k].t, wkr[k].r = s + sum;</span><br><span class="line">        s += sum, i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(wkr + <span class="number">1</span>, wkr + n + <span class="number">1</span>, [](WEN a, WEN b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.p &lt; b.p;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.7lf\n"</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF516E Drazil and His Happy Friends</title>
      <link href="/2020/07/06/CF516E-Drazil-and-His-Happy-Friends/"/>
      <url>/2020/07/06/CF516E-Drazil-and-His-Happy-Friends/</url>
      
        <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>有$n$个男生和$m$个女生，编号分别为$0\sim n-1$和$0\sim m-1$。</p><p>有$b$个男生和$g$个女生是快乐的，在第$i$天，编号为$i\bmod n$的男生和编号为$i\bmod m$的女生会一起玩。如果这两个人之中至少有一个人快乐，那么另一个人也会跟着变快乐。</p><p>求至少需要多少天才能使得所有人都变快乐，或者判断不可能。</p><script type="math/tex; mode=display">n, m\leq 10^9, b,g\leq 10^5</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>记$g=\gcd(n,m)$，可以发现，每天只有编号模$g$同余的人才有可能一起玩。因此，我们可以将这$n+m$个人分为$g$个环，每个环上有$\frac ng$个男生，$\frac mg$个女生。</p><p>由于$\frac ng\bot\frac mg$，我们不妨令$n=\frac ng,m=\frac mg$，那么此时$n\bot m$。</p><p>接下来我们只讨论$n\bot m$的情况。</p><p>如果第$k$名男生在第$i$天让第$j$名女生变快乐了，那么我们可以知道，第$(j+n)\bmod m$名女生变快乐的时间一定是$i+n$。</p><p>假设最后一个变快乐的女生$i$是由第$k$名男生变快乐的，那么我们可以断言，第$(i-n)\bmod m$名女生一定也是由第$k$名男生变快乐的，否则最后一个变快乐的女生变快乐的时间可以提前。</p><p>换句话来说，如果第$j$名女生在第$i$天变快乐了，那么第$(j+n)\bmod m$名女生变快乐的时间一定是$i+n$。</p><p>因此，我们可以将男生和女生分开考虑。对于每个人来说，有三种情况：（以女生为例）</p><ul><li>这个人一开始就是快乐的</li><li>这个人一开始不快乐，但是同编号的男生快乐</li><li>这个人一开始不快乐，且同编号的男生一开始也不快乐。</li></ul><p>建立源点$s$，从$s$向第一类和第二类人连边，权值为这个人的编号。同时，对于任意的$i$，从$i$向$(i+n)\bmod m$连边，边权为$n$。</p><p>对于第一类女生来说，她变快乐的时刻为$0$。对于第二类和第三类女生来说，她变快乐的时刻为从$s$到对应点的最短路长度。</p><p>但是这样建图会产生$O(n)$个点，而$n$是$10^9$级别的数，考虑优化。</p><p>考虑$i,(i+n)\bmod m$这两个人。如果这两个人都是第三类人，那么当$(i+n)\bmod m$变快乐时，$i$一定也变快乐了，因为$(i+n)\bmod m$这个人的快乐是由$i$传递过来的。</p><p>我们只关心最长的最短路长度，那么第$i$个人的答案一定不会对最终答案产生贡献，我们可以考虑删去$i$号点。</p><p>那么接下来这张图中只剩下了三类点：</p><ul><li>这个人一开始就是快乐的</li><li>这个人一开始不快乐，但是同编号的男生快乐</li><li>这个人一开始不快乐，且同编号的男生也不快乐，但是编号为$(i+n)\bmod m$的人是前两类人。</li></ul><p>可以发现，此时的点数已经降到了$O(n)$级别。</p><p>我们分别记这三类人为$A, B,C$，那么此时有三类边。</p><ul><li>$s$往$A,B$连的边，边权为这个人的编号</li><li>$C$连向对应的$A$或$B$，边权为$n$。</li><li>$A$或$B$连向她下一个传递到的$C$，边权为$x\times n$，这里的$x$是变量，需要靠解同余方程解出来。</li></ul><p>前两种边很好处理，关键是第三类边。</p><p>记编号最小的$A$或$B$类人的编号为$a$，那么对于一个$C$类人$b$，我们可以列出方程</p><script type="math/tex; mode=display">a+xn\equiv b\pmod m</script><p>解出的最小正整数解$x$再乘上$x$就是$a$传递到$b$时需要经过的时刻。</p><p>对于每个$C$类点我们都解出对应的$x$，接着将所有点按照$x$从小到大排序。如果$i,j$两个点在排序之后相邻，那么$j$一定是由$i$传递过来的，我们从$i$向$j$连一条边权为$(x_j-x_i)\times n$的边。注意这里的减是在模$n$下进行的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next; LL w;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, LL w)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from], w &#125;, head[from] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot, vis[N]; LL dis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) dis[i] = <span class="number">2e18</span>, vis[i] = <span class="number">0</span>; dis[s] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;P&gt; q; q.push(P(<span class="number">0</span>, s));</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.top().second; q.pop();</span><br><span class="line">        <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>; vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">            <span class="keyword">if</span> (dis[e[i].to] &gt; dis[u] + e[i].w)</span><br><span class="line">                dis[e[i].to] = dis[u] + e[i].w, q.push(P(-dis[e[i].to], e[i].to));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> b ? gcd(b, a % b) : a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> x = <span class="number">1</span>, y = <span class="number">0</span>, a;</span><br><span class="line">    <span class="keyword">int</span> d = exgcd(b, a % b), t = x; x = y, y = t - a / b * y;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;P&gt; A, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!A.size()) <span class="keyword">return</span> <span class="number">2e18</span>;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s; <span class="built_in">vector</span>&lt;P&gt; p = A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : A) s.insert(t.fir);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : A) &#123;</span><br><span class="line">        <span class="keyword">int</span> tp = ((t.fir - m) % n + n) % n;</span><br><span class="line">        <span class="keyword">if</span> (!s.count(tp)) s.insert(tp), p.push_back(P(tp, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    sort(p.begin(), p.end()), exgcd(m, n), ecnt = <span class="number">0</span>; </span><br><span class="line"><span class="comment">//    for (auto t : p) cout &lt;&lt; "(" &lt;&lt; t.fir &lt;&lt; ", " &lt;&lt; t.sec &lt;&lt; ") ";</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">int</span> st = p.size() + <span class="number">1</span>, all = p.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= st; i++) head[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= all; i++) <span class="keyword">if</span> (p[i - <span class="number">1</span>].sec &lt;= <span class="number">1</span>) adde(st, i, p[i - <span class="number">1</span>].fir);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> id[N], tmp[N]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= all; id[i] = i, i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tx = (LL)x * (p[i - <span class="number">1</span>].fir - p[<span class="number">0</span>].fir) % n;</span><br><span class="line">        <span class="keyword">if</span> (tx &lt; <span class="number">0</span>) tx += n;</span><br><span class="line">        tmp[i] = tx;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(id + <span class="number">1</span>, id + all + <span class="number">1</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> tmp[a] &lt; tmp[b]; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= all; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = tmp[id[i &lt; all ? i + <span class="number">1</span> : <span class="number">1</span>]] - tmp[id[i]];</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t += n;</span><br><span class="line">        adde(id[i], id[i &lt; all ? i + <span class="number">1</span> : <span class="number">1</span>], (LL)t * m);</span><br><span class="line">    &#125;</span><br><span class="line">    ::tot = st, Dijkstra(st); LL res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= all; i++) <span class="keyword">if</span> (p[i - <span class="number">1</span>].sec == <span class="number">0</span> || p[i - <span class="number">1</span>].sec == <span class="number">2</span>) </span><br><span class="line">        res = max(res, dis[i]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s; <span class="built_in">vector</span>&lt;P&gt; L, R;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : A) L.push_back(P(t, <span class="number">1</span>)), s.insert(t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : B) <span class="keyword">if</span> (!s.count(t % n)) s.insert(t % n), L.push_back(P(t % n, <span class="number">0</span>));</span><br><span class="line">    s.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : B) R.push_back(P(t, <span class="number">1</span>)), s.insert(t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : A) <span class="keyword">if</span> (!s.count(t % m)) s.insert(t % m), R.push_back(P(t % m, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> max(solve(L, n, m), solve(R, m, n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; zjk[N], wkr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, t1, t2; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, B; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a; i &lt;= t1; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), A.push_back(a);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a; i &lt;= t2; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), B.push_back(a);</span><br><span class="line">    <span class="keyword">int</span> g = gcd(n, m);</span><br><span class="line">    <span class="keyword">if</span> (g &gt; t1 + t2) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : A) zjk[t % g].push_back(t / g);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : B) wkr[t % g].push_back(t / g);</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g; i++) &#123;</span><br><span class="line">        LL tmp = solve(zjk[i], wkr[i], n / g, m / g);</span><br><span class="line">        <span class="keyword">if</span> (tmp &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (tmp &gt; <span class="number">1e18</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span>;</span><br><span class="line">        res = max(res, tmp * g + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF704C Black Widow</title>
      <link href="/2020/07/06/CF704C-Black-Widow/"/>
      <url>/2020/07/06/CF704C-Black-Widow/</url>
      
        <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定$m$个变量$x_1, x_2,\cdots,x_m$，每个变量的取值要么为$1$，要么为$0$。</p><p>给出$n$个形如$x_i$或者$x_i \,\text{or}\, x_j$的表达式，其中$x_i=\neg x_{-i}$。问有多少种变量的取值，使得最终这$n$个表达式的值异或出来为$1$。</p><p>保证$x_i$和$x_{-i}$的出现次数之和至多为$2$。</p><script type="math/tex; mode=display">n, m\leq 10^5</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>我们将每个变量看作一个点，将每个表达式看作一条边，那么这$m$条边构成了一个$n$个点、可能有重边和自环、每个点度数不超过$2$的图。</p><p>由于每个点的度数不超过$2$，因此这张图中的每个连通块要么是环，要么是一条链。</p><p>我们将每个连通块单独拿出来$dp$。对于链，我们记$dp[i][1/0][1/0]$表示：已经考虑了这条链的前$i$个点，第$i$个点的取值为$1/0$，这$i-1$条边的异或和为$1/0$的方案数。</p><p>对于环，可以枚举第一个点的取值，然后将环断开，做一次与链类似的$dp$即可。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x += y, x -= x &gt;= mod ? mod : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt = <span class="number">1</span>, ind[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rev</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &amp; <span class="number">1</span>) &lt;&lt; <span class="number">1</span> | (x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    ind[from]++, ind[to]++;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from], w &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to], rev(w) &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis[N], type[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>, type[u] = <span class="number">-1</span>, p.push_back(u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next) <span class="keyword">if</span> ((i ^ <span class="number">1</span>) != f) &#123;</span><br><span class="line">        type[u] = e[i].w;</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to]) dfs(e[i].to, i);</span><br><span class="line">        <span class="keyword">if</span> (!f) <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> self[N], dp[N][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, base = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, a, b; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;op, &amp;a);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) self[<span class="built_in">abs</span>(a)] ^= <span class="number">1</span> &lt;&lt; (a &lt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b);</span><br><span class="line">            <span class="keyword">int</span> A = <span class="built_in">abs</span>(a), B = <span class="built_in">abs</span>(b), type = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span>) type ^= <span class="number">1</span>; <span class="keyword">if</span> (b &lt; <span class="number">0</span>) type ^= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (A != B) adde(A, B, type);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (a == b) self[<span class="built_in">abs</span>(a)] ^= <span class="number">1</span> &lt;&lt; (a &lt; <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span> base ^= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> calc = [](<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> w) &#123;</span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (w &amp; <span class="number">1</span>) A ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (w &amp; <span class="number">2</span>) B ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> A | B;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> wkr = [](<span class="keyword">int</span> A, <span class="keyword">int</span> self) &#123;</span><br><span class="line">        <span class="keyword">if</span> (self == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (self == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> self == <span class="number">1</span> ? A : !A;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> DP = [&amp;](<span class="keyword">int</span> n, <span class="keyword">int</span> from = <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = from; i &lt;= n; i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;= <span class="number">1</span>; a++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= <span class="number">1</span>; b++) <span class="keyword">if</span> (dp[i - <span class="number">1</span>][a][b]) </span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt;= <span class="number">1</span>; v++) </span><br><span class="line">                        Inc(dp[i][v][b ^ calc(a, v, i == <span class="number">1</span> ? <span class="number">-1</span>: type[p[i - <span class="number">2</span>]]) ^ wkr(v, self[p[i - <span class="number">1</span>]])], dp[i - <span class="number">1</span>][a][b]);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> res[<span class="number">2</span>] = &#123; <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (ind[i] &lt;= <span class="number">1</span> &amp;&amp; !vis[i]) &#123;</span><br><span class="line">        p.clear(), dfs(i, <span class="number">0</span>); <span class="keyword">int</span> t = p.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= t; j++) <span class="built_in">memset</span>(dp[j], <span class="number">0</span>, <span class="keyword">sizeof</span>(dp[j]));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>, DP(t);</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> tmp[<span class="number">2</span>]; tmp[<span class="number">0</span>] = res[<span class="number">0</span>], tmp[<span class="number">1</span>] = res[<span class="number">1</span>], res[<span class="number">0</span>] = res[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;= <span class="number">1</span>; a++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= <span class="number">1</span>; b++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt;= <span class="number">1</span>; c++) </span><br><span class="line">                    res[b ^ c] = (res[b ^ c] + (LL)dp[t][a][b] * tmp[c]) % mod;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">        p.clear(), dfs(i, <span class="number">0</span>); <span class="keyword">int</span> t = p.size();</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> nw[<span class="number">2</span>]; <span class="built_in">memset</span>(nw, <span class="number">0</span>, <span class="keyword">sizeof</span>(nw));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= t; j++) <span class="built_in">memset</span>(dp[j], <span class="number">0</span>, <span class="keyword">sizeof</span>(dp[j]));</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>][wkr(<span class="number">0</span>, self[p[<span class="number">0</span>]])] = <span class="number">1</span>, DP(t, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;= <span class="number">1</span>; a++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= <span class="number">1</span>; b++) </span><br><span class="line">                Inc(nw[b ^ calc(a, <span class="number">0</span>, type[p[t - <span class="number">1</span>]])], dp[t][a][b]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= t; j++) <span class="built_in">memset</span>(dp[j], <span class="number">0</span>, <span class="keyword">sizeof</span>(dp[j]));</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>][wkr(<span class="number">1</span>, self[p[<span class="number">0</span>]])] = <span class="number">1</span>, DP(t, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;= <span class="number">1</span>; a++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= <span class="number">1</span>; b++) </span><br><span class="line">                Inc(nw[b ^ calc(a, <span class="number">1</span>, type[p[t - <span class="number">1</span>]])], dp[t][a][b]);</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> tmp[<span class="number">2</span>]; tmp[<span class="number">0</span>] = res[<span class="number">0</span>], tmp[<span class="number">1</span>] = res[<span class="number">1</span>], res[<span class="number">0</span>] = res[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;= <span class="number">1</span>; a++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= <span class="number">1</span>; b++)</span><br><span class="line">                res[a ^ b] = (res[a ^ b] + (LL)nw[a] * tmp[b]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res[<span class="number">1</span> ^ base]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.15联测 游走</title>
      <link href="/2020/06/20/6-15%E8%81%94%E6%B5%8B-%E6%B8%B8%E8%B5%B0/"/>
      <url>/2020/06/20/6-15%E8%81%94%E6%B5%8B-%E6%B8%B8%E8%B5%B0/</url>
      
        <content type="html"><![CDATA[<p>由于前两题都比较简单，这里写一下第三题。</p><div class="pdfobject-container" data-target="problem_413.pdf" data-height="500px"></div><p>考虑整个序列的答案如何计算。</p><p>最优策略一定是：在走之前就选定两个位置$l,r$，从某个位置开始随机游走，如果当前位置不是$l$或$r$那么继续随机，否则立即结束游戏。</p><p>假设我们已经选定了$l,r$，考虑计算这个区间中每个位置最后走到$l$的概率。</p><p>设$dp_i$表示从$i$走到$l$的概率，显然有$dp_l=1,dp_r=0$</p><p>对于$(l,r)$中的某个位置$i$，有</p><script type="math/tex; mode=display">\begin{aligned}dp_i&=\frac{dp_{i-1}+dp_{i+1}}{2}\\dp_i-dp_{i-1}&=dp_{i+1}-dp_i\end{aligned}</script><p>也就是说，$dp$是一个等差数列，因此有$dp_i=\frac{r-i}{r-l}$。</p><p>因此对于位置$i$，答案为$a_l\times \frac{r-i}{r-l}+a_r\times \frac{i-l}{r-l}$，可以发现，如果我们认为$l$的高度为$a_l$，$r$的高度为$a_r$，那么这个位置的答案就是$a_l,a_r$连线上被$x=i$截得的高度。</p><p>显然，这个高度的最大值就是所有$a$构成的凸包截得的高度。</p><p>因此对于每个前缀我们用单调栈维护这个前缀构成的凸包，每次加入一个点的时候会删去一部分凸包，然后假如一段新的线段。这条线段之前的答案不变，这条线段之后的答案可以直接计算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line">LL num[N]; <span class="keyword">int</span> stk[N], top, ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    LL x1 = b - a, x2 = c - a, y1 = num[b] - num[a], y2 = num[c] - num[a];</span><br><span class="line">    <span class="keyword">return</span> (LL)x1 * y2 - (LL)y1 * x2 &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)len * (len + <span class="number">1</span>) / <span class="number">2</span> % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;num[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">2</span> &amp;&amp; check(stk[top - <span class="number">1</span>], stk[top], i)) top--;</span><br><span class="line">        <span class="keyword">int</span> l = stk[top], r = i, step = (LL)(num[r] - num[l]) % mod * Pow(r - l, mod - <span class="number">2</span>) % mod;</span><br><span class="line">        ans[i] = (ans[l] + (LL)calc(r - l) * step + (LL)(r - l) * num[l]) % mod;</span><br><span class="line">        ans[i] = (ans[i] + mod) % mod, stk[++top] = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, (LL)ans[i] * Pow(i, mod - <span class="number">2</span>) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 凸包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.17联测</title>
      <link href="/2020/06/20/6-17%E8%81%94%E6%B5%8B/"/>
      <url>/2020/06/20/6-17%E8%81%94%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-qiqi20021026-的-T1"><a href="#T1-qiqi20021026-的-T1" class="headerlink" title="T1 qiqi20021026 的 T1"></a>T1 qiqi20021026 的 T1</h1><div class="pdfobject-container" data-target="problem_424.pdf" data-height="500px"></div><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>将所有串放到<code>trie</code>上，那么如果两个串匹配了，它的价值就是这两个串在<code>trie</code>上$lca$的深度。</p><p>我们换一种考虑方式，对于<code>trie</code>上的每个节点我们计算出它子树中落在第一个区间的串的数量以及落在第二个区间中的串的数量。如果第一种串数量为$a$，第二种串数量为$b$，那么这个点对答案的贡献就是$\min(a,b)$，这样可以保证在最优策略下，匹配的两个串在它们的$lca$及以上的所有点都会有$1$的贡献。</p><p>因此我们可以做到$O(len)$插入/删除一个串，然后上四维莫队。据说复杂度是$O(nq^{3/4})$，反正能过。</p><p>由于插入/删除不是$O(1)$，而是串长，因此莫队分块的时候要根据每个串的长度加权分块。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> trie[N][<span class="number">26</span>], ncnt, fa[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> s[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nw = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = s[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!trie[nw][c]) nw = trie[nw][c] = ++ncnt;</span><br><span class="line">        <span class="keyword">else</span> nw = trie[nw][c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, dep[N], A[N], B[N], pos[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    u = pos[u];</span><br><span class="line">    <span class="keyword">while</span> (u) &#123;</span><br><span class="line">        res -= min(A[u], B[u]);</span><br><span class="line">        type ? A[u]++ : B[u]++;</span><br><span class="line">        res += min(A[u], B[u]);</span><br><span class="line">        u = fa[u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    u = pos[u];</span><br><span class="line">    <span class="keyword">while</span> (u) &#123;</span><br><span class="line">        res -= min(A[u], B[u]);</span><br><span class="line">        type ? A[u]-- : B[u]--;</span><br><span class="line">        res += min(A[u], B[u]);</span><br><span class="line">        u = fa[u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> bel[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcurts</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l1, r1, l2, r2, id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> tcurts &amp;b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bel[l1] != bel[b.l1]) <span class="keyword">return</span> bel[l1] &lt; bel[b.l1];</span><br><span class="line">    <span class="keyword">if</span> (bel[r1] != bel[b.r1]) <span class="keyword">return</span> bel[r1] &lt; bel[b.r1];</span><br><span class="line">    <span class="keyword">if</span> (bel[l2] != bel[b.l2]) <span class="keyword">return</span> bel[l2] &lt; bel[b.l2];</span><br><span class="line">    <span class="keyword">return</span> r2 &lt; b.r2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; q[N * <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len[N], ans[N * <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>); <span class="keyword">int</span> t = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        pos[i] = insert(s, t), len[i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ncnt; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) <span class="keyword">if</span> (trie[i][j]) fa[trie[i][j]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;q[i].l1, &amp;q[i].r1, &amp;q[i].l2, &amp;q[i].r2), q[i].id = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, nw = <span class="number">1</span>; i &lt;= n; i++, nw++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i, sz = len[i]; </span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; sz + len[j + <span class="number">1</span>] &lt;= SZ) j++, sz += len[j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = i; t &lt;= j; t++) bel[t] = nw;</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l1 = <span class="number">1</span>, r1 = <span class="number">0</span>, l2 = <span class="number">1</span>, r2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l1 &gt; q[i].l1) insert(--l1, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (l1 &lt; q[i].l1) del(l1++, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (r1 &lt; q[i].r1) insert(++r1, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (r1 &gt; q[i].r1) del(r1--, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (l2 &gt; q[i].l2) insert(--l2, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (l2 &lt; q[i].l2) del(l2++, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (r2 &lt; q[i].r2) insert(++r2, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (r2 &gt; q[i].r2) del(r2--, <span class="number">0</span>);</span><br><span class="line">        ans[q[i].id] = res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-xuanyiming-的-T2"><a href="#T2-xuanyiming-的-T2" class="headerlink" title="T2 xuanyiming 的 T2"></a>T2 xuanyiming 的 T2</h1><div class="pdfobject-container" data-target="problem_425.pdf" data-height="500px"></div><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>考虑某一张图对答案的贡献，假设这张图里面有$m$个连通块。</p><script type="math/tex; mode=display">m^k=\sum_{i=0}^k\begin{Bmatrix}k\\ i\end{Bmatrix}{m\choose i}i!</script><p>根据套路，我们需要统计从$m$个连通块里面选出$i$个连通块的方案数。</p><p>如果我们钦定有$i$个连通块是树，那么此时的方案数对恰有$m$个连通块是树的方案数的贡献就是${m\choose i}$。</p><p>记$H(x)$为有标号无根树的<code>EGF</code>，$G(x)$为有标号无向图的<code>EGF</code>，那么选出$i$个连通块为树的<code>EGF</code>就是$\frac{H(x)^i}{i!}G(x)$，除以$i!$的原因是连通块之间是无序的。</p><p>因此，当$n,k$固定时，答案为</p><script type="math/tex; mode=display">\sum_{i=0}^k\begin{Bmatrix}k\\ i\end{Bmatrix}H(x)^iG(x)[x^n]</script><p>将询问离线，递推$H(x)^iG(x)$即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += mid) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, w = <span class="number">1</span>, t; j &lt; i + (mid &gt;&gt; <span class="number">1</span>); j++, w = (LL)w * Wn % mod)</span><br><span class="line">                t = (LL)w * a[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!type) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, inv = Pow(len, mod - <span class="number">2</span>); i &lt; len; i++) a[i] = (LL)a[i] * inv % mod; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n[N * <span class="number">2</span>], k[N * <span class="number">2</span>], S[<span class="number">21</span>][<span class="number">21</span>], A[N &lt;&lt; <span class="number">2</span>], B[N &lt;&lt; <span class="number">2</span>], ans[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, mx = <span class="number">0</span>, t = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n[i], &amp;k[i]), t = max(t, n[i]), mx = max(mx, k[i]);</span><br><span class="line">    frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    S[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mx; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            S[i][j] = (S[i - <span class="number">1</span>][j - <span class="number">1</span>] + (LL)S[i - <span class="number">1</span>][j] * j) % mod;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= <span class="number">2</span> * t) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; i++) &#123;</span><br><span class="line">        B[i] = (LL)Pow(<span class="number">2</span>, (LL)i * (i - <span class="number">1</span>) / <span class="number">2</span>) * inv[i] % mod;</span><br><span class="line">        <span class="keyword">if</span> (i) A[i] = i &lt;= <span class="number">2</span> ? <span class="number">1</span> : Pow(i, i - <span class="number">2</span>); A[i] = (LL)A[i] * inv[i] % mod; </span><br><span class="line">    &#125;</span><br><span class="line">    NTT(A, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= mx; l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i++) <span class="keyword">if</span> (k[i] &gt;= l)</span><br><span class="line">            ans[i] = (ans[i] + (LL)S[k[i]][l] * B[n[i]] % mod * frac[n[i]]) % mod;</span><br><span class="line">        NTT(B, len, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) B[i] = (LL)B[i] * A[i] % mod;</span><br><span class="line">        NTT(B, len, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = t + <span class="number">1</span>; i &lt; len; i++) B[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-daklqw-的-T3"><a href="#T3-daklqw-的-T3" class="headerlink" title="T3 daklqw 的 T3"></a>T3 daklqw 的 T3</h1><div class="pdfobject-container" data-target="problem_426.pdf" data-height="500px"></div><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>先考虑$q^2$的暴力。求出树上每个点到它最近的有权的边的距离，那么我们的策略显然是完成一个任务之后，到某条有边权的边来回横跳，时间不够的时候再走到另一个任务。这条边就是离这两个任务树上路径上的点最近的一条边。</p><p>考虑点分治，将所有任务按照时刻从大到小排序。我们设$dp[i]$表示从第$i$个任务完成之后的时刻以及这个任务所在的节点开始，所能获得的最大收益。</p><p>那么对于一个任务来说，它有以下几种情况：</p><ul><li>不再处理任何一个任务，直接走到树上离当前点最近的有权边来回走。</li><li>处理一个跨过当前分治中心的任务，但不会离开这两个任务的树上路径。</li><li>处理一个跨过当前分治中心的任务，且在过分治中心后会到某条有权边来回走。</li><li>处理一个跨过当前分治中心的任务，且在过分治中心之前到某条有权边来回走。</li></ul><p>如果两个任务的时刻差减去树上路径长度之后为$t$，即“可以浪费的时间”。同时我们记$d$表示距离这条路径最近的有权边的距离，这条边对答案的贡献就是</p><script type="math/tex; mode=display">\lfloor\frac{t-d}{2}\rfloor\times 2c</script><p>因此，我们需要对$t,d$的奇偶性分别讨论，对于每个点我们开$5$颗线段树分别维护第二种情况以及第三、四种情况的奇数/偶数。代码实现非常毒瘤。</p><p>最后，这题还卡空间，由于直接动态开点是$\log^2$的，因此我们需要将所有询问进行二次离线，提前将可能用到的所有时刻挂到对应的点上，最后查询的时候<code>lower_bound</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">20000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from], w &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to], w &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mn[N], dep[N], dis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    mn[u] = min(mn[u], d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f &amp;&amp; !e[i].w) dfs(e[i].to, u, d + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WEN</span> &#123;</span></span><br><span class="line"></span><br><span class="line">LL mx[M]; <span class="keyword">int</span> ls[M], rs[M], ncnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, LL x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; l || pos &gt; r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!rt) rt = ++ncnt, mx[rt] = <span class="number">-1e18</span>;</span><br><span class="line">    mx[rt] = max(mx[rt], x);</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) update(ls[rt], l, mid, pos, x);</span><br><span class="line">    <span class="keyword">else</span> update(rs[rt], mid + <span class="number">1</span>, r, pos, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rt || start &gt; end) <span class="keyword">return</span> <span class="number">-1e18</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> mx[rt];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (end &lt;= mid) <span class="keyword">return</span> query(ls[rt], l, mid, start, end);</span><br><span class="line">    <span class="keyword">if</span> (start &gt; mid) <span class="keyword">return</span> query(rs[rt], mid + <span class="number">1</span>, r, start, end);</span><br><span class="line">    <span class="keyword">return</span> max(query(ls[rt], l, mid, start, end), query(rs[rt], mid + <span class="number">1</span>, r, start, end));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; T[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> D[<span class="number">20</span>][N], D1[<span class="number">20</span>][N], wkr[<span class="number">20</span>][N], F[<span class="number">20</span>][N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> layer, <span class="keyword">int</span> t, <span class="keyword">int</span> d, <span class="keyword">int</span> d1, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    F[layer][u] = t, D[layer][u] = d, D1[layer][u] = d1, wkr[layer][u] = x, vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to])</span><br><span class="line">            dfs(e[i].to, layer, t, d + <span class="number">1</span>, d1 + e[i].w, min(x, mn[e[i].to]));</span><br><span class="line">    vis[u] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sz[N], at[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsz</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    sz[u] = vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to]) sz[u] += getsz(e[i].to);</span><br><span class="line">    <span class="keyword">return</span> vis[u] = <span class="number">0</span>, sz[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrt</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tot)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], tmp; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to] &amp;&amp; (tmp = getrt(e[i].to, tot)))</span><br><span class="line">            <span class="keyword">return</span> vis[u] = <span class="number">0</span>, tmp;</span><br><span class="line">    <span class="keyword">return</span> vis[u] = <span class="number">0</span>, sz[u] &gt;= (tot &gt;&gt; <span class="number">1</span>) ? u : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> layer)</span> </span>&#123;</span><br><span class="line">    u = getrt(u, getsz(u)), dfs(u, layer, u, <span class="number">0</span>, <span class="number">0</span>, mn[u]), vis[u] = <span class="number">1</span>, at[u] = layer;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to]) divide(e[i].to, layer + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> RT[N][<span class="number">5</span>], tot, c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos[<span class="number">2</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = at[u]; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = F[i][u], t1 = t + D[i][u], t2 = t1 + wkr[i][u] * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &lt;= t1 &amp;&amp; t1 &lt;= tot) </span><br><span class="line">        pos[<span class="number">0</span>][f].push_back(t1);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &lt;= t2 &amp;&amp; t2 &lt;= tot) </span><br><span class="line">        pos[<span class="number">1</span>][f].push_back(t2); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v &gt; tot) <span class="keyword">return</span> x.size();</span><br><span class="line">    <span class="keyword">return</span> upper_bound(x.begin(), x.end(), v) - x.begin() - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Just_DOIT</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    LL res = tot - t - mn[u] &gt;= <span class="number">0</span> ? (LL)(tot - t - mn[u]) * c : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = at[u]; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = F[i][u], t1 = t + D[i][u], t2 = t1 + wkr[i][u] * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> tot1 = pos[<span class="number">0</span>][f].size() - <span class="number">1</span>, tot2 = pos[<span class="number">1</span>][f].size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pos1 = find(pos[<span class="number">0</span>][f], t1), pos2 = find(pos[<span class="number">1</span>][f], t2);</span><br><span class="line">        LL base = (LL)D1[i][u] * c;</span><br><span class="line">        res = max(res, base + T[<span class="number">0</span>].query(RT[f][<span class="number">0</span>], <span class="number">0</span>, tot1, pos1, tot1));</span><br><span class="line">        res = max(res, base + T[<span class="number">1</span>].query(RT[f][<span class="number">1</span>], <span class="number">0</span>, tot1, pos1, tot1) - (LL)t1 / <span class="number">2</span> * <span class="number">2</span> * c);</span><br><span class="line">        res = max(res, base + T[<span class="number">2</span>].query(RT[f][<span class="number">2</span>], <span class="number">0</span>, tot1, pos1, tot1) - (LL)(t1 + <span class="number">1</span>) / <span class="number">2</span> * <span class="number">2</span> * c);</span><br><span class="line">        res = max(res, base + T[<span class="number">3</span>].query(RT[f][<span class="number">3</span>], <span class="number">0</span>, tot2, pos2, tot2) - (LL)(t2 / <span class="number">2</span>) * <span class="number">2</span> * c);</span><br><span class="line">        res = max(res, base + T[<span class="number">4</span>].query(RT[f][<span class="number">4</span>], <span class="number">0</span>, tot2, pos2, tot2) - (LL)((t2 + <span class="number">1</span>) / <span class="number">2</span>) * <span class="number">2</span> * c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t, LL x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = at[u]; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = F[i][u], t1 = t - D[i][u], t2 = t - D[i][u] - <span class="number">2</span> * wkr[i][u]; LL base = x + (LL)D1[i][u] * c;</span><br><span class="line">        <span class="keyword">int</span> tot1 = pos[<span class="number">0</span>][f].size() - <span class="number">1</span>, tot2 = pos[<span class="number">1</span>][f].size() - <span class="number">1</span>; </span><br><span class="line">        T[<span class="number">0</span>].update(RT[f][<span class="number">0</span>], <span class="number">0</span>, tot1, find(pos[<span class="number">0</span>][f], t1), base);</span><br><span class="line">        <span class="keyword">int</span> type1 = (t2 &amp; <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        T[type1].update(RT[f][type1], <span class="number">0</span>, tot1, find(pos[<span class="number">0</span>][f], t2), base + (LL)t2 / <span class="number">2</span> * <span class="number">2</span> * c);</span><br><span class="line">        <span class="keyword">int</span> type2 = (t1 &amp; <span class="number">1</span>) ? <span class="number">3</span> : <span class="number">4</span>;</span><br><span class="line">        T[type2].update(RT[f][type2], <span class="number">0</span>, tot2, find(pos[<span class="number">1</span>][f], t1), base + (LL)t1 / <span class="number">2</span> * <span class="number">2</span> * c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FUCKTHISPROBLEM</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d, a, k, p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> FUCKTHISPROBLEM &amp;b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a + k != b.a + b.k) <span class="keyword">return</span> a + k &gt; b.a + b.k;</span><br><span class="line">    <span class="keyword">return</span> k &lt; b.k;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125; q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;tot, &amp;c), <span class="built_in">memset</span>(mn, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(mn));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b, c; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c), adde(a, b, c);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head[i]; j; j = e[j].next)</span><br><span class="line">            <span class="keyword">if</span> (e[j].to &gt; i &amp;&amp; e[j].w) dfs(i, e[j].to, <span class="number">0</span>), dfs(e[j].to, i, <span class="number">0</span>);</span><br><span class="line">    divide(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;q[i].d, &amp;q[i].a, &amp;q[i].k, &amp;q[i].p);</span><br><span class="line">    sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) push(q[i].d, q[i].a + q[i].k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) push(i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sort(pos[<span class="number">0</span>][i].begin(), pos[<span class="number">0</span>][i].end()), sort(pos[<span class="number">1</span>][i].begin(), pos[<span class="number">1</span>][i].end());</span><br><span class="line">        pos[<span class="number">0</span>][i].resize(unique(pos[<span class="number">0</span>][i].begin(), pos[<span class="number">0</span>][i].end()) - pos[<span class="number">0</span>][i].begin());</span><br><span class="line">        pos[<span class="number">1</span>][i].resize(unique(pos[<span class="number">1</span>][i].begin(), pos[<span class="number">1</span>][i].end()) - pos[<span class="number">1</span>][i].begin());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        LL res = Just_DOIT(q[i].d, q[i].a + q[i].k) + q[i].p;</span><br><span class="line">        update(q[i].d, q[i].a, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, Just_DOIT(i, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 点分治 </tag>
            
            <tag> 莫队 </tag>
            
            <tag> trie </tag>
            
            <tag> NTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.19联测</title>
      <link href="/2020/06/20/6-19%E8%81%94%E6%B5%8B/"/>
      <url>/2020/06/20/6-19%E8%81%94%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-异或树"><a href="#T1-异或树" class="headerlink" title="T1 异或树"></a>T1 异或树</h1><p>有一个$n$个点的完全图，每个点的权值为$[0,2^m)$之间的随机整数。两点之间的边权为这两个点点权的异或值，问最小生成树的期望。</p><script type="math/tex; mode=display">n\leq 50, m\leq 8</script><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>如果这$n$个点的权值已经确定好了，那么这就是一个经典问题。每次我们根据最高位将这$n$个点划分为两个集合，第一个集合的最高位为$0$，第二个集合的最高位为$1$。此时最小生成树的边权和一定等于第一个集合的最小生成树$+$第二个集合的最小生成树$+$连接两个集合的最小边权。</p><p>回到这道题，考虑将这$n$个点按照最高位分为两个集合，枚举第一个集合的大小，那么接下来我们要解决的问题是：有两个集合，第一个大小为$x$，第二个大小为$y$。两个集合中的点权都在$[0,2^m)$中随机，问所有方案中连接这两个集合的最小边权之和。</p><p>直接统计边权$=x$的方案数不好计算，考虑统计最小边权$\geq x$的方案数。我们将这两个集合扣去最高位，根据新的最高位又分为四个集合，即第一个集合中最高位为$1/0$的子集，第二个集合中最高位为$1/0$的子集。</p><p>如果$x$的最高位为$1$，那么意味着必然有一个集合最高位全是$1$，另一个集合最高位全是$0$。我们扣去这个最高位，递归到子问题即可。</p><p>否则，异或最小值一定是在两边的$0$集合，或者在两边的$1$集合中产生。我们枚举两边$0$集合的大小，也可以递归到子问题。</p><p>特别地，如果两侧的集合至少有一个是空的，我们认为此时连接两个集合的最小边权为无穷大。</p><p>具体实现方法就是设$F(x,y,m,t)$表示左侧集合有$x$个点，右侧集合有$y$个点，所有点的权值均$&lt;2^m$，连接两个集合的边权不能小于$t$的方案数。设$G(n,m)$表示$n$个点，每个点权值小于$2^m$的所有方案的最小生成树边权和之和。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">51</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">9</span>][N][N][<span class="number">256</span>], g[<span class="number">9</span>][N], C[N][N], mod;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> mx)</span> </span>&#123; <span class="comment">// &lt; 2 ^ m, ^ &gt;= mx</span></span><br><span class="line">    <span class="keyword">if</span> (mx == <span class="number">0</span> || (!x || !y)) <span class="keyword">return</span> Pow(<span class="number">1</span> &lt;&lt; m, x + y);</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y) swap(x, y);</span><br><span class="line">    <span class="keyword">if</span> (~f[m][x][y][mx]) <span class="keyword">return</span> f[m][x][y][mx];</span><br><span class="line">    <span class="keyword">int</span> &amp;res = f[m][x][y][mx]; res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (mx &amp; (<span class="number">1</span> &lt;&lt; m - <span class="number">1</span>)) <span class="keyword">return</span> res = <span class="number">2</span> * F(x, y, m - <span class="number">1</span>, mx ^ (<span class="number">1</span> &lt;&lt; m - <span class="number">1</span>)) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;= x; a++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= y; b++) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = (LL)C[x][a] * C[y][b] % mod;</span><br><span class="line">            res = (res + (LL)F(a, b, m - <span class="number">1</span>, mx) * F(x - a, y - b, m - <span class="number">1</span>, mx) % mod * w) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">G</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span> || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (~g[m][n]) <span class="keyword">return</span> g[m][n];</span><br><span class="line">    <span class="keyword">int</span> &amp;res = g[m][n]; </span><br><span class="line">    <span class="keyword">int</span> all = Pow(<span class="number">1</span> &lt;&lt; m - <span class="number">1</span>, n); res = G(n, m - <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">1</span>; a &lt; n; a++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt; <span class="number">1</span> &lt;&lt; m - <span class="number">1</span>; t++) </span><br><span class="line">            tmp = (tmp + F(a, n - a, m - <span class="number">1</span>, t)) % mod;</span><br><span class="line">        <span class="keyword">int</span> l = Pow(<span class="number">1</span> &lt;&lt; m - <span class="number">1</span>, a), r = Pow(<span class="number">1</span> &lt;&lt; m - <span class="number">1</span>, n - a);</span><br><span class="line">        tmp = (tmp + (LL)G(a, m - <span class="number">1</span>) * r + (LL)G(n - a, m - <span class="number">1</span>) * l) % mod;</span><br><span class="line">        tmp = (tmp + (LL)l * r % mod * (<span class="number">1</span> &lt;&lt; m - <span class="number">1</span>)) % mod;</span><br><span class="line">        res = (res + (LL)tmp * C[n][a]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span>(f)), <span class="built_in">memset</span>(g, <span class="number">-1</span>, <span class="keyword">sizeof</span>(g));</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;mod);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            C[i][j] = (C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, G(n, m));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-密码"><a href="#T2-密码" class="headerlink" title="T2 密码"></a>T2 密码</h1><p>有一个长度为$n$的序列，第$i$个位置有$p_{i,j}$的概率为$j$，这里$j\in[0,9]$。给出一个长度为$m$的序列$t$，问从$1,2,\cdots, n-m+1$位置开始匹配，能匹配上$t$的概率。保留$9$位精度。</p><script type="math/tex; mode=display">n\leq 2\times 10^5, m\leq 5\times 10^4</script><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>我们将这个序列变为一个串$s$，第$i$个位置的字符为使得$p_{i,j}$最大的$j$。那么每当$t$串发生一次失配，都会使得答案至少除以$2$，除了$\log$次之后概率就很小很小了，因此我们只需要匹配$\log$次。</p><p>直接<code>hash</code>就行了，当答案小于$10^{-9}$时<code>break</code>即可。</p><p>另一种做法是将概率求一次$\ln$，然后两个概率相乘就可以看作指数相加，<code>FFT</code>求出最终每一位匹配的指数之和，最后$\exp$回去即可。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">131</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> hsh[N], hsh1[N], s[N], pw[N], t[N], n, m; <span class="keyword">double</span> wkr[N][<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> p[<span class="number">19</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">double</span> mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++) </span><br><span class="line">            <span class="keyword">if</span> (wkr[i][j] &gt; mx) mx = wkr[i][j], s[i] = j;</span><br><span class="line">        p[<span class="number">0</span>][i] = mx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">17</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= n; j++)</span><br><span class="line">            p[i][j] = p[i - <span class="number">1</span>][j] * p[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        hsh[i] = ((LL)hsh[i - <span class="number">1</span>] * P + s[i]) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        hsh1[i] = ((LL)hsh1[i - <span class="number">1</span>] * P + t[i]) % mod;</span><br><span class="line">    pw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        pw[i] = (LL)pw[i - <span class="number">1</span>] * P % mod;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (hsh[r] - (LL)hsh[l - <span class="number">1</span>] * pw[r - l + <span class="number">1</span>] % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (hsh1[r] - (LL)hsh1[l - <span class="number">1</span>] * pw[r - l + <span class="number">1</span>] % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (l + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= r) </span><br><span class="line">        res *= p[i][l], l += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lcp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = min(n - a + <span class="number">1</span>, m - b + <span class="number">1</span>), ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (get(a, a + mid - <span class="number">1</span>) == get1(b, b + mid - <span class="number">1</span>)) ans = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">1</span>; <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt;= m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; <span class="number">1e-9</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span> hh = lcp(pos, cur); ans *= calc(pos, pos + hh - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (cur + hh &gt; m || pos + hh &gt; n) <span class="keyword">break</span>;</span><br><span class="line">        ans *= wkr[pos + hh][t[cur + hh]];</span><br><span class="line">        pos += hh + <span class="number">1</span>, cur += hh + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> fuck[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a); wkr[i][j] = a / <span class="number">1e9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, fuck + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) t[i] = fuck[i] - <span class="string">'0'</span> + <span class="number">1</span>;</span><br><span class="line">    pre();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - m + <span class="number">1</span>; i++) <span class="built_in">printf</span>(<span class="string">"%.10lf\n"</span>, solve(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-排列"><a href="#T3-排列" class="headerlink" title="T3 排列"></a>T3 排列</h1><p>给定$n,m$，对于$i\in[0,n]$求出大小为$n$，且$|p_i-i|=m$的位置恰好有$i$个的排列$p$的数量。</p><script type="math/tex; mode=display">n,m\leq 10^5</script><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>先考虑$m=1$的情况。</p><p>我们将$p_i,i$看作是一张二分图，如果$p_i=x$则表示二分图左侧的第$i$个点向二分图右侧的第$x$个点连边，显然一个排列与一个匹配一一对应。</p><p>我们只考虑满足$|p_i-i|=1$的边，这些边将整张二分图连成了下图的样子</p><p><img src="image-20200620095825625.png" alt="image-20200620095825625"></p><p>由于上下两条链之间没有关系，因此我们只考虑上面那条链。</p><p>恰好有$i$条匹配的边不好直接计算，考虑计算钦定有$i$条匹配边的方案数。即恰好有$i$条边的方案数为$f_i$，钦定$i$条边的方案数为$g_i$，那么有</p><script type="math/tex; mode=display">g_i=\sum_{j\geq i}f_j{j\choose i}</script><p>二项式反演可以得到</p><script type="math/tex; mode=display">f_i=\sum_{j\geq i}(-1)^{j-i}g_j{j\choose i}</script><p>我们必须保证选出的$i$条边构成一个匹配，即同一个端点不能被选择两次</p><p>如果选边的方案已经确定了，那么我们可以将每条边的两个端点缩起来，如果一个点没有被缩起来则写下$0$，否则写下$1$。</p><p>举个例子</p><p><img src="image-20200620100645800.png" alt="image-20200620100645800"></p><p>这个匹配可以记为$011$，因为第一个点没有被匹配，第二、三；第四、五个点都被匹配了。</p><p>由于匹配一条边会将两个点缩为一个点，因此最后剩下了$n-i$个点，序列长度为$n$。</p><p>在这个序列中有$i$个位置为$1$，而任意一种恰有$i$个位置为$1$的序列都对应着一种匹配，因此方案数为${n-i\choose i}$。</p><p>将两条链的生成函数相乘，最后给$x^i$的系数乘上$(n-i)!$表示剩下的位置可以随便匹配，然后套用上面的二项式反演即可。</p><p>当$m\neq 1$时与$m=1$做法类似，就是将这$2n$个点拆成若干条链，然后将每条链的生成函数乘起来。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123; x += y, x -= x &gt;= mod ? mod : <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x - y &lt; <span class="number">0</span> ? x - y + mod : x - y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, w = <span class="number">1</span>, t; j &lt; i + (mid &gt;&gt; <span class="number">1</span>); j++, w = (LL)w * Wn % mod) </span><br><span class="line">                t = (LL)a[j + (mid &gt;&gt; <span class="number">1</span>)] * w % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = Sub(a[j], t), Inc(a[j], t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!type) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, inv = Pow(len, mod - <span class="number">2</span>); i &lt; len; i++) a[i] = (LL)a[i] * inv % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N &lt;&lt; <span class="number">2</span>], B[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> len1 = (n - <span class="number">1</span>) / m + <span class="number">1</span>, len2 = len1 - <span class="number">1</span>, a = (n - <span class="number">1</span>) % m + <span class="number">1</span>, b = (n - len1 * a) / len2;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n * <span class="number">2</span>) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len1 / <span class="number">2</span>; i++) A[i] = C(len1 - i, i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len2 / <span class="number">2</span>; i++) B[i] = C(len2 - i, i);</span><br><span class="line">    NTT(A, len, <span class="number">1</span>), NTT(B, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) A[i] = (LL)Pow(A[i], <span class="number">2</span> * a) * Pow(B[i], <span class="number">2</span> * b) % mod;</span><br><span class="line">    NTT(A, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) A[i] = (LL)A[i] * frac[n - i] % mod;</span><br><span class="line">    <span class="built_in">memset</span>(B, <span class="number">0</span>, <span class="keyword">sizeof</span>(B));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt; len; i++) A[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) A[i] = (LL)A[i] * frac[i] % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        B[n - i] = inv[i];</span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>) B[n - i] = mod - B[n - i];</span><br><span class="line">    &#125;</span><br><span class="line">    NTT(A, len, <span class="number">1</span>), NTT(B, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) A[i] = (LL)A[i] * B[i] % mod;</span><br><span class="line">    NTT(A, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL)A[n + i] * inv[i] % mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> NTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.18联测</title>
      <link href="/2020/06/18/6-18%E8%81%94%E6%B5%8B/"/>
      <url>/2020/06/18/6-18%E8%81%94%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-s1mple的矩阵"><a href="#T1-s1mple的矩阵" class="headerlink" title="T1 s1mple的矩阵"></a>T1 s1mple的矩阵</h1><p>给出一张有向图$G$，你需要统计$n$个点的排列数量$p$，满足对于给定的长度为$n-1$的$01$序列$\{a_i\}$，有$G_{p_i,p_{i+1}}=a_i$。即如果$a_i=1$，那么$p_i,p_{i+1}$之间有边，否则无边。多组询问。</p><script type="math/tex; mode=display">n\leq 17, T\leq 10^5</script><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑这样一个暴力：类似于统计哈密顿路径的方法状压$dp$，但是由于不知道$p_i,p_{i+1}$之间是否有边，因此对于每个询问必须重新$dp$。时间复杂度$O(2^{2n}\times n)$。</p><p>考虑优化这个暴力，可以发现复杂度的瓶颈在于不知道相邻两个点之间是否有边。如果我们对询问给出的$\{a_i\}$容斥，即求出钦定一些位置必然为$1$，剩下的位置可以为$1$，也可以为$0$，满足条件的排列的数量，那么我们就可以通过容斥算出这一次询问的答案。</p><p>举个例子，假如询问给出的串为$01011$，那么答案就等于$?1?11-11?11-?1111+11111$。</p><p>接下来分析$?1?11$的答案如何计算。</p><p>我们可以从这个串得到的信息是：$p_2,p_3$以及$p_4, p_5;p_5,p_6$之间一定有边，剩下的点之间可能有边，也可能没有边。</p><p>我们可以看作，这个串给出的信息将这$n$个点分为了三个子集，第一个集合为$p_1$，第二个集合为$p_2,p_3$，第三个集合为$p_4,p_5,p_6$。</p><p>每个集合内部必然是一条哈密顿路径，并且我们并不关系集合与集合之间的连边情况。</p><p>因此，问题转化为，将$1\sim n$分为三个大小分别为$1,2,3$的集合，每种方案对答案的贡献是每个集合内部的哈密顿路径数量的乘积。</p><p>可以发现这个答案只与每个集合的大小有关，与集合的顺序无关，因此，可能的拆分方案为$n$的正整数拆分数，在$n=17$时不超过$280$种。</p><p>接下来我们需要重点解决的问题是：如何快速计算上面的东西。</p><p>这个东西看似需要<a href="https://www.luogu.com.cn/problem/P6097" target="_blank" rel="noopener">子集卷积</a>，但是通过观察我们可以发现，所有集合的大小正好是$n$，而每个点都必须被一个集合包含，因此我们可以直接进行或卷积。如果在一次卷积中有一个元素被两个集合都选中了，那么最后一定没有办法得到全集。</p><p>这里提供一种拆分数的编码方式：求出每个数的前缀和，然后将前缀和的值这个二进制位设为$1$。比如$2, 2, 3$这种拆分得到的编码就是$0101001$。</p><p>最后容斥的时候可以$3^n$枚举超集，也可以做一遍与卷积。时间复杂度$O(p(n)\times 2^n\times n)$。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> G[N][N], n; LL dp[N][<span class="number">1</span> &lt;&lt; N], sum[N][<span class="number">1</span> &lt;&lt; N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT</span><span class="params">(LL a[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + (mid &gt;&gt; <span class="number">1</span>); j++)</span><br><span class="line">                a[j + (mid &gt;&gt; <span class="number">1</span>)] += a[j]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT1</span><span class="params">(LL a[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + (mid &gt;&gt; <span class="number">1</span>); j++)</span><br><span class="line">                a[j] += a[j + (mid &gt;&gt; <span class="number">1</span>)]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IFWT</span><span class="params">(LL a[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + (mid &gt;&gt; <span class="number">1</span>); j++)</span><br><span class="line">                a[j + (mid &gt;&gt; <span class="number">1</span>)] -= a[j]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline0 </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; <span class="number">1</span> &lt;&lt; n; s++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) sum[__builtin_popcount(s)][s] += dp[i][s];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) FWT(sum[i], <span class="number">1</span> &lt;&lt; n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; stk; LL ans[<span class="number">1</span> &lt;&lt; N], zjk[<span class="number">1</span> &lt;&lt; N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> remain)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (remain == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">static</span> LL wkr[<span class="number">1</span> &lt;&lt; N]; <span class="built_in">memset</span>(wkr, <span class="number">0</span>, <span class="keyword">sizeof</span>(wkr));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++) wkr[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tp = <span class="number">0</span>, st = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t : stk) &#123;</span><br><span class="line">            tp += t, st |= <span class="number">1</span> &lt;&lt; tp - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++) </span><br><span class="line">                wkr[i] *= sum[t][i];</span><br><span class="line">        &#125;</span><br><span class="line">        IFWT(wkr, <span class="number">1</span> &lt;&lt; n), ans[st] = wkr[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cur; i &lt;= n; i++) <span class="keyword">if</span> (i &lt;= remain) </span><br><span class="line">        stk.push_back(i), dfs(i, remain - i), stk.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N + <span class="number">10</span>]; LL res[<span class="number">1</span> &lt;&lt; N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) G[i][j] = s[j] - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre(), dfs(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hh; <span class="keyword">int</span> tot = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span>; j++) <span class="keyword">if</span> (i &amp; <span class="number">1</span> &lt;&lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = j;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; n - <span class="number">2</span> &amp;&amp; (i &amp; (<span class="number">1</span> &lt;&lt; k + <span class="number">1</span>))) k++;</span><br><span class="line">            hh.push_back(k - j + <span class="number">2</span>), tot -= k - j + <span class="number">2</span>, j = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) hh.push_back(<span class="number">1</span>);</span><br><span class="line">        sort(hh.begin(), hh.end());</span><br><span class="line">        <span class="keyword">int</span> st = <span class="number">0</span>, tp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t : hh) tp += t, st |= <span class="number">1</span> &lt;&lt; tp - <span class="number">1</span>;</span><br><span class="line">        zjk[i] = ans[st];</span><br><span class="line">        <span class="keyword">if</span> (__builtin_popcount(i) &amp; <span class="number">1</span>) zjk[i] = -zjk[i];</span><br><span class="line">    &#125;</span><br><span class="line">    FWT1(zjk, <span class="number">1</span> &lt;&lt; n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        res[i] = zjk[i];</span><br><span class="line">        <span class="keyword">if</span> (__builtin_popcount(i) &amp; <span class="number">1</span>) res[i] = -res[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> q; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s); <span class="keyword">int</span> st = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) <span class="keyword">if</span> (s[i] == <span class="string">'1'</span>) st |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res[st]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-s2mple的字符串"><a href="#T2-s2mple的字符串" class="headerlink" title="T2 s2mple的字符串"></a>T2 s2mple的字符串</h1><p>给出一个字符串$S$，定义一个字符串$\text{str}$的价值为其在$S$中出现的次数。有$Q$组询问，每次询问给出$l,r$，表示将$S_{l,r}$作为$\text{str}$之后，$S$所有本质不同的子串的权值之和。</p><p>两个字符串本质不同当且仅当它们看起来不同。</p><script type="math/tex; mode=display">n, Q\leq 4\times 10^5</script><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>将题意转化一下，如果询问给出的串为$s$，我们可以看作是在$s$之前添加若干个字符，在$s$之后添加若干个字符，使得$s$在添加字符后仍是$S$的子串的方案数。两种方案不同当且仅当在前面添加的字符不同或者在后面添加的字符不同。</p><p>容易发现$S$的每个不同的子串都被计算了$s$的出现次数次。</p><p>先考虑往前添加字符，我们建出$S$的后缀自动机，定位到$s$这个串。容易发现此时$s$的子树中的点代表的所有串以及$s$所在节点中，比$s$长的串都是由$s$往前添加若干字符得到的。</p><p>如果我们记$s$的子树中以及$s$所在的节点代表的串的总数为$x$，那么$s$通过往前添加字符能得到的串的总数可以表示为一个与$|s|$有关的一次函数。如果$s$所在的点的串的最短长度为$y$，那么这个一次函数就是$x+y-|s|$。</p><p>接下来考虑往后添加字符。</p><p>往前添加字符对应<code>parent</code>树的子树，往后添加字符就对应后缀自动机的子<code>DAG</code>。</p><p>将后缀自动机拓扑排序之后$dp$。考虑两个相连的点$u,v$，其中$v$是$u$添加某一个字符之后得到的，那么$v$对$u$的贡献就是$(|s|+1)k_v+b_v$。</p><p>因为落在$u$的串的长度为$|s|$，往后添加一个字符之后长度变为了$|s|+1$，同时转移到了$v$点。</p><p>另一种方式是考虑$s$的所有$endpos$，$s$往后添加字符的方案数为所有$endpos+1$位置的本质不同前缀个数。</p><p>我们对反串也建出后缀自动机，那么这个本质不同前缀个数就等于反串上这些$endpos$的虚树大小。当然，也可以在后缀数组上线段树合并。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">800010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ch[N][<span class="number">26</span>], link[N] = &#123;<span class="number">-1</span>&#125;, len[N], last, ncnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nw = ++ncnt, p = last; len[nw] = len[last] + <span class="number">1</span>, last = nw;</span><br><span class="line">    <span class="keyword">while</span> (~p &amp;&amp; !ch[p][c - <span class="string">'a'</span>]) ch[p][c - <span class="string">'a'</span>] = nw, p = link[p];</span><br><span class="line">    <span class="keyword">if</span> (!~p) <span class="keyword">return</span> nw; </span><br><span class="line">    <span class="keyword">int</span> q = ch[p][c - <span class="string">'a'</span>];</span><br><span class="line">    <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>) <span class="keyword">return</span> link[nw] = q, nw;</span><br><span class="line">    <span class="keyword">int</span> clone = ++ncnt; <span class="built_in">memcpy</span>(ch[clone], ch[q], <span class="keyword">sizeof</span>(ch[q]));</span><br><span class="line">    link[clone] = link[q], len[clone] = len[p] + <span class="number">1</span>, link[q] = link[nw] = clone;</span><br><span class="line">    <span class="keyword">while</span> (~p &amp;&amp; ch[p][c - <span class="string">'a'</span>] == q) ch[p][c - <span class="string">'a'</span>] = clone, p = link[p];</span><br><span class="line">    <span class="keyword">return</span> nw; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from] &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to] &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N][<span class="number">19</span>]; LL sum[N], k[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    sum[u] = len[u] - len[max(<span class="number">0</span>, link[u])], fa[u][<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">18</span>; i++) fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u), sum[u] += sum[e[i].to];</span><br><span class="line">    k[u] = <span class="number">-1</span>, b[u] = sum[u] + len[max(<span class="number">0</span>, link[u])] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> ind[N]; <span class="built_in">memset</span>(ind, <span class="number">0</span>, <span class="keyword">sizeof</span>(ind));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ncnt; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) <span class="keyword">if</span> (ch[i][j]) ind[ch[i][j]]++;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; wkr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ncnt; i++) <span class="keyword">if</span> (!ind[i]) q.push(i);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop(), wkr.push_back(u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) <span class="keyword">if</span> (ch[u][i] &amp;&amp; !--ind[ch[u][i]]) q.push(ch[u][i]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = wkr.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = wkr[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) <span class="keyword">if</span> (ch[u][j]) &#123;</span><br><span class="line">            k[u] += k[ch[u][j]];</span><br><span class="line">            b[u] += b[ch[u][j]] + k[ch[u][j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">18</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (len[fa[u][i]] &gt;= l) u = fa[u][i];</span><br><span class="line">    <span class="keyword">return</span> u; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, q; <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;n, &amp;q, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) pos[i] = insert(s[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ncnt; i++) adde(link[i], i);</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>), DP();</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">int</span> u = jump(pos[r], r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, k[u] * (r - l + <span class="number">1</span>) + b[u]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-s3mple的排列"><a href="#T3-s3mple的排列" class="headerlink" title="T3 s3mple的排列"></a>T3 s3mple的排列</h1><p>对于一个排列$\{a_i\}$中的位置$i$，定义$v_i$为$i$的左边或右边比$a_i$大的位置到位置$i$的距离的最小值。两个点$i,j$间的距离为$|i-j|$。特别地，我们认为$a_0$和$a_{n+1}$是极大的。</p><p>现在有不超过$10$组询问，每组询问给出$n,x$，表示询问大小为$n$的排列$p$的个数，使得$\sum v_i=x$。</p><script type="math/tex; mode=display">n\leq 200, x\leq 10^9</script><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>记$dp[i][j]$表示$1\sim i$，$v_i$和为$j$的方案数，枚举最大值的位置，可以发现由于我们认为$a_0,a_{n+1}$都是极大的，最大值左边和最大值右边形成了两个子问题。其次，可以发现$j$的最大值大概是$n\log n$的范围，因此我们得到了一个$n^4\log^2 n$的$dp$。</p><p>考虑优化，如果我们将$dp$写成生成函数的形式，这个生成函数只有$n\log n$项。那么我们可以代入$n\log n$个点值，然后直接通过上面的$dp$计算此时的答案。由于第二维不见了，因此一次$dp$的复杂度为$n^2$。最后再做一次拉格朗日插值即可。</p><p>代码咕了。</p>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 状态压缩 </tag>
            
            <tag> FWT </tag>
            
            <tag> 后缀自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.1联测</title>
      <link href="/2020/06/09/6-1%E8%81%94%E6%B5%8B/"/>
      <url>/2020/06/09/6-1%E8%81%94%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-查拉图斯特拉如是说"><a href="#T1-查拉图斯特拉如是说" class="headerlink" title="T1 查拉图斯特拉如是说"></a>T1 查拉图斯特拉如是说</h1><p>给定一个$m$次多项式$f(x)$，求</p><script type="math/tex; mode=display">\sum_{i=0}^n{n\choose i}f(i)</script><p>其中$m\leq 10^5, m\leq n\leq 10^9$</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>有两种做法。</p><script type="math/tex; mode=display">\begin{aligned}\sum_{i=0}^n{n\choose i}f(i)&=\sum_{i=0}^n{n\choose i}\sum_{j=0}^ma_ji^j\\&=\sum_{j=0}^ma_j\sum_{i=0}^n{n\choose i}\sum_{k=0}^j\begin{Bmatrix}j\\ k\end{Bmatrix}{i\choose k}k!\\&=\sum_{j=0}^ma_j\sum_{k=0}^j\begin{Bmatrix}j\\ k\end{Bmatrix}k!\sum_{i=0}^n{n\choose i}{i\choose k}\\&=\sum_{j=0}^ma_j\sum_{k=0}^j\begin{Bmatrix}j\\ k\end{Bmatrix}{n\choose k}k!\sum_{i=0}^n{n-k\choose i-k}\\&=\sum_{j=0}^ma_j\sum_{k=0}^j\begin{Bmatrix}j\\ k\end{Bmatrix}{n\choose k}k!2^{n-k}\\&=\sum_{k=0}^m{n\choose k}k!2^{n-k}\sum_{j=0}^m\begin{Bmatrix}j\\ k\end{Bmatrix}a_j\end{aligned}</script><p>接下来关键是快速求出后面那个东西。</p><script type="math/tex; mode=display">\begin{aligned}c_k&=\sum_{j}\begin{Bmatrix}j\\ k\end{Bmatrix}a_j\\&=\frac{1}{k!}\sum_{j}\sum_{i=0}^k{k\choose i}(k-i)^j(-1)^ia_j\\&=\frac{1}{k!}\sum_{i=0}^k{k\choose i}(-1)^i\sum_{j}(k-i)^ja_j\end{aligned}</script><p>对$f(x)$多点求值后再进行一次NTT即可。</p><p>但是这样既难写，而且复杂度还很不优秀。</p><p>我们回到这一步</p><script type="math/tex; mode=display">\sum_{i=0}^n{n\choose i}f(i)=\sum_{j=0}^ma_j\sum_{i=0}^n{n\choose i}i^j</script><p>考虑这个式子的组合意义</p><p>有$n$个盒子，$j$个球，现在要从这$n$个盒子中选出$i$个盒子，然后将这$j$个球放入选中的$i$个盒子中，每个盒子可以放也可以不放，球有颜色。</p><p>考虑每个盒子里面最终有多少个球，由于最终一个盒子中的球是无序的，因此可以写出一个盒子的<code>EGF</code>：</p><script type="math/tex; mode=display">F(x)=1+\sum_{i\geq 0}\frac{x^i}{i!}</script><p>这个多项式的常数项为$2$，因为最后导致这个盒子是空的可能有两种情况，一是这个盒子没有被选中，二是这个盒子被选中了，但没有放入任何球。</p><p>我们要求的就是$F(x)^n$，最后$x^j$的系数乘上$j!$就是放入$j$个球的方案。</p><p>因此只需要多项式快速幂即可。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r[N &lt;&lt; <span class="number">2</span>], wn[<span class="number">2</span>][<span class="number">20</span>][N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>, step = <span class="number">0</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>, step++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = Pow(<span class="number">3</span>, (mod - <span class="number">1</span>) / mid), b = Pow(a, mod - <span class="number">2</span>);</span><br><span class="line">        wn[<span class="number">1</span>][step][<span class="number">0</span>] = wn[<span class="number">0</span>][step][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (mid &gt;&gt; <span class="number">1</span>); i++) &#123;</span><br><span class="line">            wn[<span class="number">1</span>][step][i] = (LL)wn[<span class="number">1</span>][step][i - <span class="number">1</span>] * a % mod;</span><br><span class="line">            wn[<span class="number">0</span>][step][i] = (LL)wn[<span class="number">0</span>][step][i - <span class="number">1</span>] * b % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">GetR</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    a -= b; <span class="keyword">return</span> a &lt; <span class="number">0</span> ? a + mod : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    a += b, a -= a &gt;= mod ? mod : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> len, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>, step = <span class="number">0</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>, step++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, w = <span class="number">1</span>, t; j &lt; i + (mid &gt;&gt; <span class="number">1</span>); j++, w = wn[type][step][j - i])</span><br><span class="line">                t = (LL)a[j + (mid &gt;&gt; <span class="number">1</span>)] * w % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = Sub(a[j], t), Inc(a[j], t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!type) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, inv = Pow(len, mod - <span class="number">2</span>); i &lt; len; i++)</span><br><span class="line">        a[i] = (LL)a[i] * inv % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.size() + b.size() - <span class="number">2</span>, len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    GetR(len, l), a.resize(len), b.resize(len);</span><br><span class="line">    NTT(a, len, <span class="number">1</span>), NTT(b, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) a[i] = (LL)a[i] * b[i] % mod;</span><br><span class="line">    NTT(a, len, <span class="number">0</span>), a.resize(min(n + <span class="number">1</span>, m + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">Pow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; base, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, base = mul(base, base)) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = mul(res, base);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m); <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; base = &#123;<span class="number">2</span>&#125;; frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= m * <span class="number">2</span>) len &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    pre(len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">        base.push_back(inv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    base = Pow(base, n); <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">        res = (res + (LL)a * base[i] % mod * frac[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-橡树上的逃亡"><a href="#T2-橡树上的逃亡" class="headerlink" title="T2 橡树上的逃亡"></a>T2 橡树上的逃亡</h1><p>有一棵$n$个点的树，保证父亲节点的编号小于儿子的编号，同时每棵子树的编号是连续的。$q$次询问，每次询问给出$L, R,k$，表示如果随机从编号在$L,R$中的叶子中选$k$次点，这些点的虚树边数的期望是多少。强制在线。</p><script type="math/tex; mode=display">n, q\leq 2\times 10^5</script><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>对于树上的每一条边，我们考虑它出现在虚树中的概率。显然虚树大小的期望就等于每条边出现的概率之和。</p><p>对于一条边$(u,v)$，如果$u$的子树内编号在$[L,R]$中的叶子有$a$个，子树外编号合法的叶子有$b$个，那么这条边出现的概率就是</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>5.30联测</title>
      <link href="/2020/06/09/5-30%E8%81%94%E6%B5%8B/"/>
      <url>/2020/06/09/5-30%E8%81%94%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-最大公约数"><a href="#T1-最大公约数" class="headerlink" title="T1 最大公约数"></a>T1 最大公约数</h1><p>给定$n$，求</p><script type="math/tex; mode=display">\sum_{i=1}^n\sum_{j=1}^n\frac{i}{\gcd(i,j)}</script><p>其中$n\leq 10^{10}$</p><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先反演一波</p><script type="math/tex; mode=display">\begin{aligned}\sum_{i=1}^n\sum_{j=1}^n\frac{i}{\gcd(i,j)}&=\sum_{d=1}^n\sum_{i=1}^{n/d}i\sum_{j=1}^{n/d}[\gcd(i,j)=1]\\&=\sum_{d=1}^n\sum_{i=1}^{n/d}i\sum_{j=1}^{n/d}\sum_{l\mid \gcd(i,j)}\mu(l)\\&=\sum_{d=1}^n\sum_{l=1}^{n/d}\mu(l)\times l\sum_{i=1}^{n/dl}i\times(n/dl)\end{aligned}</script><p>记$T=dl$，有</p><script type="math/tex; mode=display">\begin{aligned}F(n) &= n\times \sum_{i=1}^ni\\ans &= \sum_{d=1}^n\sum_{l=1}^{n/d}\mu(l)\times l\times F(n/dl)\\&= \sum_{T=1}^nF(\lfloor\frac{n}{T}\rfloor)\sum_{d\mid T}\mu (d)\times d\end{aligned}</script><p>对于$T$已经可以直接分块了，关键在于如何求出后面那个函数的前缀和。</p><p>形式化地说，有一个函数</p><script type="math/tex; mode=display">f(n)=\sum_{d|n}\mu(d)\times d</script><p>我们需要求出$f(n)$的前缀和，即</p><script type="math/tex; mode=display">S(n)=\sum_{i=1}^nf(i)</script><p>回忆一下杜教筛的过程，我们需要找到一个函数$g(n)$，然后</p><script type="math/tex; mode=display">\begin{aligned}\sum_{i=1}^n(g*f)(i) &= \sum_{i=1}^n\sum_{d|i}g(d)f(\frac{i}{d})\\&= \sum_{d=1}^ng(d)\sum_{i=1}^{n/d}f(i)\\&= \sum_{d=1}^ng(d)S(\lfloor\frac{n}{d}\rfloor)\\g(1)S(n) &= \sum_{i=1}^n(g*f)(i)-\sum_{d=2}^ng(d)S(\lfloor\frac{n}{d}\rfloor)\end{aligned}</script><p>我们记$h(n)=\mu(n)\times n$，那么$f=1 * h$</p><p>如果$g(n)=n$，那么</p><script type="math/tex; mode=display">\begin{aligned}(g*h)(n)&=\sum_{i|n}\mu(i)\times i\times \frac{n}{i}=n\times \sum_{i|n}\mu(i)\\&= e\end{aligned}</script><p>因此$f<em>g=1</em>h<em>g=1</em>(h*g)=1$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(LL l, LL r)</span> </span>&#123;</span><br><span class="line">    l %= mod, r %= mod;</span><br><span class="line">    <span class="keyword">return</span> (LL)(l + r) * (r - l + <span class="number">1</span>) / <span class="number">2</span> % mod;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N], B[N]; LL n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(LL t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &lt;= n / t) <span class="keyword">return</span> A[t];</span><br><span class="line">    <span class="keyword">return</span> B[n / t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">(LL t, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &lt;= n / t) A[t] = val;</span><br><span class="line">    <span class="keyword">else</span> B[n / t] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag[N], prime[N], tot, mu[N], F[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N - <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag[i]) prime[++tot] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt;= N - <span class="number">10</span>; j++) &#123;</span><br><span class="line">            flag[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            mu[i * prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N - <span class="number">10</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= N - <span class="number">10</span>; j += i) </span><br><span class="line">            F[j] += i * mu[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N - <span class="number">10</span>; i++) </span><br><span class="line">        F[i] = (F[i - <span class="number">1</span>] + F[i]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(LL t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &lt;= N - <span class="number">10</span>) <span class="keyword">return</span> F[t];</span><br><span class="line">    <span class="keyword">int</span> tmp = get(t);</span><br><span class="line">    <span class="keyword">if</span> (tmp) <span class="keyword">return</span> tmp;</span><br><span class="line">    <span class="keyword">int</span> res = t % mod;</span><br><span class="line">    <span class="keyword">for</span> (LL l = <span class="number">2</span>, r; l &lt;= t; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = t / (t / l);</span><br><span class="line">        res = (res - (LL)calc(l, r) * solve(t / l)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    res = (res + mod) % mod;</span><br><span class="line">    <span class="keyword">return</span> store(t, res), res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n), sieve(); <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (LL l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = n / (n / l); LL h = n / l; </span><br><span class="line">        res = (res + (LL)h % mod * calc(<span class="number">1</span>, h) % mod * (solve(r) - solve(l - <span class="number">1</span>))) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    res = (res + mod) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-凸包的价值"><a href="#T2-凸包的价值" class="headerlink" title="T2 凸包的价值"></a>T2 凸包的价值</h1><div class="pdfobject-container" data-target="problem_121.pdf" data-height="500px"></div><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>题目中两个凸包不同当且仅当凸包上的边不同，考虑一个凸包对答案的贡献。</p><p>假设这个凸包边上、内部、外面分别有$x,y,z$个点，显然有$x+y+z=n$。</p><p>根据定义，这个凸包的价值为</p><script type="math/tex; mode=display">xa^xb^yc^z</script><p>注意到$b=a+c$，二项式定理展开</p><script type="math/tex; mode=display">\begin{aligned}xa^xb^yc^z&=x\sum_{i=0}^y{y\choose i}a^{x+i}c^{z+y-i}\\&= x\sum_{i=0}^y{y\choose i}a^{x+i}c^{n-(x+i)}\end{aligned}</script><p>考虑这个式子的组合意义，此时我们定义一种新的凸包，两个凸包不同当且仅当凸包边上或者凸包内部的点不同。如果这个凸包一共有$x+i$个点，那么它对答案的贡献就是$a^{x+i}c^{n-(x+i)}$。</p><p>同时，如果这个凸包边上有$x$条边，那么这个凸包对答案的贡献就要乘上$x$。</p><p>我们可以理解为每条边都对答案有一次贡献。</p><p>问题转化为对于每条边，求出有多少个恰有$m$个点的凸包，使得这条边出现在这个凸包上。</p><p>如果枚举这条边，那么凸包上剩下的点只能在这条直线的一侧，这里我们认为是左侧，同时我们认为$a\rightarrow b$与$b\rightarrow a$是不同的边。</p><p>如果枚举剩下的点，统计有多少个点在这条直线的左侧，我们就得到了一个$n^3$的算法。</p><p>如果我们固定这条边的一个端点，将剩下的所有点按照到这个端点的极角从小到大排序，那么直接双指针就可以了。</p><p>同时这道题中可能出现三点共线的情况，需要特殊考虑。解决方法是统计的时候顺便记录下在一条直线上的凸包的总数，最后直接用凸包总数减去这个就可以了。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N], C[N], ct[N], ct1[N], id[N], ans[N], n;</span><br><span class="line"></span><br><span class="line">P p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> P <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> P(p[a].x - p[b].x, p[a].y - p[b].y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    P t1 = sub(b, a), t2 = sub(c, a);</span><br><span class="line">    <span class="keyword">if</span> ((LL)t1.x * t2.y - (LL)t1.y * t2.x != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(p[c].x - p[a].x) + <span class="built_in">abs</span>(p[b].x - p[c].x) == <span class="built_in">abs</span>(p[b].x - p[a].x) &amp;&amp; <span class="built_in">abs</span>(p[c].y - p[a].y) + <span class="built_in">abs</span>(p[b].y - p[c].y) == <span class="built_in">abs</span>(p[b].y - p[a].y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> fuck[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (i != t) id[++tot] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (i != t) </span><br><span class="line">        fuck[i] = <span class="built_in">atan2</span>(p[i].y - p[t].y, p[i].x - p[t].x);</span><br><span class="line">    sort(id + <span class="number">1</span>, id + tot + <span class="number">1</span>, [&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">double</span> A = fuck[a], B = fuck[b];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(A - B) &gt; <span class="number">1e-6</span>) <span class="keyword">return</span> A &gt; B;</span><br><span class="line">        P t1 = sub(a, t), t2 = sub(b, t);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(t1.x) &gt; <span class="built_in">abs</span>(t2.x) || <span class="built_in">abs</span>(t1.y) &gt; <span class="built_in">abs</span>(t2.y);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, pos = <span class="number">1</span>, nw = <span class="number">0</span>, t1 = <span class="number">0</span>; i &lt;= tot; i++, nw--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == i - <span class="number">1</span> &amp;&amp; nw &lt; <span class="number">0</span>) pos = i, nw = t1 = <span class="number">0</span>;</span><br><span class="line">        P delta = sub(id[i], t);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span> || !check(t, id[i - <span class="number">1</span>], id[i])) t1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> t1++;</span><br><span class="line">        delta = P(-delta.x, -delta.y);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">233</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> nxt = pos == tot ? <span class="number">1</span> : pos + <span class="number">1</span>;</span><br><span class="line">            P tmp = sub(id[nxt], t);</span><br><span class="line">            LL cross = (LL)tmp.x * delta.y - (LL)tmp.y * delta.x;</span><br><span class="line">            <span class="keyword">if</span> (cross &gt; <span class="number">0</span> || nxt == i) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (cross == <span class="number">0</span> &amp;&amp; !check(t, id[i], id[nxt])) <span class="keyword">break</span>;</span><br><span class="line">            pos = nxt, nw++;</span><br><span class="line">        &#125;</span><br><span class="line">        ct[nw + <span class="number">2</span>]++, ct1[t1 + <span class="number">2</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C1</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); <span class="keyword">int</span> a, b, c; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    A[<span class="number">0</span>] = C[<span class="number">0</span>] = frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        A[i] = (LL)A[i - <span class="number">1</span>] * a % mod, C[i] = (LL)C[i - <span class="number">1</span>] * c % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        process(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">3</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = C1(i - <span class="number">2</span>, j - <span class="number">2</span>);</span><br><span class="line">            ans[j] = (ans[j] + (LL)w * (ct[i] - ct1[i])) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">        res = (res + (LL)A[i] * ans[i] % mod * C[n - i]) % mod;</span><br><span class="line">    res = (res + mod) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-交通网络"><a href="#T3-交通网络" class="headerlink" title="T3 交通网络"></a>T3 交通网络</h1><div class="pdfobject-container" data-target="problem_122.pdf" data-height="500px"></div><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>假设现在已经确定好了最终会保留哪些“高速公路”，且这些高速公路一共形成了$k$个连续段。</p><p>此时实际上我们已经默认有了以下限制：如果$(i,i+1)$之间的高速公路被断掉了，那么我们之后也不能连上这条边。</p><p>我们先暂且不管这一条限制，那么问题转化为：有一张完全图，其中第$i$个点的点权为$a_i$，一条边的边权为两个端点的权值的乘积，问所有生成树的边权的乘积之和。</p><p>考虑这颗生成树的<code>prufer</code>序，显然每个点在<code>prufer</code>序上出现了度数$-1$次，一个点的贡献是$a_i^{d_i}$，其中$d_i$是这个点的度数。</p><p>由于$\sum a_i=n$且<code>prufer</code>序长度为$n-2$，因此这个问题的答案为$n^{n-2}\times \prod a_i$。</p><p>记$f_i$表示钦定有$i-1$条高速公路可能会被断开，剩下的高速公路一定不会被断开，即至多形成$i$个连续段的方案数。</p><p>记$g_i$表示恰好有$i-1$条高速公路被断开，即恰好形成$i$个连续段的方案数。</p><p>由于一共有$n-1$条高速公路，因此有</p><script type="math/tex; mode=display">f_i=\sum_{j\leq i}g_j{n-j\choose i-j}</script><p>对于一个恰有$j$个连续段的$g$来说，它可以从剩下的$n-j$条边中选出$i-j$条边，假装这些边断开了。</p><p>代入二项式反演，我们可以得到</p><script type="math/tex; mode=display">g_i=\sum_{j\leq i}f_j(-1)^{i-j}{n-j\choose i-j}</script><p>考虑如何计算$f$。</p><p>可以发现，关键在于如何求出对于$n$的每种划分，每个集合大小的乘积。</p><p>形式化地说，我们要求出不定方程$x_1+x_2+\cdots +x_k=n$的解的数量，其中$x_1,x_2\cdots x_k$均是正整数。每种解对答案贡献是$\prod x_i$。</p><p>这是一个经典问题，可以参考下面这个ppt里“青春猪头少年不会梦到兔女郎学姐”这道题以及前面的组合数部分。</p><div class="pdfobject-container" data-target="main.pdf" data-height="500px"></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N &lt;&lt; <span class="number">1</span>], g[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, w = <span class="number">1</span>, t; j &lt; i + (mid &gt;&gt; <span class="number">1</span>); j++, w = (LL)w * Wn % mod)</span><br><span class="line">                t = (LL)a[j + (mid &gt;&gt; <span class="number">1</span>)] * w % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (!type) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, inv = Pow(len, mod - <span class="number">2</span>); i &lt; len; i++)</span><br><span class="line">        a[i] = (LL)a[i] * inv % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++) </span><br><span class="line">        frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    inv[n * <span class="number">2</span>] = Pow(frac[n * <span class="number">2</span>], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n * <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) inv[i] = (LL)inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        f[i] = (LL)C(n + i - <span class="number">1</span>, i * <span class="number">2</span> - <span class="number">1</span>) * Pow(n, i == <span class="number">1</span> ? mod - <span class="number">2</span> : i - <span class="number">2</span>) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i] = (LL)f[i] * frac[n - i] % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) g[i] = i &amp; <span class="number">1</span> ? mod - inv[i] : inv[i];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n * <span class="number">2</span>) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    NTT(f, len, <span class="number">1</span>), NTT(g, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) f[i] = (LL)f[i] * g[i] % mod;</span><br><span class="line">    NTT(f, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i] = (LL)f[i] * inv[n - i] % mod;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, pw = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        pw = pw * <span class="number">2</span> % mod;</span><br><span class="line">        res = (res + (LL)pw * f[n - i] % mod * i) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫比乌斯反演 </tag>
            
            <tag> 计算几何 </tag>
            
            <tag> 多项式 </tag>
            
            <tag> 杜教筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.29联测</title>
      <link href="/2020/06/08/5-29%E8%81%94%E6%B5%8B/"/>
      <url>/2020/06/08/5-29%E8%81%94%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-倾尽天下"><a href="#T1-倾尽天下" class="headerlink" title="T1 倾尽天下"></a>T1 倾尽天下</h1><p>有一个数组$a_i$，满足$a_1=0,a_{ij}=a_i\oplus a_j$。可以看出，只要确定了所有质数下标的$a$就能确定整个序列。一开始整个数组都是$0$，有$q$次操作，每次给定一个值$p$，表示翻转$a_p$的值，保证$p$是质数。在每次操作之后都需要回答序列的前$n$项有多少个$1$。</p><script type="math/tex; mode=display">n,q\leq 2\times 10^5</script><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>有两种做法。</p><p>第一种做法是直接对较小的质数维护一个<code>bitset</code>，为$1$的位置就表示这个质数对这个位置有贡献。对于一次询问，如果它操作的是一个较小的质数，那么直接将所有数异或上这个<code>bitset</code>即可；否则暴力模拟操作，需要卡一下常。</p><p>第二种做法比较奇妙。由于此函数是完全积性函数，因此我们考虑维护$\sqrt n$个点值$f_{\frac{n}{1}},f_{\frac{n}{2}},\cdots$，其中$f_i$表示前$i$个位置$1$的个数之和，显然答案就是$f_n$。</p><p>考虑一次操作对$f$的影响。考虑去除$a_p$对答案的影响，修改完$a_p$之后再重新考虑回来。如果在操作之前，$a_p=1$，那么有$f’_n=f_n-(\lfloor\frac{n}{p}\rfloor-f_{\lfloor\frac{n}{p}\rfloor})$，即原来序列的前$\lfloor\frac{n}{p}\rfloor$项中所有为$0$的位置都会对$f_n$产生$1$的贡献。当$a_p=0$时贡献类似。</p><p>由于维护了$\sqrt n$个点值，一次修改会影响到所有的点值，因此复杂度为$O(n\sqrt n)$</p><p>下面是第一种做法的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag[N], prime[N], tot, id[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag[i]) id[i] = ++tot, prime[tot] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt;= <span class="number">100</span>; j++) &#123;</span><br><span class="line">            flag[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = (N &gt;&gt; <span class="number">6</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WEN</span> &#123;</span></span><br><span class="line"></span><br><span class="line">LL val[SZ + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> ^= (<span class="keyword">const</span> WEN &amp;b) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= SZ; i++) val[i] ^= b.val[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">operator</span> [] (<span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">int</span> base = x &gt;&gt; <span class="number">6</span>, t = x &amp; <span class="number">63</span>;</span><br><span class="line">    <span class="keyword">return</span> val[base] &gt;&gt; t &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= SZ; i++) res += __builtin_popcountll(val[i]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> base = x &gt;&gt; <span class="number">6</span>, t = x &amp; <span class="number">63</span>;</span><br><span class="line">    val[base] ^= <span class="number">1u</span>ll &lt;&lt; t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; mask[<span class="number">100</span>], num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, q; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q); sieve();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = prime[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span> (j % t == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> ct = <span class="number">0</span>, tmp = j;</span><br><span class="line">            <span class="keyword">while</span> (tmp % t == <span class="number">0</span>) tmp /= t, ct ^= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (ct) mask[i].flip(j); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> p; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p);</span><br><span class="line">        <span class="keyword">if</span> (p &gt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = p; i &lt;= n; i += p) &#123;</span><br><span class="line">                <span class="keyword">int</span> ct = <span class="number">0</span>, tmp = i;</span><br><span class="line">                <span class="keyword">while</span> (tmp % p == <span class="number">0</span>) tmp /= p, ct ^= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (ct) ans -= num[i], num.flip(i), ans += num[i];</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">else</span> num ^= mask[id[p]], ans = num.count();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-春风一顾"><a href="#T2-春风一顾" class="headerlink" title="T2 春风一顾"></a>T2 春风一顾</h1><p><a href="https://planarg.top/2020/03/04/agc021f-trinity/" target="_blank" rel="noopener">原题链接</a></p><h1 id="T3-陌上花早"><a href="#T3-陌上花早" class="headerlink" title="T3 陌上花早"></a>T3 陌上花早</h1><p>有$n$个物品，每个物品有一个$[1,K]$之间的颜色$c_i$，也有一个权值$v_i$。</p><p>你希望选择$x$个物品，同时对于任意的颜色$i$都要满足，如果存在颜色为$i$的物品被选中，那么这样的物品至少有两个。你需要最大化总权值和。</p><p>对于$x\in [1, n]$输出答案，无解输出$-1$。</p><script type="math/tex; mode=display">n\leq 2\times 10^5,K\leq \frac{n}{2},0\leq v_i\leq 10^9</script><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>首先对于每种颜色将所有的物品按照权值从大到小排序，显然我们会优先取大的。</p><p>考虑可撤销贪心，有以下几种情况：</p><ul><li>某一种已经至少取了两个物品的颜色又取了一个物品。</li><li>某一种至少取了三个物品的颜色抛掉一个物品，同时新开一种颜色。</li><li>某一种恰好取了两个物品的颜色不要了，同时新开一种颜色，一次性取三个物品。</li><li>某一种恰好取了三个物品的颜色不要了，同时新开两种颜色，每种颜色各取两个物品。</li></ul><p>对于其它情况，可以证明它一定没有以上几种情况更加优秀。举个例子，一定不会出现丢掉三个，然后一次性拿四个的情况。</p><p>我们不妨设这三个物品的权值为$a_1, a_2,a_3$，另外四个物品权值为$b_1,b_2,b_3,b_4$（从大到小排序）。</p><p>接下来，我们证明：它一定没有从$a$中拿两个，从$b$中拿两个优秀。</p><p>如果这种方案更劣，那么说明$a_1+a_2&lt;b_3+b_4$。</p><p>一开始我们取了$a$中的前三个，说明$a_1+a_2+a_3&gt;b_1+b_2+b_3$，而由于$a_1+a_2<b_3+b_4$，因此有$a_1+a_2<b_1+b_2$，从而$a_3>b_3$。</p><p>而这可以推出$a_1&gt;b_3,a_2&gt;b_3$，与$a_1+a_2&lt;b_3+b_4$矛盾。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span>&lt;P&gt; S1, S2, S3, S4, S5, S6;</span><br><span class="line"></span><br><span class="line"><span class="comment">// S4: 所有只取了两个的堆; S5: 所有取了 &gt;= 3 个的堆的堆顶 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num[N]; <span class="keyword">int</span> pos[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos[x] == <span class="number">2</span> &amp;&amp; <span class="number">2</span> &lt; num[x].size()) S1.erase(P(num[x][<span class="number">2</span>], x)), S4.erase(P(num[x][<span class="number">0</span>] + num[x][<span class="number">1</span>], x));</span><br><span class="line">    S2.insert(P(num[x][<span class="number">0</span>] + num[x][<span class="number">1</span>], x));</span><br><span class="line">    <span class="keyword">if</span> (num[x].size() &gt;= <span class="number">3</span>) S3.insert(P((LL)num[x][<span class="number">0</span>] + num[x][<span class="number">1</span>] + num[x][<span class="number">2</span>], x));</span><br><span class="line">    pos[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    S2.erase(S2.find(P(num[x][<span class="number">0</span>] + num[x][<span class="number">1</span>], x))), S4.insert(P(num[x][<span class="number">0</span>] + num[x][<span class="number">1</span>], x));</span><br><span class="line">    <span class="keyword">if</span> (num[x].size() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        S3.erase(S3.find(P((LL)num[x][<span class="number">0</span>] + num[x][<span class="number">1</span>] + num[x][<span class="number">2</span>], x)));</span><br><span class="line">        S1.insert(P(num[x][<span class="number">2</span>], x));</span><br><span class="line">    &#125;</span><br><span class="line">    pos[x] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos[x] == <span class="number">2</span>) S4.erase(S4.find(P(num[x][<span class="number">0</span>] + num[x][<span class="number">1</span>], x))), S6.insert(P((LL)num[x][<span class="number">0</span>] + num[x][<span class="number">1</span>] + num[x][<span class="number">2</span>], x));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pos[x] == <span class="number">3</span>) S6.erase(S6.find(P((LL)num[x][<span class="number">0</span>] + num[x][<span class="number">1</span>] + num[x][<span class="number">2</span>], x)));</span><br><span class="line">    S1.erase(P(num[x][pos[x]], x)), S5.insert(P(num[x][pos[x]], x));</span><br><span class="line">    <span class="keyword">if</span> (pos[x] &gt; <span class="number">2</span>) S5.erase(P(num[x][pos[x] - <span class="number">1</span>], x));</span><br><span class="line">    <span class="keyword">if</span> (pos[x] + <span class="number">1</span> &lt; num[x].size()) S1.insert(P(num[x][pos[x] + <span class="number">1</span>], x));</span><br><span class="line">    pos[x]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos[x] == <span class="number">3</span>) S4.insert(P(num[x][<span class="number">0</span>] + num[x][<span class="number">1</span>], x)), S6.erase(S6.find(P((LL)num[x][<span class="number">0</span>] + num[x][<span class="number">1</span>] + num[x][<span class="number">2</span>], x))); </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos[x] == <span class="number">4</span>) S6.insert(P((LL)num[x][<span class="number">0</span>] + num[x][<span class="number">1</span>] + num[x][<span class="number">2</span>], x));</span><br><span class="line">        S5.insert(P(num[x][pos[x] - <span class="number">2</span>], x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos[x] &lt; num[x].size()) S1.erase(S1.find(P(num[x][pos[x]], x)));</span><br><span class="line">    S1.insert(P(num[x][pos[x] - <span class="number">1</span>], x)), S5.erase(S5.find(P(num[x][pos[x] - <span class="number">1</span>], x)));</span><br><span class="line">    pos[x]--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t, v; i &lt;= n; i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;t, &amp;v), num[t].push_back(v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) <span class="keyword">if</span> (num[i].size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        sort(num[i].begin(), num[i].end(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> a &gt; b; &#125;);</span><br><span class="line">        insert(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">    LL res = S2.rbegin() -&gt; first; erase(S2.rbegin() -&gt; second);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res); <span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        LL A = <span class="number">-1e18</span>, B = A, C = A, D = A;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!S2.size()) &#123; <span class="built_in">puts</span>(<span class="string">"-1"</span>); <span class="keyword">continue</span>; &#125;</span><br><span class="line">            res += S2.rbegin() -&gt; first, erase(S2.rbegin() -&gt; second), flag = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (S2.size() &amp;&amp; S5.size()) A = S2.rbegin() -&gt; first - S5.begin() -&gt; first;</span><br><span class="line">        <span class="keyword">if</span> (S1.size()) B = S1.rbegin() -&gt; first;</span><br><span class="line">        <span class="keyword">if</span> (S3.size() &amp;&amp; S4.size()) C = S3.rbegin() -&gt; first - S4.begin() -&gt; first;</span><br><span class="line">        <span class="keyword">if</span> (S2.size() &gt;= <span class="number">2</span> &amp;&amp; S6.size()) D = S2.rbegin() -&gt; first + (++S2.rbegin()) -&gt; first - S6.begin() -&gt; first;</span><br><span class="line">        <span class="keyword">if</span> (max(max(A, B), max(C, D)) &lt; <span class="number">-1e17</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"-1"</span>), flag = <span class="number">0</span>; <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (A &gt;= B &amp;&amp; A &gt;= C &amp;&amp; A &gt;= D) &#123;</span><br><span class="line">            <span class="keyword">int</span> from = S5.begin() -&gt; second, to = S2.rbegin() -&gt; second;</span><br><span class="line"><span class="comment">//            cerr &lt;&lt; "A: " &lt;&lt; from &lt;&lt; ' ' &lt;&lt; to &lt;&lt; endl;</span></span><br><span class="line">            down(from), erase(to), res += A;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (B &gt;= A &amp;&amp; B &gt;= C &amp;&amp; B &gt;= D) &#123;</span><br><span class="line">            <span class="keyword">int</span> from = S1.rbegin() -&gt; second;</span><br><span class="line"><span class="comment">//            cerr &lt;&lt; "B: " &lt;&lt; from &lt;&lt; endl;</span></span><br><span class="line">            up(from), res += B;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (C &gt;= A &amp;&amp; C &gt;= B &amp;&amp; C &gt;= D) &#123;</span><br><span class="line">            <span class="keyword">int</span> from = S4.begin() -&gt; second, to = S3.rbegin() -&gt; second;</span><br><span class="line"><span class="comment">//            cerr &lt;&lt; "C: " &lt;&lt; from &lt;&lt; ' ' &lt;&lt; to &lt;&lt; endl;</span></span><br><span class="line">            insert(from), erase(to), up(to), res += C;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> from = S6.begin() -&gt; second, to1 = S2.rbegin() -&gt; second, to2 = (++S2.rbegin()) -&gt; second;</span><br><span class="line"><span class="comment">//            cerr &lt;&lt; "fuck: " &lt;&lt; from &lt;&lt; ' ' &lt;&lt; to1 &lt;&lt; ' ' &lt;&lt; to2 &lt;&lt; endl;</span></span><br><span class="line">            down(from), insert(from), erase(to1), erase(to2), res += D;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        cerr &lt;&lt; S4.begin() -&gt; second &lt;&lt; ' ' &lt;&lt; S3.rbegin() -&gt; second &lt;&lt; endl;</span></span><br><span class="line">     <span class="comment">//   cerr &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 多项式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.27联测</title>
      <link href="/2020/06/04/5-27%E8%81%94%E6%B5%8B/"/>
      <url>/2020/06/04/5-27%E8%81%94%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-矩阵"><a href="#T1-矩阵" class="headerlink" title="T1 矩阵"></a>T1 矩阵</h1><p>有一个$n\times m$的$01$矩阵$A$。</p><p>如果矩阵的第$i$列有奇数个$1$，那么它的权值就是$a_i3^{b_i}$，否则是$0$，一个矩阵的权值为每一列的权值之和。</p><p>你可以删去矩阵的若干行，使得最终矩阵的权值最大。</p><p>对于任意的$i,j$，保证$a_i\neq a_j$或$b_i\neq b_j$。</p><script type="math/tex; mode=display">n\leq 2\times 10^5, m\leq 70,a_i=\pm 1,1\leq b_i\leq 35</script><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>我们将所有列按照$b_i$从大到小排序，并且将$b_i$相同的列归为一类。那么最优的方案一定是尽量让排在前面的列的$a_i$尽量大，因为就算这一列的$a_i=1$，后面所有列的$a_i$都取$-1$，也不会劣于这一列$a_i$取$0$，后面所有列$a_i=1$。</p><p>我们记$c_i$为第$i$列最终的系数。如果这一列保留了奇数个$1$，那么$c_i=a_i$，否则$c_i=0$。</p><p>接着我们贪心地确定每一类的$c_i$，我们需要保证至少存在一种保留行的方式，使得可以异或出当前方案。</p><p>将每一行看作一个二进制数扔进线性基，每次枚举当前这一类的最终取值时就放到线性基里面查，如果存在一种方案可以异或出这个前缀就说明这种方案是可行的。</p><p>为方便起见，下面我们称“行”为线性基里面的某一行。</p><p>接下来我们仅讨论$b_i=b_{i+1}$的情况，分两种情况讨论。</p><p>第一种：仅有一种方案使得$c_i+c_{i+1}$最大，直接取这种方案即可。</p><p>第二种：有两种方案使得$c_i+c_{i+1}$最大，由于$a_i=1,a_{i+1}=-1$，因此此时的两种方案分别为：取这两列，或者不取这两列。</p><p>可以发现无论取或不取对当前这两行的答案不会有任何影响，但是如果取的话会导致后面的列异或上一个值。对于后面的列来说，这个值可以取，也可以不取。因此，我们将这两行异或之后抠掉第$i$位和第$i+1$位的值扔进线性基即可。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bitset</span>&lt;70&gt; base[<span class="number">70</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">bitset</span>&lt;<span class="number">70</span>&gt; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (s[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (base[i].any()) s ^= base[i];</span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) <span class="keyword">if</span> (base[j][i]) </span><br><span class="line">                base[j] ^= s;</span><br><span class="line">            base[i] = s;     </span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">bitset</span>&lt;<span class="number">70</span>&gt; tmp, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= cur; i--) <span class="keyword">if</span> (tmp[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (base[i].any()) tmp ^= base[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">200010</span>][<span class="number">75</span>]; <span class="keyword">int</span> a[<span class="number">70</span>], b[<span class="number">70</span>], id[<span class="number">70</span>];</span><br><span class="line"></span><br><span class="line">LL pw3[<span class="number">36</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen("ex_matrix1.in", "r", stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m), pw3[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">35</span>; i++) pw3[i] = pw3[i - <span class="number">1</span>] * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i]); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a[i], &amp;b[i]), id[i] = i;</span><br><span class="line">    sort(id, id + m, [](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i] != b[j]) <span class="keyword">return</span> b[i] &lt; b[j];</span><br><span class="line">        <span class="keyword">return</span> a[i] &lt; a[j];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">bitset</span>&lt;70&gt; nw;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) nw[j] = s[i][id[j]] == <span class="string">'1'</span>;</span><br><span class="line">        insert(nw);</span><br><span class="line">    &#125;</span><br><span class="line">    LL res = <span class="number">0</span>; <span class="built_in">bitset</span>&lt;70&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; b[id[i]] == b[id[i - <span class="number">1</span>]]) &#123;</span><br><span class="line">            <span class="keyword">int</span> mx = <span class="number">-2</span>, ct = <span class="number">0</span>, ss = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">4</span>; s++) &#123;</span><br><span class="line">                ans[i] = s &amp; <span class="number">1</span>, ans[i - <span class="number">1</span>] = s &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (!check(ans, i - <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (ans[i] - ans[i - <span class="number">1</span>] == mx) ct++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ans[i] - ans[i - <span class="number">1</span>] &gt; mx) </span><br><span class="line">                    mx = ans[i] - ans[i - <span class="number">1</span>], ct = <span class="number">1</span>, ss = s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ct == <span class="number">1</span>) ans[i] = ss &amp; <span class="number">1</span>, ans[i - <span class="number">1</span>] = ss &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp = base[i] ^ base[i - <span class="number">1</span>]; </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= i - <span class="number">1</span>; j--) tmp[j] = <span class="number">0</span>;</span><br><span class="line">                insert(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[id[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">                ans[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (!check(ans, i)) ans[i] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!check(ans, i)) ans[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        res += ans[i] * a[id[i]] * pw3[b[id[i]]];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-树"><a href="#T2-树" class="headerlink" title="T2 树"></a>T2 树</h1><p>给定一棵大小为$n$，以$1$为根的树，每条边的初始权值为$c_i$，单位修改代价为$d_i$。将一条边 $i$ 的权值修改为 $X$($X$ 必须为整数，但可以为负) 的代价为 $d_i \times |c_i − X|$。</p><p>你可以任意调整每条边的权值，使得从根节点到每个叶子的距离都相等，请你求出最小代价, 并输出一种方案。</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>没啥好说的，直接维护凸函数。</p><p><img src="5-27联测/image-20200604102056550.png" alt="image-20200604102056550"></p><p>因为太难写了所以鸽了。</p><h2 id="T3-向量"><a href="#T3-向量" class="headerlink" title="T3 向量"></a>T3 向量</h2><p>给定一棵$n$个点的树，你需要给每个点分配一个$m$维的向量（$m$自己定，但不能超过$16$）$p_{1,i},p_{2,i},\cdots,p_{m,i}$，使得对于树上的任意两点$i,j$，$i,j$之间的距离都等于$\max_{k=1}^m\{|p_{k,i}-p_{k,j}|\}$。</p><script type="math/tex; mode=display">n\leq 1000,|p|\leq 10^9</script><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>考虑在忽略那个 $\max$ 的情况下怎么整。即，对于 $i,j$ 至少要出现一个 $k$ 使得 $|p_{k,i}-p_{k,j}|$ 是 $i,j$ 之间的实际距离。一个很显然的想法是，直接边分，在边分的时候为一侧的点赋上到中心边的距离，另一侧的点赋上到中心边距离的相反数，这样对于任意一条跨过中心边的路径，有正的那一侧减去负的那一侧等于实际距离。边分后反复分治下去，这样分治的层数不会超过 $\log$ 层。</p><p>这样做存在一个问题：对于一次边分分出的两边，下一层在中心边两侧的点可能出现绝对值之差大于中心边长度的情况。</p><p>举个例子</p><p><img src="5-27联测/image-20200604104724279.png" alt="image-20200604104724279"></p><p>假设这张图中边权都是$1$。</p><p>第一次分治时，我们选择了中间那条边，同时将左半边全部标记为负，右半边全部标记为正。第二次和第三次分治时的标记如图所示。那么此时，第二个点到第三个点的距离为$1$，但是$p$的绝对值之差为$2$。</p><p>怎么避免这种情况出现呢？</p><p>观察到，除去在之前边分割掉的边以外，我们在树上经过任何边，$p_k$ 的变化量恰好是边的长度。</p><p>我们还知道，两点之间的距离就是两点之间边的长度和。因此，如果对于每个 $k$，都满足 $p_k$ 在经过一条边的变化量恰好是边的长度的话，对于任意层我们都有 $|p_{k,i}-p_{k,j}|\leq dist(i,j)$。</p><p>所以，我们可以先做一次边分，在做完边分之后我们遍历每一层，在每一层钦定一个点作为起点，当遇到在先前层被割掉的边时我们给另一边的块整体加一个权值，保证在经过割边时 $p_k$ 的变化量恰好是边长即可。</p><p>时间复杂度 $O(n\log n)$。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt; G[N]; <span class="keyword">int</span> id[<span class="number">21</span>][N], tot[<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt = <span class="number">1</span>, ncnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; "adde: " &lt;&lt; from &lt;&lt; ' ' &lt;&lt; to &lt;&lt; ' ' &lt;&lt; w &lt;&lt; endl;</span></span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from], w &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to], w &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last = u, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) <span class="keyword">if</span> (v.first != f) t = v.first;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) <span class="keyword">if</span> (v.first != f) &#123;</span><br><span class="line">        build(v.first, u), adde(last, v.first, v.second);</span><br><span class="line">        <span class="keyword">if</span> (v.first != t) adde(last, ++ncnt, <span class="number">0</span>), last = ncnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mark[N], sz[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tmp, cur;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetEG</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> tot)</span> </span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f &amp;&amp; !mark[i]) &#123;</span><br><span class="line">            GetEG(e[i].to, u, tot), sz[u] += sz[e[i].to];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(tot - <span class="number">2</span> * sz[e[i].to]) &lt; tmp) </span><br><span class="line">                tmp = <span class="built_in">abs</span>(tot - <span class="number">2</span> * sz[e[i].to]), cur = i;</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> layer, t, p[<span class="number">21</span>][N], mx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> dis, <span class="keyword">int</span> sgn)</span> </span>&#123;</span><br><span class="line">    id[layer][u] = t, p[layer][u] = sgn * dis, sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f &amp;&amp; !mark[i]) </span><br><span class="line">            dfs(e[i].to, u, dis + e[i].w, sgn), sz[u] += sz[e[i].to];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Divide</span><span class="params">(<span class="keyword">int</span> dep, <span class="keyword">int</span> ed)</span> </span>&#123;</span><br><span class="line">    t = ++tot[dep], layer = dep, mark[ed] = mark[ed ^ <span class="number">1</span>] = <span class="number">1</span>, mx = max(mx, dep);</span><br><span class="line">    dfs(e[ed].to, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), dfs(e[ed ^ <span class="number">1</span>].to, <span class="number">0</span>, e[ed].w, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">auto</span> find = [&amp;](<span class="keyword">int</span> u) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        cur = <span class="number">-1</span>, tmp = <span class="number">1e9</span>, GetEG(u, <span class="number">0</span>, sz[u]);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> L = find(e[ed].to), R = find(e[ed ^ <span class="number">1</span>].to);</span><br><span class="line">    <span class="keyword">if</span> (~L) Divide(dep + <span class="number">1</span>, L); <span class="keyword">if</span> (~R) Divide(dep + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> layer, <span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> diff)</span> </span>&#123;</span><br><span class="line">    p[layer][u] += diff;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id[layer][e[i].to] != id[layer][u]) dfs1(layer, e[i].to, u, p[layer][u] + e[i].w - p[layer][e[i].to]);</span><br><span class="line">            <span class="keyword">else</span> dfs1(layer, e[i].to, u, diff);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Divide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ncnt = n, build(<span class="number">1</span>, <span class="number">0</span>), tmp = <span class="number">1e9</span>, GetEG(<span class="number">1</span>, <span class="number">0</span>, n), Divide(<span class="number">1</span>, cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b, c; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c), G[a].push_back(P(b, c)), G[b].push_back(P(a, c));</span><br><span class="line">    Divide();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mx; i++) dfs1(i, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mx);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++, <span class="built_in">puts</span>(<span class="string">""</span>)) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= mx; j++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, p[j][i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造 </tag>
            
            <tag> 边分治 </tag>
            
            <tag> splay </tag>
            
            <tag> 线性基 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.25联测</title>
      <link href="/2020/05/26/5-25%E8%81%94%E6%B5%8B/"/>
      <url>/2020/05/26/5-25%E8%81%94%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-序列"><a href="#T1-序列" class="headerlink" title="T1 序列"></a>T1 序列</h1><p>给定一个长度为$n$的序列$a$以及$m$个整数$b_1, b_2,\cdots,b_m$，你要从这$m$个数中选出$i$个数插入$a$中，不能插到头部和尾部，同时$a$中相邻两个数之间最多只能插入一个$b$。你要最大化最终序列相邻两个数之差的绝对值之和，对$1\leq i\leq m$都输出答案。</p><script type="math/tex; mode=display">m\leq n\leq 10^5</script><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>我们记一个空隙左右两边$a$的最大值为$mx$，最小值$mn$。首先无论往这个空隙里面塞啥，或者不塞，这个空隙对答案都至少有$mx-mn$的贡献，因此我们可以先给答案加上这部分贡献。如果这个空隙中塞的数$b_i$大于$mx$，那么贡献为$2(b_i-mx)$；如果塞的数小于$mn$，那么贡献为$2(mn-b_i)$。</p><p>因此，考虑一个显然错误的贪心：我们将$b$从小到大排序，每次尝试拿出最大的未取过的$b$以及最小未取过的$b$，尝试将其塞入空隙。如果取最大的$b$，那么我们要找到所有还没有塞过的空隙中，$mx$最小的空隙；否则则是$mn$最大的空隙。比较一下哪种方案对答案的贡献更大，接着将对应的$b$插入空隙。</p><p>这个贪心错误的原因是，每一步取最优解并不一定是最优秀的，比如以下这种情况：</p><p><img src="5-25联测/image-20200528211533389.png" alt="image-20200528211533389"></p><p>如果按照之前的方法贪心选取，那么最终会得到左边的方案。在第一次选择中，我们会选择最小的$b$，然后将其与左边的第一个间隙匹配；接着只剩下一个$b$和一个间隙，我们会将这两个匹配起来。但是很明显，最优的方案应该是右图，两次匹配都不会匹配最优的空隙。</p><p>考虑优化贪心，从原来的贪心变为可撤销贪心。</p><p>原来的贪心只有两种情况：拿出一个最大的$b$，找到一个空隙；或者拿出一个最小的$b$，找到一个空隙。考虑加上两种情况：拿出一个最大的$b\quad b_{max}$，找到一个已经匹配过的空隙$t$，将$t$中填的$b$取出来，替换为$b_{max}$，同时找到一个未使用过的空隙匹配取出的$b$。</p><p>画出图来大概就是上面右边那张图的情况，接着我们来推一波式子</p><p><img src="5-25联测/image-20200528213330957.png" alt="image-20200528213330957"></p><p>原来的贡献为$mn_1-y$，现在的贡献为$x-mx_2+mn_1-y$，做差可以得到$x-(mn_2+mx_2)+mn_1$。因此我们应该从所有匹配了较小值的空隙中，取出$mn+mx$最小的空隙；从所有未匹配的空隙中，取出$mn$最大的空隙。我们将这种情况称为“用$mx$替换$mn$”，那么与之对应的另一种情况就是用$mn$替换$mx$。</p><p>接着我们证明它的正确性。</p><p>首先我们不可能用$mx$替换$mx$，或者用$mn$替换$mn$，因为这样替换之后贡献是不变的。</p><p>接着我们证明，不会发生连锁替换，即用$x$替换$y$之后，$y$不是寻找一个未匹配的空隙，而是像$x$一样寻找一个填过的$z$并替换$z$。</p><p>下面是来自钟神的证明</p><p>假设发生了一次连锁替换</p><p><img src="5-25联测/image-20200528213715277.png" alt="image-20200528213715277"></p><p>这意味着$x-mx_1+mn_2-y+z-mx_3&gt;x-mx_3+mn_1-y+z-mx_2$。</p><p>即$mn_2-mx_1&gt;mn_1-mx_2$。</p><p>我们给等式两边同时加上$z-y$</p><p>$mn_2-y+z-mx_1&gt;mn_1-y+z-mx_2$，这与$y,z$已是最优匹配矛盾，即之前的方案可以通过互换$y,z$的位置变得更加优秀。</p><p>因此我们维护四个堆：未匹配的$mx$最小的空隙、未匹配的$mn$最大的空隙、匹配过最大值的$mn+mx$最小的空隙、匹配过最小值的$mn+mx$最大的空隙。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N]; <span class="built_in">set</span>&lt;P&gt; s1, s2; <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s, S1, S2;</span><br><span class="line"></span><br><span class="line">LL res[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max(num[pos], num[pos + <span class="number">1</span>]) + min(num[pos], num[pos + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    s2.erase(P(max(num[pos], num[pos + <span class="number">1</span>]), pos));</span><br><span class="line">    s1.erase(P(min(num[pos], num[pos + <span class="number">1</span>]), pos));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen("ex_data1.in", "r", stdin), freopen("out.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> A = min(num[i], num[i + <span class="number">1</span>]), B = max(num[i], num[i + <span class="number">1</span>]);</span><br><span class="line">        s2.insert(P(B, i)), s1.insert(P(A, i)), res[<span class="number">0</span>] += B - A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a; i &lt;= m; i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), s.insert(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = *s.begin(), b = *s.rbegin(), v[<span class="number">4</span>];</span><br><span class="line">        v[<span class="number">0</span>] = S1.size() ? b + s1.rbegin() -&gt; first - *S1.begin() : <span class="number">-1e9</span>;</span><br><span class="line">        v[<span class="number">1</span>] = S2.size() ? -a - s2.begin() -&gt; first + *S2.rbegin() : <span class="number">-1e9</span>;</span><br><span class="line">        v[<span class="number">2</span>] = b - s2.begin() -&gt; first;</span><br><span class="line">        v[<span class="number">3</span>] = s1.rbegin() -&gt; first - a;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) <span class="keyword">if</span> (v[i] &gt; v[pos]) pos = i;</span><br><span class="line">        <span class="keyword">if</span> (v[pos] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= m; j++) res[j] = res[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = res[i - <span class="number">1</span>] + v[pos] * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = *S1.begin(); S1.erase(S1.begin()), S2.insert(t);</span><br><span class="line">            s.erase(s.find(b)), S1.insert(calc(s1.rbegin() -&gt; second)), del(s1.rbegin() -&gt; second);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = *S2.rbegin(); S2.erase(S2.find(t)), S1.insert(t);</span><br><span class="line">            s.erase(s.find(a)), S2.insert(calc(s2.begin() -&gt; second)), del(s2.begin() -&gt; second);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos == <span class="number">2</span>) &#123;</span><br><span class="line">            s.erase(s.find(b)), S2.insert(calc(s2.begin() -&gt; second)), del(s2.begin() -&gt; second);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s.erase(s.find(a)), S1.insert(calc(s1.rbegin() -&gt; second)), del(s1.rbegin() -&gt; second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, res[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-小Z的树"><a href="#T2-小Z的树" class="headerlink" title="T2 小Z的树"></a>T2 小Z的树</h1><p>维护一个森林，每个点都有一个权值，支持三种操作</p><ul><li>$0\ x\ v$：断开$x$与其父亲的连边，并将$x$的权值改为$v$。</li><li>$1\ x\ y$：将$x$的父亲修改为$y$。</li><li>$2\ l\ r$：询问编号在$[l,r]$内的点所在的树的根节点的权值之和（如果根相同，权值会记多次）</li></ul><script type="math/tex; mode=display">n,q\leq 6\times 10^4</script><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>对询问分块，每块内被操作的点数只有$\sqrt n$个，我们将这些被操作的点以及它们的根标记为关键点。可以发现，关键点把原树分成了若干个连通块，每个连通块的答案都是一致的。因此我们对关键点建一棵虚树，虚树上的每个点都代表原树上的一个连通块，在虚树上暴力模拟操作。对于每个连通块，我们将其内部的点按照下标排好序，这样就能$O(\log)$求出一个连通块内部有多少个$[l,r]$之间的点。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">nc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    return getchar();</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">1000000</span>],*p1=buf,*p2=buf;</span><br><span class="line">    <span class="keyword">return</span> p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,<span class="number">1</span>,<span class="number">1000000</span>,<span class="built_in">stdin</span>),p1==p2) ? EOF : *p1++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">    x=<span class="number">0</span>; <span class="keyword">char</span> c=nc(); <span class="keyword">int</span> f=<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) &#123; <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=nc(); &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) x=x*<span class="number">10</span>-<span class="string">'0'</span>+c,c=nc(); x*=f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#pragma GCC optimize("Ofast")</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">1200</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G1[N], wkr[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mark[N], ans[N], val[N], AiAe[N], belong[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from] &#125;, head[from] = ecnt;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (mark[u]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next) </span><br><span class="line">        <span class="keyword">if</span> (check(e[i].to)) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">ans[u] = val;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next) pushdown(e[i].to, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; zzh;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> top)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (mark[u]) G1[top].push_back(u), top = u, zzh.push_back(u);</span><br><span class="line">belong[u] = top;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next) dfs(e[i].to, top);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcurts</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> op, a, b;</span><br><span class="line">&#125; q[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> F[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> upper_bound(wkr[i].begin(), wkr[i].end(), r) - lower_bound(wkr[i].begin(), wkr[i].end(), l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = belong[F[u]];</span><br><span class="line"><span class="comment">//cout &lt;&lt; "erase: " &lt;&lt; u &lt;&lt; ' ' &lt;&lt; f &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//assert(G1[f].size());</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : G1[f]) </span><br><span class="line">    <span class="keyword">if</span> (v == u) &#123; swap(v, G1[f].back()); <span class="keyword">break</span>; &#125;</span><br><span class="line">G1[f].pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; "link: " &lt;&lt; u &lt;&lt; ' ' &lt;&lt; F[u] &lt;&lt; endl;</span></span><br><span class="line">G1[F[u]].push_back(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v1)</span> </span>&#123;</span><br><span class="line">AiAe[u] = v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> v : G1[u]) pd(v, v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tim1 , tim2 , tim3 , tim4;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen("ex_data2.in", "r", stdin), freopen("fuck.out", "w", stdout);</span></span><br><span class="line"><span class="keyword">int</span> n, fuck; rd(n),rd(fuck);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) rd(val[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= fuck; i++) rd(q[i].op),rd(q[i].a),rd(q[i].b);</span><br><span class="line"><span class="keyword">int</span> hh = (fuck + SZ - <span class="number">1</span>) / SZ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= hh; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> l = (i - <span class="number">1</span>) * SZ + <span class="number">1</span>, r = min(fuck, i * SZ); zzh.clear(), G1[<span class="number">0</span>].clear(), ecnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) head[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) mark[j] = <span class="number">0</span>, wkr[j].clear(), ans[j] = <span class="number">0</span>, G1[j].clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) adde(F[i], i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt;= r; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[j].op == <span class="number">0</span>) mark[q[j].a] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q[j].op == <span class="number">1</span>) mark[q[j].a] = mark[q[j].b] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[<span class="number">0</span>]; i; i = e[i].next) </span><br><span class="line">        <span class="keyword">if</span> (!check(e[i].to)) pushdown(e[i].to, val[e[i].to]);</span><br><span class="line">        <span class="keyword">else</span> mark[e[i].to] = <span class="number">1</span>, dfs(e[i].to, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (belong[i]) wkr[belong[i]].push_back(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans[i] += ans[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i].op == <span class="number">0</span>) &#123;</span><br><span class="line">            erase(q[i].a), F[q[i].a] = <span class="number">0</span>, val[q[i].a] = q[i].b, ins(q[i].a);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (q[i].op == <span class="number">1</span>) &#123;</span><br><span class="line">            erase(q[i].a), F[q[i].a] = q[i].b, ins(q[i].a);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> L = q[i].a, R = q[i].b, res = ans[R] - ans[L - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : G1[<span class="number">0</span>]) pd(v, val[v]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : zzh) res += count(v, L, R) * AiAe[v];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-小Y的图"><a href="#T3-小Y的图" class="headerlink" title="T3 小Y的图"></a>T3 小Y的图</h1><div class="pdfobject-container" data-target="problem_94.pdf" data-height="500px"></div><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>我们将一个$5\times 5$的网格称为一个单元，那么这个$n\times n$的大网格可以划分为若干个小的单元。</p><p>对于一个$5\times 5$的网格，可以构造从任意点开始，结束在任意点的哈密顿路径，方法是暴力<code>dfs</code></p><p>将网格划分成若干个单元之后，我们可以钦定一条连接各个单元的哈密顿回路</p><p>比如$20\times 20$的网格</p><p><img src="5-25联测/image-20200529103821972.png" alt="image-20200529103821972"></p><p>如果$n/5$是奇数，那么就无法构造出只往左、上、右、下的哈密顿回路，因此需要加入一些斜向的路径。</p><p><img src="5-25联测/image-20200529104128281.png" alt="image-20200529104128281"></p><p>每一小块的起点、终点都是钦定好的，直接爆搜就可以了</p>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.18联测</title>
      <link href="/2020/05/21/5-18%E8%81%94%E6%B5%8B/"/>
      <url>/2020/05/21/5-18%E8%81%94%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-菱形"><a href="#T1-菱形" class="headerlink" title="T1 菱形"></a>T1 菱形</h1><div class="pdfobject-container" data-target="problem_83.pdf" data-height="500px"></div><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先特判掉$b=0,c=0$的情况。</p><p>如果$b&lt;c$，那么我们可以将矩形沿$y=x$镜像翻转，同时也翻转起点、终点的坐标，从而转化为$b\geq c$的情况。</p><p>如果起点不在$2,3$，或者终点不在$1,0$，那么我们可以枚举第一步、最后一步是怎么走的，从而强制让起点在$2,3$，终点在$1,0$。</p><p>如果$b=c$，可以枚举最后一步是怎么走的，从而转化为$b\neq c$的情况。</p><p>接下来以$a=2,d=1$为例。</p><p>可以发现，拐一次角经过的路径长度为$3$，而直行经过的路径长度为$4$，因此，我们应该让拐角的次数尽量多。</p><p>由于起点在$2$，终点在$1$，我们可以认为，第一步之前的方向为横向，最后一步之后的方向为纵向。</p><p><img src="image-20200521195218201.png" alt="image-20200521195218201"></p><p>即，如果第一步是向上走的，我们认为这也是一个拐角；如果最后一步是向右走的，我们认为这是一个拐角。我们的目的是让拐角个数尽量多。</p><p>由于我们强制让$b&gt;c$，因此拐角的个数是确定的，接下来我们只需要将剩余的向右走的情况塞到这条路径中。</p><p>显然除了开头结尾外，每个拐角之后都可以塞任意多条向右走的路径，因此这实际上对应着将$n$个球塞入$m$个盒子的方案数，盒子可空，方案数为$n+m-1\choose m-1$。</p><p>同时，每塞入一条向右走的边，方案数就会$\times 2$，因为直行的时候可以选择菱形的上半部分走过去，也可以选择下半部分。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N], pw2[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">P <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; "solve: " &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; ' ' &lt;&lt; c &lt;&lt; ' ' &lt;&lt; d &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span> &amp;&amp; c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == d) <span class="keyword">return</span> P(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((a + d) % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> P(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> P(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">0</span>) a = <span class="number">2</span> - a;</span><br><span class="line">        <span class="keyword">if</span> (d % <span class="number">2</span> == <span class="number">0</span>) d = <span class="number">2</span> - d;</span><br><span class="line">        <span class="keyword">return</span> solve(a, -b, c, d);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">1</span>) a = <span class="number">4</span> - a;</span><br><span class="line">        <span class="keyword">if</span> (d % <span class="number">2</span> == <span class="number">1</span>) d = <span class="number">4</span> - d;</span><br><span class="line">        <span class="keyword">return</span> solve(a, b, -c, d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; c) <span class="keyword">return</span> solve(a ^ <span class="number">1</span>, c, b, d ^ <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!c) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = (b - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">1</span> || a == <span class="number">3</span>) len++;</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">1</span> || d == <span class="number">3</span>) len++;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">2</span>) len += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">0</span>) len += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> P(len, pw2[b - <span class="number">1</span> + (a == <span class="number">2</span>) + (d == <span class="number">0</span>)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">1</span> || a == <span class="number">0</span> || d == <span class="number">2</span> || d == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="function">P <span class="title">fuck</span><span class="params">(<span class="number">1e9</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t1 = <span class="number">2</span>; t1 &lt;= <span class="number">3</span>; t1++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t2 = <span class="number">0</span>; t2 &lt;= <span class="number">1</span>; t2++) &#123;</span><br><span class="line">                <span class="keyword">int</span> tb = b - (t1 == <span class="number">2</span>) - (t2 == <span class="number">0</span>), tc = c - (t1 == <span class="number">3</span>) - (t2 == <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (tb &lt; <span class="number">0</span> || tc &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                P res = solve(t1, tb, tc, t2);</span><br><span class="line"><span class="comment">//                cout &lt;&lt; t1 &lt;&lt; ' ' &lt;&lt; tb &lt;&lt; ' ' &lt;&lt; tc &lt;&lt; ' ' &lt;&lt; t2 &lt;&lt; ' ' &lt;&lt; res.first &lt;&lt; ' ' &lt;&lt; res.second &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span> (a == t1) res.first += <span class="number">2</span>, res.second = res.second * <span class="number">2</span> % mod;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a % <span class="number">2</span> != t1 % <span class="number">2</span>) res.first++;</span><br><span class="line">                <span class="keyword">if</span> (d == t2) res.first += <span class="number">2</span>, res.second = res.second * <span class="number">2</span> % mod;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (d % <span class="number">2</span> != t2 % <span class="number">2</span>) res.first++;</span><br><span class="line">                res.first += <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (res.first &lt; fuck.first) fuck = res;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (res.first == fuck.first) fuck.second = (fuck.second + res.second) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> fuck;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b == c) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">3</span>) <span class="keyword">return</span> solve(a ^ <span class="number">1</span>, b, c, d ^ <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">1</span>) <span class="keyword">return</span> P(<span class="number">4</span> * b + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        P A = solve(a, b - <span class="number">1</span>, c, <span class="number">0</span>), B = solve(a, b, c - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        A.first += <span class="number">3</span>, B.first += <span class="number">2</span>, A.second = A.second * <span class="number">2</span> % mod;</span><br><span class="line">        <span class="keyword">if</span> (A.first != B.first) <span class="keyword">return</span> A.first &lt; B.first ? A : B;</span><br><span class="line">        <span class="keyword">return</span> P(A.first, (A.second + B.second) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">2</span> &amp;&amp; d == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = c * <span class="number">2</span>, delta = b + c - t;</span><br><span class="line">        <span class="keyword">return</span> P(c * <span class="number">4</span> + (b - c) * <span class="number">3</span> + <span class="number">1</span>, (LL)C(delta + c, c) * pw2[delta] % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">2</span> &amp;&amp; d == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = c * <span class="number">2</span> - <span class="number">1</span>, delta = b + c - t;</span><br><span class="line">        <span class="keyword">return</span> P(c * <span class="number">4</span> + (b - c) * <span class="number">3</span> + <span class="number">2</span>, (LL)C(delta + c, c) * pw2[delta] % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">3</span> &amp;&amp; d == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = c * <span class="number">2</span> + <span class="number">1</span>, delta = b + c - t;</span><br><span class="line">        <span class="keyword">return</span> P(c * <span class="number">4</span> + (b - c) * <span class="number">3</span>, (LL)C(delta + c, c) * pw2[delta] % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">3</span> &amp;&amp; d == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = c * <span class="number">2</span>, delta = b + c - t;</span><br><span class="line">        <span class="keyword">return</span> P(c * <span class="number">4</span> + (b - c) * <span class="number">3</span> + <span class="number">1</span>, (LL)C(delta + c, c) * pw2[delta] % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = pw2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N - <span class="number">10</span>; i++) &#123;</span><br><span class="line">        frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        pw2[i] = <span class="number">2</span> * pw2[i - <span class="number">1</span>] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    inv[N - <span class="number">10</span>] = Pow(frac[N - <span class="number">10</span>], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">11</span>; i &gt;= <span class="number">1</span>; i--) inv[i] = (LL)inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c, d; <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">        P res = solve(a, b, c, d);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, res.first, res.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-正方形"><a href="#T2-正方形" class="headerlink" title="T2 正方形"></a>T2 正方形</h1><div class="pdfobject-container" data-target="problem_84.pdf" data-height="500px"></div><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>由于$n\times m\leq 4\times 10^6$，且$n\geq m$，这意味着$m\leq 2\times 10^3$，同时$q$非常小。</p><p>我们将$n$这一维称为行，将$m$这一维称为列。</p><p>考虑对行建一棵线段树，线段树上每个节点开一个长度为$m$的数组，第$i$个位置维护仅考虑这个节点对应的行，以第$i$列作为右边界的最大正方形边长。</p><p>同时，我们对每个节点还要开两个长度为$m$的数组<code>up,down</code>。如果当前节点对应$[l,r]$，那么<code>up[i]</code>表示从$(l,i)$开始，仅考虑第$i$列，向上最多有多少个连续的$1$；<code>down[i]</code>表示，从$(r,i)$开始，仅考虑第$i$列，向下最多有多少个连续的$1$。</p><p><code>up</code>和<code>down</code>很好维护，重点在于如何求以每一列作为有边界的、跨过区间中点的最大正方形。</p><p>我们从小到大依次考虑每一列</p><p><img src="image-20200521201214612.png" alt="image-20200521201214612"></p><p>$i$是当前枚举的右端点，$j$是当右端点取$i-1$时，最大正方形的左边界。蓝色的条代表当前节点右儿子的<code>up</code>，橙色的条代表当前节点左儿子的<code>down</code>。</p><p>我们先考虑如何求$i,j$之间的最大矩形。</p><p>显然，这个矩形的上边界不能高于$i,j$间<code>up</code>的最小值，矩形的下边界不能低于$i,j$间<code>down</code>的最小值。</p><p>$i,j$之间<code>up,down</code>的最小值可以使用单调队列维护，接下来我们尝试将$j$往右移动，直到$i,j$间矩形的高度大于等于$j-i+1$。此时以$i$为有边界的最大正方形边长为$i-j+1$。</p><p>由于$i,j$只会单调移动，因此一次<code>pushup</code>的复杂度为$O(m)$。</p><p>查询的时候，可以用类似<code>pushup</code>的方法合并两次子询问得到的结果，总时间复杂度为$O(mq\log n)$。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WEN</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">operator</span> [] (<span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + x * m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; up, down, ans, G;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q1[N], q2[N], head1, tail1, head2, tail2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> ls, <span class="keyword">int</span> rs, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    head1 = head2 = <span class="number">1</span>, tail1 = tail2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (head1 &lt;= tail1 &amp;&amp; up[rs][i] &lt;= up[rs][q1[tail1]]) tail1--;</span><br><span class="line">        <span class="keyword">while</span> (head2 &lt;= tail2 &amp;&amp; down[ls][i] &lt;= down[ls][q2[tail2]]) tail2--;</span><br><span class="line">        q1[++tail1] = i, q2[++tail2] = i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= i &amp;&amp; i - j + <span class="number">1</span> &gt; up[rs][q1[head1]] + down[ls][q2[head2]]) &#123;</span><br><span class="line">            <span class="keyword">while</span> (head1 &lt;= tail1 &amp;&amp; q1[head1] &lt;= j) head1++;</span><br><span class="line">            <span class="keyword">while</span> (head2 &lt;= tail2 &amp;&amp; q2[head2] &lt;= j) head2++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[rt][i] = max(ans[ls][i], max(ans[rs][i], i - j + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        up[rt][i] = up[ls][i] + (up[ls][i] == L ? up[rs][i] : <span class="number">0</span>);</span><br><span class="line">        down[rt][i] = down[rs][i] + (down[rs][i] == R ? down[ls][i] : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) </span><br><span class="line">            up[rt][i] = down[rt][i] = ans[rt][i] = G[l][i];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span>, l, mid), build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    merge(rt, rt &lt;&lt; <span class="number">1</span>, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid - l + <span class="number">1</span>, r - mid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> up[rt][y] = down[rt][y] = ans[rt][y] = G[l][y] ^= <span class="number">1</span>, <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) flip(rt &lt;&lt; <span class="number">1</span>, l, mid, x, y);</span><br><span class="line">    <span class="keyword">else</span> flip(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y);</span><br><span class="line">    merge(rt, rt &lt;&lt; <span class="number">1</span>, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid - l + <span class="number">1</span>, r - mid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> merge(<span class="number">0</span>, <span class="number">0</span>, rt, l - start, r - l + <span class="number">1</span>), <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) query(rt &lt;&lt; <span class="number">1</span>, l, mid, start, end);</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;G[i][j]);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, x, y, a, b; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;op, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">0</span>) flip(<span class="number">1</span>, <span class="number">1</span>, n, x, y);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) up[<span class="number">0</span>][i] = down[<span class="number">0</span>][i] = ans[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">            query(<span class="number">1</span>, <span class="number">1</span>, n, x, a); <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = y; i &lt;= b; i++) res = max(res, min(ans[<span class="number">0</span>][i], i - y + <span class="number">1</span>));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-最小生成树"><a href="#T3-最小生成树" class="headerlink" title="T3 最小生成树"></a>T3 最小生成树</h1><div class="pdfobject-container" data-target="problem_85.pdf" data-height="500px"></div><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>设$f_{i,j,k}$表示仅考虑了边权$\leq i$的边，连通了$j$个点，且最小生成树边权和为$k$的概率。</p><p>转移的时候枚举仅考虑$\leq i-1$的边时，$1$号节点所在的连通块。我们强制让这个连通块向外连出的边的边权$\geq i$，特别地，我们认为断开的边的边权为$\infty$，同时，我们将这些边权$\geq i$的边的边权都视为$i$。我们将转移之后得到的结果称为$g_{i,j,k}$。</p><p>可以得到如下转移：</p><script type="math/tex; mode=display">g_{i,j,k}=f_{i-1,j,k}+\sum_{l=1}^{j-1}\sum_{t+i\leq k}f_{i-1,l,t}\times g_{i,j-l,k-t-i}\times{j-1\choose l-1}\times p_i^{l\times (j-l)}</script><p>其中，$p_i$表示随机到$\geq i$的边权的概率。</p><p>接下来我们容斥掉不合法的情况，即使用了边权$&gt; i$的边的情况。</p><p>同样，枚举仅考虑$\leq i$的边时，$1$号节点所在的连通块，可以得到如下转移</p><script type="math/tex; mode=display">f_{i,j,k}=g_{i,j,k}-\sum_{l=1}^{j-1}\sum_{t+i\leq k}f_{i,l,t}\times g_{i,j-l,k-t-i}\times{j-1\choose l-1}\times p_{i+1}^{l\times (j-l)}</script><p>最终的答案就是$f_{k,n,\cdots}$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">41</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">5</span>][N][N * N * <span class="number">4</span>], g[N][N * N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[<span class="number">6</span>], pw[<span class="number">6</span>][N * N], C[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m); <span class="keyword">int</span> inv = Pow(<span class="number">100</span>, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i]), p[i] = (LL)p[i] * inv % mod;</span><br><span class="line">    p[m + <span class="number">1</span>] = p[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= <span class="number">1</span>; i--) p[i] = (p[i] + p[i + <span class="number">1</span>]) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        pw[i][<span class="number">0</span>] = <span class="number">1</span>, pw[i][<span class="number">1</span>] = p[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= n * n; j++) pw[i][j] = (LL)pw[i][j - <span class="number">1</span>] * p[i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            C[i][j] = (C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j - <span class="number">1</span>; k &lt;= (j - <span class="number">1</span>) * i; k++) &#123;</span><br><span class="line">                g[j][k] = f[i - <span class="number">1</span>][j][k];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt; j; l++) </span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> t = l - <span class="number">1</span>; t &lt;= (l - <span class="number">1</span>) * (i - <span class="number">1</span>) &amp;&amp; t + i &lt;= k; t++) </span><br><span class="line">                        g[j][k] = (g[j][k] + (LL)f[i - <span class="number">1</span>][l][t] * C[j - <span class="number">1</span>][l - <span class="number">1</span>] % mod </span><br><span class="line">                                * g[j - l][k - t - i] % mod * pw[i][l * (j - l)]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(f[i], g, <span class="keyword">sizeof</span>(g));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j - <span class="number">1</span>; k &lt;= (j - <span class="number">1</span>) * i; k++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt; j; l++) </span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> t = l - <span class="number">1</span>; t &lt;= (l - <span class="number">1</span>) * i &amp;&amp; t + i &lt;= k; t++) &#123;</span><br><span class="line">                        f[i][j][k] = (f[i][j][k] - (LL)f[i][l][t] * g[j - l][k - t - i] % mod </span><br><span class="line">                            * C[j - <span class="number">1</span>][l - <span class="number">1</span>] % mod * pw[i + <span class="number">1</span>][l * (j - l)]) % mod;</span><br><span class="line">                        f[i][j][k] = (f[i][j][k] + mod) % mod;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &lt;= m * (n - <span class="number">1</span>); i++) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, f[m][n][i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 容斥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.13联测</title>
      <link href="/2020/05/21/5-13%E8%81%94%E6%B5%8B/"/>
      <url>/2020/05/21/5-13%E8%81%94%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-endemic"><a href="#T1-endemic" class="headerlink" title="T1 endemic"></a>T1 endemic</h1><p>有$n$个数，一开始第$i$个数为$h_i$。有$m$种操作，第$i$种操作可以将一段长度为$l_i$的区间升高/降低$1$，同时有$c_i$的代价。你可以执行任意次操作，问将整个序列变为不降序列的最小代价。</p><script type="math/tex; mode=display">n, m\leq 200, h_i\leq 10^6</script><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先将整个序列转成差分数组，每次操作变为给一个位置$+1$，给一个位置$-1$。</p><p>记$\Delta_i=h_i-h_{i-1},\Delta_0=\Delta_{n+1}=\infty$，那么我们的目的是使得所有$\Delta\geq 0$。</p><p>对于$i$，如果$\Delta_i&gt;0$，我们从源点向$i$连一条容量为$\Delta_i$，费用为$0$的边，表示这个位置可以贡献的$-1$的数量。</p><p>如果$\Delta_i&lt;0$，我们从$i$向汇点连一条容量为$-\Delta_i$，费用为$0$的边，表示这个位置需要填的$+1$的数量，且这条边在最终的方案中必须流满。</p><p>对于一次操作$i$，不妨设这个操作会给一个区间$+1$。对于任意的$j$，让$j$向$j-l_i$连一条容量为$\infty$，费用为$c_i$的边。</p><p>在这张图上跑最小费用流即可。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">410</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w, c;</span><br><span class="line">&#125; e[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt = <span class="number">1</span>, vis[N], cur[N]; LL dis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> f, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from], f, c&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to], <span class="number">0</span>, -c&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis)), <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis)), dis[t] = <span class="number">0</span>, vis[t] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q; q.push_back(t);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop_front(), vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">            <span class="keyword">if</span> (e[i ^ <span class="number">1</span>].w &amp;&amp; dis[e[i].to] &gt; dis[u] - e[i].c) &#123;</span><br><span class="line">                dis[e[i].to] = dis[u] - e[i].c;</span><br><span class="line">                <span class="keyword">if</span> (!vis[e[i].to]) &#123;</span><br><span class="line">                    vis[e[i].to] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!q.empty() &amp;&amp; dis[e[i].to] &lt; dis[q.front()]) q.push_front(e[i].to);</span><br><span class="line">                    <span class="keyword">else</span> q.push_back(e[i].to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[s] &lt; <span class="number">1e17</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL MCMF;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>; <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (u == t || !f) <span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u], tmp;i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to] &amp;&amp; e[i].w &amp;&amp; dis[u] - e[i].c == dis[e[i].to] &amp;&amp; (tmp = DFS(e[i].to, min(f, e[i].w), t))) &#123;</span><br><span class="line">            f -= tmp, res += tmp, e[i].w -= tmp, e[i ^ <span class="number">1</span>].w += tmp, MCMF += (LL)tmp * e[i].c;</span><br><span class="line">            <span class="keyword">if</span> (!f) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    MCMF = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (SPFA(s, t)) <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span>(head)), f += DFS(s, <span class="number">1e9</span>, t);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) num[i] -= num[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> s = n + <span class="number">2</span>, t = s + <span class="number">1</span>; LL tot = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[i] &lt; <span class="number">0</span>) adde(s, i, -num[i], <span class="number">0</span>), tot -= num[i];</span><br><span class="line">        <span class="keyword">else</span> adde(i, t, num[i], <span class="number">0</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    adde(<span class="number">1</span>, t, <span class="number">1e9</span>, <span class="number">0</span>), adde(n + <span class="number">1</span>, t, <span class="number">1e9</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">4</span>]; <span class="keyword">int</span> l, c; <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>, op + <span class="number">1</span>, &amp;l, &amp;c);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j + l - <span class="number">1</span> &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (op[<span class="number">1</span>] == <span class="string">'+'</span>) adde(j, j + l, <span class="number">1e9</span>, c);</span><br><span class="line">            <span class="keyword">else</span> adde(j + l, j, <span class="number">1e9</span>, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Dinic(s, t) != tot) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, MCMF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-epidemic"><a href="#T2-epidemic" class="headerlink" title="T2 epidemic"></a>T2 epidemic</h1><div class="pdfobject-container" data-target="problem_30.pdf" data-height="500px"></div><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>首先我们知道$\lfloor\frac{a}{\lfloor\frac bc\rfloor}\rfloor=\lfloor\frac{a}{bc}\rfloor$。</p><p>因此在任何一次操作之后，任何一个数都可以被表示为$\lfloor\frac{x+a}{b}\rfloor$的形式。</p><p>$a$可能很大，不好维护，因此我们将其整数部分提出来，即表示成$\lfloor\frac{x+a}{b}\rfloor+c$，其中$a&lt;b$。</p><p>显然$\lfloor\frac{x+a}{b}\rfloor$要么等于$\lfloor\frac xb\rfloor$，要么等于这个东西$+1$，因此我们只关心$b-a$是多少。</p><p>考虑对$\lfloor\frac{x+a}{b}\rfloor+c$进行操作。</p><p>首先加一个数很简单，直接对$c$操作就可以了</p><p>如果除了一个数，假设是$y$。显然$\lfloor\frac cy\rfloor$可以提出去，我们不妨设$c&lt;y$。</p><p>那么会变成$\lfloor\frac{x+a+cb}{by}\rfloor$。</p><p>由于$c&lt;y,a&lt;b$，因此$a+cb&lt;by$。</p><p>如果$by$太大，比如超过了$10^9$，那么我们就将$a+cb$和$by$同时减去$by-10^9$，因为我们只关心$b-a$的取值，并且每次加的数都很小。</p><p>因此直接分块即可，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">410</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> belong[N], A[N], B[N], C[N], D[N], bass[N], kick[N], mx[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Heaven</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    A[t] = C[t] = <span class="number">0</span>, B[t] = <span class="number">1</span>, D[t] = <span class="number">1</span>, mx[t] = tmp[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AiAe</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    mx[t] /= x; LL tmp = A[t] + (LL)(C[t] % x) * B[t]; C[t] /= x;</span><br><span class="line">    LL nw = (LL)B[t] * x;</span><br><span class="line"><span class="comment">//    assert(tmp &lt; nw);</span></span><br><span class="line">    <span class="keyword">if</span> (nw &gt; <span class="number">1e9</span>) tmp = max(<span class="number">0l</span>l, tmp - nw + (<span class="keyword">int</span>)<span class="number">1e9</span>), nw = <span class="number">1e9</span>;</span><br><span class="line">    A[t] = tmp, B[t] = nw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Atmosphere</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = (t - <span class="number">1</span>) * SZ + <span class="number">1</span>, r = t * SZ;</span><br><span class="line">    <span class="keyword">if</span> (D[t]) <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) kick[i] = bass[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) kick[i] = (kick[i] + A[t]) / B[t] + C[t];</span><br><span class="line">    A[t] = C[t] = D[t] = <span class="number">0</span>, B[t] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">UMMU</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = (t - <span class="number">1</span>) * SZ + <span class="number">1</span>, r = t * SZ;</span><br><span class="line">    mx[t] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) mx[t] = max(mx[t], kick[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Censored</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = belong[l], R = belong[r];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L + <span class="number">1</span>; i &lt; R; i++) C[i] += x, mx[i] += x;</span><br><span class="line">    Atmosphere(L);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= min(L * SZ, r); i++) kick[i] += x;</span><br><span class="line">    UMMU(L);</span><br><span class="line">    <span class="keyword">if</span> (L != R) &#123;</span><br><span class="line">        Atmosphere(R);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (R - <span class="number">1</span>) * SZ + <span class="number">1</span>; i &lt;= r; i++) kick[i] += x;</span><br><span class="line">        UMMU(R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Stasis</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = belong[l], R = belong[r];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L + <span class="number">1</span>; i &lt; R; i++) AiAe(i, x);</span><br><span class="line">    Atmosphere(L);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= min(L * SZ, r); i++) kick[i] /= x;</span><br><span class="line">    UMMU(L);</span><br><span class="line">    <span class="keyword">if</span> (L != R) &#123;</span><br><span class="line">        Atmosphere(R);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (R - <span class="number">1</span>) * SZ + <span class="number">1</span>; i &lt;= r; i++) kick[i] /= x;</span><br><span class="line">        UMMU(R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Cyanine</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = belong[l], R = belong[r];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L + <span class="number">1</span>; i &lt; R; i++) Heaven(i);</span><br><span class="line">    Atmosphere(L);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= min(L * SZ, r); i++) kick[i] = bass[i];</span><br><span class="line">    UMMU(L);</span><br><span class="line">    <span class="keyword">if</span> (L != R) &#123;</span><br><span class="line">        Atmosphere(R);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (R - <span class="number">1</span>) * SZ + <span class="number">1</span>; i &lt;= r; i++) kick[i] = bass[i];</span><br><span class="line">        UMMU(R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Sheriruth</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = belong[l], R = belong[r], res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L + <span class="number">1</span>; i &lt; R; i++) res = max(res, mx[i]);</span><br><span class="line">    Atmosphere(L);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= min(L * SZ, r); i++) res = max(res, kick[i]);</span><br><span class="line">    UMMU(L);</span><br><span class="line">    <span class="keyword">if</span> (L != R) &#123;</span><br><span class="line">        Atmosphere(R);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (R - <span class="number">1</span>) * SZ + <span class="number">1</span>; i &lt;= r; i++) res = max(res, kick[i]);</span><br><span class="line">        UMMU(R);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen("ex_epidemic2.in", "r", stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) belong[i] = (i - <span class="number">1</span>) / SZ + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;bass[i]), kick[i] = bass[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        tmp[belong[i]] = mx[belong[i]] = max(mx[belong[i]], bass[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= belong[n]; i++) B[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, l, r, x; <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;op, &amp;l, &amp;r, &amp;x), l++, r++;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">0</span>) Censored(l, r, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">1</span>) Stasis(l, r, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Sheriruth(l, r));</span><br><span class="line">        <span class="keyword">else</span> Cyanine(l, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-pandemic"><a href="#T3-pandemic" class="headerlink" title="T3 pandemic"></a>T3 pandemic</h1><div class="pdfobject-container" data-target="problem_31.pdf" data-height="500px"></div><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>显然最优的答案一定是直径长度除以$2$上取整，并且方案很好构造，即直径一半向左，一半向右，其它点看作是挂到直径上的点。如果是挂在左边那么向下，否则向上。</p><p>然后问题转化为有多少种给边定向的方案，使得对于树上的任意一条路径，它经过的反向边长度都不超过$t$。</p><p>设$dp[u][i][j]$表示已经给$u$的子树中的边定向完毕，且满足上面的条件，从$u$出发的路径至多经过了恰好$i$条反向边，到$u$的路径至多经过了$j$条反向边，转移的时候枚举$u,v$连边的朝向。</p><p>直接做的复杂度是$O(n^4)$，可以前缀和优化，但我不会</p><p>下面是$80$分代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from] &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to] &#125;, head[to] = ecnt;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">afs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) </span><br><span class="line">            res = max(res, afs(e[i].to, u) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x += y, x -= x &gt;= mod ? mod : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lim, len[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FUCK &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">310</span>][<span class="number">310</span>][<span class="number">310</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    len[u] = <span class="number">0</span>, dp[u][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].to; dfs(v, u); <span class="keyword">static</span> <span class="keyword">int</span> tmp[N][N];</span><br><span class="line">            <span class="keyword">int</span> fuck = max(len[u], len[v] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= fuck; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= fuck; k++) tmp[j][k] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len[u]; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= len[u]; k++) <span class="keyword">if</span> (dp[u][j][k]) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= len[v] &amp;&amp; k + l &lt;= lim; l++) </span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt;= len[v] &amp;&amp; j + t &lt;= lim; t++) <span class="keyword">if</span> (dp[v][l][t]) &#123;</span><br><span class="line">                            LL w = (LL)dp[u][j][k] * dp[v][l][t] % mod;</span><br><span class="line">                            <span class="keyword">if</span> (t + j + <span class="number">1</span> &lt;= lim) Inc(tmp[max(j, l)][max(k, t + <span class="number">1</span>)], w);</span><br><span class="line">                            <span class="keyword">if</span> (k + l + <span class="number">1</span> &lt;= lim) Inc(tmp[max(j, l + <span class="number">1</span>)][max(k, t)], w);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= fuck; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= fuck; k++) dp[u][j][k] = tmp[j][k];</span><br><span class="line">            len[u] = fuck;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FUCK1 &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">81</span>][<span class="number">81</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    len[u] = <span class="number">0</span>, dp[u][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].to; dfs(v, u); <span class="keyword">static</span> <span class="keyword">int</span> tmp[N][N];</span><br><span class="line">            <span class="keyword">int</span> fuck = min(lim, max(len[u], len[v] + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= fuck; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= fuck; k++) tmp[j][k] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len[u] &amp;&amp; j &lt;= lim; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= len[u] &amp;&amp; k &lt;= lim; k++) <span class="keyword">if</span> (dp[u][j][k]) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= len[v] &amp;&amp; k + l &lt;= lim; l++) </span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt;= len[v] &amp;&amp; j + t &lt;= lim; t++) <span class="keyword">if</span> (dp[v][l][t]) &#123;</span><br><span class="line">                            LL w = (LL)dp[u][j][k] * dp[v][l][t] % mod;</span><br><span class="line">                            <span class="keyword">if</span> (t + j + <span class="number">1</span> &lt;= lim) Inc(tmp[max(j, l)][max(k, t + <span class="number">1</span>)], w);</span><br><span class="line">                            <span class="keyword">if</span> (k + l + <span class="number">1</span> &lt;= lim) Inc(tmp[max(j, l + <span class="number">1</span>)][max(k, t)], w);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= fuck; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= fuck; k++) dp[u][j][k] = tmp[j][k];</span><br><span class="line">            len[u] = fuck;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) lim = max(lim, (afs(i, <span class="number">0</span>) + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">300</span>) FUCK::dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> FUCK1::dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len[<span class="number">1</span>] &amp;&amp; i &lt;= lim; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len[<span class="number">1</span>] &amp;&amp; j &lt;= lim; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &lt;= <span class="number">300</span>) Inc(res, FUCK::dp[<span class="number">1</span>][i][j]);</span><br><span class="line">            <span class="keyword">else</span> Inc(res, FUCK1::dp[<span class="number">1</span>][i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题解似乎是$n^2$的</p><div class="pdfobject-container" data-target="problem_solution_29.pdf" data-height="500px"></div>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.11联测</title>
      <link href="/2020/05/21/5-11%E8%81%94%E6%B5%8B/"/>
      <url>/2020/05/21/5-11%E8%81%94%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-高精度"><a href="#T1-高精度" class="headerlink" title="T1 高精度"></a>T1 高精度</h1><div class="pdfobject-container" data-target="problem_32.pdf" data-height="500px"></div><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑在第$i$次操作中加入的数$x$对第$j$次操作之后的数的贡献。如果在第$i$次操作之后，数的位数为$len_i$，在第$j$次操作之后，数的位数为$len_j$，那么贡献为$x\times 10^{len_j-len_i}$。</p><p>但此时我们默认$x$这个数直到第$j$次操作结束都没有被删去，如果它在中间的某次操作中被删去了，那么这个贡献显然是错误的。</p><p>考虑用减操作抵消这个数在被删去之后对整个数的影响，对于每次减操作我们记录一下它删去了哪个数，假设为$x$，那么我们将这个位置的权值看作$-x$，对$j$操作之后数的贡献为$-x\times 10^{len_j-len_i+1}$。</p><p>现在我们就可以无视掉“在中间的某次操作中被删去”这种情况了，考虑<code>CDQ</code>分治，即计算左区间的操作对右区间的数的影响。这是一个差卷积的形式。</p><p>另一种做法是使用有根点分治。观察到所有的操作形成了一棵树型的结构，因此可以直接点分治。每次提出分治中心到根的路径，再用<code>NTT</code>计算这条路径到其它子树的贡献。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> len, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, t, w = <span class="number">1</span>; j &lt; i + (mid &gt;&gt; <span class="number">1</span>); j++, w = (LL)w * Wn % mod)</span><br><span class="line">                t = (LL)w * a[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!type) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, inv = Pow(len, mod - <span class="number">2</span>); i &lt; len; i++)</span><br><span class="line">        a[i] = (LL)a[i] * inv % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.size() + B.size() - <span class="number">2</span>, len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">C</span><span class="params">(len + <span class="number">1</span>, <span class="number">0</span>)</span></span>; A.resize(len + <span class="number">1</span>), B.resize(len + <span class="number">1</span>);</span><br><span class="line">    NTT(A, len, <span class="number">1</span>), NTT(B, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) C[i] = (LL)A[i] * B[i] % mod;</span><br><span class="line">    NTT(C, len, <span class="number">0</span>), C.resize(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> num[N], pre[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[l] &gt;= <span class="number">0</span>) ans[<span class="number">0</span>] += num[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    solve(l, mid), solve(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">int</span> mn = <span class="number">1e9</span>, lmn = <span class="number">1e9</span>, rmn = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        mn = min(mn, pre[i]);</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= mid) lmn = min(lmn, pre[i]);</span><br><span class="line">        <span class="keyword">else</span> rmn = min(rmn, pre[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp, tmp1; <span class="keyword">int</span> len = <span class="number">0</span>, t1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= mid; i++) len = max(len, pre[i] + (s[i] == <span class="string">'-'</span>) - lmn);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= r; i++) t1 = max(t1, pre[i] - rmn);</span><br><span class="line">    tmp.resize(len + <span class="number">1</span>), tmp1.resize(t1 + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= mid; i++) </span><br><span class="line">        tmp[len - (pre[i] + (s[i] == <span class="string">'-'</span>) - lmn)] += num[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">        tmp1[pre[i] - rmn]++;</span><br><span class="line">    <span class="keyword">int</span> delta = rmn - lmn;</span><br><span class="line">    tmp = mul(tmp, tmp1); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = i - len + delta;</span><br><span class="line">        <span class="keyword">if</span> (t &gt;= <span class="number">0</span>) ans[t] = (ans[t] + tmp[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d%s"</span>, &amp;n, s + <span class="number">1</span>); <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fuck;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != <span class="string">'-'</span>) t++, num[i] = s[i] - <span class="string">'0'</span>, fuck.push_back(num[i]), pre[i] = t;</span><br><span class="line">        <span class="keyword">else</span> t--, pre[i] = t, num[i] = -fuck.back(), fuck.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    solve(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) </span><br><span class="line">        ans[i + <span class="number">1</span>] += ans[i] / <span class="number">10</span>, ans[i] %= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n, flag = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ans[i]) flag = <span class="number">1</span>, <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-最短路"><a href="#T2-最短路" class="headerlink" title="T2 最短路"></a>T2 最短路</h1><div class="pdfobject-container" data-target="problem_33.pdf" data-height="500px"></div><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>首先有结论：假设只走白边，从起点走到终点至少要经过$k$条边，那么可能的路径只有三种情况：</p><ul><li>全是白边，长度为$ka$。</li><li>有$k\bmod 2$条白边，$\lfloor\frac k2\rfloor$条黑边。</li><li>全是黑边。</li></ul><p>第三种路径不一定存在，但第二种路径一定存在，因为每次我们可以将最终路径中相邻的两条白边缩成一条黑边。如果这两条白边在同一个三元环上，那么这样走一定不优秀，即只走白边，从起点到终点的最短路径一定比这条路径短。</p><p>接下来我们只需要考虑第三种情况，即求出从起点开始，只走黑边，到其它每个点的最短路。</p><p>看起来只能暴力，即遍历当前点的所有出边，再依次遍历这条边的另一个端点$u$的所有出边，假设这条边到达$v$，再判断当前点到$v$是否有连边。很显然，这样的复杂度是不低于$n^2$的，会被菊花图卡飞。</p><p>考虑这样一种优化：我们用<code>BFS</code>来求到每个点的最短路。如果到$u$的最短路已经计算好了，那么所有到$u$的出边就都没用了，我们一定不会再用到这些边。</p><p>因此，记录一张新图$G’$，在这张图上，我们仅保留所有目标点没有被计算的边，在<code>BFS</code>枚举$v$时，我们在这张新图上枚举出边。</p><p>每次加边时，意味着有一个三元环被缩掉了。由于三元环的总数为$m\sqrt m$，因此总时间复杂度为$O(n+m\sqrt m)$。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">150010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N], G1[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N], B[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, a, b; <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;a, &amp;b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        G[a].push_back(b), G[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) G1[i] = G[i];</span><br><span class="line">    <span class="built_in">memset</span>(A, <span class="number">-1</span>, <span class="keyword">sizeof</span>(A)), A[<span class="number">1</span>] = <span class="number">0</span>; <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; q.push(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) <span class="keyword">if</span> (A[v] == <span class="number">-1</span>) </span><br><span class="line">            A[v] = A[u] + <span class="number">1</span>, q.push(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(B, <span class="number">-1</span>, <span class="keyword">sizeof</span>(B)), B[<span class="number">1</span>] = <span class="number">0</span>, q.push(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop(); <span class="keyword">static</span> <span class="keyword">int</span> vis[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : G1[u]) vis[v] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : G1[u]) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> t : G[v]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[t] &amp;&amp; !~B[t]) B[t] = B[u] + <span class="number">1</span>, q.push(t);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!~B[t]) tmp.push_back(t);</span><br><span class="line">            &#125;</span><br><span class="line">            G[v] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : G1[u]) vis[v] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        LL t1 = (LL)A[i] * a, t2 = (LL)(A[i] % <span class="number">2</span>) * a + (LL)(A[i] / <span class="number">2</span>) * b, t3 = B[i] == <span class="number">-1</span> ? <span class="number">1e18</span> : (LL)B[i] * b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld "</span>, min(t1, min(t2, t3)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-网格图"><a href="#T3-网格图" class="headerlink" title="T3 网格图"></a>T3 网格图</h1><div class="pdfobject-container" data-target="problem_34.pdf" data-height="500px"></div><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>显然最后的黑点一定形成了若干个矩形，且任意两个矩形中最近点的欧几里得距离大于$2$。</p><p>本质上来讲，我们在维护这样一个过程：一开始每个黑点都是一个$1\times 1$的矩形，接着我们不断合并这些矩形。如果存在两个矩形使得最近点的欧几里得距离小于等于$2$，那么我们就合并这两个矩形。</p><p>将所有点按照$y$坐标排序，枚举待合并的矩形，尝试将其与之前$y$坐标小于它的矩形合并，可以发现可以合并的矩形只有三种：</p><p><img src="image-20200521083714645.png" alt="image-20200521083714645"></p><p>因此我们需要维护的是，所有$x$坐标与$[l,r]$有交的矩形中，$y$坐标最大，且没有被删除的（我们将合并视为删去另一个矩形，并扩大当前矩形）。</p><p>由于我们将所有点按照$y$坐标排好了序，因此每次插入新的矩形时，$y$坐标一定是递增的，使用线段树套<code>vector</code>即可。</p><p>由于要标记永久化，因此对于线段树上的每个节点，我们需要记录两个信息：完全包含这个区间的矩形以及被这个区间完全包含的矩形。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">&#125; T[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt; A[N &lt;&lt; <span class="number">2</span>], B[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    T[rt].l = l, T[rt].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span>, l, mid), build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> y, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    A[rt].push_back(P(y, id));</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> B[rt].push_back(P(y, id)), <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, start, end, y, id);</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, start, end, y, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (A[rt].size() &amp;&amp; vis[A[rt].back().second]) A[rt].pop_back();</span><br><span class="line">    <span class="keyword">while</span> (B[rt].size() &amp;&amp; vis[B[rt].back().second]) B[rt].pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> P <span class="title">merge</span><span class="params">(P a, P b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.first &gt; b.first ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">P <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r; <span class="function">P <span class="title">res</span><span class="params">(<span class="number">-1e9</span>, <span class="number">0</span>)</span></span>; check(rt);</span><br><span class="line">    <span class="keyword">if</span> (B[rt].size()) res = B[rt].back();</span><br><span class="line"><span class="comment">//    cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; ' ' &lt;&lt; start &lt;&lt; ' ' &lt;&lt; end &lt;&lt; ' ' &lt;&lt; res.first &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[rt].size()) <span class="keyword">return</span> A[rt].back();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) res = merge(res, query(rt &lt;&lt; <span class="number">1</span>, start, end));</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) res = merge(res, query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, start, end));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcurts</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> tcurts &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> X[N], Y[N], mX[N], mY[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fuck</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; "fuck: " &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">    X[a] = min(X[a], X[b]), Y[a] = min(Y[a], Y[b]);</span><br><span class="line">    mX[a] = max(mX[a], mX[b]), mY[a] = max(mY[a], mY[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">    sort(p + <span class="number">1</span>, p + k + <span class="number">1</span>), build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        X[i] = mX[i] = p[i].x, Y[i] = mY[i] = p[i].y; </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">233</span>) &#123;</span><br><span class="line">            P res = query(<span class="number">1</span>, X[i] - <span class="number">2</span>, mX[i] + <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (res.first &gt;= Y[i]) </span><br><span class="line">                vis[res.second] = <span class="number">1</span>, fuck(i, res.second);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res = query(<span class="number">1</span>, X[i] - <span class="number">1</span>, mX[i] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (res.first &gt;= Y[i] - <span class="number">1</span>)</span><br><span class="line">                    vis[res.second] = <span class="number">1</span>, fuck(i, res.second);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    res = query(<span class="number">1</span>, X[i], mX[i]);</span><br><span class="line">                    <span class="keyword">if</span> (res.first &gt;= Y[i] - <span class="number">2</span>)</span><br><span class="line">                        vis[res.second] = <span class="number">1</span>, fuck(i, res.second);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        update(<span class="number">1</span>, X[i], mX[i], mY[i], i);</span><br><span class="line"><span class="comment">//        cout &lt;&lt; "update: " &lt;&lt; X[i] &lt;&lt; ' ' &lt;&lt; mX[i] &lt;&lt; ' ' &lt;&lt; mY[i] &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) <span class="keyword">if</span> (!vis[i]) </span><br><span class="line">        res += (LL)(mX[i] - X[i] + <span class="number">1</span>) * (mY[i] - Y[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 多项式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.8联测</title>
      <link href="/2020/05/20/5-8%E8%81%94%E6%B5%8B/"/>
      <url>/2020/05/20/5-8%E8%81%94%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-天才数学少女"><a href="#T1-天才数学少女" class="headerlink" title="T1 天才数学少女"></a>T1 天才数学少女</h1><p>给定$a, m$，求出$k$满足$a^k\equiv k\pmod m$且$k\leq 2\times 10^{18}$，或判断无解。多组数据。</p><script type="math/tex; mode=display">T\leq 100, 1\leq a_i,m_i\leq 10^9</script><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>如果$m$是质数，那么我们钦定$k\equiv 1\pmod m$，于是我们可以得到方程</p><script type="math/tex; mode=display">\begin{cases}k\equiv 0\pmod {m - 1}\\ k\equiv 1\pmod m\end{cases}</script><p>使用<code>exgcd</code>解同余方程即可。</p><p>当$m$不是质数的时候，$a^k\not\equiv a^{k\bmod {m - 1}}\pmod m$，我们必须使用拓展欧拉定理。</p><p>拓展欧拉定理是一个大概长这样的东西：</p><script type="math/tex; mode=display">a^k\equiv \begin{cases}a^k & k<\varphi(m)\\ a^{k\bmod \varphi(m)+\varphi(m)} & k\geq \varphi(m)\end{cases}</script><p>如果我们忽略$k&lt;\varphi(m)$的情况，那么相当于我们希望找到一个$x$，使得</p><script type="math/tex; mode=display">\begin{cases}k\bmod{\varphi(m)}+\varphi(m)=x\\k\bmod m=a^x\bmod m\end{cases}\Rightarrow\begin{cases}k\equiv x & \pmod{\varphi(m)}\\k\equiv a^x&\pmod m\end{cases}</script><p>可以发现，这个方程有解的条件是$\gcd(\varphi(m),m)\mid a^x-x$，问题转化为我们需要找到一个$x$，使得$a^x\equiv x\pmod{\gcd(\varphi(m),m)}$，这变成了一个原问题的子问题。</p><p>如果解出的$k&lt;\varphi(m)$，那么我们直接给$k$加上$\mathrm{lcm}(\varphi(m),m)$即可，可以发现加上之后这个方程仍然满足。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line">LL x, y;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a, LL b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> x = <span class="number">1</span>, y = <span class="number">0</span>, a;</span><br><span class="line">    LL res = exgcd(b, a % b), t = x;</span><br><span class="line">    <span class="keyword">return</span> x = y, y = t - a / b * y, res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; i++) <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">        res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> b ? gcd(b, a % b) : a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, LL y, <span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">excrt</span><span class="params">(LL A[], LL P[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    LL lcm = P[<span class="number">1</span>], a = A[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        LL t = exgcd(lcm, P[i]), delta = A[i] - a, fuck = P[i] / t;</span><br><span class="line">        <span class="keyword">if</span> (delta % t) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">        x = x * (delta / t), x = (x % fuck + fuck) % fuck;</span><br><span class="line">        a = x * lcm + a, lcm *= fuck;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL A[<span class="number">3</span>], P[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    a %= m;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> t = phi(m), g = gcd(t, m);</span><br><span class="line">    LL res = solve(a, g); </span><br><span class="line">    A[<span class="number">1</span>] = res, P[<span class="number">1</span>] = t;</span><br><span class="line">    A[<span class="number">2</span>] = Pow(a, res, m), P[<span class="number">2</span>] = m;</span><br><span class="line">    LL fuck = excrt(A, P, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (fuck &lt; t) <span class="keyword">return</span> fuck + (LL)t / g * m;</span><br><span class="line">    <span class="keyword">return</span> fuck;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;m);</span><br><span class="line">        LL t = solve(a, m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-fake"><a href="#T2-fake" class="headerlink" title="T2 fake"></a>T2 fake</h1><p>有$1\sim m$这$m$个数，$n$个人轮流取数，取数的顺序为$1,2,\cdots,n,1,2,\cdots$且取数的总次数必须是$n$的倍数。第$i$个人最终取的数之和不能超过$a_i$，问所有被取走的数之和最大是多少。</p><script type="math/tex; mode=display">n\leq 10^5,m\leq 10^9,a_i\leq \frac{m(m+1)}{2}</script><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>先考虑这样一个暴力：枚举轮数，然后尽可能多地给每一个人分配数。</p><p>显然有这样一个性质：第$i$个人取走的数之和至多是第$i + 1$个人取走的数之和减去轮数，我们记轮数为$t$。</p><p>一个很自然的想法是，让最后一个人取走的数尽量多，然后之前的每个人都取到自己上界，即$\min(v_{i+1}-t,a_i)$，其中$v_{i+1}$表示第$i+1$最终取走的数之和。那么最后一个人就必须保证至少存在一种取数的方案。</p><p>二分最后一个人取走的数之和，接下来我们将$1\sim m$这$m$个数排成一列，那么最后一个人会占去这$m$个空位中的$t$个空位。接着，我们让第$i$个人紧贴着第$i+1$个人取数的位置取数，又会用去$t(n-1)$个空位，此时这$m$个数大概长这样：</p><p><img src="image-20200520085739181.png" alt=""></p><p>方便起见，我们将数称为“球”</p><p>用相同颜色染色的位置表示同一个人取的数，那么接下来我们可以将一些球往左挪动，同时用去一个剩余的空位。注意此时我们剩下的空位总数是$m-tn$。</p><p>如果最后一个人的球的总数不足以取第$m$个数，那么就让他取到自己能取的最靠后的球，同时更新剩下的空位总数。</p><p>接下来，我们从后往前依次判断每个人还要往左挪动多少格。如果$v_{i+1}-t&gt;a_i$，那么我们就必须将当前这个人选的球往左挪动，用去$v_{i+1}-t-a_i$个空位，最后我们只需要判断剩余的空位是否够用。</p><p>通过尝试或者观察可以发现，答案是一个关于轮数的上凸函数，因此可以直接对轮数三分。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int LL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = (r - l) / d + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (l + r) * t / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> turn, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last = min(m, mid - calc(n, (turn - <span class="number">1</span>) * n, n));</span><br><span class="line">    <span class="keyword">int</span> remain = last - turn * n, hh = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>, t = mid; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        t -= turn;</span><br><span class="line">        <span class="keyword">if</span> (t &gt; a[i]) hh += t - a[i], t = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> remain &gt;= hh;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">solve</span><span class="params">(<span class="keyword">int</span> turn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = calc(n, n * turn, n), r = min(calc(m - n * (turn - <span class="number">1</span>), m, n), a[n]), mid, ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(turn, mid)) ans = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = ans, tp = ans, mn = calc(<span class="number">1</span>, n * (turn - <span class="number">1</span>) + <span class="number">1</span>, n), flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        tp -= turn, tp = min(tp, a[i]), res += tp;</span><br><span class="line">        <span class="keyword">if</span> (tp &lt; mn + (i - <span class="number">1</span>) * turn) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = m / n, mid, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        LL L = solve(mid), R = solve(mid + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (L &lt; R) ans = max(ans, R), l = mid + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> ans = max(ans, L), r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-绰绰有余"><a href="#T3-绰绰有余" class="headerlink" title="T3 绰绰有余"></a>T3 绰绰有余</h1><div class="pdfobject-container" data-target="problem_4.pdf" data-height="500px"></div><p>题解写得挺详细的</p><div class="pdfobject-container" data-target="problem_solution_4.pdf" data-height="500px"></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> U[N], M[N], D[N], tp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt; C1, C2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work1</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> id, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nxt = tp + (k + a + <span class="number">2</span> * b) / <span class="number">3</span>;</span><br><span class="line">    M[tp] = id, U[tp] = id;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a; i++) M[tp + i] = A.back(), A.pop_back(), U[tp + i] = id;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= b; i++) U[tp + a + i] = M[tp + a + i] = B.back(), B.pop_back();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tp; i &lt; nxt; i++) D[i] = id;</span><br><span class="line">    tp = nxt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nxt = tp + (a + <span class="number">2</span> * b) / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> mn = min(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mn; i++) &#123;</span><br><span class="line">        M[tp + i - <span class="number">1</span>] = U[tp + i - <span class="number">1</span>] = B.back(), B.pop_back();</span><br><span class="line">        D[tp + i - <span class="number">1</span>] = A.back(), A.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = tp + mn; i &lt; nxt; i += <span class="number">2</span>) &#123;</span><br><span class="line">            M[i] = U[i] = B.back(), B.pop_back();</span><br><span class="line">            M[i + <span class="number">1</span>] = U[i + <span class="number">1</span>] = B.back(), B.pop_back();</span><br><span class="line">            D[i] = D[i + <span class="number">1</span>] = B.back(), B.pop_back();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = tp + mn; i &lt; nxt; i++) &#123;</span><br><span class="line">            U[i] = A.back(), A.pop_back();</span><br><span class="line">            M[i] = A.back(), A.pop_back();</span><br><span class="line">            D[i] = A.back(), A.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tp = nxt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work3</span><span class="params">(<span class="keyword">int</span> k1, <span class="keyword">int</span> id1, <span class="keyword">int</span> k2, <span class="keyword">int</span> id2, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> step = (k1 - <span class="number">2</span>) / <span class="number">2</span>, nxt = tp + (k1 + k2 + a) / <span class="number">3</span>; M[tp] = id1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= step; i++) U[tp + i - <span class="number">1</span>] = D[tp + i - <span class="number">1</span>] = id1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= step; i++) </span><br><span class="line">        M[tp + i - <span class="number">1</span>] = A.back(), A.pop_back();</span><br><span class="line">    D[tp + step] = id1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tp + step, t = <span class="number">0</span>; i &lt; nxt; i++, t++) &#123;</span><br><span class="line">        M[i] = id2;</span><br><span class="line">        <span class="keyword">if</span> (t &amp; <span class="number">1</span>) D[i] = id2, U[i] = A.back(), A.pop_back();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            U[i] = id2;</span><br><span class="line">            <span class="keyword">if</span> (i != tp + step) D[i] = A.back(), A.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tp = nxt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work4</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> id, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> step = (k - <span class="number">2</span>) / <span class="number">2</span>, nxt = tp + (k + a) / <span class="number">3</span>; M[tp] = id;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= step; i++) U[tp + i - <span class="number">1</span>] = D[tp + i - <span class="number">1</span>] = id;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= step; i++)</span><br><span class="line">        M[tp + i - <span class="number">1</span>] = A.back(), A.pop_back();</span><br><span class="line">    D[tp + step] = id;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tp + step; i &lt; nxt; i++) &#123;</span><br><span class="line">        U[i] = A.back(), A.pop_back();</span><br><span class="line">        M[i] = A.back(), A.pop_back();</span><br><span class="line">        <span class="keyword">if</span> (i != tp + step) D[i] = A.back(), A.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    tp = nxt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, sum = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m), tp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; n) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"no"</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">1</span>) A.push_back(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">2</span>) B.push_back(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a &amp; <span class="number">1</span>) C1.push_back(P(a, i));</span><br><span class="line">        <span class="keyword">else</span> C2.push_back(P(a, i));</span><br><span class="line">        sum += a;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; <span class="number">3</span> * n) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"no"</span>), <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum != <span class="number">3</span> * n) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"no"</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"yes"</span>);</span><br><span class="line">    <span class="keyword">while</span> (tp &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (C1.size() || C2.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (B.size()) &#123;</span><br><span class="line">                <span class="keyword">int</span> k, id;</span><br><span class="line">                <span class="keyword">if</span> (C2.size()) k = C2.back().first, id = C2.back().second, C2.pop_back();</span><br><span class="line">                <span class="keyword">else</span> k = C1.back().first, id = C1.back().second, C1.pop_back();</span><br><span class="line">                <span class="keyword">int</span> a = min((<span class="keyword">int</span>)A.size(), (k - <span class="number">3</span>) / <span class="number">2</span>), b = k - <span class="number">3</span> - <span class="number">2</span> * a;</span><br><span class="line">                work1(k, id, a, b);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (C1.size()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = C1.back().first, id = C1.back().second; C1.pop_back();</span><br><span class="line">                    work1(k, id, (k - <span class="number">3</span>) / <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (C2.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> k1 = C2.back().first, id1 = C2.back().second; C2.pop_back();</span><br><span class="line">                        <span class="keyword">int</span> k2 = C2.back().first, id2 = C2.back().second; C2.pop_back();</span><br><span class="line">                        work3(k1, id1, k2, id2, (k1 + k2 - <span class="number">6</span>) / <span class="number">2</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> work4(C2.back().first, C2.back().second, A.size());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> work2(A.size(), B.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, U[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, M[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, D[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> exgcd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF568E Longest Increasing Subsequence</title>
      <link href="/2020/05/15/CF568E-Longest-Increasing-Subsequence/"/>
      <url>/2020/05/15/CF568E-Longest-Increasing-Subsequence/</url>
      
        <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定一个长度为$n$的序列，其中有$k$个位置是空出来的。给出$m$个数，你可以用这$m$个数来填补空位，但是每个数只能用一次，问最长上升子序列的长度最大是多少，要求输出方案。</p><script type="math/tex; mode=display">n, m\leq 10^5, k\leq 10^3</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>先不考虑输出方案。</p><p>首先有这样一种填数策略：先将最长上升子序列中的每一个空位填满，再用剩下的数随便填空位。</p><p>接下来我们分两种情况讨论：$i$是否是空位。</p><p>设$l_i$表示，当$i$不是空位的时候，前$i$个数的最长上升子序列长度。</p><p>设$f_i$表示，长度为$i$的上升序列结尾的最小值。</p><p>对于位置$i$，如果它不是空位，那么我们可以直接对$f$二分，从而确定这个位置的最长上升子序列$l_i$，同时更新$f$。</p><p>否则，直接从大到小枚举这个空位填的数。与非空位的转移类似，可以在$f$上二分找到决策点，但是由于我们是从大到小枚举的，因此也可以直接维护一个向前移动的指针。</p><p>那么最终$f$最靠后的有值的位置就是答案。</p><p>考虑如何输出方案，对于$l_i$，我们同时记录$p_i$表示序列上一项的位置；对于$f_i$，我们记录$g_i$表示$f_i$的结尾位置。我们从后往前依次确定每一项。如果$i$位置不是空位，那么直接转移到$p_i$即可。否则，我们记录后一项的数$x$，那么这个空位填的数就是在所有可用的数中，小于$x$的最大的数。</p><p>同时，枚举这个空位的前一项是啥，如果存在一个非空的位置$i$，满足$l_i$等于当前长度$-1$，并且$i$处的数小于此时填的数，那么可以直接转移到$i$；否则转移到上一个空位。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// l, p: 对于非空位置，以i结尾的最长上升子序列以及上一个位置</span></span><br><span class="line"><span class="comment">// f, g: 长度为i的上升子序列结尾的最小值以及位置</span></span><br><span class="line"><span class="keyword">int</span> l[N], p[N], f[N], g[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N], use[N]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; remain;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f)), <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(g)), f[<span class="number">0</span>] = g[<span class="number">0</span>] = <span class="number">0</span>, <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a; i &lt;= m; i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), remain.push_back(a);</span><br><span class="line">    sort(remain.begin(), remain.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">if</span> (num[i] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = n, mid, pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (f[mid] &lt; num[i]) pos = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ::l[i] = pos + <span class="number">1</span>, p[i] = g[pos];</span><br><span class="line">            <span class="keyword">if</span> (num[i] &lt; f[pos + <span class="number">1</span>]) f[pos + <span class="number">1</span>] = num[i], g[pos + <span class="number">1</span>] = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">0</span>; <span class="keyword">static</span> <span class="keyword">int</span> lst[N];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) lst[i] = f[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> a : remain) &#123;</span><br><span class="line">                <span class="keyword">while</span> (lst[pos + <span class="number">1</span>] &lt; a) pos++;</span><br><span class="line">                <span class="keyword">if</span> (a &lt; f[pos + <span class="number">1</span>]) f[pos + <span class="number">1</span>] = a, g[pos + <span class="number">1</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (g[ans + <span class="number">1</span>] &lt;= n) ans++;</span><br><span class="line">    <span class="keyword">int</span> pos = g[ans], up = <span class="number">1e9</span>, t = remain.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos) &#123;</span><br><span class="line">        ans--;</span><br><span class="line">        <span class="keyword">if</span> (num[pos] == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (remain[t] &gt;= up) t--;</span><br><span class="line">            up = num[pos] = remain[t], use[t] = <span class="number">1</span>; <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos &amp;&amp; !flag; i++) </span><br><span class="line">                <span class="keyword">if</span> (l[i] == ans &amp;&amp; num[i] != <span class="number">-1</span> &amp;&amp; num[i] &lt; up) </span><br><span class="line">                    pos = i, flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!flag) <span class="keyword">while</span> (num[pos] != <span class="number">-1</span>) pos--;</span><br><span class="line">        &#125; <span class="keyword">else</span> up = num[pos], pos = p[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (num[i] == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; remain.size() &amp;&amp; num[i] == <span class="number">-1</span>; j++) <span class="keyword">if</span> (!use[j])</span><br><span class="line">            num[i] = remain[j], use[j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, num[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.26联测T1 钩子</title>
      <link href="/2020/05/01/4-26%E8%81%94%E6%B5%8BT1-%E9%92%A9%E5%AD%90/"/>
      <url>/2020/05/01/4-26%E8%81%94%E6%B5%8BT1-%E9%92%A9%E5%AD%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>4.23联测</title>
      <link href="/2020/05/01/4-23%E8%81%94%E6%B5%8B/"/>
      <url>/2020/05/01/4-23%E8%81%94%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-矩阵求和"><a href="#T1-矩阵求和" class="headerlink" title="T1 矩阵求和"></a>T1 矩阵求和</h1><p>给你一个$n\times m$的矩阵，一开始第$i$行第$j$列的格子的值是$(i - 1)\times m + j$，现在要求实现以下操作：</p><ul><li>交换两行</li><li>交换两列</li><li>求一个子矩阵做$k$次前缀和之后的和，对$10^9+7$取模</li></ul><script type="math/tex; mode=display">n, m, q\leq 10^5, k\leq 10</script><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>我们考虑一次询问操作，维护此时每一行对应原矩阵的哪一行，每一列对应原矩阵的哪一列。我们将行记为$a_i$，将列记为$b_i$，那么此时第$i$行$j$列的格子的值为$(a_i - 1)\times m + b_j$。</p><p>接下来为了方便，我们给询问的矩阵的行列重标号一下，假设询问矩阵的大小为$r\times c$。</p><p>如果$k = 1$，那么$(i, j)$对答案的贡献就是$(r - i + 1)\times (c - j + 1)$，可以看作在右下角选一个点的方案数。</p><p>那么当$k&gt;1$时可以看出，这个贡献实际上是在当前点的右下角选择$k$个横纵坐标都不降的点的方案数。</p><p>因此答案为</p><script type="math/tex; mode=display">\begin{aligned}ans &= \sum_{i = 1}^r\sum_{j = 1}^c[(a_i - 1)\times m+b_j]{r - i + k\choose k}{c - j + k\choose k}\\&= m\times \sum_{i = 1}^r(a_i - 1){r - i + k\choose k}\sum_{j = 1}^c{c - j + k\choose k}+\cdots\end{aligned}</script><p>第二部分的计算与第一部分类似，这里省略一下。</p><p>第二个$\sum$里面的是一个组合恒等式，它等于${c + k\choose k}$，非要暴力算的话也可以。</p><p>那么接下来的问题就是如何计算第一个$\sum$。</p><p>此时有两种方法：第一种是直接将组合数暴力展开成关于$i$的多项式，第二种是先将组合数转为下降幂，再用斯特林数展开下降幂。事实上，这两种方法得出的结果是一样的。</p><script type="math/tex; mode=display">\begin{aligned}\sum_{i = 1}^ra_i{r - i + k\choose k}&= \frac{1}{k!}\sum_{i = 1}^ra_i(r - i + k)^{\underline{k}}\\&= \frac{1}{k!}\sum_{i = 1}^ra_i(-1)^k\sum_{j = 0}^k\begin{Bmatrix}k\\ j\end{Bmatrix}(i - r - k)^j\\&= \frac{1}{k!}\sum_{i = 1}^ra_i(-1)^k\sum_{j = 0}^k\begin{Bmatrix}k\\ j\end{Bmatrix}\sum_{l = 0}^ji^l(r + k)^{j - l}{j\choose l}(-1)^{j - l}\\&= \frac{(-1)^k}{k!}\sum_{j = 0}^k\begin{Bmatrix}k\\ j\end{Bmatrix}\sum_{l = 0}^j(r - k)^{j - l}{j\choose l}(-1)^{j - l}\sum_{i = 1}^ra_i\times i^l\end{aligned}</script><p>因此，维护$\sum a_i\times i^l$即可，其中$l\in [0, k]$。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x += y, x -= x &gt;= mod ? mod : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = x + y;</span><br><span class="line">    <span class="keyword">return</span> t &gt;= mod ? t - mod : t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tree[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += x &amp; -x) Inc(tree[x], y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= x &amp; -x) Inc(res, tree[x]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Add(mod - query(l - <span class="number">1</span>), query(r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; A[<span class="number">11</span>], B[<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S[<span class="number">11</span>][<span class="number">11</span>], C[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    S[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++) </span><br><span class="line">            S[i][j] = (S[i - <span class="number">1</span>][j - <span class="number">1</span>] + (LL)S[i - <span class="number">1</span>][j] * (i - <span class="number">1</span>)) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) </span><br><span class="line">            C[i][j] = Add(C[i - <span class="number">1</span>][j - <span class="number">1</span>], C[i - <span class="number">1</span>][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> wkr[N], zjk[N], pw[<span class="number">11</span>][N], inv[<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">FUCK</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; i++) </span><br><span class="line">        res = (LL)res * (n - i + <span class="number">1</span>) % mod * Pow(i, mod - <span class="number">2</span>) % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, q; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;q), pre();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) wkr[i] = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) zjk[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max(n, m) + <span class="number">11</span>; i++) &#123;</span><br><span class="line">        pw[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++) pw[j][i] = (LL)pw[j - <span class="number">1</span>][i] * i % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        A[i].n = n, B[i].n = m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) A[i].update(j, (LL)pw[i][j] * wkr[j] % mod); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) B[i].update(j, (LL)pw[i][j] * zjk[j] % mod); </span><br><span class="line">    &#125;</span><br><span class="line">    inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) </span><br><span class="line">        inv[i] = (LL)inv[i - <span class="number">1</span>] * Pow(i, mod - <span class="number">2</span>) % mod;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">5</span>]; <span class="keyword">int</span> a, b, c, d; <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>, s + <span class="number">1</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">'Q'</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;c, &amp;d); <span class="keyword">int</span> k; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">int</span> tmpA[<span class="number">11</span>], tmpB[<span class="number">11</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">                tmpA[i] = A[i].query(a, c), tmpB[i] = B[i].query(b, d);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> solve = [&amp;](<span class="keyword">int</span> lim, <span class="keyword">int</span> H[]) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; j++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= j; i++) &#123;</span><br><span class="line">                        <span class="keyword">int</span> h = (LL)H[i] * pw[j - i][lim + k] % mod * C[j][i] % mod;</span><br><span class="line">                        <span class="keyword">if</span> ((j - i) &amp; <span class="number">1</span>) h = mod - h;</span><br><span class="line">                        Inc(t, h);</span><br><span class="line">                    &#125;</span><br><span class="line">                    res = (res + (LL)t * S[k][j]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">                res = (LL)res * inv[k] % mod;</span><br><span class="line">                <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = mod - res;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">int</span> res1 = (LL)solve(c, tmpA) * m % mod, res2 = solve(d, tmpB);</span><br><span class="line">            res1 = (LL)res1 * FUCK(d - b + k + <span class="number">1</span>, k + <span class="number">1</span>) % mod, res2 = (LL)res2 * FUCK(c - a + k + <span class="number">1</span>, k + <span class="number">1</span>) % mod;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Add(res1, res2));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">'R'</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                A[i].update(a, (LL)pw[i][a] * (wkr[b] - wkr[a] + mod) % mod);</span><br><span class="line">                A[i].update(b, (LL)pw[i][b] * (wkr[a] - wkr[b] + mod) % mod);</span><br><span class="line">            &#125;</span><br><span class="line">            swap(wkr[a], wkr[b]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                B[i].update(a, (LL)pw[i][a] * (zjk[b] - zjk[a] + mod) % mod);</span><br><span class="line">                B[i].update(b, (LL)pw[i][b] * (zjk[a] - zjk[b] + mod) % mod);</span><br><span class="line">            &#125;</span><br><span class="line">            swap(zjk[a], zjk[b]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-西行寺无余涅槃"><a href="#T2-西行寺无余涅槃" class="headerlink" title="T2 西行寺无余涅槃"></a>T2 西行寺无余涅槃</h1><p>有$k$类菜，第$i$类菜有$a_i$种，再接下来的$n$天，每天你都会吃一种菜（注意不是吃了就没了）。如果你在第$i$天吃了第$j$类菜，那么会获得$p_{i, j}$的美味度，你最终的得分是每天美味度的异或和，$0\leq p_{i, j}&lt; 2^m$。问最终得分为$0, 1, \cdots 2^m - 1$的方案数。</p><script type="math/tex; mode=display">m + k\leq 20, k\leq 9, n\leq 10^6</script><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>为了方便起见，我们令接下来的$m = 2^m$。</p><p>考虑最暴力的$dp$，设$dp_{i, j}$表示前$i$天，美味度异或和为$j$的方案数。转移的时候对于第$i$天，我们在数组的$p_{i, j}$位置加上$a_j$，然后做一次<code>FWT</code>。</p><p>直接这样刚显然是不行的，时间复杂度是$O(nm\log m)$，会T飞。</p><p>由于是异或<code>FWT</code>，因此<code>FWT</code>之前位置$i$对<code>FWT</code>之后位置$j$的贡献系数为$(-1)^{bc(i\&amp; j)}$，这里$bc$表示<code>bitcount</code>。</p><p>因此实际上每一天<code>FWT</code>之后，每个位置的取值只有$2^k$种。比如当$k = 3$时，就有$a_1+a_2+a_3,a_1+a_2-a_3,a_1-a_2+a_3,\cdots$这$8$种取值。</p><p>考虑先对每一天做一次<code>FWT</code>，然后将对应位置的值乘起来，最后做一次<code>IFWT</code>。如果我们知道了最终每个位置，每种取值出现了多少次，那么就可以直接$pow$算出最后每个位置的乘积。</p><p>我们给每种取值重标号一下，将$a_1, a_2, \cdots ,a_k$的系数写下来，如果这一位的系数是$-1$就写$1$，否则就写$0$，然后将$a_1$作为最低位，将$a_k$作为最高位，可以得到一个二进制数。将这个二进制转为十进制就是这种取值的编号。</p><p>记$f_{pos, i}$表示在将$n$天都<code>FWT</code>之和，第$pos$个位置有多少天的值编号为$i$。我们的目的是要求出$f_{1\cdots n, 0\cdots 2^k - 1}$</p><p>考虑开一个数组，然后对于第$i$天，在第$p_{i, 1}$个位置$+1$，然后做一次<code>FWT</code>。</p><p>考虑此时$pos$这个位置的取值$x_1$，根据$f$的定义显然有</p><script type="math/tex; mode=display">f_{pos,0}-f_{pos, 1}+f_{pos, 2}-\cdots = x_1</script><p>如果对于第$i$天，在第$p_{i, 2}$个位置$+1$，然后<code>FWT</code>，那么可以得到</p><script type="math/tex; mode=display">f_{pos,0}+f_{pos,1}-f_{pos,2}-f_{pos, 3}+\cdots = x_2</script><p>即，考虑$i$的二进制，如果此时对应的这一位为$1$，那么系数为负，否则系数为正。</p><p>如果对于每一天，我们将$p_{i, 1}\oplus p_{i, 2}$这个位置$+1$，然后再做<code>FWT</code></p><p>考虑每一天这个东西对最终$pos$这个位置的贡献系数，为$(-1)^{bc[(p_1\oplus p_2)\&amp; pos]}$。</p><p>将这个东西拆开，可以得到$(-1)^{bc[(p_1\&amp; pos)\oplus (p_2\&amp; pos)]}$。</p><p>由于这个$bc$是写在指数上的，因此可以将这个东西拆开，得到$(-1)^{bc(p_1\&amp; pos) + bc(p_2\&amp; pos)}$</p><p>如果$bc(p_1\&amp; pos)$与$bc(p_2\&amp; pos)$同号，那么这个系数是正的，否则是负的。</p><p>这意味着，如果$p_{i, 1}\oplus p_{i, 2}$对$pos$的贡献为正，那么这一天<code>FWT</code>之后，$pos$这一位的系数编号中，最低的两位必然相同。</p><p>因此，可以得到方程</p><script type="math/tex; mode=display">f_{pos, 0}-f_{pos, 1}-f_{pos, 2}+f_{pos,3}+f_{pos, 4}-\cdots = x</script><p>如果每天考虑的不是两种菜，而是很多种菜呢？那么最终的方程中，如果$i$在这些菜对应位置$1$的个数为偶数，那么系数为$1$，否则系数为$-1$。</p><p>枚举$k$的子集做<code>FWT</code>，我们可以得到$2^k$个方程，而未知数恰好也有$2^k$个，接下来我们尝试解这个方程。</p><p>直接高斯消元显然不太行，考虑一种更神奇的做法。</p><p>将最终得到的方程组列出来，方便起见，我们省略$pos$这一维</p><script type="math/tex; mode=display">\begin{cases}f_0+f_1+f_2+\cdots &= n\\f_0-f_1+f_2-\cdots &= \cdots\\f_0-f_1+f_2+f_3-\cdots &= \cdots\\\cdots\end{cases}</script><p>可以发现一件有趣的事情，如果我们从$0$开始编号（即认为最开始那个方程为第$0$个方程），那么第$i$个方程的第$j$项系数为$(-1)^{bc(i\&amp; j)}$，原因上面已经说过了。</p><p>因此，等号右边的值恰好就是将所有$f$做一次<code>FWT</code>之后的结果，我们只需要做一次<code>IFWT</code>即可还原每个$f$。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inv2 = <span class="number">499122177</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + (mid &gt;&gt; <span class="number">1</span>); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = (a[j] + a[j + (mid &gt;&gt; <span class="number">1</span>)]) % mod, t1 = (a[j] - a[j + (mid &gt;&gt; <span class="number">1</span>)] + mod) % mod;</span><br><span class="line">                a[j] = t, a[j + (mid &gt;&gt; <span class="number">1</span>)] = t1;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IFWT</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + (mid &gt;&gt; <span class="number">1</span>); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = (LL)(a[j] + a[j + (mid &gt;&gt; <span class="number">1</span>)]) * inv2 % mod, t1 = (LL)(a[j] - a[j + (mid &gt;&gt; <span class="number">1</span>)] + mod) * inv2 % mod;</span><br><span class="line">                a[j] = t, a[j + (mid &gt;&gt; <span class="number">1</span>)] = t1;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[N][<span class="number">11</span>], a[<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; F[<span class="number">1</span> &lt;&lt; <span class="number">19</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> w[<span class="number">1</span> &lt;&lt; <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; m; i++) F[i].resize(<span class="number">1</span> &lt;&lt; k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; <span class="number">1</span> &lt;&lt; k; s++) &#123; <span class="comment">// 方程组的值</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(<span class="number">1</span> &lt;&lt; m, <span class="number">0</span>)</span></span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) <span class="keyword">if</span> (s &amp; (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>))</span><br><span class="line">                pos ^= p[i][j];</span><br><span class="line">            tmp[pos]++;</span><br><span class="line">        &#125;</span><br><span class="line">        FWT(tmp, <span class="number">1</span> &lt;&lt; m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; m; i++) </span><br><span class="line">            F[i][s] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; m; i++)  <span class="comment">// 求解方程组</span></span><br><span class="line">        F[i][<span class="number">0</span>] = n, IFWT(F[i], <span class="number">1</span> &lt;&lt; k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; k; i++) &#123; <span class="comment">// 预处理每个编号对应的系数</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)) t = (t + mod - a[j]) % mod;</span><br><span class="line">            <span class="keyword">else</span> t = (t + a[j]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        w[i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">1</span> &lt;&lt; m, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; k; j++)</span><br><span class="line">            t = (LL)t * Pow(w[j], F[i][j]) % mod;</span><br><span class="line">        ans[i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    IFWT(ans, <span class="number">1</span> &lt;&lt; m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; m; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-鱼贯而入"><a href="#T3-鱼贯而入" class="headerlink" title="T3 鱼贯而入"></a>T3 鱼贯而入</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h is the hash tabl</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_fish</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> &amp;cnt, <span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> y = x % len;</span><br><span class="line">    <span class="keyword">while</span>(h[y] != -l &amp;&amp; h[y] != x)</span><br><span class="line">    y = (y + <span class="number">1</span>) % <span class="number">1</span>en, cnt++;</span><br><span class="line">    h[y] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; len; i ++) h[i]=<span class="number">-1</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) add_fish(cnt, a[i], len);</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给出互不相同的$n$个数$a_1, a_2, \cdots,a_n$，你需要找到一个合适的$len(\geq n)$，使得最后的<code>cnt</code>最大，问<code>cnt</code>最大是多少。</p><script type="math/tex; mode=display">n\leq 200,1\leq a_i\leq 10^{18}</script><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>忽略$len\geq n$的限制，如果<code>len</code>增大了，那么显然有至少两个数发生了碰撞，也就是这两个数模$len$之后相同。那么一种不错的想法是，枚举碰撞的两个数，然后把它们的差的所有质因数拿出来作为<code>len</code>暴力验证。</p><p>我们之所以不需要拿出所有的因数，是因为因数肯定没有质因数优秀，质因数会导致更多的碰撞。</p><p>但是这样有个问题，我们无法保证$len\geq n$。如果有这个限制，那么最优秀的$len$就不一定是质数了。</p><p>其实有一个奇妙的结论：我们只需要拿出$[n, n^2]$之间的所有数暴力验证即可。</p><p>考虑最优的$len$，如果这个$len$是合数，那么它必定是我们之前筛出来的某个$&lt;len$的质因数的倍数。我们不妨设这个质因数是$p$，这个合数为$x$，那么有$x=pq$。接下来我们证明：这个合数必定小于等于$n^2$。</p><p>考虑反证法，如果最优的$len&gt;n^2$，且$len$是合数，那么它必定有一个因数大于等于$n$，取这个数显然比取$len$更优秀。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">mul</span><span class="params">(LL a, LL b, LL mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a * b - (LL)((<span class="keyword">long</span> <span class="keyword">double</span>)a / mod * b + <span class="number">0.5</span>) * mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Pow</span><span class="params">(LL x, LL y, LL mod)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)mul(x, x, mod)) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = mul(res, x, mod);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> _A[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">131</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Miller_Rabin</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LL tmp = n - <span class="number">1</span>; <span class="keyword">int</span> ct = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!(tmp &amp; <span class="number">1</span>)) tmp &gt;&gt;= <span class="number">1</span>, ct++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == _A[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        LL a = Pow(_A[i], tmp, n), nxt = a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= ct; j++) &#123;</span><br><span class="line">            nxt = mul(a, a, n);</span><br><span class="line">            <span class="keyword">if</span> (nxt == <span class="number">1</span> &amp;&amp; a != <span class="number">1</span> &amp;&amp; a != n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            a = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> LL _rand(LL x, LL c, LL mod) &#123;</span><br><span class="line">    <span class="keyword">return</span> (mul(x, x, mod) + c) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> LL _rand() &#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)rand() &lt;&lt; <span class="number">48</span> | (LL)rand() &lt;&lt; <span class="number">32</span> | rand() &lt;&lt; <span class="number">16</span> | rand();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> LL _abs(LL x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Pollard_Rho</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">    LL s = <span class="number">0</span>, t = <span class="number">0</span>, c = _rand() % (n - <span class="number">1</span>) + <span class="number">1</span>, val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cir = <span class="number">1</span>; ; cir &lt;&lt;= <span class="number">1</span>, s = t, val = <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cir; i++) &#123;</span><br><span class="line">            t = _rand(t, c, n), val = mul(val, _abs(t - s), n);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">127</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                LL g = gcd(val, n);</span><br><span class="line">                <span class="keyword">if</span> (g != <span class="number">1</span>) <span class="keyword">return</span> g;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        LL g = gcd(val, n);</span><br><span class="line">        <span class="keyword">if</span> (g != <span class="number">1</span>) <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;LL&gt; divisors; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Factor</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (Miller_Rabin(n)) <span class="keyword">return</span> divisors.push_back(n), <span class="keyword">void</span>();</span><br><span class="line">    LL d = n;</span><br><span class="line">    <span class="keyword">while</span> (d == n) d = Pollard_Rho(n);</span><br><span class="line">    <span class="keyword">while</span> (n % d == <span class="number">0</span>) n /= d;</span><br><span class="line">    Factor(n), Factor(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;LL, LL&gt; fuck;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">find</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!fuck.count(x)) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fuck[x] = find(fuck[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">push</span><span class="params">(LL k, LL len)</span> </span>&#123;</span><br><span class="line">    LL t = find(k);</span><br><span class="line">    fuck[t] = (t + <span class="number">1</span>) % len;</span><br><span class="line">    <span class="keyword">if</span> (t &gt;= k) <span class="keyword">return</span> t - k;</span><br><span class="line">    <span class="keyword">return</span> t + len - k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL num[<span class="number">210</span>]; <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">solve</span><span class="params">(LL len)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>; fuck.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res += push(num[i] % len, len);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Abs</span><span class="params">(LL x)</span> </span>&#123; <span class="keyword">return</span> x &gt; <span class="number">0</span> ? x : -x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%*d%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;num[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) </span><br><span class="line">            Factor(Abs(num[j] - num[i]));</span><br><span class="line">    LL res = <span class="number">0</span>; sort(divisors.begin(), divisors.end());</span><br><span class="line">    divisors.resize(unique(divisors.begin(), divisors.end()) - divisors.begin());</span><br><span class="line">    <span class="comment">// cout &lt;&lt; solve(6) &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt;= n * n; i++) &#123;</span><br><span class="line">        res = max(res, solve(i));</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; res &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : divisors) <span class="keyword">if</span> (t &gt; n * n) res = max(res, solve(t));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>4.22联测</title>
      <link href="/2020/04/22/4-22%E8%81%94%E6%B5%8B/"/>
      <url>/2020/04/22/4-22%E8%81%94%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-未来"><a href="#T1-未来" class="headerlink" title="T1 未来"></a>T1 未来</h1><p>有一棵$n$个节点的树，一开始每个节点$i$都有其权值$v_i$。</p><p>对于一个$1$到$n$的排列$p_1$，我们会按照$p_1,p_2,\cdots$的顺序依次操作下去，每次操作会导致$p_i$以及它的子树中所有节点的权值加上$v_{p_i}$，注意$v_{p_i}$是在动态变化的。</p><p>求出所有的排列$p$按照这样的顺序操作之后整棵树的权值之和的和。</p><p>保证树的<code>prufer</code>序随机生成。</p><script type="math/tex; mode=display">n\leq 10^5</script><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>我们枚举两个点$u, v$，其中$u$是$v$的祖先，考虑$u$对$v$最终权值的贡献。</p><p>假设$u, v$的路径上的点数为$d$（包含$u, v$），我们忽略这条路径上除了$u, v$以外的点，假设$u$的权值为$a$。</p><p>假设$d = 3$，我们将$u$编号为$1$，$v$编号为$3$，$u, v$中间的那个点编号为$2$。</p><p>不考虑每个点原来的权值对自己的贡献，那么当排列为<code>123</code>时，第一次操作之后每个点的权值变为了$(a, a, a)$，第二次操作之后变成了$(a, 2a, 2a)$，第三次操作过后变成了$(a, 2a, 4a)$。</p><p>如果排列为<code>132</code>，那么第二次操作过后的权值为$(a, a, 2a)$，第三次操作之后的权值为$(a, 2a, 3a)$。</p><p>观察这个过程，可以发现每次我们都会给一个后缀加上某个点的值。如果将这个过程看作是某个$dp$的过程，可以发现实际上我们在统计：从第一个位置出发的上升子序列个数。</p><p>枚举上升子序列的长度，可以得出此时如果只考虑这条链上的排列，$u$对$v$的贡献系数为</p><script type="math/tex; mode=display">w_d=\sum_{i = 0}^d{d - 1\choose i - 1}{d\choose i}(d-i)!</script><p>考虑其它点的排列方式，那么答案为</p><script type="math/tex; mode=display">\sum_{u, v}w_d{n\choose d}(n-d)!</script><p>需要注意的是，$u$对自己的贡献系数为$2\times n!$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from] &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to] &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son[N]; <span class="keyword">int</span> dep[N], mx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    dep[u] = dep[f] + <span class="number">1</span>, mx = max(mx, dep[u]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) &#123;</span><br><span class="line">            dfs(e[i].to, u);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : son[e[i].to]) son[u].push_back(v);</span><br><span class="line">            son[u].push_back(e[i].to);</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> w[N], frac[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mx; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) </span><br><span class="line">            w[i] = (w[i] + (LL)C(i - <span class="number">1</span>, j - <span class="number">1</span>) * frac[i] % mod * inv[j]) % mod;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) tmp[i] = C(n, i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = frac[n] * <span class="number">2</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : son[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = dep[v] - dep[i];</span><br><span class="line">            res = (res + (LL)w[t + <span class="number">1</span>] * tmp[t + <span class="number">1</span>] % mod * frac[n - t - <span class="number">1</span>]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = (ans + (LL)res * num[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-幸运"><a href="#T2-幸运" class="headerlink" title="T2 幸运"></a>T2 幸运</h1><p>给出一棵树，一开始这棵树上有$n$个节点，支持如下操作：</p><ul><li><code>1 u w</code> 新建一个节点，并将其编号为$n + i + 1$，其中$i$为之前出现的操作$1$的个数，它的父亲为$u$，边权为$w$。</li><li><code>2 u</code> 断开$u$与其父亲的连边，保证这条边没有被断开过。</li><li><code>3 op</code> 撤销第<code>op</code>次询问的断开操作。</li><li><code>4 k</code> 从$1$出发，每次等概率随机向一个儿子走去，走到叶子节点会立刻返回$1$号节点，问到达$k$的期望时间。保证此时$1$和$k$连通。</li></ul><script type="math/tex; mode=display">n, q\leq 10^6, w\leq 998244353</script><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>先考虑如果只有一组询问，怎么计算答案。</p><p>求出此时根到每个叶子需要走的距离以及到这个叶子的概率，我们记$E=\sum dis_vp_v,P=\sum p_v$</p><p>$k$的叶子不可能到达，因此在此次行走没有走到$k$的情况下，到其它所有叶子时间的期望为</p><script type="math/tex; mode=display">t=\frac{E - E_k}{P-p_k}</script><p>这里$E_k$表示$k$的子树中叶子的期望之和，那么这个询问的答案就是</p><script type="math/tex; mode=display">t\times(\frac{1}{1-p_k}-1)+dis_k</script><p>考虑将所有操作离线，然后建出最终的树，那么这个过程实际上就是将一些节点标记为叶子，或者某一个节点不再是叶子，同时我们需要维护每个点此时连通的儿子个数。</p><p>对这棵树的<code>dfs</code>序建一棵线段树，线段树上维护$\sum dis_u\times p_u$以及$\sum p_u$。</p><p>$p_v$显然等于$v$每个祖先儿子个数的倒数的乘积，这个很好维护，当更新一个点的儿子个数时我们直接区间乘就行了。需要注意的是这个概率是无视当前点是否与$1$连通的，即断边操作除了会更新某个点的儿子个数以外，对$p_v$没有任何影响。</p><p>有一件需要注意的事情，每次断边的操作并不保证$u$与根连通，$u$子树中的叶子不再能到达了，我们考虑对这个子树对应的区间打上一个标记，表示它被断边操作覆盖的次数，那么一个区间的答案就是哪些被覆盖次数为$0$的位置答案之和。</p><p>维护每个区间中被覆盖次数的最小值，以及覆盖次数等于这个值的点的答案之和，那么一次断边操作我们就直接给这个区间加一层覆盖就行了。</p><p>方便起见，我们给这棵树上所有不是叶子节点的点的覆盖次数$+1$，那么答案就是所有被覆盖次数为$0$的点的答案之和。</p><p>对于操作$1$，此时出现了一个新的叶子，同时其父亲节点的儿子个数加了$1$，这有可能会导致原来是叶子的父亲节点不再是叶子了。</p><p>对于操作$2$，直接按照上面的过程维护即可，注意更新父亲节点的儿子个数，以及父亲节点有可能成为叶子。</p><p>对于操作$3$，撤销它对应的标记，同时更新父亲节点的儿子个数。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mn, sum1, sum2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = x + y;</span><br><span class="line">    <span class="keyword">return</span> t &gt;= mod ? t - mod : t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x += y, x -= x &gt;= mod ? mod : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> data <span class="title">Merge</span><span class="params">(data a, data b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mn = min(a.mn, b.mn); </span><br><span class="line">    <span class="keyword">if</span> (a.mn != b.mn) <span class="keyword">return</span> a.mn &lt; b.mn ? a : b;</span><br><span class="line">    <span class="keyword">return</span> (data)&#123; a.mn, Add(a.sum1, b.sum1), Add(a.sum2, b.sum2) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, tag, tag1; data t;</span><br><span class="line">&#125; T[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    T[rt].t = Merge(T[rt &lt;&lt; <span class="number">1</span>].t, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wkr</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    T[rt].tag += x, T[rt].t.mn += x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">zjk</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    T[rt].tag1 = (LL)T[rt].tag1 * x % mod;</span><br><span class="line">    T[rt].t.sum1 = (LL)T[rt].t.sum1 * x % mod;</span><br><span class="line">    T[rt].t.sum2 = (LL)T[rt].t.sum2 * x % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T[rt].tag) &#123;</span><br><span class="line">        wkr(rt &lt;&lt; <span class="number">1</span>, T[rt].tag), wkr(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, T[rt].tag);</span><br><span class="line">        T[rt].tag = <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (T[rt].tag1 != <span class="number">1</span>) &#123;</span><br><span class="line">        zjk(rt &lt;&lt; <span class="number">1</span>, T[rt].tag1), zjk(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, T[rt].tag1);</span><br><span class="line">        T[rt].tag1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len[N], bk[N], n, ct[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    T[rt].l = l, T[rt].r = r, T[rt].tag1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> T[rt].t.mn = (!!ct[bk[l]]) || bk[l] &gt; n, T[rt].t.sum1 = len[bk[l]], T[rt].t.sum2 = <span class="number">1</span>, <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; build(rt &lt;&lt; <span class="number">1</span>, l, mid), build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> zjk(rt, x), <span class="keyword">void</span>();</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) mul(rt &lt;&lt; <span class="number">1</span>, start, end, x);</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) mul(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, start, end, x);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> wkr(rt, x), <span class="keyword">void</span>();</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) add(rt &lt;&lt; <span class="number">1</span>, start, end, x);</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) add(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, start, end, x);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">data <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> T[rt].t;</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">if</span> (end &lt;= mid) <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span>, start, end);</span><br><span class="line">    <span class="keyword">if</span> (start &gt; mid) <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, start, end);</span><br><span class="line">    <span class="keyword">return</span> Merge(query(rt &lt;&lt; <span class="number">1</span>, start, end), query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, start, end));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from], w &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to], w &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[N], dfsn, ed[N], inv[N], fa[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    dfn[u] = ++dfsn, bk[dfsn] = u, fa[u] = f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) &#123;</span><br><span class="line">            len[e[i].to] = Add(len[u], e[i].w), dfs(e[i].to, u);</span><br><span class="line">            <span class="keyword">if</span> (e[i].to &lt;= n) ct[u]++;</span><br><span class="line">        &#125;  </span><br><span class="line">    ed[u] = dfsn; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ZJKAK</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> op, a, b;</span><br><span class="line">&#125; q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> ls, <span class="keyword">int</span> nw)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; T[1].t.sum2 &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; "update: " &lt;&lt; u &lt;&lt; ' ' &lt;&lt; ls &lt;&lt; ' ' &lt;&lt; nw &lt;&lt; endl;</span></span><br><span class="line">    mul(<span class="number">1</span>, dfn[u] + <span class="number">1</span>, ed[u], (LL)max(ls, <span class="number">1</span>) * max(inv[nw], <span class="number">1</span>) % mod);</span><br><span class="line">    <span class="comment">// cout &lt;&lt; T[1].t.sum2 &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m); <span class="keyword">int</span> ncnt = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++) inv[i] = Pow(i, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b; read(a), read(b);</span><br><span class="line">        adde(a, i, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        read(q[i].op), read(q[i].a);</span><br><span class="line">        <span class="keyword">if</span> (q[i].op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x; read(x);</span><br><span class="line">            adde(++ncnt, q[i].a, x), q[i].b = ncnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>), build(<span class="number">1</span>, <span class="number">1</span>, ncnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">if</span> (ct[i]) mul(<span class="number">1</span>, dfn[i] + <span class="number">1</span>, ed[i], inv[ct[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i].op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++ct[q[i].a] == <span class="number">1</span>) add(<span class="number">1</span>, dfn[q[i].a], dfn[q[i].a], <span class="number">1</span>);</span><br><span class="line">            add(<span class="number">1</span>, dfn[q[i].b], dfn[q[i].b], <span class="number">-1</span>);</span><br><span class="line">            update(q[i].a, ct[q[i].a] - <span class="number">1</span>, ct[q[i].a]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (q[i].op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q[i].a;</span><br><span class="line">            add(<span class="number">1</span>, dfn[u], ed[u], <span class="number">1</span>), ct[fa[u]]--, update(fa[u], ct[fa[u]] + <span class="number">1</span>, ct[fa[u]]);</span><br><span class="line">            <span class="keyword">if</span> (!ct[fa[u]]) add(<span class="number">1</span>, dfn[fa[u]], dfn[fa[u]], <span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (q[i].op == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q[q[i].a].a;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; "fuck: " &lt;&lt; u &lt;&lt; endl;</span></span><br><span class="line">            add(<span class="number">1</span>, dfn[u], ed[u], <span class="number">-1</span>), ct[fa[u]]++, update(fa[u], ct[fa[u]] - <span class="number">1</span>, ct[fa[u]]);</span><br><span class="line">            <span class="keyword">if</span> (ct[fa[u]] == <span class="number">1</span>) add(<span class="number">1</span>, dfn[fa[u]], dfn[fa[u]], <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q[i].a; </span><br><span class="line">            data A = T[<span class="number">1</span>].t, B = query(<span class="number">1</span>, dfn[u], ed[u]), C = query(<span class="number">1</span>, dfn[u], dfn[u]);</span><br><span class="line">            <span class="keyword">int</span> t1 = A.sum1, t2 = A.sum2;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; t1 &lt;&lt; ' ' &lt;&lt; t2 &lt;&lt; ' ' &lt;&lt; B.mn &lt;&lt; ' ' &lt;&lt; B.sum1 &lt;&lt; ' ' &lt;&lt; B.sum2 &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (B.mn == <span class="number">0</span>) Inc(t1, mod - B.sum1), Inc(t2, mod - B.sum2);</span><br><span class="line">            <span class="keyword">int</span> other = (LL)t1 * Pow(t2, mod - <span class="number">2</span>) % mod, tim = Pow(C.sum2, mod - <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Add((LL)other * (tim - <span class="number">1</span>) % mod, len[u]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-重逢"><a href="#T3-重逢" class="headerlink" title="T3 重逢"></a>T3 重逢</h1><p>有$n$堆石子，一开始第$i$堆石子有$a_i$颗。</p><p>先手会将所有石子分为数目相等的两堆，接着在分出的第一堆石子上，两人交替取石子，先手先取。如果第一堆石子被取完了，那么就接着在第二堆石子上取，后手先取。</p><p>每人每次只能取一棵石子，第一堆石头被取完之后，假如此时第$i$堆石子被先手取了$c_i$个，那么先手将会获得$\lfloor\frac{c_i}{p_i}\rfloor\times v_i$的分数。在第二堆石头被取完之后也按照这个规则计算分数，先手的得分为两次游戏的分数之和。</p><p>先手想要最大化自己的得分，后手想要最小化先手的得分，问先手的得分最终是多少。</p><script type="math/tex; mode=display">n\leq 2000, \sum a_i\leq 2\times 10^6,\sum p_i\leq 2000</script><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>我们先不考虑先手分石子的操作，那么后手一定可以通过跟先手进行镜像操作，使得对于第$i$堆石子，先手取到的石子个数不超过$\lceil\frac{a_i}{2}\rceil$。</p><p>因此，对于一堆石子，先手要么能取到$\lceil\frac{a_i}{2}\rceil$颗石子，要么能取到$\lfloor\frac{a_i}{2}\rfloor$颗石子，这取决于是先手先操作还是后手先操作。</p><p>如果$\lfloor\frac{a_i}{2p_i}\rfloor=\lceil\frac{a_i}{2p_i}\rceil$，那么无论是先手先操作还是后手先操作，先手的得分都是固定的。</p><p>否则则意味着$2p_i\mid a_i+1$，即$a_i\equiv -1\pmod{2p_i}$。此时如果先手先操作，那么可以多获得$v_i$的分数。我们将这种石子成为特殊的石子。</p><p>将所有特殊的石子按照权值从大到小排序，那么最终的方案一定是先手先取第一堆，然后后手取第二堆，先手取第三堆，后手取第四堆这样交替取。</p><p>接下来考虑先手第一次划分的过程，可以考虑这样一个$dp$：设$dp[i][j][1/0][1/0]$表示已经考虑了前$i$堆石子的划分方案，此时第一堆石子共有$j$个，第一堆中的特殊石子堆数的奇偶性以及第二堆中特殊石子堆数的奇偶性，先手最多能获得多少分。</p><p>那么答案就是$dp[n][\frac{\sum a_i}{2}][1/0][1/0]$。</p><p>直接$dp$显然要不得，考虑优化。可以注意到一件奇妙的事情，对于第$i$堆石子先手划分出的两堆，如果从第二堆拿出$2p_i$个石子到第一堆中，不会导致最终先手的得分变化，我们将这$2p_i$个石头称为一组。</p><p>因此对于每一堆石子，我们只需要考虑先手将$0$到$2p_i-1$个石子划分到第一堆的情况，然后通过将第二堆石子挪动到第一堆石子来调整最终第一堆石子个数的总和。</p><p>我们记$r_i=a_i\mod 2p_i$，如果先手划分给第一堆的石子个数不超过$r_i$，那么可以自由分配的石头组数为$\lfloor\frac{a_i}{2p_i}\rfloor$，否则为$\lfloor\frac{a_i}{2p_i}\rfloor - 1$。</p><p>考虑统一这两个值，如果在$dp$的过程中，对于划分给第一堆的石子个数不超过$r_i$的情况，我们同时考虑先手划分出这$x$个石子以及$x+2p_i$个石子的情况，那么此时自由分配的石子个数就变成了$\lfloor\frac{a_i}{2p_i}\rfloor - 1$。</p><p>接着，问题转化为：第$i$堆石头被分为了若干组，每组的石头个数为$2p_i$，问能否通过拿出若干组石头凑出$0, 1,\cdots , \frac{\sum a_i}{2}$个石子。</p><p>将$p_i$相等的石头堆归为一类，至多有$\sqrt{\sum p_i}$类，接下来相当于是一个多重背包，使用二进制分组+<code>bitset</code>即可。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a, p, v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> data &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> v &gt; b.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>][N * <span class="number">4</span>], remain[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, tot = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;p[i].a, &amp;p[i].p, &amp;p[i].v), tot += p[i].a;</span><br><span class="line">    sort(p + <span class="number">1</span>, p + n + <span class="number">1</span>); <span class="keyword">int</span> cur = <span class="number">0</span>, s = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span>(dp)), dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cur ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= s; j++)</span><br><span class="line">            dp[cur][<span class="number">0</span>][<span class="number">0</span>][j] = dp[cur][<span class="number">0</span>][<span class="number">1</span>][j] = dp[cur][<span class="number">1</span>][<span class="number">0</span>][j] = dp[cur][<span class="number">1</span>][<span class="number">1</span>][j] = <span class="number">-1e9</span>;</span><br><span class="line">        <span class="keyword">int</span> h = max(p[i].a / (<span class="number">2</span> * p[i].p) - <span class="number">1</span>, <span class="number">0</span>); remain[p[i].p] += h;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * p[i].p &amp;&amp; j &lt;= p[i].a; j++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> process = [&amp;](<span class="keyword">int</span> x) &#123; <span class="comment">// 给第一堆分配 x</span></span><br><span class="line">                <span class="keyword">int</span> tmp = p[i].p;</span><br><span class="line">                assert(x &gt;= <span class="number">0</span> &amp;&amp; x &lt;= p[i].a);</span><br><span class="line">                <span class="keyword">auto</span> check = [&amp;](<span class="keyword">int</span> x) -&gt; <span class="keyword">bool</span> &#123; <span class="keyword">return</span> x % (<span class="number">2</span> * tmp) == <span class="number">2</span> * tmp - <span class="number">1</span>; &#125;;</span><br><span class="line">                <span class="keyword">bool</span> t1 = check(x), t2 = check(p[i].a - x);</span><br><span class="line">                <span class="keyword">int</span> val = x / (<span class="number">2</span> * tmp) * p[i].v + (p[i].a - x) / (<span class="number">2</span> * tmp) * p[i].v;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;= <span class="number">1</span>; a++)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= <span class="number">1</span>; b++)</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= s; l++) <span class="keyword">if</span> (dp[cur ^ <span class="number">1</span>][a][b][l] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ta = a, tb = b, v = dp[cur ^ <span class="number">1</span>][a][b][l] + val;</span><br><span class="line">                            <span class="keyword">if</span> (t1) &#123; ta ^= <span class="number">1</span>; <span class="keyword">if</span> (ta) v += p[i].v; &#125;</span><br><span class="line">                            <span class="keyword">if</span> (t2) &#123; tb ^= <span class="number">1</span>; <span class="keyword">if</span> (!tb) v += p[i].v; &#125;</span><br><span class="line">                            dp[cur][ta][tb][l + x] = max(dp[cur][ta][tb][l + x], v);</span><br><span class="line">                        &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            process(j);</span><br><span class="line">            <span class="keyword">if</span> (j &lt;= p[i].a % (<span class="number">2</span> * p[i].p) &amp;&amp; j + <span class="number">2</span> * p[i].p &lt;= p[i].a) </span><br><span class="line">                process(j + <span class="number">2</span> * p[i].p); </span><br><span class="line">        &#125;</span><br><span class="line">        s += <span class="number">4</span> * p[i].p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;500000&gt; g; g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N - <span class="number">10</span>; i++) <span class="keyword">if</span> (remain[i]) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp; <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; s + t &lt;= remain[i]; t *= <span class="number">2</span>) </span><br><span class="line">            tmp.push_back(t), s += t;</span><br><span class="line">        <span class="keyword">if</span> (s != remain[i]) tmp.push_back(remain[i] - s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t : tmp) </span><br><span class="line">            g |= g &lt;&lt; t * i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;= <span class="number">1</span>; a++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= <span class="number">1</span>; b++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i * <span class="number">2</span> &lt;= tot / <span class="number">2</span>; i++) <span class="keyword">if</span> (g[i] &amp;&amp; tot / <span class="number">2</span> - i * <span class="number">2</span> &gt;= <span class="number">0</span>) </span><br><span class="line">                res = max(res, dp[cur][a][b][tot / <span class="number">2</span> - i * <span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 博弈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF643F Bears and Juice</title>
      <link href="/2020/04/21/CF643F-Bears-and-Juice/"/>
      <url>/2020/04/21/CF643F-Bears-and-Juice/</url>
      
        <content type="html"><![CDATA[<p>有$n$头熊和若干个桶，其中有一个桶里面是酒，其它桶里面都是饮料，但所有熊一开始并不知道酒在哪个桶里面。每一天，每头熊都可以选择一些桶喝。如果一头熊喝到了酒，那么它就会去睡觉，并且会一直睡下去不再回来。</p><p>一共有$p$个睡觉的位置，熊们想知道酒在哪个桶中。如果睡觉的熊超过了$p$头，或者所有熊都睡觉了，那么熊们酒失败了。</p><p>令$R_i$表示共有$i$天时，桶的个数最多是多少，使得无论酒在哪个桶中，熊们都可以猜出酒在哪里。分别求出$R_1, R_2, \cdots, R_q$。</p><script type="math/tex; mode=display">n\leq 10^9, p\leq 130, q\leq 2\times 10^6</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>非常神仙的一道题。</p><p>我们假设所有熊喝的方案一开始就已经确定好了，然后将一种情况扔给所有熊尝试，那么我们最终可以获得的信息是：</p><ul><li>某一头熊是否会睡觉</li><li>如果这头熊睡觉了，那么是在第几天睡的</li></ul><p>对于两种情况，它们一定对应两种不同的信息，否则熊们就无法区分这两种情况。而一种返回的信息不一定能对应上一种情况，因此总情况数的上界也就是桶的最大个数就是信息的总数。</p><p>令$p = \min(p, n - 1)$，假设此时有$d$天，那么这个上界是</p><script type="math/tex; mode=display">\sum_{i = 0}^p{n\choose i}d^i</script><p>枚举最终有多少头熊睡觉，每头熊都可以选择$d$天中的某一天睡觉，因此总方案数就是这个。</p><p>接下来我们考虑构造方案</p><p>对于第$i$种情况，它对应第$i$个桶中是酒。如果在第$x$天，这种情况中有$y$头熊会睡觉，那么我们就在最终的方案中，让这$y$头熊在第$x$天喝这个桶。</p><p>这道题的模数不是质数，因此需要暴力求组合数，即拿出分母中的每一项来约分，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> b ? gcd(b, a % b) : a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; i++) tmp.push_back(n - i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> zjk = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : tmp) <span class="keyword">if</span> (t != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> g = gcd(zjk, t);</span><br><span class="line">            zjk /= g, t /= g;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : tmp) res *= t;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Pow</span><span class="params">(LL x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x *= x) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res *= x;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL t[<span class="number">150</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;p, &amp;q), p = min(p, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= p; i++) t[i] = C(n, i);</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        LL tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= p; j++) </span><br><span class="line">            tmp += t[j] * Pow(i, j);</span><br><span class="line">        res ^= tmp * i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%u\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SCOI2018 题解</title>
      <link href="/2020/04/12/SCOI2018-%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/04/12/SCOI2018-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>好早以前就有过写一下SCOI2018题解的想法了，毕竟是自己参加过的第一次省选。可惜当时我非常菜，啥都不会，然后就咕咕咕了</p><p>最近四川省重新组织了一场SCOI2018的重现赛，现在我来补一下题解</p><p>题目描述会尽可能还原原题的描述</p><a id="more"></a><h1 id="D1T1-树"><a href="#D1T1-树" class="headerlink" title="D1T1 树"></a>D1T1 树</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一棵大小为$n$的树上，点从$1$到$n$标号，第$i$个点的点权为$A_i$，要求支持两种操作</p><ul><li>$1\ u\,$询问从$u$出发的简单路径，经过的点权之和的最大值</li><li>$2\ u\ v\,$将$u$的权值修改为$v$</li></ul><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个整数$n,m$，表示树的大小和操作数</p><p>第二行$n - 1$个整数，第$i$个整数$p_i$表示$p_i$和$i + 1$有边相连</p><p>第三行$n$个整数，分别代表每个点的点权</p><p>接下来$m$行，每行描述一个操作，格式见题目描述</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每个询问操作，输出经过的点权之和的最大值</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于$10\%$的数据，满足$n\leq 1000, m\leq 1000$</p><p>对于另$20\%$的数据，不存在修改操作</p><p>对于另$20\%$的数据，满足$p_i = i$</p><p>对于$100\%$的数据，满足$n, m\leq 10^5, -10^4\leq A_i, v\leq 10^4$</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>在复现赛中，这道题的内存限制从<code>64MB</code>变成了<code>512MB</code></p><p>熟悉<code>LCT</code>维护虚子树的话可以看出，这道题实际上就是该算法的模板题</p><p>具体来说，考虑<code>LCT</code>剖出的每一条重链，该重链对应一棵<code>splay</code>。对于这棵<code>splay</code>上的每个节点，它在<code>splay</code>上的子树都对应原树中的一条子链。我们维护从这条子链的最浅点（即子树中最靠左的点）出发，在当前重链上只能经过<code>splay</code>上其子树内的点，并且可以从某个点走进虚儿子的最长路径长度。此外，我们还需要维护这条子链上的所有点（即<code>splay</code>子树中的点）的点权之和</p><p>对于每个点我们开一个<code>multiset</code>，维护从它的每个虚儿子走过来的最长路径。注意在<code>access</code>的时候需要修改</p><p>对于每个询问，直接将$u$<code>makeroot</code>，然后查询它对应的最长路径即可</p><p>如果在<code>makeroot</code>的时候翻转了<code>splay</code>，那么我们还需要额外维护从每条子链的最深点出发的最长路径</p><details><summary>代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N], ch[<span class="number">2</span>][N], sum[N], L[N], R[N], val[N], rev[N]; <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123; <span class="keyword">return</span> (u != ch[<span class="number">0</span>][fa[u]] &amp;&amp; u != ch[<span class="number">1</span>][fa[u]]) || !u; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">child</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123; <span class="keyword">return</span> u == ch[<span class="number">1</span>][fa[u]]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> son)</span> </span>&#123; fa[u] = f, ch[son][f] = u; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    sum[u] = sum[ch[<span class="number">0</span>][u]] + sum[ch[<span class="number">1</span>][u]] + val[u]; <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (s[u].size()) t = max(t, *s[u].rbegin());</span><br><span class="line">    L[u] = max(L[ch[<span class="number">0</span>][u]], sum[ch[<span class="number">0</span>][u]] + val[u] + max(t, L[ch[<span class="number">1</span>][u]]));</span><br><span class="line">    R[u] = max(R[ch[<span class="number">1</span>][u]], sum[ch[<span class="number">1</span>][u]] + val[u] + max(t, R[ch[<span class="number">0</span>][u]]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rev</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    swap(L[u], R[u]), swap(ch[<span class="number">0</span>][u], ch[<span class="number">1</span>][u]), rev[u] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rev[u]) Rev(ch[<span class="number">0</span>][u]), Rev(ch[<span class="number">1</span>][u]), rev[u] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = fa[u], ff = fa[f], tmp = child(u), tmp1 = child(f);</span><br><span class="line">    <span class="keyword">if</span> (!isroot(f)) connect(u, ff, tmp1);</span><br><span class="line">    fa[u] = ff, connect(ch[tmp ^ <span class="number">1</span>][u], f, tmp), connect(f, u, tmp ^ <span class="number">1</span>), pushup(f), pushup(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stk[N], top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    stk[top = <span class="number">1</span>] = u; <span class="keyword">int</span> t = u;</span><br><span class="line">    <span class="keyword">while</span> (!isroot(t)) stk[++top] = t = fa[t];</span><br><span class="line">    <span class="keyword">while</span> (top) pushdown(stk[top--]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> f; !isroot(u); rotate(u))</span><br><span class="line">        <span class="keyword">if</span> (!isroot(f = fa[u]))</span><br><span class="line">            rotate(child(u) ^ child(f) ? u : f);</span><br><span class="line">    pushup(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ls = <span class="number">0</span>; u; u = fa[ls = u]) &#123;</span><br><span class="line">        splay(u); </span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">1</span>][u]) s[u].insert(L[ch[<span class="number">1</span>][u]]);</span><br><span class="line">        <span class="keyword">if</span> (ls) s[u].erase(s[u].find(L[ls]));</span><br><span class="line">        ch[<span class="number">1</span>][u] = ls, pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    access(u), splay(u), Rev(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen("T1.in", "r", stdin), freopen("T1.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n, q; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i]);</span><br><span class="line">    L[<span class="number">0</span>] = R[<span class="number">0</span>] = <span class="number">-1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val[i]), L[i] = R[i] = sum[i] = val[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">2</span>; i--) </span><br><span class="line">        s[p[i]].insert(L[i]), L[p[i]] = R[p[i]] = max(L[p[i]], val[p[i]] + L[i]), fa[i] = p[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, a, b; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;op, &amp;a);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) makeroot(a), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, L[a]); </span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b), makeroot(a), val[a] = b, pushup(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>注：由于没有测试数据，不保证代码的正确性</details><h1 id="D1T2-Numazu-的蜜柑"><a href="#D1T2-Numazu-的蜜柑" class="headerlink" title="D1T2 Numazu 的蜜柑"></a>D1T2 Numazu 的蜜柑</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>蜜柑是 Numazu 的特产！这天 Chika 来到一棵蜜柑树下，发现这棵树由 $n$ 个结点组成（$1$号结点为根节点），每个结点都生长了一些蜜柑，结点 $u$ 的蜜柑数量记为 $a_u$ 。她想问聪明的你这样一个问题，有多少顶点对$(u,v)$满足：</p><ol><li>$v$是$u$的祖先</li><li>$a_u^2 + Aa_ua_v+Ba_v^2\equiv 0\pmod p$</li></ol><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行$4$个整数$n, p, A, B$</p><p>第二行包含$n$个整数$a_1, \cdots, a_n$</p><p>第三行包含$n - 1$个整数$fa_2, \cdots, fa_n$，分别代表每个点的父亲</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>仅包含一行一个整数，为满足条件的顶点的数量</p><h2 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h2><p><img src="1.png" alt=""></p><p><img src="2.png" alt=""></p><script type="math/tex; mode=display">a_i, A, B,p\leq 10^{16}</script><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>考虑枚举祖先$a_v$，将$a_v$看作常数，那么根据求根公式</p><script type="math/tex; mode=display">a_u\equiv a_v\frac{-A \pm \sqrt{A^2 - 4B}}{2} \pmod p</script><p>求出$A^2 - 4B$在模$p$下的二次剩余，如果二次剩余不存在，那么当且仅当$a_u = a_v = 0$时方程成立</p><p>问题转化为统计每个点的子树内有多少个权值为$x$的点，启发式合并即可</p><details><summary> 代码 </summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; P;</span><br><span class="line"></span><br><span class="line">LL mod;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">mul</span><span class="params">(LL a, LL b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a * b - (LL)((<span class="keyword">long</span> <span class="keyword">double</span>)a / mod * b) * mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Pow</span><span class="params">(LL x, LL y)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = mul(x, x)) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = mul(res, x);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Cipolla</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Pow(x, (mod - <span class="number">1</span>) / <span class="number">2</span>) != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    LL a = rand() % mod;</span><br><span class="line">    <span class="keyword">while</span> (Pow((mul(a, a) - x + mod) % mod, (mod - <span class="number">1</span>) / <span class="number">2</span>) != mod - <span class="number">1</span>) a = rand() % mod;</span><br><span class="line">    LL t = (mul(a, a) - x + mod) % mod;</span><br><span class="line">    <span class="keyword">auto</span> Mul = [&amp;](P a, P b) -&gt; P &#123;</span><br><span class="line">        LL A = (mul(a.first, b.first) + mul(a.second, mul(b.second, t))) % mod;</span><br><span class="line">        LL B = (mul(a.first, b.second) + mul(a.second, b.first)) % mod;</span><br><span class="line">        <span class="keyword">return</span> P(A, B);</span><br><span class="line">    &#125;;</span><br><span class="line">    P res(1, 0), tmp(a, 1); LL y = (mod + 1) / 2;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, tmp = Mul(tmp, tmp)) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = Mul(res, tmp);</span><br><span class="line">    <span class="keyword">return</span> res.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL num[N], t1, t2, res; <span class="built_in">map</span>&lt;LL, <span class="keyword">int</span>&gt; mp[N]; <span class="keyword">int</span> RT[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mp[RT[a]].size() &gt; mp[RT[b]].size()) swap(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : mp[RT[a]]) mp[RT[b]][t.first] += t.second;</span><br><span class="line">    mp[RT[a]].clear(), RT[a] = RT[b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    RT[u] = u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) </span><br><span class="line">            dfs(e[i].to, u), merge(u, e[i].to);</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!u) res += mp[RT[u]][<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res += mp[RT[u]][mul(num[u], t1)];</span><br><span class="line">        <span class="keyword">if</span> (t1 != t2) res += mp[RT[u]][mul(num[u], t2)];</span><br><span class="line">    &#125;</span><br><span class="line">    mp[RT[u]][num[u]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand((LL)<span class="keyword">new</span> <span class="keyword">char</span>);</span><br><span class="line">    <span class="keyword">int</span> n; LL A, B; <span class="built_in">scanf</span>(<span class="string">"%d%lld%lld%lld"</span>, &amp;n, &amp;mod, &amp;A, &amp;B);</span><br><span class="line">    LL tmp = ((mul(A, A) - <span class="number">4</span> * B) % mod + mod) % mod, inv2 = (mod + <span class="number">1</span>) / <span class="number">2</span>; tmp = Cipolla(tmp);</span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="number">-1</span>) t1 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        t1 = (tmp - A + mod) % mod, t2 = (-tmp - A + <span class="number">2</span> * mod) % mod;</span><br><span class="line">        t1 = mul(t1, inv2), t2 = mul(t2, inv2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, a; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), adde(a, i);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>不保证代码的正确性</details><h1 id="D1T3-星际迷航"><a href="#D1T3-星际迷航" class="headerlink" title="D1T3 星际迷航"></a>D1T3 星际迷航</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>“如果宇宙中真有什么终极的逻辑，那就是终有一天我们会在舰桥上重逢，直到生命的终结，对于我们来说旅途的本身就是归宿。”，小 $7$ 一边说着一边凭借曲率引擎在宇宙中航行着，他十分在意自己能否到达他所想的时空坐标。确切的说在现代科学的描述中，空间、时间以及某些未知的要素构成的时空坐标可以描述为一个 $m$ 维空间，初始可以假设小 $7$ 所在的位置就是空间的原点。在 $m$ 维时空中存在着 $n$ 个已经探明的奇点，而曲率引擎的移动方法为：先选择一个奇点，然后借‘力’穿越到关于该点对称的时空坐标。小 $7$ 非常关心自己能否通过有限次移动到达他所想去的地方，现在请你来回答这个问题。</p><p>小 $7$ 想了想觉得这个问题很难，为了不为难你弱化了判定条件，他会给你一个数字 $p$，只要你能到达一个空间坐标，且每一维都与目标坐标在模 $p$ 意义下同余即认为可以到达目标。</p><h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含四个空格隔开的正整数 $n$、$m$、$q$ 和 $p$，分别表示奇点的数量、空间的维度、询问的数量和模数。</p><p>接下来 $n$ 行，每行 $m$ 个整数，依次表示时空中每个奇点的空间坐标。</p><p>接下来 $q$ 行，每行 $m$ 个整数，表示询问小 $7$ 能否到达这个时空坐标。</p><h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出 $q$ 行，每行用<code>YES</code>和<code>NO</code>表示对于每个询问可否到达。</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>这题我暂时还不会，如果以后会了应该会回来补/kel</p><h1 id="D2T1-维护序列"><a href="#D2T1-维护序列" class="headerlink" title="D2T1 维护序列"></a>D2T1 维护序列</h1><p>题目记不太清了，毕竟都隔了两年了。在复现赛的时候这道题被替换成了SCOI2019的D2T2，也就是RGB那道题</p><h2 id="简化版题面"><a href="#简化版题面" class="headerlink" title="简化版题面"></a>简化版题面</h2><p>有一个长度为$n$的序列，有$q$个询问。每次询问给出$l, r, x$，表示你可以选择$l$到$r$中任意三个连续的数，然后将这三个数都加上$x$，询问最终序列每个数绝对值之和的最大值。注意询问没有后效性</p><h2 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h2><script type="math/tex; mode=display">n, q\leq 10^5, |x|\leq \mathrm{int\_max}</script><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>将绝对值拆开，$|a + b| = \max(a + b, -a - b)$，然后大概就没了</p><p>由于最后求的是答案的最大值，而这个绝对值只有当被正确计算的时候才最大，因此我们可以直接将$\max$扔掉。此时相邻的三个数拆开之后一共有$8$种可能，线段树分别维护这$8$个值即可</p><p>另一种思路是考虑$y = |x + a|$构成的图像，三个这种图像叠加起来构成的图像分为四段，斜率从左到右分别为$-3, -1, 1, 3$，使用线段树分别维护这四段函数。同样，这个分段函数的值当且仅当被正确计算的时候才最大，因此我们可以将分段函数拆成四条直线，维护这四条直线即可</p><p>没有代码</p><h1 id="D2T2-游泳池"><a href="#D2T2-游泳池" class="headerlink" title="D2T2 游泳池"></a>D2T2 游泳池</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>淘淘家的后院有一个巨大的凸多边形游泳池，泳池包含 $n$ 个顶点。泳池内有  $m$ 座圆形石雕，环境十分优雅。每天清晨，淘淘都会在泳池池边随机选取一个起点，开始她今天的游泳活动。为了达到更好的健身效果，淘淘会找到与起点直线距离最远的顶点作为终点，并尽可能以直线的方式从起点游到终点。抵达终点之后，淘淘希望可以泡在水中欣赏四周的风景，随后开启心情舒畅的一天。</p><p>然而，淘淘也有心情不舒畅的时候。一方面，不是每个顶点处都有优美的风景，倘若淘淘选取风景不优美的顶点作为终点，这会导致她当天心情不舒畅；另一方面，淘淘发现了石雕十分碍事，倘若淘淘从起点到终点的直线路线被石雕所阻挡，那么她必须改变游泳路线，这也会导致她当天心情不舒畅。</p><p>暑假即将来临，面对连续的 $t$ 天假期，淘淘已经有些迫不及待了。经过认真的数学计算，淘淘发现她心情舒畅的期望天数居然少得可怜！经过认真分析，她认为那些碍事的石雕才是罪魁祸首。为此，她决定开展泳池改造计划——移除石雕。具体地讲，淘淘移除一块石雕需要花费 $k$ 天，并且在此期间她并不会心情舒畅。淘淘可以使用暑假开始前的额外 $k\times r$ 天来移除 $r$ 座石雕（$r$ 的数值由淘淘自己决定，可以为 $0$）。</p><p>淘淘一方面希望提升她心情舒畅的期望天数，但她更关心心情舒畅的期望天数占总天数$(t+r\times k)$的比例可以有多大。现在，淘淘找到了聪明的你来协助她设计泳池改造计划，并计算这个比值的最大值。</p><h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含四个整数 $n, m, t, k$，其中 $n$ 表示凸多边形泳池的顶点数量，$m$ 表示泳池内圆形石雕的数量，$t$ 表示淘淘即将游泳的天数，$k$ 表示拆除一个石雕所需要的天数；</p><p>随后 $n$ 行，沿逆时针方向描述泳池的 $n$ 个顶点，每行三个整数 $X_i, Y_i, A_i$，依次表示顶点的横、纵坐标以及风景是否优美，$A_i=1$ 表示优美，$A_i=0$ 表示不优美；</p><p>随后 $m$ 行，描述泳池内的 $m$ 个圆形石雕，每行三个整数 $C_i, D_i, R_i$，依次表示圆心的横、纵坐标以及半径，数据保证石雕与石雕不会重合，石雕也不会超出泳池边界。</p><h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个浮点数，表示心情舒畅的期望天数占总天数比例的最大值。输出的结果须保留 $4$ 位小数，当你的答案与标准答案的误差不超过 $0.001$ 时视为正确。</p><h2 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于 $30\%$ 的数据，$m=0$，即没有石雕；</p><p>另有 $30\%$ 的数据，$t=1, k=10^6$，此种情况下无需拆除石雕；</p><p>另有 $20\%$ 的数据，$m\leq 10$；</p><p>对于 $100\%$ 的数据，$4\leq n\leq 500, m\leq 50, t\leq 10^4, k\leq 10^6$；</p><p>对于 $100\%$ 的数据，所有坐标、半径的绝对值不超过 $10^7$。</p><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><p>首先如果没有石雕，怎么统计答案</p><p>考虑将游泳过程倒过来，即考虑最终游到的目标点，求出多边形上有哪些点最终会游到这个目标点</p><p>相当于在多边形上找到一个范围，使得这个范围内的所有点距离这个顶点的距离最远</p><p>枚举这个顶点$i$，然后再枚举其它的每个顶点$j$，最终范围内的所有点到$i$的距离必须大于到$j$的距离。作出$i, j$连线的中位线，显然这个范围内的所有点都必须在这条中位线靠近$j$的那一侧</p><p>因此，将原多边形的所有边以及我们新添加的这$n - 1$条直线拿来做半平面交，就可以得到这个范围。我们将其称作$i$“控制”这个范围内的所有点</p><p>如果不能移除石雕，枚举顶点$i$之后再枚举多边形的每一条边$j$，然后将所有的石雕拿来求切线，并求出切线与$j$的交点。然后我们就可以在$j$上跑扫描线，只有那些未被石雕覆盖的点对答案才有贡献</p><p>如果能移除一些石雕，我们假设通过移除$k$个石雕能使得期望天数增加$x’$，原来的期望天数为$x$，考虑分数规划二分的过程，假设二分的答案为$mid$</p><script type="math/tex; mode=display">\begin{gathered}\frac{x + x'}{t + rk}\geq mid \Rightarrow x + x'\geq mid(t + rk)\\x' - k\times(mid\times r) \geq mid\times t - x\end{gathered}</script><p>我们将$x’$看作最终的价值，每移除一个石雕就扣除$mid\times r$的价值，然后要使得最终的方案的价值最大</p><p>这很明显是一个最小割的模型，在刚刚的扫描线的过程中我们可以顺便求出每一段被哪些石雕遮挡，要么不要这一段的价值，要么扣除移除这些石雕的代价，网络流即可</p><p>代码很长，可以看<a href="https://www.cnblogs.com/ImagineC/p/10121566.html" target="_blank" rel="noopener">这个</a></p><details><summary>还是贴一下</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, max_node = <span class="number">3e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-10</span>, inf = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">double</span> x, y;</span><br><span class="line"></span><br><span class="line">  point () &#123;&#125;</span><br><span class="line">  point (<span class="keyword">double</span> x, <span class="keyword">double</span> y): x(x), y(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  point <span class="keyword">operator</span> + (point a) &#123;</span><br><span class="line">    <span class="keyword">return</span> point (x + a.x, y + a.y);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  point <span class="keyword">operator</span> - (point a) &#123;</span><br><span class="line">    <span class="keyword">return</span> point (x - a.x, y - a.y);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  point <span class="keyword">operator</span> * (<span class="keyword">double</span> a) &#123;</span><br><span class="line">    <span class="keyword">return</span> point (x * a, y * a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  point <span class="keyword">operator</span> / (<span class="keyword">double</span> a) &#123;</span><br><span class="line">    <span class="keyword">return</span> point (x / a, y / a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> point&amp; a) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(x - a.x) &lt; eps &amp;&amp; <span class="built_in">fabs</span>(y - a.y) &lt; eps;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> point&amp; a) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !(*<span class="keyword">this</span> == a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; points[N], point_q[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dot</span><span class="params">(point a, point b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.x * b.x + a.y * b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(point a, point b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(point a, point b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sqrt</span>(dot(a - b, a - b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">point <span class="title">rotate</span><span class="params">(point a, <span class="keyword">double</span> rad)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> point (a.x * <span class="built_in">cos</span>(rad) - a.y * <span class="built_in">sin</span>(rad), a.x * <span class="built_in">sin</span>(rad) + a.y * <span class="built_in">cos</span>(rad));</span><br><span class="line">&#125;       </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">on_segment</span><span class="params">(point p, point a, point b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> d = dist(a, b);</span><br><span class="line">  <span class="keyword">return</span> dist(a, p) &lt;= d &amp;&amp; dist(b, p) &lt;= d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">circle</span> &#123;</span></span><br><span class="line">  point center;</span><br><span class="line">  <span class="keyword">double</span> r;</span><br><span class="line"></span><br><span class="line">  circle () &#123;&#125;</span><br><span class="line">  circle (point center, <span class="keyword">double</span> r): center(center), r(r) &#123;&#125;</span><br><span class="line">&#125; stone[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">  point p, v;</span><br><span class="line">  <span class="keyword">double</span> angle;</span><br><span class="line"></span><br><span class="line">  line () &#123;&#125;</span><br><span class="line">  line (point p, point v, <span class="keyword">int</span> id): p(p), v(v), id(id) &#123;</span><br><span class="line">    angle = <span class="built_in">atan2</span>(v.y, v.x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> line&amp; a) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> angle &lt; a.angle;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; line_q[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, days, cost, type[N];</span><br><span class="line"><span class="keyword">double</span> p0, all_dist;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;point, point&gt;&gt; control[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function">point <span class="title">line_intersection</span><span class="params">(line a, line b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">fabs</span>(cross(a.v, b.v)) &gt; eps) &#123;</span><br><span class="line">    <span class="keyword">double</span> t = cross(b.v, a.p - b.p) / cross(a.v, b.v);</span><br><span class="line">    <span class="keyword">return</span> a.p + a.v * t;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> point (inf, inf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">on_left</span><span class="params">(point p, line x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cross(x.v, p - x.p) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;line&gt; <span class="title">half_plane_intersection</span><span class="params">(<span class="built_in">vector</span>&lt;line&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">  sort(s.begin(), s.end());</span><br><span class="line">  <span class="keyword">int</span> first = <span class="number">0</span>, last = <span class="number">0</span>;</span><br><span class="line">  line_q[<span class="number">0</span>] = s[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; first &lt; last &amp;&amp; !on_left(point_q[last - <span class="number">1</span>], s[i]); --last);</span><br><span class="line">    <span class="keyword">for</span> (; first &lt; last &amp;&amp; !on_left(point_q[first], s[i]); ++first);</span><br><span class="line">    line_q[++last] = s[i];</span><br><span class="line">    <span class="keyword">if</span> (first &lt; last &amp;&amp; <span class="built_in">fabs</span>(cross(line_q[last].v, line_q[last - <span class="number">1</span>].v)) &lt; eps) &#123;</span><br><span class="line">      --last;</span><br><span class="line">      <span class="keyword">if</span> (on_left(s[i].p, line_q[last])) &#123;</span><br><span class="line">        line_q[last] = s[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (first &lt; last) &#123;</span><br><span class="line">      point_q[last - <span class="number">1</span>] = line_intersection(line_q[last - <span class="number">1</span>], line_q[last]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (; first &lt; last &amp;&amp; !on_left(point_q[last - <span class="number">1</span>], line_q[first]); --last);</span><br><span class="line">  <span class="built_in">vector</span>&lt;line&gt; result;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt;= last; ++i) &#123;</span><br><span class="line">    result.push_back(line_q[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> to;</span><br><span class="line">  <span class="keyword">double</span> refer, cap, flow;</span><br><span class="line"></span><br><span class="line">  edge () &#123;&#125;</span><br><span class="line">  edge (<span class="keyword">int</span> to, <span class="keyword">double</span> refer): to(to), refer(refer) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; edges;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; graph[max_node];</span><br><span class="line"><span class="keyword">int</span> s, t, node_cnt, stone_id[N], cur[max_node], dis[max_node];</span><br><span class="line"><span class="keyword">double</span> dinic_flow;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">double</span> cap)</span> </span>&#123;</span><br><span class="line">  edges.emplace_back(v, cap);</span><br><span class="line">  edges.emplace_back(u, <span class="number">0</span>);</span><br><span class="line">  graph[u].push_back(edges.size() - <span class="number">2</span>);</span><br><span class="line">  graph[v].push_back(edges.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">  <span class="built_in">memset</span>(dis, <span class="number">0</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">  <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="keyword">sizeof</span> cur);</span><br><span class="line">  que.push(s);</span><br><span class="line">  dis[s] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = que.front();</span><br><span class="line">    que.pop();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : graph[x]) &#123;</span><br><span class="line">      edge&amp; e = edges[v];</span><br><span class="line">      <span class="keyword">if</span> (e.cap - e.flow &gt; eps &amp;&amp; !dis[e.to]) &#123;</span><br><span class="line">        dis[e.to] = dis[x] + <span class="number">1</span>;</span><br><span class="line">        que.push(e.to);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dis[t] &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">double</span> a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (u == t || a &lt; eps) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">double</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[u]; i &lt; graph[u].size(); ++i) &#123;</span><br><span class="line">      edge&amp; e = edges[graph[u][i]];</span><br><span class="line">      <span class="keyword">if</span> (dis[e.to] == dis[u] + <span class="number">1</span> &amp;&amp; (f = dfs(e.to, min(a, e.cap - e.flow))) &gt; eps) &#123;</span><br><span class="line">        e.flow += f;</span><br><span class="line">        edges[graph[u][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">        flow += f;</span><br><span class="line">        a -= f;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; eps) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; bfs(); dinic_flow -= dfs(s, inf));</span><br><span class="line">  <span class="keyword">return</span> dinic_flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> p_id, stone_id;</span><br><span class="line">  <span class="keyword">double</span> d;</span><br><span class="line">  point p;</span><br><span class="line"></span><br><span class="line">  state () &#123;&#125;</span><br><span class="line">  state (<span class="keyword">int</span> p_id, <span class="keyword">int</span> stone_id, <span class="keyword">double</span> d, point p): p_id(p_id), stone_id(stone_id), d(d), p(p) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> state&amp; a) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p_id == a.p_id ? d &lt; a.d : p_id &lt; a.p_id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;state&gt; cover[N];</span><br><span class="line"><span class="keyword">bool</span> appeared[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, point a, point b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (control[i][j].size()) &#123;</span><br><span class="line">    point p = control[i][j][<span class="number">0</span>].first;</span><br><span class="line">    point q = control[i][j][<span class="number">0</span>].second;</span><br><span class="line">    <span class="keyword">double</span> dist0 = dist(points[j], p);</span><br><span class="line">    <span class="keyword">double</span> dist1 = dist(points[j], a);</span><br><span class="line">    <span class="keyword">double</span> dist2 = dist(points[j], q);</span><br><span class="line">    <span class="keyword">double</span> dist3 = dist(points[j], b);</span><br><span class="line">    <span class="keyword">if</span> (max(dist0, dist1) &lt;= min(dist2, dist3)) &#123;</span><br><span class="line">      point l = dist0 &gt; dist1 ? p : a;</span><br><span class="line">      point r = dist2 &lt; dist3 ? q : b;</span><br><span class="line">      ++node_cnt;</span><br><span class="line">      <span class="keyword">double</span> d = dist(l, r) / all_dist;</span><br><span class="line">      p0 -= d;</span><br><span class="line">      add_edge(s, node_cnt, d * days);</span><br><span class="line">      dinic_flow += d * days;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (appeared[k]) &#123;</span><br><span class="line">          add_edge(node_cnt, stone_id[k], inf);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  s = ++node_cnt;</span><br><span class="line">  t = ++node_cnt;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    stone_id[i] = ++node_cnt;</span><br><span class="line">    add_edge(stone_id[i], t, -cost);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (type[i]) &#123;</span><br><span class="line">      <span class="built_in">memset</span>(appeared, <span class="literal">false</span>, <span class="keyword">sizeof</span> appeared);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, k, last = <span class="number">-1</span>; j &lt; cover[i].size(); j = k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (~last) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> l = last == n ? <span class="number">1</span> : last + <span class="number">1</span>; l != cover[i][j].p_id; l = l == n ? <span class="number">1</span> : l + <span class="number">1</span>) &#123;</span><br><span class="line">            add_edge(i, l, points[l], points[l == n ? <span class="number">1</span> : l + <span class="number">1</span>]);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (k = j; k &lt; cover[i].size() &amp;&amp; cover[i][j].p_id == cover[i][k].p_id; ++k);</span><br><span class="line">        last = cover[i][j].p_id;</span><br><span class="line">        add_edge(i, last, points[last], cover[i][j].p);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = j; l &lt; k; ++l) &#123;</span><br><span class="line">          <span class="keyword">int</span> u = cover[i][l].stone_id;</span><br><span class="line">          <span class="keyword">if</span> (!appeared[u]) &#123;</span><br><span class="line">            appeared[u] = <span class="literal">true</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            appeared[u] = <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (l + <span class="number">1</span> &lt; k) &#123;</span><br><span class="line">            add_edge(i, last, cover[i][l].p, cover[i][l + <span class="number">1</span>].p);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        add_edge(i, last, cover[i][k - <span class="number">1</span>].p, points[last == n ? <span class="number">1</span> : last + <span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> answer)</span> </span>&#123;</span><br><span class="line">  dinic_flow = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : edges) &#123;</span><br><span class="line">    v.flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (v.refer &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      v.cap = v.refer;</span><br><span class="line">      <span class="keyword">if</span> (v.refer &lt; inf) &#123;</span><br><span class="line">        dinic_flow += v.refer;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      v.cap = -answer * v.refer;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (p0 - answer) * days + dinic() &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;days, &amp;cost);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf%lf%d"</span>, &amp;points[i].x, &amp;points[i].y, &amp;type[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (type[i]) &#123;</span><br><span class="line">      <span class="built_in">vector</span>&lt;line&gt; half_plane;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = j == n ? <span class="number">1</span> : j + <span class="number">1</span>;</span><br><span class="line">        half_plane.emplace_back(points[j], points[k] - points[j], j);</span><br><span class="line">        <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">          point mid = point ((points[i].x + points[j].x) / <span class="number">2</span>, (points[i].y + points[j].y) / <span class="number">2</span>);</span><br><span class="line">          point v = point (points[j].y - points[i].y, points[i].x - points[j].x);</span><br><span class="line">          half_plane.emplace_back(mid, v, <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">vector</span>&lt;line&gt; convex_hull = half_plane_intersection(half_plane);</span><br><span class="line">      <span class="keyword">if</span> (convex_hull.size() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; convex_hull.size(); ++j) &#123;</span><br><span class="line">          <span class="keyword">if</span> (~convex_hull[j].id) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = j == <span class="number">0</span> ? convex_hull.size() - <span class="number">1</span> : j - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = j + <span class="number">1</span> == convex_hull.size() ? <span class="number">0</span> : j + <span class="number">1</span>;</span><br><span class="line">            point a = line_intersection(convex_hull[l], convex_hull[j]);</span><br><span class="line">            point b = line_intersection(convex_hull[j], convex_hull[r]);</span><br><span class="line">            p0 += dist(a, b);</span><br><span class="line">            control[i][convex_hull[j].id].emplace_back(a, b);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = i == n ? <span class="number">1</span> : i + <span class="number">1</span>;</span><br><span class="line">    all_dist += dist(points[i], points[j]);</span><br><span class="line">  &#125;</span><br><span class="line">  p0 /= all_dist;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>, &amp;stone[i].center.x, &amp;stone[i].center.y, &amp;stone[i].r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (type[i]) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">        point v = stone[j].center - points[i];</span><br><span class="line">        <span class="keyword">double</span> angle = <span class="built_in">asin</span>(stone[j].r / dist(points[i], stone[j].center));</span><br><span class="line">        line a = line (points[i], rotate(v, angle), <span class="number">-1</span>);</span><br><span class="line">        line b = line (points[i], rotate(v, -angle), <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">          <span class="keyword">int</span> p = k == n ? <span class="number">1</span> : k + <span class="number">1</span>;</span><br><span class="line">          point intersection = line_intersection(line(points[k], points[p] - points[k], <span class="number">-1</span>), a);</span><br><span class="line">          <span class="keyword">if</span> (intersection != points[i] &amp;&amp; on_segment(intersection, points[k], points[p])) &#123;</span><br><span class="line">            cover[i].emplace_back(k &lt; i ? k + n : k, j, dist(points[k], intersection), intersection);</span><br><span class="line">          &#125;</span><br><span class="line">          intersection = line_intersection(line(points[k], points[p] - points[k], <span class="number">-1</span>), b);</span><br><span class="line">          <span class="keyword">if</span> (intersection != points[i] &amp;&amp; on_segment(intersection, points[k], points[p])) &#123;</span><br><span class="line">            cover[i].emplace_back(k &lt; i ? k + n : k, j, dist(points[k], intersection), intersection);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      sort(cover[i].begin(), cover[i].end());</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : cover[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v.p_id &gt; n) &#123;</span><br><span class="line">          v.p_id -= n;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  add_edge();</span><br><span class="line">  <span class="keyword">double</span> l = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (r - l &gt; <span class="number">1e-5</span>) &#123;</span><br><span class="line">    <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (check(mid)) &#123;</span><br><span class="line">      l = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%.4lf\n"</span>, l);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="D2T3-ABNS"><a href="#D2T3-ABNS" class="headerlink" title="D2T3 ABNS"></a>D2T3 ABNS</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>ABNS 生活在一个异次元宇宙中，在那个宇宙中，所有人都可以自由地进行时间旅行，这个宇宙的时间满足一个奇特的结构。人们可以自由地穿越到以前的任何一个时间点，并且从这个时间点开始产生一条新的时间线，很显然，这是一个树形结构。为了方便地管理每一位公民的时间旅行行为，成立了一个超脱时间线束缚的时空管理局，时空管理局负责协助公民进行时间旅行以及记录每一位公民的时间旅行树，时间树上的节点会有一个独一无二的索引 <code>index</code>，表示该节点的创建次序。即对于每一个新事件，时空管理局就会为相关的人员创建一个新的时间节点。</p><p>在那里的人们非常喜欢喝饮料，饮料店有许多饮品，一种饮料由三个参数表示，$a$ 表示卡路里含量，$b$ 表示花费，$c$ 表示美味度。（均为每单位体积，每种饮料总量无限）有时候 ABNS 嘴馋，想买一些混合味饮料，但对指标有严格控制，即热量（卡路里总含量）不能超过 $A$，花费不能超过 $B$，同时混合味饮料最美味。</p><p>由于 ABNS 是个十分挑剔的人，每次他买饮料的指标会有所变动。同时，饮料店为了满足尽可能多的顾客的需求，会在某些时候增加一种饮品。最后，ABNS 可能会在当前时间点选择穿越到另一个时间点。</p><h2 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数 $n$ 表示总共 $n$ 个事件。</p><p>接下来 $n$ 行每行一种事件，事件为一下三种之一：</p><ol><li><code>add a b c</code>，表示饮品店上架了一种每单位体积卡路里、花费、美味度分别为 $a,b,c$ 的饮料。</li><li><code>buy A B</code>，表示 ABNS 来买饮料的口味指标为 $A$、$B$。（保证此时有饮料可买）</li><li><code>return index</code>，表示由于 ABNS 的时间旅行，时间跳到事件 <code>index</code>（事件从 $1$ 开始编号）之后（保证 <code>index</code> 是这之前某一个事件）。</li></ol><h2 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每一个第二种操作，输出混合味饮料的最美味度，要求与答案的绝对误差或相对误差小于 $10^{-6}$。</p><h2 id="数据范围-4"><a href="#数据范围-4" class="headerlink" title="数据范围"></a>数据范围</h2><p><img src="3.png" alt=""></p><h2 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h2><p>每种饮料有三种属性$(A, B, C)$，我们将其“标准化”，即考虑每单位热量的花费以及美味度，那么这个属性会变成$(1, \frac BA, \frac CA)$</p><p>对于这种混合问题有一个经典的套路：我们将每种饮料看作二维平面上的一个点$(\frac BA, \frac CA)$，那么有这样一个结论：对于两种饮料$A, B$所代表的点，在$A, B$连线上的所有饮料都能通过适当地调配$A, B$得到</p><p>有了这个结论之后可以看出，实际上我们要求的就是所有饮料的上凸壳。如果我们求出了这个凸壳，在某一次询问的时候，我们找到$x = \frac BA$这条直线与凸壳的交点，这个交点的纵坐标乘以$A$就是答案</p><p>问题转化为维护这个凸包，直接维护可以获得$70$分的好成绩</p><p>可以发现所有的操作都形成了一棵树型的结构，对于每个点，其影响的询问为操作树中它的子树内的所有询问，对应一段连续的<code>dfs</code>序。类似标记永久化的方式，我们建一棵线段树，然后将这个点挂到线段树上那$\log$个区间上。对于线段树上的每个区间我们都求出这个区间上挂的所有点的凸包，查询的时候枚举当前询问在线段树上的所有祖先，在凸包上查询当前询问坐标的前驱后继。最后将这$O(\log n)$个前驱后继拿出来两两枚举就可以得到最终的答案</p><p>代码应该不长，但是咕了</p>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二次剩余 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 启发式合并 </tag>
            
            <tag> 计算几何 </tag>
            
            <tag> 半平面交 </tag>
            
            <tag> LCT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.7联测</title>
      <link href="/2020/04/08/47-lian-ce/"/>
      <url>/2020/04/08/47-lian-ce/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-ZSY家今天的饭"><a href="#T1-ZSY家今天的饭" class="headerlink" title="T1 ZSY家今天的饭"></a>T1 ZSY家今天的饭</h1><p>一棵$n$个节点的树，树上有$m$个节点有餐厅，现在会随机地在这$m$个节点中选择$k$个节点放东西。你可以从树上任意一个节点出发，然后沿着边走，从任意一个节点离开。问要吃完这$k$个节点的东西，期望下最短要走多远</p><script type="math/tex; mode=display">n\leq 10^5, k\leq m\leq 500, w_i\leq 10^9</script><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>显然最优的路径一定是这$k$个点的虚树抠掉直径走两次，直径走一次</p><p>因此我们可以将答案拆成两个部分计算：虚树大小的期望，以及直径长度的期望</p><p>对于虚树，我们可以考虑对于这棵树上的每条边，它出现在虚树中的概率是多少</p><p>统计这条边两侧餐厅的数量，这个概率很好计算</p><p>对于直径，我们可以考虑枚举直径是啥。如果一棵树有多条直径，那么我们就让这条直径的第一个端点尽量小，在第一个端点尽量小的前提下再让第二个端点尽量小，这样就可以避免重复计数</p><p>预处理出这$m$个餐厅两两之间的路径长度，然后枚举直径，统计有多少个点可能出现即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[<span class="number">510</span>], inv[<span class="number">510</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from], w &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to], w &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL dis[N]; <span class="keyword">int</span> dep[N], fa[N][<span class="number">17</span>], res, sz[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mark[N], n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    dep[u] = dep[f] + <span class="number">1</span>, dis[u] = dis[f] + w, fa[u][<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">17</span>; i++) fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    sz[u] = mark[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) </span><br><span class="line">            dfs(e[i].to, u, e[i].w), sz[u] += sz[e[i].to];</span><br><span class="line">    <span class="keyword">int</span> t = C(m, k) - C(sz[u], k) - C(m - sz[u], k); t = (t % mod + mod) % mod;</span><br><span class="line">    res = (res + (LL)t * w * <span class="number">2</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[a] &lt; dep[b]) swap(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">16</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (dep[fa[a][i]] &gt;= dep[b]) a = fa[a][i];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">16</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i];</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Dis</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dis[a] + dis[b] - <span class="number">2</span> * dis[LCA(a, b)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL G[<span class="number">510</span>][<span class="number">510</span>]; <span class="keyword">int</span> pos[<span class="number">510</span>]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pos[i]), mark[pos[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b, c; i &lt; n; i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c), adde(a, b, c);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= m; j++) </span><br><span class="line">            G[i][j] = G[j][i] = Dis(pos[i], pos[j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            LL tmp = G[i][j]; <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; k++) <span class="keyword">if</span> (k != i &amp;&amp; k != j) &#123;</span><br><span class="line">                LL a = G[k][i], b = G[k][j];</span><br><span class="line">                <span class="keyword">if</span> (a &lt; tmp &amp;&amp; b &lt; tmp) &#123; tot++; <span class="keyword">continue</span>; &#125; </span><br><span class="line">                <span class="keyword">if</span> (a &gt; tmp || b &gt; tmp) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (a == tmp &amp;&amp; k &lt; j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (b == tmp &amp;&amp; k &lt; i) <span class="keyword">continue</span>;</span><br><span class="line">                tot++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = (res - tmp % mod * C(tot, k - <span class="number">2</span>)) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    res = (LL)(res + mod) * Pow(C(m, k), mod - <span class="number">2</span>) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-划愤"><a href="#T2-划愤" class="headerlink" title="T2 划愤"></a>T2 划愤</h1><p>不会<code>Nim</code>积/kel</p><p><img src="1586351569726.png" alt=""></p><p><img src="1586351597589.png" alt=""></p><p><img src="1586351621606.png" alt=""></p><p><img src="1586351721981.png" alt=""></p><h1 id="T3-树上的鼠"><a href="#T3-树上的鼠" class="headerlink" title="T3 树上的鼠"></a>T3 树上的鼠</h1><p>考虑这样一个游戏：有一棵树，一开始$1$号节点有一棵棋子，先手后手轮流移动这枚棋子，先手第一次必须挪动这枚棋子至少一步，之后每个人挪动的距离都必须严格大于上一个人挪动的距离，不能挪动的那一方输</p><p>问对于给出的树，有多少个包含$1$号节点的连通块使得如果在这个连通块上进行游戏，先手必胜</p><script type="math/tex; mode=display">n\leq 10^6</script><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>首先考虑对于一棵确定的树，如何判断先手是否必胜</p><p>先考虑最简单的情况：一条链</p><p>接下来我们认为一条链的长度为这条链上经过的点数</p><p>如果这条链的长度是奇数，并且$1$号节点不是正中间那个点，那么先手第一步可以将这枚棋子挪到这个点上，然后后手怎么挪先手就跟他对称地挪</p><p>否则，无论$1$号节点的位置在哪里，先手只需要将其挪到最靠近正中间的两个点之一，然后就又可以开始对称地挪了</p><p>因此我们可以得到这样一个结论：先手必败当且仅当$1$号节点是直径的中点</p><p>可以发现这个结论也可以拓展到树上</p><p>问题转化为：统计有多少个连通块，使得$1$号点不是直径的中点</p><p>如果我们知道了$1$号点每棵子树深度恰为$j$的连通块的方案数，那么我们就可以枚举最深的那棵子树是啥，然后强制让其它子树的深度小于这棵子树的深度</p><p>设$dp[i][j]$表示以$i$为根的子树，有多少个深度为$j$的连通块，这里我们认为必须选$i$，并且$i$的深度为$0$</p><p>这个定义看起来就很长链剖分，类似于希望的做法，我们对于$dp$数组同时维护一个后缀积，然后合并两棵子树的时候暴力下放需要用到的信息的标记</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from] &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to] &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> F[N * <span class="number">10</span>], G[N * <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> st[N], len[N], tot, son[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) &#123;</span><br><span class="line">            dfs(e[i].to, u);</span><br><span class="line">            <span class="keyword">if</span> (len[e[i].to] &gt;= len[son[u]]) </span><br><span class="line">                son[u] = e[i].to, len[u] = len[e[i].to] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    st[u] = tot, tot += len[u] + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len[u]; i++) G[st[u] + i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= l; j++) &#123;</span><br><span class="line">        pre = (LL)pre * G[st[u] + j] % mod;</span><br><span class="line">        F[st[u] + j] = (LL)F[st[u] + j] * pre % mod, G[st[u] + j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l != len[u]) G[st[u] + l + <span class="number">1</span>] = (LL)G[st[u] + l + <span class="number">1</span>] * pre % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!son[u]) <span class="keyword">return</span> F[st[u]] = G[st[u]] = <span class="number">1</span>, <span class="keyword">void</span>();</span><br><span class="line">    st[son[u]] = st[u] + <span class="number">1</span>, dfs1(son[u], u), G[st[u]] = F[st[u]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f &amp;&amp; e[i].to != son[u]) &#123;</span><br><span class="line">            apply(e[i].to), dfs1(e[i].to, u); <span class="keyword">static</span> <span class="keyword">int</span> tmp[N];</span><br><span class="line">            <span class="comment">// if (u == 2) cout &lt;&lt; "to: " &lt;&lt; e[i].to &lt;&lt; endl;</span></span><br><span class="line">            pushdown(u, len[e[i].to] + <span class="number">1</span>), pushdown(e[i].to, len[e[i].to]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len[e[i].to] + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                tmp[j] = F[st[u] + j];</span><br><span class="line">                <span class="comment">// cout &lt;&lt; F[st[u] + j] &lt;&lt; ' ';</span></span><br><span class="line">                <span class="keyword">if</span> (j) tmp[j] = (tmp[j - <span class="number">1</span>] + tmp[j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">1</span>; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len[e[i].to]; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> a = ((LL)tmp[j + <span class="number">1</span>] * F[st[e[i].to] + j] + (LL)F[st[u] + j + <span class="number">1</span>] * sum) % mod;</span><br><span class="line">                sum = (sum + F[st[e[i].to] + j]) % mod, F[st[u] + j + <span class="number">1</span>] = a;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; sum &lt;&lt; ' ' &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (len[u] != len[e[i].to] + <span class="number">1</span>) </span><br><span class="line">                G[st[u] + len[e[i].to] + <span class="number">2</span>] = (LL)G[st[u] + len[e[i].to] + <span class="number">2</span>] * sum % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// pushdown(u, len[u]);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; "at: " &lt;&lt; u &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt;= len[u]; i++) cout &lt;&lt; F[st[u] + i] &lt;&lt; ' ';</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fuck[N], suf[N], tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) suf[i] = tag[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[<span class="number">1</span>]; i; i = e[i].next) &#123;</span><br><span class="line">        apply(e[i].to), dfs1(e[i].to, <span class="number">1</span>), pushdown(e[i].to, len[e[i].to]);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; e[i].to &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// for (int j = 0; j &lt;= len[e[i].to]; j++)</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; F[st[e[i].to] + j] &lt;&lt; ' ';</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">        F[st[e[i].to]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len[e[i].to]; j++) </span><br><span class="line">            F[st[e[i].to] + j] = (F[st[e[i].to] + j] + F[st[e[i].to] + j - <span class="number">1</span>]) % mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len[e[i].to]; j++) tag[j] = (LL)tag[j] * F[st[e[i].to] + j] % mod;</span><br><span class="line">        suf[len[e[i].to]] = (LL)suf[len[e[i].to]] * F[st[e[i].to] + len[e[i].to]] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, pre = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        pre = (LL)pre * suf[i] % mod;</span><br><span class="line">        fuck[i] = (LL)tag[i] * pre % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[<span class="number">1</span>]; i; i = e[i].next) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len[e[i].to]; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = j ? fuck[j - <span class="number">1</span>] : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (j) t = (LL)t * Pow(F[st[e[i].to] + j - <span class="number">1</span>], mod - <span class="number">2</span>) % mod;</span><br><span class="line">            <span class="keyword">int</span> delta = F[st[e[i].to] + j];</span><br><span class="line">            <span class="keyword">if</span> (j) delta -= F[st[e[i].to] + j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> delta--; </span><br><span class="line">            res = (res + (LL)delta * t) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res = (res + mod) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 博弈 </tag>
            
            <tag> 长链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.31联测T1 简单数学题</title>
      <link href="/2020/04/05/331-lian-ce-t1-jian-dan-shu-xue-ti/"/>
      <url>/2020/04/05/331-lian-ce-t1-jian-dan-shu-xue-ti/</url>
      
        <content type="html"><![CDATA[<p>给定非负整数$x$，质数$p$，求最小的非负整数$n$，使得$f_n\equiv x \pmod p$</p><p>其中$f_n$是斐波那契数列，$f_0 = 0, f_1 = 1, f_i = f_{i-1} + f_{i - 2}$</p><p>保证$p$的个位数为$1$或$9$，多组数据</p><script type="math/tex; mode=display">p\leq 2\times 10^9, T\leq 100, x<p</script><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>通过解特征方程可以得出斐波那契数列的通项公式是</p><script type="math/tex; mode=display">f_n = \frac{1}{\sqrt 5}\left[\left(\frac{1 + \sqrt 5}{2}\right)^n - \left(\frac{1 - \sqrt 5}{2}\right)^n\right]</script><p>有一个结论就是当$p$的个位为$1$或$9$时$5$的二次剩余一定存在</p><p>解出$5$的二次剩余，无论是$\sqrt 5$还是$-\sqrt 5$都无关紧要，因为将$-\sqrt 5$代入原式可以发现值不会变</p><p>设$T = \frac{1 + \sqrt{5}}{2}$，然后让$x$乘上$\sqrt 5$，问题转化为解</p><script type="math/tex; mode=display">T^n - \left(\frac{-1}{T}\right)^n \equiv x \pmod p</script><p>对于$n$是奇数和偶数的情况分别讨论，以$n$是奇数的情况为例</p><script type="math/tex; mode=display">\begin{aligned}T^n + \frac{1}{T^n} &\equiv x &\pmod p\\T^n &\equiv \frac{x \pm \sqrt{x^2 - 4}}{2} &\pmod p\end{aligned}</script><p>解出$T^k \equiv 1\pmod p$，假如$n$是原方程的一个解，那么$n+k$也是原方程的一个解</p><p>如果$k$是奇数，且$n$是偶数，那么我们可以得到一个$n$是奇数的解</p><p><code>BSGS</code>即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mod;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">42899</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HashMap</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt; buff[SZ]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = x % SZ;</span><br><span class="line">    buff[t].push_back(P(x, y)), pos.push_back(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = x % SZ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : buff[t]) <span class="keyword">if</span> (v.first == x) <span class="keyword">return</span> v.second;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : pos) buff[t].clear();</span><br><span class="line">    pos.clear();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125; s;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sol;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">BSGS</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">bool</span> flag = <span class="number">1</span>)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (B == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag &amp;&amp; B % mod == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; s.clear();</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(mod)), ls = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++, ls = (LL)ls * A % mod)</span><br><span class="line">        s.insert((LL)B * ls % mod, i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, t = ls; i &lt;= mod; i += m, t = (LL)t * ls % mod) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = s.query(t);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="number">-1</span>) <span class="keyword">return</span> i - res;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fuck;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">BSGS1</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = BSGS(A, B);</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    sol.push_back(a);</span><br><span class="line">    <span class="keyword">if</span> (fuck != <span class="number">-1</span> &amp;&amp; fuck % <span class="number">2</span> == <span class="number">1</span>) sol.push_back(a + fuck);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Cipolla</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Pow(x, (mod - <span class="number">1</span>) / <span class="number">2</span>) != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> a = rand() % mod;</span><br><span class="line">    <span class="keyword">while</span> (Pow(((LL)a * a - x + mod) % mod, (mod - <span class="number">1</span>) / <span class="number">2</span>) != mod - <span class="number">1</span>) a = rand() % mod;</span><br><span class="line">    <span class="keyword">int</span> t = ((LL)a * a - x + mod) % mod; </span><br><span class="line">    <span class="keyword">auto</span> mul = [&amp;](P a, P b) -&gt; P &#123;</span><br><span class="line">        <span class="keyword">int</span> A = ((LL)a.first * b.first + (LL)a.second * b.second % mod * t) % mod;</span><br><span class="line">        <span class="keyword">int</span> B = ((LL)a.first * b.second + (LL)a.second * b.first) % mod;</span><br><span class="line">        <span class="keyword">return</span> P(A, B);</span><br><span class="line">    &#125;;</span><br><span class="line">    P res = P(<span class="number">1</span>, <span class="number">0</span>), tmp = P(a, <span class="number">1</span>); <span class="keyword">int</span> y = (mod + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, tmp = mul(tmp, tmp)) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = mul(res, tmp);</span><br><span class="line">    <span class="keyword">return</span> res.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> inv2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> T, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A = Cipolla(((LL)x * x + <span class="number">4</span>) % mod), B = Cipolla(((LL)x * x - <span class="number">4</span> + mod) % mod), res = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; T &lt;&lt; ' ' &lt;&lt; x &lt;&lt; ' ' &lt;&lt; A &lt;&lt; ' ' &lt;&lt; B &lt;&lt; endl;</span></span><br><span class="line">    fuck = BSGS(T, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (A != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = (LL)(x + A) * inv2 % mod, b = (LL)(x - A + mod) * inv2 % mod;</span><br><span class="line">        sol.clear(), BSGS1(T, a), BSGS1(T, b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t : sol) <span class="keyword">if</span> (t % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="number">-1</span>) res = t;</span><br><span class="line">            res = min(res, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (B != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = (LL)(x + B) * inv2 % mod, b = (LL)(x - B + mod) * inv2 % mod;</span><br><span class="line">        sol.clear(), BSGS1(T, a), BSGS1(T, b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t : sol) <span class="keyword">if</span> (t % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="number">-1</span>) res = t;</span><br><span class="line">            res = min(res, t); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> sqrt5)</span> </span>&#123;</span><br><span class="line">    x = (LL)x * sqrt5 % mod; <span class="keyword">int</span> T = (LL)(sqrt5 + <span class="number">1</span>) * inv2 % mod;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; T &lt;&lt; ' ' &lt;&lt; (LL)(mod - 1) * Pow(T, mod - 2) % mod &lt;&lt; ' ' &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> solve(T, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen("ex_data2.in", "r", stdin), freopen("out.out", "w", stdout);</span></span><br><span class="line">    srand((LL)<span class="keyword">new</span> <span class="keyword">char</span>);</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;x, &amp;mod), inv2 = (mod + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> sqrt5 = Cipolla(<span class="number">5</span>); sqrt5 = min(sqrt5, mod - sqrt5);</span><br><span class="line">        <span class="keyword">int</span> A = solve1(x, sqrt5), B = <span class="comment">/*solve1(x, mod - sqrt5)*/</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="number">-1</span> || B == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, max(A, B));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, min(A, B));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二次剩余 </tag>
            
            <tag> BSGS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.4联测 by ZJK</title>
      <link href="/2020/04/05/44-lian-ce-by-zjk/"/>
      <url>/2020/04/05/44-lian-ce-by-zjk/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-Permutation"><a href="#T1-Permutation" class="headerlink" title="T1 Permutation"></a>T1 Permutation</h1><p>有一棵$n$个点的树，每条边有一个权值$v_i$</p><p>统计有多少个长度为$n$的排列$p$满足</p><p>将路径 $(p_1,p_2)$上的所有边值减$1$，然后将路径 $(p_2,p_3)$ 上的所有边值减$1$，…，将 $(p_{n−1},p_n)$ 上所有边值减$1$，将 $(p_n,p_1)$ 上所有边减$1$之后，每条边的值都是$0$</p><p>保证至少存在一个排列满足条件</p><script type="math/tex; mode=display">n\leq 5000</script><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑对于一个确定的排列，一条被会被减多少次</p><p>对于树上的任意一条边来说，它的两个端点一个是祖先，一个是儿子。我们称儿子所在的子树中的所有点都为白点，剩下的点都为黑点</p><p>将整个排列看作一个环，环上有一些黑点，有一些白点。为了方便起见，我们钦定$1$号点为环的起点</p><p>我们将一段极长的同色段称为连续段，那么可以考虑这样$dp$：对于$u$，我们只考虑$u$子树中的点在最终排列中的相对顺序，统计它们形成了多少段连续段，一个连续段最终排列中一定相邻，然后每次合并两个儿子</p><p>考虑断环为链，如果$u$不是$1$号点，其与父亲的连边权值为$v$，那么$u$的子树中的所有点会形成$\frac{v}{2}$个连续段</p><p>考虑合并两棵子树的时候会发生什么，假如第一棵子树有$a$个连续段，第二棵子树有$b$个连续段，那么把它们合并起来之后一共有$a+b$个连续段。注意此时我们已经断环为链了，因此接下来我们讨论的都是链上的情况</p><p>在这$a+b$个连续段中，有些连续段是可以合起来的，但是每一段合起来的连续段中，相邻的两段不能来自同一棵子树</p><p>考虑容斥，枚举每棵子树有多少段连续段在缩完之后相邻，强制将这些位置缩在一起，然后$dp$即可</p><p>由于我们钦定了$1$为环的起点，因此最后的方案数要乘上$n$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from], w &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to], w &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N], C[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> fuck)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u, e[i].w);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> F[N]; <span class="built_in">memset</span>(F, <span class="number">0</span>, <span class="keyword">sizeof</span>(F)), F[u != <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].w / <span class="number">2</span>; <span class="keyword">static</span> <span class="keyword">int</span> G[N];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= t + v; j++) G[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= t; j++) </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= v; k++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = (LL)F[j] * C[v - <span class="number">1</span>][k - <span class="number">1</span>] % mod * inv[k] % mod;</span><br><span class="line">                    <span class="keyword">if</span> ((v - k) &amp; <span class="number">1</span>) G[j + k] = (G[j + k] + mod - tmp) % mod;</span><br><span class="line">                    <span class="keyword">else</span> G[j + k] = (G[j + k] + tmp) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= t + v; j++) F[j] = G[j];</span><br><span class="line">            t += v;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = fuck / <span class="number">2</span>; i &lt;= t; i++) </span><br><span class="line">        ans = (ans + (LL)C[i - <span class="number">1</span>][fuck / <span class="number">2</span> - <span class="number">1</span>] * frac[i] % mod * F[i]) % mod;</span><br><span class="line">    res = (LL)res * ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;mod), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b, c; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c), adde(a, b, c);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            C[i][j] = C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (C[i][j] &gt;= mod) C[i][j] -= mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (LL)res * n % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-LCM-game"><a href="#T2-LCM-game" class="headerlink" title="T2 LCM game"></a>T2 LCM game</h1><p>一个长度为$k$的序列，序列中的每个数都在$[1,n]$之间</p><p>你需要求出$n^k$种序列的$\mathrm{lcm}$的和与乘积</p><script type="math/tex; mode=display">n\leq 500, k\leq 100</script><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>首先乘积是很好求的，我们对于每一个质因子分别考虑，枚举下一个数填啥，然后只需要考虑最后$\mathrm{lcm}$中这个质数的指数即可</p><p>需要注意的是由于最终$dp$的值需要拿到指数上，因此需要对$\mathrm{mod}-1$取模</p><p>对于第一问，有一个显然的想法是设$dp[i][j]$表示已经填了$i$个数，$\mathrm{lcm}$为$j$的方案数</p><p>注意到当$n$比较小的时候，所有可能的$\mathrm{lcm}$的数量不大，因此可以压状态，即对于每个可能出现的质因子记录这个质因子的次数</p><p>部分暴力代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flag[N], prime[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> G[N][N], G1[N][N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag[i]) prime[++tot] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; j++) &#123;</span><br><span class="line">            flag[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ct = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (tmp % prime[j] == <span class="number">0</span>) tmp /= prime[j], ct++;</span><br><span class="line">            G[j][ct]++, G1[i][prime[j]] = ct;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[M][<span class="number">30</span>], k, f[N][<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">if_n_is_ssssssssssssssmall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">30</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> p[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c[] = &#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>&#125;;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">10000</span>; j++) <span class="keyword">if</span> (f[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">int</span> buk[<span class="number">20</span>]; <span class="keyword">int</span> tmp = j;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--) buk[i] = tmp % c[i], tmp /= c[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">                <span class="keyword">static</span> <span class="keyword">int</span> nw[<span class="number">20</span>]; <span class="keyword">int</span> code = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= <span class="number">9</span>; l++) nw[l] = max(G1[k][p[l]], buk[l]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= <span class="number">9</span>; l++) code = code * c[l] + nw[l];</span><br><span class="line">                f[i][code] = (f[i][code] + f[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">10000</span>; j++) <span class="keyword">if</span> (f[k][j]) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> buk[<span class="number">20</span>]; <span class="keyword">int</span> tmp = j, nw = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--) buk[i] = tmp % c[i], tmp /= c[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) nw = (LL)nw * Pow(p[i], buk[i]) % mod;</span><br><span class="line">        res = (res + (LL)nw * f[k][j]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑优化这个过程，其中一个瓶颈在于合并两个$\mathrm{lcm}$，可以发现这是一个类似于$\max$卷积的东西</p><p>如果用类似<code>FWT</code>的方法，求出两个$dp$的高维前缀和，那么就可以直接对高维前缀和点值相乘，然后再<code>IFWT</code>回去</p><p>OIwiki上对高维前缀和解释得很清楚</p><p><img src="1586090124846.png" alt=""></p><p>然后实现出来这是一个类似于<code>FFT</code>的东西，部分代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">encode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> base[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> code = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dimension; i++) </span><br><span class="line">        code *= up[i], code += base[i];</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nw = dimension, step = <span class="number">1</span>; nw &gt;= <span class="number">1</span>; step *= up[nw--]) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum; i += step * up[nw])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + step * (up[nw] - <span class="number">1</span>); j += step)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; step; k++)</span><br><span class="line">                    Inc(a[j + k + step], a[j + k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IFWT</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nw = dimension, step = <span class="number">1</span>; nw &gt;= <span class="number">1</span>; step *= up[nw--]) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum; i += step * up[nw])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + step * (up[nw] - <span class="number">2</span>); j &gt;= i; j -=  step)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; step; k++)</span><br><span class="line">                    Dec(a[j + k + step], a[j + k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里<code>a[i]</code>表示$\mathrm{lcm}$在压缩之后为$i$的方案数</p><p>直接上<code>FWT</code>对$dp$进行优化，可以获得$68$分的好成绩</p><p>考虑进一步优化</p><p>我们将所有质数分为两类：大于$\sqrt n$的和小于等于$\sqrt n$的</p><p>对于大于$\sqrt n$的那些质数，他们在某个数的所有质因子中最多出现一次</p><p>我们按照最大质因子的大小将所有数分为为$A,B$，那么最后的$\mathrm{lcm}$一定可以被表示成$\mathrm{lcm}(\mathrm{lcm}_{i\in A} i, \mathrm{lcm}_{j\in B}j)$的形式</p><p>由于$A$中的质数在每个数的质因子中至多出现一次，因此我们考虑枚举这个质数。设$f_{i,j,k}$表示考虑了大于等于$i$的那些质数，我们选择了$j$个含有这其中的某个质数的数，$B$中质因子的$\mathrm{lcm}$为$k$的所有方案的权值之和</p><p>转移的时候，设$g_{i,j,k}$表示只考虑$[1,i]$的数，填了$j$个位置，$\mathrm{lcm}$为$k$的方案数</p><p>对于每个大于$\sqrt n$的质数$p$，最大质因子为$p$的数为$2p, 3p, \cdots$，给这些数都除上$p$，就能用$g$转移了。如果此次填的数多余一个，那么还要乘上一个$p$的权值，因为$p$也是最终所有数的$\mathrm{lcm}$的因数</p><p>最后再用$f_{\sqrt n+ 1}$和$B$中的数合并即可，转移的时候使用<code>FWT</code>优化</p><p>需要注意的是，转移和合并的时候的状态是不一样的，因为转移的时候每个数不大于$\sqrt n$，而最终合并的时候每个数都是$O(n)$级别。前者的状态数小于$1000$，而后者的状态数大约有$70000$</p><p>这样可以获得$84$分的好成绩</p><p>继续考虑如何优化，注意到有很多$p$的$\lfloor\frac{n}{p}\rfloor$是相同的，也就是说它们转移时所用的$g$的状态也是相同的，我们将这些$p$归为一类，一起转移</p><p>具体地，设$h_{i,j}$表示考虑长度为$i$的序列，每个元素都在$[1,j]$之间，且每种数都出现过的方案数</p><p>然后枚举当前这一类质数有多少个数出现，填了多少个位置，再算出从这些$p$中选出$i$个相乘的和即可</p><p>我最后只改了$84$分，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123; x += y, x -= x &gt;= mod ? mod : <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dec</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123; x -= y, x += x &lt; <span class="number">0</span> ? mod : <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">int</span> t = x + y; <span class="keyword">return</span> t &gt;= mod ? t - mod : t; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">int</span> t = x - y; <span class="keyword">return</span> t &lt; <span class="number">0</span> ? t + mod : t; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag[N], prime[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> G[N][N], G1[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag[i]) prime[++tot] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * prime[j] &lt;= n; j++) &#123;</span><br><span class="line">            flag[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ct = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (tmp % prime[j] == <span class="number">0</span>) tmp /= prime[j], ct++;</span><br><span class="line">            G[j][ct]++, G1[i][prime[j]] = ct;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> task1 &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dimension, lim, sum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> up[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> type = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    lim = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(n)), sum = <span class="number">1</span>; <span class="keyword">int</span> hh = n;</span><br><span class="line">    <span class="keyword">if</span> (!type) hh = lim;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prime[i] &gt; lim) <span class="keyword">break</span>;</span><br><span class="line">        dimension = i, up[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = hh; </span><br><span class="line">        <span class="keyword">while</span> (tmp /= prime[i]) up[i]++; </span><br><span class="line">        sum *= up[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">encode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> base[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> code = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dimension; i++) </span><br><span class="line">        code *= up[i], code += base[i];</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getLCM</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = dimension; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = code % up[i]; code /= up[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t; j++) res = (LL)res * prime[i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(<span class="keyword">int</span> code, <span class="keyword">int</span> result[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = dimension; i &gt;= <span class="number">1</span>; i--) </span><br><span class="line">        result[i] = code % up[i], code /= up[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">unpack</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> result[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= dimension; i++) &#123;</span><br><span class="line">        result[i] = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">while</span> (n % prime[i] == <span class="number">0</span>) n /= prime[i], result[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nw = dimension, step = <span class="number">1</span>; nw &gt;= <span class="number">1</span>; step *= up[nw--]) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum; i += step * up[nw])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + step * (up[nw] - <span class="number">1</span>); j += step)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; step; k++)</span><br><span class="line">                    Inc(a[j + k + step], a[j + k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IFWT</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nw = dimension, step = <span class="number">1</span>; nw &gt;= <span class="number">1</span>; step *= up[nw--]) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum; i += step * up[nw])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + step * (up[nw] - <span class="number">2</span>); j &gt;= i; j -=  step)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; step; k++)</span><br><span class="line">                    Dec(a[j + k + step], a[j + k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g[i][j][k]: [1, i]的数，选j个，lcm为k</span></span><br><span class="line"><span class="keyword">int</span> g[<span class="number">80</span>][M][<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve_g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lim; i++) &#123;</span><br><span class="line">        g[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; sum; l++) <span class="keyword">if</span> (g[i][j - <span class="number">1</span>][l]) &#123;</span><br><span class="line">                <span class="keyword">static</span> <span class="keyword">int</span> buk[<span class="number">60</span>]; decode(l, buk);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> nw = <span class="number">1</span>; nw &lt;= i; nw++) &#123;</span><br><span class="line">                    <span class="keyword">static</span> <span class="keyword">int</span> hh[<span class="number">60</span>];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= dimension; t++) </span><br><span class="line">                        hh[t] = max(G1[nw][prime[t]], buk[t]);</span><br><span class="line">                    Inc(g[i][j][encode(hh)], g[i][j - <span class="number">1</span>][l]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; "g: " &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt;= k; i++)</span></span><br><span class="line">    <span class="comment">//     for (int j = 0; j &lt; sum; j++)</span></span><br><span class="line">    <span class="comment">//         cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; getLCM(j) &lt;&lt; ' ' &lt;&lt; g[1][i][j] &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; "end" &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> C[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// f[i][j][k]: 考虑了[i, n]的质数，已经有j个位置确定好了，[1, sqrt(n)]的lcm为k</span></span><br><span class="line"><span class="keyword">int</span> f[N][M][<span class="number">1010</span>], tp[<span class="number">1010</span>], id[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pre(), solve_g();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            C[i][j] = Add(C[i - <span class="number">1</span>][j - <span class="number">1</span>], C[i - <span class="number">1</span>][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    f[tot + <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tot; i &gt; dimension; i--) &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; "solve: " &lt;&lt; prime[i] &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; j++) <span class="keyword">if</span> (f[i + <span class="number">1</span>][j][<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> nw = <span class="number">0</span>; nw + j &lt;= k; nw++) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; j &lt;&lt; ' ' &lt;&lt; nw &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">int</span> w = C[nw + j][j]; <span class="keyword">static</span> <span class="keyword">int</span> A[<span class="number">1010</span>], B[<span class="number">1010</span>];</span><br><span class="line">                <span class="keyword">if</span> (nw) w = (LL)w * prime[i] % mod;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; sum; l++) A[l] = f[i + <span class="number">1</span>][j][l], B[l] = g[n / prime[i]][nw][l];</span><br><span class="line">                FWT(A), FWT(B);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; sum; l++) A[l] = (LL)A[l] * B[l] % mod;</span><br><span class="line">                IFWT(A); </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; sum; l++) Inc(f[i][j + nw][l], (LL)A[l] * w % mod);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; prime[dimension + 1] &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// for (int j = 0; j &lt;= k; j++)</span></span><br><span class="line">    <span class="comment">//     for (int l = 0; l &lt; sum; l++)</span></span><br><span class="line">    <span class="comment">//         cout &lt;&lt; j &lt;&lt; ' ' &lt;&lt; getLCM(l) &lt;&lt; ' ' &lt;&lt; f[dimension + 1][j][l] &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sum; i++) tp[i] = getLCM(i);</span><br><span class="line">    <span class="keyword">int</span> last = sum; pre(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> fk[<span class="number">110</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; last; i++) </span><br><span class="line">        unpack(tp[i], fk), id[i] = encode(fk);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> B[<span class="number">100010</span>]; <span class="built_in">memset</span>(B, <span class="number">0</span>, <span class="keyword">sizeof</span>(B));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; j++) <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) mx = j;</span><br><span class="line">        <span class="keyword">if</span> (mx &gt; dimension) <span class="keyword">continue</span>;</span><br><span class="line">        unpack(i, fk), B[encode(fk)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    FWT(B); <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> A[<span class="number">100010</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; sum; l++) A[l] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; last; l++) A[id[l]] = f[dimension + <span class="number">1</span>][i][l];</span><br><span class="line">        FWT(A);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; sum; l++)</span><br><span class="line">            A[l] = (LL)A[l] * Pow(B[l], k - i) % mod;</span><br><span class="line">        IFWT(A);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; sum; l++) &#123;</span><br><span class="line">            res = (res + (LL)getLCM(l) * A[l] % mod * C[k][i]) % mod;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; "fuck: " &lt;&lt; getLCM(l) &lt;&lt; ' ' &lt;&lt; (LL)getLCM(l) * A[l] % mod * C[k][i] % mod &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; k &lt;&lt; ' ' &lt;&lt; i &lt;&lt; ' ' &lt;&lt; C[k][i] &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; res &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> task2 &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[M][<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp)), dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (G[i][tp + <span class="number">1</span>]) tp++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;= tp; a++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= tp; b++) </span><br><span class="line">                    dp[j][max(a, b)] = (dp[j][max(a, b)] + (LL)dp[j - <span class="number">1</span>][a] * G[i][b]) % (mod - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, t = <span class="number">1</span>; j &lt;= tp; j++, t = (LL)t * prime[i] % mod)</span><br><span class="line">            res = (LL)res * Pow(t, dp[k][j]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k, sieve();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, task1::solve(), task2::solve());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-Easy-Data-Structure"><a href="#T3-Easy-Data-Structure" class="headerlink" title="T3 Easy Data Structure"></a>T3 Easy Data Structure</h1><p>参考farewell to mount celeste</p>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 状态压缩 </tag>
            
            <tag> 容斥 </tag>
            
            <tag> FWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.28联测T1 数一数</title>
      <link href="/2020/04/03/328-lian-ce-t1-shu-yi-shu/"/>
      <url>/2020/04/03/328-lian-ce-t1-shu-yi-shu/</url>
      
        <content type="html"><![CDATA[<p>有一个 $n$ 行 $m$ 列的表格，每个位置上有$0$或者$1$，对于每一列，第$i$行是1的概率是$P_i$，每一列仅会出现一个$1$。</p><p>你可以选择一个初始位置$(x,y)$，表示第$x$行$y$列的格子，然后每次移动可以走到$(x−1,y+1),(x,y+1),(x+1,y+1)$这三个格子里面的一个，直到$y=m$，你的得分为中途走过的格子的值的和。</p><p>假设对于随机生成的$n$行$m$列的表格，能得到的最大得分的期望为$f(m)$。</p><p>求：$\lim_{m\rightarrow \infty} \frac{f(m)}{m}$</p><script type="math/tex; mode=display">n\leq 6</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>如果每个位置上是$1$还是$0$已经确定好了，那么这就是一道很简单的$dp$题，从后往前按列$dp$即可</p><p>现在每个位置出现的数是随机的，那么根据套路我们可以尝试将$dp$状态压下来，换个说法就是$dp$套$dp$</p><p>爆搜出每一种可能的状态，在$n=6$的时候只有$478$种</p><p>当$m\rightarrow \infty$的时候，我们可以认为每列的转移形成了一张图，可以进一步地在这张图上高斯消元。最终我们只关系每种状态出现次数的比例</p><p>我们钦定一种状态的出现次数为$1$，可以求出其它状态的出现次数，从而求出所有状态出现次数的比例</p><p>最后枚举这张图上的每一条边，考虑这条边出现的概率以及是否会对答案产生贡献即可</p><p>这道题我在考试的时候调了很久，最后发现wa的原因是<code>(int)(0.3 * 10) = 2</code></p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> G[N][N], tot, n, inc[N][N], p[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ID</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mp.count(s)) <span class="keyword">return</span> mp[s];</span><br><span class="line">    <span class="keyword">return</span> mp[s] = ++tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">trans</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;base, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    vector&lt;int&gt; res(n), tmp = base; int A = 0, B = 0;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) tmp[i] += tmp[i - <span class="number">1</span>], A = max(A, tmp[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// int t = tmp[i] + (i == pos); </span></span><br><span class="line">        <span class="comment">// if (i) t = max(t, tmp[i - 1] + (i - 1 == pos));</span></span><br><span class="line">        <span class="comment">// if (i &lt; n - 1) t = max(t, tmp[i + 1] + (i + 1 == pos));</span></span><br><span class="line">        <span class="keyword">int</span> t = tmp[i]; </span><br><span class="line">        <span class="keyword">if</span> (i) t = max(t, tmp[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>) t = max(t, tmp[i + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (i == pos) t++;</span><br><span class="line">        res[i] = t, B = max(B, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) res[i] -= res[i - <span class="number">1</span>];</span><br><span class="line">    res[<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">int</span> s = ID(base), t = ID(res);</span><br><span class="line">    G[s][t] = (G[s][t] + p[pos]) % mod;</span><br><span class="line">    <span class="keyword">if</span> (A != B) inc[s][t] = (inc[s][t] + p[pos]) % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = ID(status);</span><br><span class="line">    <span class="keyword">if</span> (vis[id]) <span class="keyword">return</span>;</span><br><span class="line">    vis[id] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) build(trans(status, i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N][N], res[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Gauss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; j++) </span><br><span class="line">            A[i][j] = G[j][i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tot; i++) </span><br><span class="line">        A[i][i] = (A[i][i] - <span class="number">1</span> + mod) % mod;</span><br><span class="line">    A[tot][tot] = <span class="number">1</span>, A[tot][tot + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= tot; j++) <span class="keyword">if</span> (A[j][i]) &#123;</span><br><span class="line">            swap(A[i], A[j]); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        assert(A[i][i]); <span class="keyword">int</span> inv = Pow(A[i][i], mod - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= tot; j++) <span class="keyword">if</span> (A[j][i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = (LL)inv * A[j][i] % mod;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= tot + <span class="number">1</span>; k++) </span><br><span class="line">                A[j][k] = (A[j][k] - (LL)A[i][k] * t % mod + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tot; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> inv = Pow(A[i][i], mod - <span class="number">2</span>);</span><br><span class="line">        res[i] = (LL)A[i][tot + <span class="number">1</span>] * inv % mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) <span class="keyword">if</span> (A[j][i]) </span><br><span class="line">            A[j][tot + <span class="number">1</span>] = (A[j][tot + <span class="number">1</span>] - (LL)res[i] * A[j][i] % mod + mod) % mod, A[j][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for (int i = 1; i &lt;= tot; i++) cout &lt;&lt; res[i] &lt;&lt; ' ';</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) sum = (sum + res[i]) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) res[i] = (LL)res[i] * Pow(sum, mod - <span class="number">2</span>) % mod;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; j++) <span class="keyword">if</span> (inc[i][j]) </span><br><span class="line">            ans = (ans + (LL)res[i] * inc[i][j]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); <span class="keyword">int</span> inv = Pow(<span class="number">10</span>, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">double</span> t; <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;t);</span><br><span class="line">        p[i] = ((LL)(t * <span class="number">10</span>)) * inv % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">base</span><span class="params">(n)</span></span>;</span><br><span class="line">    build(base), Gauss(), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, process());</span><br><span class="line"><span class="comment">//    cout &lt;&lt; tot &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高斯消元 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4220 [WC2018] 通道</title>
      <link href="/2020/04/03/wc2018-tong-dao/"/>
      <url>/2020/04/03/wc2018-tong-dao/</url>
      
        <content type="html"><![CDATA[<p>给出三棵树，求出</p><script type="math/tex; mode=display">\mathrm{dis}_{T_1}(a,b) + \mathrm{dis}_{T_2}(a,b) + \mathrm{dis}_{T_3}(a,b)</script><p>的最大值，边权为正</p><script type="math/tex; mode=display">n\leq 10^5, w\leq 10^{12}</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这题跟暴力写挂长得很像，但是暴力写挂只有两棵树，而这道题有三棵</p><p>但是需要注意的一点是，暴力写挂的边权有负数，因此不能直接求直径，而这道题的边权都是正的</p><p>考虑对于第一棵树边分治，在第二棵树上<code>dfs</code>。在合并两棵子树对应的边分树的时候，我们需要求出它们在第三棵树上的直径</p><p>具体来说，我们对于每个点单独考虑只有这个点在边分树上的情况，跟暴力写挂一样把这条链存下来。对于这条链上的每一个点，我们维护这个点左侧的点在$T_3$上的直径，右侧的点在$T_3$上的直径，合并的时候就是普通的合并直径</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, LL&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dis1(a, b) + dep2[a] + dep2[b] - 2dep2[lca2(a, b)] + dis3(a, b)</span></span><br><span class="line"><span class="comment"> * 对T1边分治，在T2上合并边分树，维护T3的加权直径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三度化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next; LL w;</span><br><span class="line">&#125; e[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N * <span class="number">2</span>], ecnt = <span class="number">1</span>, ncnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, LL w)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; "--adde: " &lt;&lt; from &lt;&lt; ' ' &lt;&lt; to &lt;&lt; ' ' &lt;&lt; w &lt;&lt; endl;</span></span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from], w &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to], w &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt; G1[N], G2[N], G3[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rebuild</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last = u, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G1[u]) <span class="keyword">if</span> (v.first != f) t = v.first;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G1[u]) <span class="keyword">if</span> (v.first != f) &#123;</span><br><span class="line">        Rebuild(v.first, u), adde(last, v.first, v.second);</span><br><span class="line">        <span class="keyword">if</span> (v.first != t) adde(last, ++ncnt, <span class="number">0</span>), last = ncnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T2, T3</span></span><br><span class="line">LL dep2[N], dep3[N]; <span class="keyword">int</span> dep[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> st[<span class="number">18</span>][N * <span class="number">2</span>], lg[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G2[u]) <span class="keyword">if</span> (v.first != f) </span><br><span class="line">        dep2[v.first] = dep2[u] + v.second, dfs1(v.first, u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn, fir[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    st[<span class="number">0</span>][++dfn] = u, fir[u] = dfn, dep[u] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G3[u]) <span class="keyword">if</span> (v.first != f) </span><br><span class="line">        dep3[v.first] = dep3[u] + v.second, dfs2(v.first, u), st[<span class="number">0</span>][++dfn] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dep[x] &lt; dep[y] ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">17</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= dfn; j++)</span><br><span class="line">            st[i][j] = Min(st[i - <span class="number">1</span>][j], st[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= dfn; i++) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LCA on T3</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line">    a = fir[a], b = fir[b];</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) swap(a, b);</span><br><span class="line">    <span class="keyword">int</span> len = lg[b - a + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> Min(st[len][a], st[len][b - (<span class="number">1</span> &lt;&lt; len) + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Dis</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dep3[a] + dep3[b] - <span class="number">2</span> * dep3[LCA(a, b)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并直径</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b; LL A, B, dis;</span><br><span class="line">&#125; val[<span class="number">2</span>][N * <span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> data <span class="title">Max</span><span class="params">(data a, data b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.dis &gt; b.dis ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> data <span class="title">Merge</span><span class="params">(data a, data b, LL diff)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((!a.a) || (!b.a)) <span class="keyword">return</span> a.a ? a : b;</span><br><span class="line">    <span class="keyword">static</span> LL tmp[<span class="number">4</span>]; <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    tmp[<span class="number">0</span>] = Dis(a.a, b.a) + a.A + b.A, tmp[<span class="number">1</span>] = Dis(a.a, b.b) + a.A + b.B;</span><br><span class="line">    tmp[<span class="number">2</span>] = Dis(a.b, b.a) + a.B + b.A, tmp[<span class="number">3</span>] = Dis(a.b, b.b) + a.B + b.B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) <span class="keyword">if</span> (tmp[i] &gt; tmp[pos]) pos = i;</span><br><span class="line">    data res = (data)&#123; (pos &amp; <span class="number">2</span>) ? a.b : a.a, (pos &amp; <span class="number">1</span>) ? b.b : b.a, (pos &amp; <span class="number">2</span>) ? a.B : a.A, (pos &amp; <span class="number">1</span>) ? b.B : b.A, tmp[pos] &#125;;</span><br><span class="line">    <span class="keyword">if</span> (diff != <span class="number">233</span>) ans = max(ans, tmp[pos] + diff); </span><br><span class="line">    <span class="keyword">return</span> Max(res, Max(a, b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边分治</span></span><br><span class="line"><span class="keyword">int</span> sz[N * <span class="number">2</span>], cur, fucked[N * <span class="number">4</span>], n, ch[<span class="number">2</span>][N * <span class="number">30</span>]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lst[N * <span class="number">2</span>], lst1[N * <span class="number">2</span>], RT[N * <span class="number">2</span>], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> nw, LL dis)</span> </span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lst[u]) lst[u] = RT[u] = ++tot;</span><br><span class="line">        <span class="keyword">else</span> tot++, ch[lst1[u]][lst[u]] = tot, lst[u] = tot;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; "fuck: " &lt;&lt; u &lt;&lt; ' ' &lt;&lt; dis &lt;&lt; ' ' &lt;&lt; dep2[u] &lt;&lt; endl;</span></span><br><span class="line">        lst1[u] = nw, val[nw][tot] = (data)&#123; u, u, dis + dep2[u], dis + dep2[u], dis * <span class="number">2</span> + dep2[u] * <span class="number">2</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f &amp;&amp; !fucked[i]) dfs(e[i].to, u, nw, dis + e[i].w), sz[u] += sz[e[i].to];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> &amp;rt1, <span class="keyword">int</span> rt2, LL diff)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((!rt1) || (!rt2)) <span class="keyword">return</span> rt1 |= rt2, <span class="keyword">void</span>();</span><br><span class="line"><span class="comment">//    cout &lt;&lt; ch[0][rt1] &lt;&lt; ' ' &lt;&lt; ch[1][rt1] &lt;&lt; ' ' &lt;&lt; ch[0][rt2] &lt;&lt; ' ' &lt;&lt; ch[1][rt2] &lt;&lt; endl;</span></span><br><span class="line">    Merge(val[<span class="number">0</span>][rt1], val[<span class="number">1</span>][rt2], diff), Merge(val[<span class="number">1</span>][rt1], val[<span class="number">0</span>][rt2], diff);</span><br><span class="line">    val[<span class="number">0</span>][rt1] = Merge(val[<span class="number">0</span>][rt1], val[<span class="number">0</span>][rt2], <span class="number">233</span>), val[<span class="number">1</span>][rt1]= Merge(val[<span class="number">1</span>][rt1], val[<span class="number">1</span>][rt2], <span class="number">233</span>);</span><br><span class="line">    Merge(ch[<span class="number">0</span>][rt1], ch[<span class="number">0</span>][rt2], diff), Merge(ch[<span class="number">1</span>][rt1], ch[<span class="number">1</span>][rt2], diff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找中心边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetEG</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> tot)</span> </span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f &amp;&amp; !fucked[i]) &#123;</span><br><span class="line">            GetEG(e[i].to, u, tot), sz[u] += sz[e[i].to];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(tot - <span class="number">2</span> * sz[e[i].to]) &lt; tmp) </span><br><span class="line">                tmp = <span class="built_in">abs</span>(tot - <span class="number">2</span> * sz[e[i].to]), cur = i;</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Divide</span><span class="params">(<span class="keyword">int</span> ed)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; "--find: " &lt;&lt; e[ed].to &lt;&lt; ' ' &lt;&lt; e[ed ^ 1].to &lt;&lt; endl;</span></span><br><span class="line">    fucked[ed] = fucked[ed ^ <span class="number">1</span>] = <span class="number">1</span>, dfs(e[ed].to, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), dfs(e[ed ^ <span class="number">1</span>].to, <span class="number">0</span>, <span class="number">1</span>, e[ed].w);</span><br><span class="line">    <span class="keyword">auto</span> find = [&amp;](<span class="keyword">int</span> u) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        cur = <span class="number">-1</span>, tmp = <span class="number">1e9</span>, GetEG(u, <span class="number">0</span>, sz[u]);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> L = find(e[ed].to), R = find(e[ed ^ <span class="number">1</span>].to);</span><br><span class="line">    <span class="keyword">if</span> (~L) Divide(L); <span class="keyword">if</span> (~R) Divide(R);</span><br><span class="line"><span class="comment">//    cout &lt;&lt; "--end" &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Divide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ncnt = n, Rebuild(<span class="number">1</span>, <span class="number">0</span>), tmp = <span class="number">1e9</span>, GetEG(<span class="number">1</span>, <span class="number">0</span>, n), Divide(cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G2[u]) <span class="keyword">if</span> (v.first != f) </span><br><span class="line">        dfs3(v.first, u), Merge(RT[u], RT[v.first], <span class="number">-2</span> * dep2[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b; LL c; read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        read(a), read(b), read(c);</span><br><span class="line">        G1[a].push_back(P(b, c)), G1[b].push_back(P(a, c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        read(a), read(b), read(c);</span><br><span class="line">        G2[a].push_back(P(b, c)), G2[b].push_back(P(a, c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        read(a), read(b), read(c);</span><br><span class="line">        G3[a].push_back(P(b, c)), G3[b].push_back(P(a, c));</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>), dfs2(<span class="number">1</span>, <span class="number">0</span>), ST(), Divide(), dfs3(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//    Merge(RT[2], RT[3], 0);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 边分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4565 [CTSC2018] 暴力写挂  </title>
      <link href="/2020/03/31/p4565-ctsc2018-bao-li-xie-gua/"/>
      <url>/2020/03/31/p4565-ctsc2018-bao-li-xie-gua/</url>
      
        <content type="html"><![CDATA[<p>给出两棵带边权的树$T_1, T_2$，你需要求出</p><script type="math/tex; mode=display">\mathrm{dep}_{T_1}(a) + \mathrm{dep}_{T_1}(b) - \mathrm{dep}_{T_1}(\mathrm{lca}_{T_1}(a,b)) - \mathrm{dep}_{T_2}(\mathrm{lca}_{T_2}(a,b))</script><p>的最大值</p><p>边权可能为负</p><script type="math/tex; mode=display">n\leq 4\times 10^5</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这个题有两种做法</p><p>首先将这个式子改写一下</p><script type="math/tex; mode=display">\frac 12[\mathrm{dis}_{T_1}(a, b) + \mathrm{dep}_{T_1}(a) +  \mathrm{dep}_{T_1}(b) - 2\mathrm{dep}_{T_2}(\mathrm{lca}_{T_2}(a,b))]</script><p>这个式子的最后一项是拆不掉的</p><p>考虑对第一棵树进行点分治，那么当前枚举的中心点会将当前连通块分为若干棵子树。我们将当前连通块里面的其它点拿出来，到$T2$上建一棵虚树，再在这棵虚树上进行树形$dp$</p><p>此时我们需要保证$a,b$在$T1$中落在当前中心点的两个不同的子树内，并且$a,b$在$T2$中落在当前根的不同子树内。由于点分治的时候中心点分出的子树可能有很多个，因此这样做复杂度会爆炸</p><p>如果当前中心点只有两棵子树，那么我们可以将这两棵子树分别染成黑色和白色。接着我们枚举$a,b$在$T2$上的$\mathrm{lca}$，问题转化为在当前点的两棵不同的子树中找到一个黑点，一个白点，使得这两个点的权值之和最大</p><p>而“当前中心点只有两棵子树”这个限制可以使用边分治实现</p><p>首先我们将整棵树三度化，转化为一棵二叉树</p><p><img src="1585639193685.png" alt=""></p><p>转化之后可以得到</p><p><img src="1585639347536.png" alt=""></p><p>注意，我们要保证转化之后两点之间的距离不变</p><p>实现过程就是：对于当前根，我们记录一个<code>last</code>表示上一次新建的虚点，一开始<code>last</code>的值就等于根</p><p>每遇到一个儿子，我们将这个儿子挂到<code>last</code>下面，边权为当前根到这个儿子的边权，同时新建一个虚点，将这个虚点挂到<code>last</code>下，同时边权为$0$，最后令<code>last</code>等于新建的虚点</p><p>代码很短</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rebuild</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last = u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G1[u]) <span class="keyword">if</span> (v.first != f) &#123;</span><br><span class="line">        Rebuild(v.first, u), adde(last, v.first, v.second);</span><br><span class="line">        adde(last, ++ncnt, <span class="number">0</span>), last = ncnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们就可以开始愉快地边分治了</p><p>类似点分治的方法，每次我们根据子树大小选出一条中心边，然后这条中心边会将当前连通块分为两个部分。我们将这两个部分的点分别染成黑色和白色，然后丢到$T2$上建虚树，再跑一遍树形$dp$。最后对这两个部分继续分治下去</p><p>如果虚树的实现不够优秀，那么这样的时间复杂度就为$O(n\log^2 n)$，但这个方法不是我想讨论的重点</p><p>类似于动态点分治，其实也是有“动态边分治”，也就是边分树这种东西的</p><p>每次选择当前分治的中心边，为这条边新建一个节点，然后左右两边递归分治，容易发现这样得到的是一棵树型的结构，并且每个叶子都对应原树中的一个点</p><p>对于原树中的每一个点，类似动态开点线段树，我们求出仅保留这个点的所有祖先的边分树</p><p>接着，我们枚举$a,b$在$T2$上的$\mathrm{lca}$，类似线段树合并的方法，每次合并当前节点的两个儿子对应的边分树，同时更新答案</p><p>时间复杂度跟线段树合并的时间复杂度一样，为$O(n\log n)$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * dis1(a, b) + dep1[a] + dep1[b] - dep2[lca(a, b)]</span></span><br><span class="line"><span class="comment"> * 对T1建边分树，维护左右儿子的dep1 + dis1(a, t0 / t1)的最大值</span></span><br><span class="line"><span class="comment"> * 对T2dfs，同时合并对应的边分树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三度化之后的树</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;</span><br><span class="line">&#125; e[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N * <span class="number">2</span>], ecnt = <span class="number">1</span>, ncnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; "adde: " &lt;&lt; from &lt;&lt; ' ' &lt;&lt; to &lt;&lt; ' ' &lt;&lt; w &lt;&lt; endl;</span></span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from], w &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to], w &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T1, T2</span></span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt; G1[N], G2[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个点在T1中的深度</span></span><br><span class="line">LL dep[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三度化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rebuild</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last = u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G1[u]) <span class="keyword">if</span> (v.first != f) &#123;</span><br><span class="line">        dep[v.first] = dep[u] + v.second, Rebuild(v.first, u), adde(last, v.first, v.second);</span><br><span class="line">        adde(last, ++ncnt, <span class="number">0</span>), last = ncnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sz[N * <span class="number">2</span>], cur, fucked[N * <span class="number">4</span>], n; LL ans = <span class="number">-1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边分树结构</span></span><br><span class="line"><span class="keyword">int</span> lst[N], lst1[N], tot, tmp = <span class="number">1e9</span>, RT[N], ch[<span class="number">2</span>][N * <span class="number">30</span>]; LL val[<span class="number">2</span>][N * <span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对T1中的每个点单独求出其在边分树上的链</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> nw, LL dis)</span> </span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lst[u]) lst[u] = RT[u] = ++tot;</span><br><span class="line">        <span class="keyword">else</span> ch[lst1[u]][lst[u]] = ++tot, lst[u] = tot;</span><br><span class="line">        lst1[u] = nw, val[nw][lst[u]] = dis + dep[u], val[nw ^ <span class="number">1</span>][lst[u]] = <span class="number">-1e18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f &amp;&amp; !fucked[i]) </span><br><span class="line">            dfs(e[i].to, u, nw, dis + e[i].w), sz[u] += sz[e[i].to];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并边分树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> &amp;rt1, <span class="keyword">int</span> rt2, LL diff)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rt1 || !rt2) <span class="keyword">return</span> rt1 |= rt2, <span class="keyword">void</span>();</span><br><span class="line">    ans = max(ans, max(val[<span class="number">0</span>][rt1] + val[<span class="number">1</span>][rt2] + diff, val[<span class="number">1</span>][rt1] + val[<span class="number">0</span>][rt2] + diff));</span><br><span class="line">    val[<span class="number">0</span>][rt1] = max(val[<span class="number">0</span>][rt1], val[<span class="number">0</span>][rt2]), val[<span class="number">1</span>][rt1] = max(val[<span class="number">1</span>][rt1], val[<span class="number">1</span>][rt2]);</span><br><span class="line">    Merge(ch[<span class="number">0</span>][rt1], ch[<span class="number">0</span>][rt2], diff), Merge(ch[<span class="number">1</span>][rt1], ch[<span class="number">1</span>][rt2], diff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找中心边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetEG</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> tot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f &amp;&amp; !fucked[i]) &#123;</span><br><span class="line">            GetEG(e[i].to, u, tot);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(tot - <span class="number">2</span> * sz[e[i].to]) &lt; tmp) </span><br><span class="line">                tmp = <span class="built_in">abs</span>(tot - <span class="number">2</span> * sz[e[i].to]), cur = i;</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Divide</span><span class="params">(<span class="keyword">int</span> ed)</span> </span>&#123;</span><br><span class="line">    fucked[ed] = fucked[ed ^ <span class="number">1</span>] = <span class="number">1</span>, dfs(e[ed].to, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), dfs(e[ed ^ <span class="number">1</span>].to, <span class="number">0</span>, <span class="number">1</span>, e[ed].w);</span><br><span class="line">    <span class="keyword">auto</span> find = [&amp;](<span class="keyword">int</span> u) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        cur = <span class="number">-1</span>, tmp = <span class="number">1e9</span>, GetEG(u, <span class="number">0</span>, sz[u]);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> L = find(e[ed].to), R = find(e[ed ^ <span class="number">1</span>].to);</span><br><span class="line">    <span class="keyword">if</span> (~L) Divide(L); <span class="keyword">if</span> (~R) Divide(R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Divide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ncnt = n, Rebuild(<span class="number">1</span>, <span class="number">0</span>), tmp = <span class="number">1e9</span>, GetEG(<span class="number">1</span>, <span class="number">0</span>, n), Divide(cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在T2上边分树合并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, LL dis)</span> </span>&#123;</span><br><span class="line">    ans = max(ans, dep[u] * <span class="number">2</span> - dis * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G2[u]) <span class="keyword">if</span> (v.first != f) </span><br><span class="line">        dfs(v.first, u, dis + v.second), Merge(RT[u], RT[v.first], -dis * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b, c; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        G1[a].push_back(P(b, c)), G1[b].push_back(P(a, c));</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b, c; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        G2[a].push_back(P(b, c)), G2[b].push_back(P(a, c));</span><br><span class="line">    &#125;</span><br><span class="line">    Divide(), dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 边分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.17 省选集训 day5</title>
      <link href="/2020/03/17/317-sheng-xuan-ji-xun-day5/"/>
      <url>/2020/03/17/317-sheng-xuan-ji-xun-day5/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-买到"><a href="#T1-买到" class="headerlink" title="T1 买到"></a>T1 买到</h1><p>给定一张$N$个点的无向完全图，点的标号从$1$开始。对于一个非空点集$S$，你需要找到一条路径，起点和终点均任意，满足$S$中的每个点在路径上出现了恰好一次，且不能经过集合外的其他点。</p><p>在到达了一个点$u$之后（包括起点和终点），你需要先“激活”这个点，才能进行之后的操作。你并不是必须在到达该点之后立刻激活，而是可以等待一段时间。同时，假如当前时刻为$t$，那么激活该点所需要花费的时间就是$A[u][t\mod T]$。</p><p>另外，对于一条边$e$，如果你从t时刻开始从边的起点出发向终点走去，那么在这条边上所需要花费时间就是$B[e][t\mod T]$。同样地，你也可以选择在起点等待一段时间再出发。</p><p>在路径起点开始的时候，为$0$时刻。</p><p>现在有$Q$次询问，每次都会给定一个非空点集$S$。你需要找到一条花费时间最少的路径，包括其在路径上走的方法。你只需要给出这个最少的花费时间。</p><script type="math/tex; mode=display">N\leq 20,Q\leq 2^N-1,T\leq 10^4</script><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>显然到达一个点的时间越早越优秀</p><p>预处理出在模$T$意义下的每个时刻准备激活每个点时的最小耗费时间，以及走每条边的最小耗费时间即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">21</span>][<span class="number">1</span> &lt;&lt; <span class="number">20</span>], A[<span class="number">21</span>][M], B[<span class="number">21</span>][<span class="number">21</span>][M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> F[<span class="number">21</span>][M], G[<span class="number">21</span>][<span class="number">21</span>][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, T; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; T; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; T; k++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;B[i][j][k]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        F[i][T - <span class="number">1</span>] = A[i][T - <span class="number">1</span>]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; T - <span class="number">1</span>; j++)</span><br><span class="line">            F[i][T - <span class="number">1</span>] = min(F[i][T - <span class="number">1</span>], A[i][j] + j + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = T - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            F[i][j] = min(F[i][j + <span class="number">1</span>] + <span class="number">1</span>, A[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            G[i][j][T - <span class="number">1</span>] = B[i][j][T - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; T - <span class="number">1</span>; k++)</span><br><span class="line">                G[i][j][T - <span class="number">1</span>] = min(G[i][j][T - <span class="number">1</span>], B[i][j][k] + k + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = T - <span class="number">2</span>; k &gt;= <span class="number">0</span>; k--)</span><br><span class="line">                G[i][j][k] = min(G[i][j][k + <span class="number">1</span>] + <span class="number">1</span>, B[i][j][k]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; T; k++) G[j][i][k] = G[i][j][k];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dp[i][<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>] = F[i][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); s++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (s &amp; (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = dp[i][s] % T;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span> (!(s &amp; (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>))) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = dp[i][s] + G[i][j][tmp], w = t + F[j][t % T];</span><br><span class="line">                dp[j][s | (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)] = min(dp[j][s | (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)], w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> q; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> s; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;s); <span class="keyword">int</span> res = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (s &amp; (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)) </span><br><span class="line">            res = min(res, dp[i][s]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-口罩"><a href="#T2-口罩" class="headerlink" title="T2 口罩"></a>T2 口罩</h1><p>给定一棵$N$个点的带标号无根树。定义一次操作为，把树中的某一条边去掉，然后再加上一条边，使得它仍然是一棵树。</p><p>你需要进行恰好$K$次这样的操作。请你求出，你可以得到多少棵不同的树。</p><p>两棵树定义为不同，当且仅当存在一条无向边$(x, y)$，在一棵树中出现、在另一棵树中不出现。</p><p>由于答案可能很大，请你输出其在模$10^9 + 7$意义下的结果</p><script type="math/tex; mode=display">N\leq 5000</script><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>容易发现，最终树的形态一定是将整棵树分为至多$k$个连通块，然后这些连通块再由若干条新边连成一棵树</p><p>如果我们确定了每个连通块的大小，假如在最终的连边方案中有一条边$(u,v)$，注意此时$u,v$代表的是两个连通块，那么这条边的端点一共有$sz_u\times sz_v$种选法</p><p>那么单独考虑每个连通块对总方案数的贡献，就是这个连通块的大小的度数次方</p><p>注意这里我们并没有要求此时连的边必须与原树上的边不同，因此会导致重复计数，如何去重我们后面再说</p><p>考虑由这些连通块构成的<code>prufer</code>序，显然每个连通块在这个序列中出现了度数$-1$次，少乘了一次</p><p>而每个连通块的大小之和为$n$</p><p>因此如果整棵树被分为了$i$个连通块，那么添加$i-1$条边使得整棵树连通的方案数为$n^{i-2}\times$所有连通块大小的乘积</p><p>因此我们需要求出对于每一种将整棵树分为$i(i\leq k)$个连通块的方案中，每个连通块大小的乘积之和</p><p>考虑这个东西的组合意义，就是从每个连通块中选出一个点的方案数</p><p>因此设$dp[i][j][1/0]$表示以$i$为根的子树，被划分为了$j$个连通块，其中根节点所在的连通块是否选了点的方案数</p><p>现在我们求出了将整棵树分为$i$个连通块并将这些连通块连接起来的方案数，如何去重呢</p><p>设$f[i]$表示将整棵树分为$i$个连通块，且连接的边都不是原树上的边的方案数</p><p>那么当前答案应该减去</p><script type="math/tex; mode=display">\sum_{j=1}^{i-1}{n-j\choose i-j}f[j]</script><p>因为每一种存在$j$个连通块的方案，断开$i-j$条连通块内部的边之和都能得到一种存在$i$个连通块的不合法方案</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from] &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to] &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][N][N], k, sz[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][u][<span class="number">1</span>] = dp[<span class="number">1</span>][u][<span class="number">1</span>] = sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) &#123;</span><br><span class="line">            dfs(e[i].to, u); <span class="keyword">static</span> <span class="keyword">int</span> tmp[<span class="number">2</span>][N];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sz[u] + sz[e[i].to]; j++) tmp[<span class="number">0</span>][j] = tmp[<span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sz[u] &amp;&amp; j &lt;= k; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= sz[e[i].to] &amp;&amp; l &lt;= k; l++) &#123;</span><br><span class="line">                    tmp[<span class="number">0</span>][j + l] = (tmp[<span class="number">0</span>][j + l] + (LL)dp[<span class="number">0</span>][u][j] * dp[<span class="number">1</span>][e[i].to][l]) % mod;</span><br><span class="line">                    tmp[<span class="number">0</span>][j + l - <span class="number">1</span>] = (tmp[<span class="number">0</span>][j + l - <span class="number">1</span>] + (LL)dp[<span class="number">0</span>][u][j] * dp[<span class="number">0</span>][e[i].to][l]) % mod;</span><br><span class="line">                    tmp[<span class="number">1</span>][j + l] = (tmp[<span class="number">1</span>][j + l] + (LL)dp[<span class="number">1</span>][u][j] * dp[<span class="number">1</span>][e[i].to][l]) % mod;</span><br><span class="line">                    tmp[<span class="number">1</span>][j + l - <span class="number">1</span>] = (tmp[<span class="number">1</span>][j + l - <span class="number">1</span>] + (LL)dp[<span class="number">1</span>][u][j] * dp[<span class="number">0</span>][e[i].to][l]) % mod;</span><br><span class="line">                    tmp[<span class="number">1</span>][j + l - <span class="number">1</span>] = (tmp[<span class="number">1</span>][j + l - <span class="number">1</span>] + (LL)dp[<span class="number">0</span>][u][j] * dp[<span class="number">1</span>][e[i].to][l]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sz[u] + sz[e[i].to] &amp;&amp; j &lt;= k; j++) </span><br><span class="line">                dp[<span class="number">0</span>][u][j] = tmp[<span class="number">0</span>][j], dp[<span class="number">1</span>][u][j] = tmp[<span class="number">1</span>][j];</span><br><span class="line">            sz[u] += sz[e[i].to];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> F[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>, k++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt; n; i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>), F[<span class="number">1</span>] = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= k; i++) </span><br><span class="line">        F[i] = (LL)Pow(n, i - <span class="number">2</span>) * dp[<span class="number">1</span>][<span class="number">1</span>][i] % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= k; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) </span><br><span class="line">            F[i] = (F[i] - (LL)F[j] * C(n - j, i - j)) % mod;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) res = (res + F[i]) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (res + mod) % mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-了吗"><a href="#T3-了吗" class="headerlink" title="T3 了吗"></a>T3 了吗</h1><p>给定一棵$N$个点的有根树，其中$1$是树根，除了$1$以外的其他点$u$有唯一的父亲$Father_u$。每个点$u$都有两个权值$V_u$和$W_u$。其中$W_u$是给定的，而且满足$W_u\in\{0,1\}$。</p><p>每个点的$V_u$则是你决定的。同时，给定了一个非负整数常数$K$。</p><p>设$Sum_u = \sum_{v\in Son_u}V_v$，其中$Son_u$表示$u$的儿子集合。对于一个合法的方案，<br>任意点$u$均需要满足：<br>（1） 若$W_u = 1$，$V_u = 2 \times Sum_u$；<br>（2） 若$W_u = 0$，$Sum_u \leq V_u \leq Sum_u + K$。</p><p>请你对于每个$0 \leq s \leq S$的$s$求出，在所有的合法方案中，最终满足$V_1 = s$的合<br>法方案有多少个。由于答案可能很大，你只需要求出其在模$998244353$意义下的结果。</p><p>如果对于每个$s$均输出答案，那么输出会过大。所以，你只需要输出所有答案的异或和。</p><script type="math/tex; mode=display">N,K,S\leq 10^6</script><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>考虑一个点权值的生成函数$F_u(x)$</p><p>如果$w_u=1$，那么</p><script type="math/tex; mode=display">F_u(x)=\prod_{v\in son_u}F_v(x^2)</script><p>否则</p><script type="math/tex; mode=display">F_u(x)=\frac{x^{k+1}-1}{x-1}\prod_{v\in son_u}F_v(x)</script><p>容易发现，最后$F_1(x)$一定可以被表示为若干个形如$\frac{(x^n)^{k+1}-1}{x^n-1}$的幂的乘积的形式</p><p>容易发现一个很重要的性质：这里的$n$都是$2$的幂</p><p>因此，$F_1(x)$的表达式中本质不同的底数只有$\log s$种</p><p>我们对分子分母分别求出它们的乘积，最后再求一遍逆</p><p>开一个桶，记录一下每种底数的次数，然后最后用二项式定理展开</p><p>第$i$个底数可能有值的地方只有$x^{2^i},x^{2^{i+1}},x^{2^{i+2}},\cdots$这些位置</p><p>因此我们倒着合并这些多项式，每次用$x$的系数来表示$x^{2^i}$的系数就行了</p><p>另一个优化是，可以发现求出分母也就求出了分子，因此我们可以只<code>NTT</code>一边</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from] &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to] &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> val[N], ans[<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w &gt; <span class="number">20</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (val[u]) w++; <span class="keyword">else</span> ans[w]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> poly[N &lt;&lt; <span class="number">2</span>], res[N &lt;&lt; <span class="number">2</span>], res1[N &lt;&lt; <span class="number">2</span>], B[N &lt;&lt; <span class="number">2</span>], s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r[N &lt;&lt; <span class="number">2</span>], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Wn[<span class="number">2</span>][<span class="number">22</span>][N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>, step = <span class="number">0</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>, step++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = Pow(<span class="number">3</span>, (mod - <span class="number">1</span>) / mid), t1 = Pow(t, mod - <span class="number">2</span>);</span><br><span class="line">        Wn[<span class="number">0</span>][step][<span class="number">0</span>] = Wn[<span class="number">1</span>][step][<span class="number">0</span>] = <span class="number">1</span>, Wn[<span class="number">1</span>][step][<span class="number">1</span>] = t, Wn[<span class="number">0</span>][step][<span class="number">1</span>] = t1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; (mid &gt;&gt; <span class="number">1</span>); i++) &#123;</span><br><span class="line">            Wn[<span class="number">1</span>][step][i] = (LL)Wn[<span class="number">1</span>][step][i - <span class="number">1</span>] * t % mod;</span><br><span class="line">            Wn[<span class="number">0</span>][step][i] = (LL)Wn[<span class="number">0</span>][step][i - <span class="number">1</span>] * t1 % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dec</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123; x -= y, x += x &lt; <span class="number">0</span> ? mod : <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">int</span> t = x - y; <span class="keyword">return</span> t &lt; <span class="number">0</span> ? t + mod : t; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">int</span> t = x + y; <span class="keyword">return</span> t &gt;= mod ? t - mod : t; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123; x += y, x -= x &gt;= mod ? mod : <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>, step = <span class="number">0</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>, step++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, t; j &lt; i + (mid &gt;&gt; <span class="number">1</span>); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = Wn[type][step][j - i]; </span><br><span class="line">                t = (LL)w * a[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = Sub(a[j], t), Inc(a[j], t);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">if</span> (!type) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, inv = Pow(len, mod - <span class="number">2</span>); i &lt; len; i++) </span><br><span class="line">        a[i] = (LL)a[i] * inv % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">GetR</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> A[], <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">void</span>(B[<span class="number">0</span>] = Pow(A[<span class="number">0</span>], mod - <span class="number">2</span>));</span><br><span class="line">    Inv(A, B, (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>); <span class="keyword">static</span> <span class="keyword">int</span> tmpa[N &lt;&lt; <span class="number">2</span>]; <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n * <span class="number">2</span>) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    GetR(len, l);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) tmpa[i] = A[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; len; i++) tmpa[i] = <span class="number">0</span>;</span><br><span class="line">    NTT(tmpa, len, <span class="number">1</span>), NTT(B, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) B[i] = (<span class="number">2</span> - (LL)tmpa[i] * B[i] % mod + mod) * B[i] % mod;</span><br><span class="line">    NTT(B, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; len; i++) B[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> tmpb[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n * <span class="number">2</span>) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) tmpb[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (n &gt;&gt; <span class="number">1</span>); i++) tmpb[i &lt;&lt; <span class="number">1</span>] = B[i];</span><br><span class="line">    GetR(len, l), NTT(A, len, <span class="number">1</span>), NTT(tmpb, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) B[i] = (LL)A[i] * tmpb[i] % mod;</span><br><span class="line">    NTT(B, len, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;k, &amp;s), k++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, a; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), adde(a, i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val[i]);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>); inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= s + <span class="number">1</span>; i++) inv[i] = (LL)(mod - mod / i) * inv[mod % i] % mod;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= <span class="number">2</span> * s) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    pre(len), res1[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> up = s &gt;&gt; i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= up; j++) poly[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, t = <span class="number">1</span>; j &lt;= min(ans[i], up); j++) &#123;</span><br><span class="line">            poly[j] = (ans[i] - j) &amp; <span class="number">1</span> ? mod - t : t;</span><br><span class="line">            t = (LL)t * inv[j + <span class="number">1</span>] % mod * (ans[i] - j) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        mul(poly, res1, up);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i * k &lt;= s; i++) res[i * k] = res1[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s + <span class="number">1</span>; i &lt; len; i++) res1[i] = <span class="number">0</span>;</span><br><span class="line">    Inv(res1, B, s + <span class="number">1</span>);</span><br><span class="line">    len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= <span class="number">2</span> * s) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    GetR(len, l), NTT(res, len, <span class="number">1</span>), NTT(B, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) B[i] = (LL)res[i] * B[i] % mod;</span><br><span class="line">    NTT(B, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s; i++) hh ^= B[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, hh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 状态压缩 </tag>
            
            <tag> 容斥 </tag>
            
            <tag> 生成函数 </tag>
            
            <tag> 多项式求逆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.14 省选集训 day4</title>
      <link href="/2020/03/15/314-sheng-xuan-ji-xun-day4/"/>
      <url>/2020/03/15/314-sheng-xuan-ji-xun-day4/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-Manager"><a href="#T1-Manager" class="headerlink" title="T1 Manager"></a>T1 Manager</h1><p>给出一棵有根树，每个点有一个权值$a_i$。定义一个点的价值为其子树（包括这个点自己）中的所有点的权值的中位数。对于每个$i\in [1,n]$，输出当$i$的权值变为$10^5$时整棵树的价值之和</p><script type="math/tex; mode=display">n\leq 2\times 10^5,a_i\leq 10^5</script><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>对于一个序列来说，将所有数从小到大排序，如果我们修改的数在中位数左边（包括中位数这个位置），那么会导致修改后的中位数往右移动一个位置</p><p>也就是说，如果一开始中位数右边的第一个数与中位数相等，那么这次修改不会产生任何影响</p><p>然后这道题就很简单了，我们考虑每个点对答案的贡献，如果修改的点在这个点的子树中，且修改的点在修改之前的权值小于等于中位数，那么这个点的贡献为中位数右边的第一个数；否则这个点的贡献是中位数</p><p>查找一个点子树中的中位数可以主席树，对一棵子树的区间加可以在这个点上打<code>tag</code>，最后用树状数组维护，再<code>dfs</code>一遍即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from] &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to] &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[N], rk[N], sz[N], dfsn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>, dfn[u] = ++dfsn, rk[dfn[u]] = u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u), sz[u] += sz[e[i].to];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcurts</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;tcurts&gt; tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, ls, rs, sum;</span><br><span class="line">&#125; T[N * <span class="number">32</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ncnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rt = ++ncnt; T[rt].l = l, T[rt].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> rt;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    T[rt].ls = build(l, mid), T[rt].rs = build(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r; <span class="keyword">int</span> nw = ++ncnt; T[nw] = T[rt], T[nw].sum++;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> nw;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) T[nw].ls = update(T[nw].ls, pos);</span><br><span class="line">    <span class="keyword">else</span> T[nw].rs = update(T[nw].rs, pos);</span><br><span class="line">    <span class="keyword">return</span> nw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> rt1, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> left = T[T[rt1].ls].sum - T[T[rt].ls].sum;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= left) <span class="keyword">return</span> query(T[rt].ls, T[rt1].ls, k);</span><br><span class="line">    <span class="keyword">return</span> query(T[rt].rs, T[rt1].rs, k - left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N], n, RT[N], mx; LL ans[N], tree[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= mx; x += x &amp; -x) tree[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    upd(l, x), upd(r + <span class="number">1</span>, -x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">que</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= x &amp; -x) res += tree[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m[N]; LL fuck, all;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : tmp[u]) upd(t.l, t.r, t.x);</span><br><span class="line">    fuck += m[u];</span><br><span class="line">    ans[u] = que(num[u]) + all - fuck; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs1(e[i].to, u);</span><br><span class="line">    fuck -= m[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : tmp[u]) upd(t.l, t.r, -t.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]), mx = max(mx, num[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, a; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), adde(a, i);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>), RT[<span class="number">0</span>] = build(<span class="number">1</span>, mx);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) RT[i] = update(RT[i - <span class="number">1</span>], num[rk[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = query(RT[dfn[i] - <span class="number">1</span>], RT[dfn[i] + sz[i] - <span class="number">1</span>], (sz[i] + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> mid1 = sz[i] == <span class="number">1</span> ? <span class="number">1e5</span> : query(RT[dfn[i] - <span class="number">1</span>], RT[dfn[i] + sz[i] - <span class="number">1</span>], (sz[i] + <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        tmp[i].push_back((tcurts)&#123; <span class="number">1</span>, mid, mid1 &#125;), tmp[i].push_back((tcurts)&#123; mid + <span class="number">1</span>, mx, mid &#125;), m[i] = mid, all += mid;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-GCD再放送"><a href="#T2-GCD再放送" class="headerlink" title="T2 GCD再放送"></a>T2 GCD再放送</h1><p>定义一个序列$\{a_1,a_2,\cdots,a_k\}$的价值之和为其所有区间的$\gcd$之和，即</p><script type="math/tex; mode=display">\sum_{i=1}^k\sum_{j=i}^k\gcd\{a_i,\cdots, a_j\}</script><p>现在给出$n$个序列，这$n$个序列会随机地拼接成一个大的序列，求出这$n!$种拼接方式最后形成的序列的价值之和，对$10^9+7$取模</p><script type="math/tex; mode=display">n,\sum k\leq 10^5,b_i\leq 10^5</script><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>首先反演一波，单独考虑一个序列的答案</p><p>设$F(x)$为$\gcd$恰好为$x$的区间个数，$G(x)$为$\gcd$为$x$的倍数的区间个数</p><p>$G(x)$很好求，即考虑哪些数是$x$的倍数，这样这个序列就变成了一个$01$串，$1$代表这个位置的数是$x$的倍数，我们只需要统计有多少个区间全是$1$</p><script type="math/tex; mode=display">\begin{aligned}G(x)&=\sum_{x|d}F(d)\\F(x)&=\sum_{x|d}G(d)\mu(\frac dx)\\ans&=\sum_{i\geq 1}i\times F(i)\\&=\sum_{i\geq 1}i\times \sum_{i|d}G(d)\mu(\frac di)\\&=\sum_{d\geq 1}G(d)\sum_{i|d}i\times \mu(\frac di)\\&=\sum_{d\geq 1}G(d)\varphi(d)\end{aligned}</script><p>如果每个区间的长度都是$1$，那么我们可以直接考虑对于一个区间$[l,r]$，对于某个约数在多少个排列里面这个区间全是$1$</p><p>这个的方案数显然就是一个组合数再乘一个阶乘</p><p>事实上我们并不需要枚举$l$，我们只需要知道这个区间的长度就行了，即我们只需要知道这两个端点中间夹了多少个$1$</p><p>考虑更一般的情况，容易发现最后每个区间$[l,r]$的左右端点只有四种情况：</p><ul><li>左右端点落在同一段内</li><li>左右端点一个落在一个全$1$段，另一个落在某一段的前缀$1$/后缀$1$中</li><li>一个落在前缀$1$，另一个落在后缀$1$中</li><li>两个端点都落在全$1$段中</li></ul><p>枚举左右端点直接有多少个完整的全$1$段，我们可以将同一类的区间揉在一起统计</p><p>因此维护全$1$段的段数、段长之和、段长的平方之和以及前后缀段的前缀之和、后缀之和以及前缀后缀的乘积之和即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N], n, frac[N], st[N], ed[N], bel[N], inv[N], sum2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _p[N], _s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pos[d].size()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> full = <span class="number">0</span>, full1 = <span class="number">0</span>, full2 = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">0</span>, suf = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : pos[d]) _p[bel[t]] = _s[bel[t]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> add = [&amp;](<span class="keyword">int</span> len) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">        res = (res + (LL)len * (len + <span class="number">1</span>) / <span class="number">2</span> % mod * frac[n]) % mod;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> process = [&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> A = bel[a], B = bel[b], len = b - a + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (A == B) &#123;</span><br><span class="line">            add(len);</span><br><span class="line">            <span class="keyword">if</span> (a == st[A] &amp;&amp; b == ed[B]) full++, full1 += len, full2 = (full2 + (LL)len * len) % mod;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a == st[A]) _p[A] = len;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (b == ed[A]) _s[A] = len;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> l = a == st[A] ? A : A + <span class="number">1</span>, r = b == ed[B] ? B : B - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (l &lt;= r) &#123;</span><br><span class="line">                full += r - l + <span class="number">1</span>, full1 += ed[r] - st[l] + <span class="number">1</span>, full2 = ((LL)full2 + sum2[r] - sum2[l - <span class="number">1</span>] + mod) % mod;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) add(ed[i] - st[i] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a != st[A]) _s[A] = ed[A] - a + <span class="number">1</span>, add(_s[A]);</span><br><span class="line">            <span class="keyword">if</span> (b != ed[B]) _p[B] = b - st[B] + <span class="number">1</span>, add(_p[B]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos[d].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j + <span class="number">1</span> &lt; pos[d].size() &amp;&amp; pos[d][j + <span class="number">1</span>] == pos[d][j] + <span class="number">1</span>) j++;</span><br><span class="line">        process(pos[d][i], pos[d][j]), i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos[d].size(); i++) </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || bel[pos[d][i]] != bel[pos[d][i - <span class="number">1</span>]]) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = bel[pos[d][i]];</span><br><span class="line">            pre += _p[cur], suf += _s[cur], sum = (sum + (LL)_p[cur] * _s[cur]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> A = ((LL)pre * suf - sum) % mod, B = ((LL)full1 * full1 - full2) % mod;</span><br><span class="line">    A = (A + mod) % mod, B = (B + mod) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= full; i++) <span class="keyword">if</span> (n - i - <span class="number">2</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = (LL)A * C(full, i) % mod;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; full) tmp = (tmp + (LL)(pre + suf) * full1 % mod * C(full - <span class="number">1</span>, i)) % mod;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; full - <span class="number">1</span>) tmp = (tmp + (LL)B * C(full - <span class="number">2</span>, i)) % mod;</span><br><span class="line">        res = (res + (LL)tmp * frac[i] % mod * frac[n - i - <span class="number">2</span>] % mod * (n - i - <span class="number">1</span>)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> phi[N], flag[N], prime[N], pcnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N - <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag[i]) prime[++pcnt] = i, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pcnt &amp;&amp; i * prime[j] &lt;= N - <span class="number">10</span>; j++) &#123;</span><br><span class="line">            flag[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                phi[i * prime[j]] = phi[i] * prime[j]; <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            phi[i * prime[j]] = phi[i] * (prime[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> tp = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> k; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k), st[i] = tp + <span class="number">1</span>, ed[i] = tp + k;</span><br><span class="line">        <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[++tp]), bel[tp] = i, mx = max(mx, num[tp]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= num[tp]; j++) <span class="keyword">if</span> (num[tp] % j == <span class="number">0</span>) &#123;</span><br><span class="line">                pos[j].push_back(tp);</span><br><span class="line">                <span class="keyword">if</span> (j != num[tp] / j) pos[num[tp] / j].push_back(tp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = ed[i] - st[i] + <span class="number">1</span>;</span><br><span class="line">        sum2[i] = (sum2[i - <span class="number">1</span>] + (LL)len * len) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; sieve();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mx; i++) res = (res + (LL)solve(i) * phi[i]) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-dict"><a href="#T3-dict" class="headerlink" title="T3 dict"></a>T3 dict</h1><p>给定一个$1\cdots n$的排列$p_{1\cdots n}$，定义两个大小为$n$的不可重集合$A,B$的字典序比较方式为：</p><p>先比较$A$和$B$的第$p_1$小元素，较小的那个字典序较小，否则就比较第$p_2$小的元素，以此类推</p><p>现在给定$p_{1\cdots n}$和一个大小为$n$的不可重集合$B$，求有多少个值在$1\cdots m$，大小为$n$的不可重集合$A$满足$A$的字典序比$B$小，答案对$998244353$取模</p><script type="math/tex; mode=display">n,m\leq 2\times 10^5</script><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>按照比较字典序的方法，我们枚举在哪一次比较时，$A$的元素比$B$的对应元素要小</p><p>这样$A$在这一位之前的元素都必须与$B$在这一位之前的元素相同，而$A$后面的元素可以随便选</p><p>将$B$中的元素从小到大排序，假设现在比较到了第$p_i$小的元素，这就意味着$p_1,p_2,\cdots,p_{i-1}$这些位置中填的数已经确定了</p><p>假设在这些位置之中，比$p_i$小的最大的位置为$p_j$，比$p_i$大的最小的位置为$p_k$</p><p>如果$p_j$不存在，那么我们认为$p_j=0$；如果$p_k$不存在，那么我们认为$p_k=n+1$</p><p>显然在$p_j$以及$p_j$之前的位置、在$p_k$以及$p_k$之后的这些位置的方案数已经确定了，因为$p_j,p_k$这两个位置的值必须等于$B$中对应的值，在$p_i$处填的数无论如何也不会影响到这些位置</p><p>因此我们只需要考虑$(p_j,p_k)$这些位置</p><p>假设$B_{p_i}$减去$B_{p_j}$的值为$r+1$，那么$A_{p_i}$至多为$A_{p_j}+r$</p><p>假设$B_{p_k}$减去$B_{p_j}$的值是$t+1$，那么$A_{p_i}$至多为$A_{p_j}+t$</p><p>设$a$为$p_i-p_j-1$，即$p_i$左边的空位的个数，$b$为$p_k-p_i-1$，即$p_i$右边的空位的个数</p><p>那么此时这一段的方案数就是</p><script type="math/tex; mode=display">\sum_{i=1}^r{i-1\choose a}{t-i\choose b}</script><p>如果$i$能取到$t$的上界，那么这个式子就是一个简单的组合恒等式，显然它等于${m\choose a+b+1}$</p><p>然后，似乎没有什么好的优化方法</p><p>注意到一件事情，当$i-1&lt;a$或$t-i&lt;b$时显然对答案的贡献是$0$</p><p>当$r-a$比较小的时候，我们暴力枚举$i$</p><p>否则，我们考虑用$i=[1,t]$的答案减去$i=[r+1,t]$的答案</p><p>这样的复杂度是对的，因为这实际上是一个启发式分裂的过程，因此复杂度为$n\log n$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> up, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> tot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (up &lt;= <span class="number">0</span> || tot &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, A = min(tot - b, up) - a, B = tot - b - up;</span><br><span class="line">    <span class="keyword">if</span> (A &lt; B) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = a + <span class="number">1</span>; i &lt;= up &amp;&amp; tot - i &gt;= b; i++) </span><br><span class="line">            res = (res + (LL)C(i - <span class="number">1</span>, a) * C(tot - i, b)) % mod;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = C(tot, a + b + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = up + <span class="number">1</span>; tot - i &gt;= b; i++) </span><br><span class="line">            res = (res - (LL)C(i - <span class="number">1</span>, a) * C(tot - i, b)) % mod;</span><br><span class="line">        res = (res + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N], p[N], tree[N], n; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l, r, down, up, val;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> data &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> l &lt; b.l;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;data&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">    sort(num + <span class="number">1</span>, num + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i]);</span><br><span class="line">    frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, coef = <span class="number">1</span>; s.insert((data)&#123; <span class="number">1</span>, n, <span class="number">1</span>, m, <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> pos = *--s.upper_bound((data)&#123; p[i] &#125;); s.erase(pos);</span><br><span class="line">        coef = (LL)coef * Pow(pos.val, mod - <span class="number">2</span>) % mod;</span><br><span class="line">        res = (res + (LL)coef * process(num[p[i]] - pos.down, p[i] - pos.l, pos.r - p[i], pos.up - pos.down + <span class="number">1</span>)) % mod;</span><br><span class="line">        <span class="keyword">if</span> (p[i] != pos.l) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = C(num[p[i]] - pos.down, p[i] - pos.l); coef = (LL)coef * w % mod;</span><br><span class="line">            s.insert((data)&#123; pos.l, p[i] - <span class="number">1</span>, pos.down, num[p[i]] - <span class="number">1</span>, w&#125;);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (p[i] != pos.r) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = C(pos.up - num[p[i]], pos.r - p[i]); coef = (LL)coef * w % mod;</span><br><span class="line">            s.insert((data)&#123; p[i] + <span class="number">1</span>, pos.r, num[p[i]] + <span class="number">1</span>, pos.up, w &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫比乌斯反演 </tag>
            
            <tag> 启发式合并 </tag>
            
            <tag> 主席树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF582D Number of Binominal Coefficients</title>
      <link href="/2020/03/13/cf582d-number-of-binominal-coefficients/"/>
      <url>/2020/03/13/cf582d-number-of-binominal-coefficients/</url>
      
        <content type="html"><![CDATA[<p>统计有序对$(k,n)$的数量，满足$0\leq k\leq n\leq A$，且$n\choose k$能被$p^a$整除</p><script type="math/tex; mode=display">1\leq p,a\leq 10^9,0\leq A\leq 10^{1000}</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>库默尔定理：</p><p>组合数$n+m\choose m$所含$p$的次数为$n,m$在$p$进制下相加的进位次数</p><p>证明：次数为</p><script type="math/tex; mode=display">\sum_{i\geq 1}\lfloor\frac{n+m}{p_i}\rfloor-\sum_{i\geq 1}\lfloor\frac{n}{p_i}\rfloor-\sum_{i\geq 1}\lfloor\frac{m}{p_i}\rfloor\\=\sum_{i\geq 1}\lfloor\frac{n+m}{p_i}\rfloor-\lfloor\frac{n}{p_i}\rfloor-\lfloor\frac{m}{p_i}\rfloor</script><p>$\lfloor\frac{n}{p_i}\rfloor$表示$n$在$p$进制下去掉最后$i$位，如果$n+m$在第$i+1$位收到了来自第$i$位的进位，那么就意味着</p><p>$\lfloor\frac{n+m}{p_i}\rfloor-\lfloor\frac{n}{p_i}\rfloor-\lfloor\frac{m}{p_i}\rfloor=1$</p><p>因此上面的式子等价于$m+n$在$p$进制下的进位次数</p><p>有用的$a$只有$3500$左右</p><p>因此我们可以数位<code>dp</code></p><p><code>dp[i][j][1/0][1/0]</code>代表当前到了第$i$位，进位次数为$j$，当前$n+m$是否与$A$相等，下一位是否必须进位到这一位</p><p>这个题的转移非常恶心</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>, N = <span class="number">3510</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][<span class="number">2</span>][N][N], a[N], p, n, lim;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &gt;= <span class="number">2</span> * p - <span class="number">2</span>) <span class="keyword">return</span> (LL)p * p % mod;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; p) <span class="keyword">return</span> (LL)(r + <span class="number">2</span>) * (r + <span class="number">1</span>) / <span class="number">2</span> % mod;</span><br><span class="line">    <span class="keyword">return</span> ((LL)(r - p + <span class="number">1</span>) * p + (LL)(p - r + p - <span class="number">1</span>) * (r + <span class="number">2</span>) / <span class="number">2</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> get(r) - get(l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span> ? x : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> cnt, <span class="keyword">int</span> t1, <span class="keyword">int</span> t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == n + <span class="number">1</span>) <span class="keyword">return</span> t2 == <span class="number">0</span> &amp;&amp; cnt &gt;= lim;</span><br><span class="line">    <span class="keyword">if</span> (~dp[t1][t2][cur][cnt]) <span class="keyword">return</span> dp[t1][t2][cur][cnt];</span><br><span class="line">    <span class="keyword">int</span> &amp;sum = dp[t1][t2][cur][cnt]; sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t2) &#123;</span><br><span class="line">            sum = (sum + (LL)DP(cur + <span class="number">1</span>, cnt, <span class="number">1</span>, <span class="number">0</span>) * (p - <span class="number">1</span> - a[cur]) % mod + (LL)DP(cur + <span class="number">1</span>, cnt + <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * (p - a[cur])) % mod;</span><br><span class="line">            sum = (sum + (LL)DP(cur + <span class="number">1</span>, cnt, <span class="number">0</span>, <span class="number">0</span>) * get(p, p + a[cur] - <span class="number">1</span>) % mod + (LL)DP(cur + <span class="number">1</span>, cnt + <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>) * get(p - <span class="number">1</span>, p + a[cur] - <span class="number">2</span>)) % mod; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum = (sum + (LL)DP(cur + <span class="number">1</span>, cnt, <span class="number">1</span>, <span class="number">0</span>) * (a[cur] + <span class="number">1</span>) % mod + (LL)DP(cur + <span class="number">1</span>, cnt + <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * a[cur]) % mod;</span><br><span class="line">            sum = (sum + (LL)DP(cur + <span class="number">1</span>, cnt, <span class="number">0</span>, <span class="number">0</span>) * get(a[cur] - <span class="number">1</span>) % mod + (LL)DP(cur + <span class="number">1</span>, cnt + <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>) * get(a[cur] - <span class="number">2</span>)) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t2) sum = (sum + (LL)DP(cur + <span class="number">1</span>, cnt, <span class="number">0</span>, <span class="number">0</span>) * get(p, <span class="number">2</span> * p - <span class="number">2</span>) % mod + (LL)DP(cur + <span class="number">1</span>, cnt + <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>) * get(p - <span class="number">1</span>, <span class="number">2</span> * p - <span class="number">2</span>)) % mod;</span><br><span class="line">        <span class="keyword">else</span> sum = (sum + (LL)DP(cur + <span class="number">1</span>, cnt, <span class="number">0</span>, <span class="number">0</span>) * get(p - <span class="number">1</span>) % mod + (LL)DP(cur + <span class="number">1</span>, cnt + <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>) * get(p - <span class="number">2</span>)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = (sum + mod) % mod;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> t[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;p, &amp;lim, s + <span class="number">1</span>); <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (lim &gt;= <span class="number">3500</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) t[i] = s[i] - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">233</span>) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) <span class="keyword">if</span> (t[i]) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;</span><br><span class="line">        LL nw = <span class="number">0</span>; <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            nw = nw * <span class="number">10</span> + t[i];</span><br><span class="line">            <span class="keyword">if</span> (!l &amp;&amp; nw &gt;= p) tmp[++l] = nw / p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (l) tmp[++l] = nw / p;</span><br><span class="line">            nw %= p;</span><br><span class="line">        &#125;</span><br><span class="line">        a[++n] = nw;</span><br><span class="line">        len = l, <span class="built_in">memcpy</span>(t, tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (l + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, DP(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 数位 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF521E Cycling City</title>
      <link href="/2020/03/13/cf521e-cycling-city/"/>
      <url>/2020/03/13/cf521e-cycling-city/</url>
      
        <content type="html"><![CDATA[<p>给出一张$n$个点$m$条边的无向图，求图中是否存在两个点，满足这两个点之间至少有三条除起点、终点外不共点的简单路径</p><p>如果不存在，输出<code>NO</code>，否则需要输出任意一种方案</p><script type="math/tex; mode=display">n\leq 2\times 10^5</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先建出原图的任意一棵生成树，考虑以下三种情况</p><p><img src="1584107840916.png" alt=""></p><p>我们可以发现，如果存在一条树边被至少两条非树边覆盖，那么就一定是<code>YES</code></p><p>可以用树上差分找到两条相交的路径，然后这两条路径的交一定满足条件</p><p>只需要<code>dfs</code>出这三条路径即可，注意只能走树边以及选出的两条边</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> from, to, next;&#125; e[N * <span class="number">20</span>], e2[N * <span class="number">10</span>];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt, vis[N], fa[N][<span class="number">18</span>], dep[N], ok[N * <span class="number">10</span>], ecnt2; <span class="built_in">map</span>&lt;P, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fir, sec; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = f, dep[u] = dep[f] + <span class="number">1</span>, vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">17</span>; i++) fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">        adde(v, u); <span class="keyword">int</span> a = v, b = u; <span class="keyword">if</span> (a &gt; b) swap(a, b);</span><br><span class="line">        ok[mp[P(a, b)]] = <span class="number">1</span>, dfs(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[a] &lt; dep[b]) swap(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (dep[fa[a][i]] &gt;= dep[b]) a = fa[a][i];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i];</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; add[N], del[N], fuck[N]; <span class="keyword">bool</span> flg;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lca = LCA(a, b);</span><br><span class="line">    add[a].insert(id), add[b].insert(id), del[lca].insert(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i &amp;&amp; !flg; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs2(e[i].to, u);</span><br><span class="line">    <span class="keyword">if</span> (flg) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : add[u]) fuck[u].insert(v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f &amp;&amp; fuck[e[i].to].size()) fuck[u].insert(*fuck[e[i].to].begin());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : del[u]) fuck[u].erase(v);</span><br><span class="line">    <span class="keyword">if</span> (fuck[u].size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        fir = *fuck[u].begin(), fuck[u].erase(fuck[u].begin()), sec = *fuck[u].begin();</span><br><span class="line">        flg = <span class="literal">true</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp[N], to, stk[N], top, hh, tmp2[N * <span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == to) &#123;</span><br><span class="line">        hh = <span class="number">1</span>, <span class="built_in">printf</span>(<span class="string">"%d "</span>, top);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= top; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, stk[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>); <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) <span class="keyword">if</span> (!tmp[v]) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = u, b = v; <span class="keyword">if</span> (a &gt; b) swap(a, b); <span class="keyword">int</span> t = mp[P(a, b)];</span><br><span class="line">        <span class="keyword">if</span> (tmp2[t]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!ok[t] &amp;&amp; t != fir &amp;&amp; t != sec) <span class="keyword">continue</span>;</span><br><span class="line">        tmp2[t] = <span class="number">1</span>, stk[++top] = v, dfs3(v), top--;</span><br><span class="line">        <span class="keyword">if</span> (hh) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> b1, <span class="keyword">int</span> b2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> p[<span class="number">5</span>];</span><br><span class="line">    p[<span class="number">1</span>] = LCA(a1, b1), p[<span class="number">2</span>] = LCA(a1, b2), p[<span class="number">3</span>] = LCA(a2, b1), p[<span class="number">4</span>] = LCA(a2, b2);</span><br><span class="line">    sort(p + <span class="number">1</span>, p + <span class="number">5</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> dep[a] &gt; dep[b];&#125;);</span><br><span class="line">    <span class="keyword">int</span> A = p[<span class="number">1</span>], B = p[<span class="number">2</span>];</span><br><span class="line">    hh = <span class="number">0</span>, to = B, stk[top = <span class="number">1</span>] = A, dfs3(A), hh = <span class="number">0</span>, top = <span class="number">1</span>, dfs3(A), hh = <span class="number">0</span>, top = <span class="number">1</span>, dfs3(A);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b); <span class="keyword">if</span> (a &gt; b) swap(a, b);</span><br><span class="line">        G[a].push_back(b), G[b].push_back(a), e2[++ecnt2] = (edge)&#123;a, b, <span class="number">0</span>&#125;, mp[P(a, b)] = ecnt2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (!vis[i]) dfs(i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ecnt2; i++) <span class="keyword">if</span> (!ok[i]) mark(e2[i].from, e2[i].to, i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (!fa[i][<span class="number">0</span>]) &#123;</span><br><span class="line">        dfs2(i, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (flg) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"YES"</span>), work(e2[fir].from, e2[fir].to, e2[sec].from, e2[sec].to);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>析合树</title>
      <link href="/2020/03/13/xi-he-shu/"/>
      <url>/2020/03/13/xi-he-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="连续段"><a href="#连续段" class="headerlink" title="连续段"></a>连续段</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>对于排列$P$，如果对于一段区间$[l,r]$，满足$P_{l\sim r}$是连续的，那么我们将区间$[l,r]$称为连续段</p><p>形式化地来讲， 如果$[l,r]$是连续段，那么不存在 $x &lt; l$ 或 $x &gt; r$，使得存在$l&lt;a&lt;r,l&lt;b&lt;r$，满足$P_a &lt; P_x &lt; P_b$</p><p>比如对于排列<code>1 3 2 4 5</code>，<code>2 4 5</code>不是连续段，因为其值域不连续；而<code>3 2 4 5</code>是一个连续段</p><p>我们将排列$P$的所有连续段构成的集合记为$I_P$</p><a id="more"></a><h2 id="连续段的性质"><a href="#连续段的性质" class="headerlink" title="连续段的性质"></a>连续段的性质</h2><p>对于两个相交的区间$A,B$，如果$A,B$均为连续段，那么</p><ul><li>$A\cap B$是连续段</li></ul><p>若存在$x\not \in A\cap B$使得存在$a\in A\cap B,b\in A\cap B$使得$P_a&lt;P_x&lt;P_b$，那么无论$x$落在哪个区域都会导致$A,B$至少一个区间不再是连续段，与假设矛盾</p><ul><li>$A\cup B$是连续段</li></ul><p>$A$值域连续，$B$值域连续，显然$A\cup B$值域连续</p><ul><li>$A\setminus B,B\setminus A$是连续段</li></ul><p>$A\cap B$的值域就是$A,B$的值域相交的部分，因为$A\cap B$是连续段，故$A\setminus B,B\setminus A$也是连续段</p><h1 id="析合树"><a href="#析合树" class="headerlink" title="析合树"></a>析合树</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><h3 id="本原连续段"><a href="#本原连续段" class="headerlink" title="本原连续段"></a>本原连续段</h3><p>对于排列$P$，如果$A\in I_P$，且不存在$B\in I_P,B\not= A$使得$A,B$不存在包含关系但是相交，那么我们称$A$是$P$的一个<strong>本原连续段</strong></p><p>例如在排列<code>1 2 3 4</code>中，<code>2 3</code>就不是本原连续段，因为<code>1 2</code>与它相交但是互不包含</p><p>显然每个长度为$1$的区间都是本原连续段</p><p>根据本原连续段的定义，任意两个本原连续段间只能存在包含或相离关系，即它们形成了一棵树状的结构，我们将这个树状结构称为析合树</p><h3 id="析点与合点"><a href="#析点与合点" class="headerlink" title="析点与合点"></a>析点与合点</h3><p>析合树上的每一个点都是一个本原连续段，并且有析点和合点之分</p><p>考虑对于排列<code>9 1 10 3 2 5 7 6 8 4</code>建出析合树</p><p><img src="1584107146871.png" alt=""></p><p>图中蓝色代表合点，橙色代表析点</p><p>对于析合树上的一个点，我们将它的所有儿子按照在排列中的下标排好</p><p>那么对于合点，<strong>完整包含其儿子的任意一个子串都是连续段</strong></p><p>比如，对于图中$[5,8]$这个节点，它有$3$个儿子$[5,5],[6,7],[8,8]$</p><p>那么$[5,7],[6,8]$也是连续段</p><p>也就是它的所有儿子是按照值域排好的，要么从大到小，要么从小到大</p><p>与合点相对的是析点，<strong>它的任意一个完整包含其儿子的子串都不是连续段</strong></p><p>比如，对于$[1,10]$这个节点，它的儿子是$[9,9],[1,1],[10,10],[2,8]$</p><p>显然$[9,9]\cup[1,1]$不是连续段，$[10,10],[2,8]$同理</p><p>合点的性质很好证明，下面来证明析点的性质</p><p>我们考虑一个析点的所有儿子</p><p>如果存在它儿子序列的一个子区间，使得这个区间也是连续段，我们考虑满足这种条件的最大区间</p><p>由于它是最大的，因此找不到另一个与它相交，但不包含的区间</p><p>也就是说，这一段区间也是一个本原连续段，我们应该为它新建一个节点，与析合树的定义矛盾</p><p>析合树的另一个性质是：合点至少有$2$个儿子，而析点至少有$4$个儿子</p><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>考虑使用增量法构造析合树，即先构造出前$i-1$个点的析合森林，然后再加入第$i$个点</p><p>构造其实很简单，大致分为四步</p><ol><li>如果最后一个点是合点，并且当前点能合并到合点中，那么就合并，并且将合并之后的点作为当前点</li><li>否则，如果上一个点与当前点能够合并，那么我们新建一个合点，将上一个点与这一个点作为它的两个儿子</li><li>否则，向前找到最后一个点，使得这个点到当前点中间的所有点能构成连续段，新建一个析点，并将这些点作为它的儿子。可以证明一定存在这样一个点</li><li>重复以上操作直到不能合并为止，即最后一个点的左端点小于$i$作为右端点的所有连续段中，最靠左的左端点</li></ol><p>那么问题来了，如何判断一个区间是否是连续段</p><p>一个区间是连续段当且仅当这个区间的值域连续，也就是</p><script type="math/tex; mode=display">\max_{i=l}^ra_i-\min_{i=l}^ra_i=r-l</script><p>因此使用<code>RMQ</code>即可$O(1)$判断一个区间是否是连续段</p><p>第二个问题是，如何找到所有右端点是$i$的连续段的最靠左的左端点呢</p><p>由于$P$是一个排列，因此对于$P$的任意一个区间，都有</p><script type="math/tex; mode=display">\max_{i=l}^ra_i-\min_{i=l}^ra_i\geq r-l\\\max_{i=l}^ra_i-\min_{i=l}^ra_i-r+l\geq 0</script><p>故我们可以用线段树维护上式的最小值，然后找到第一个为$0$的位置即可</p><p>考虑加入$i$时会对区间造成哪些影响</p><p>首先，所有区间的$r$会$+1$，即区间减</p><p>然后我们使用单调栈维护$\min,\max$，每次弹栈的时候栈中相邻两个元素之间的区间的$\min/\max$一定是相同的，我们可以先将其减去其原来的值，最后再加上$a_i$</p><p>代码如下（对应<code>CF526F Pudding Monsters</code>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RMQ</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> lg[N], mn[<span class="number">19</span>][N], mx[<span class="number">19</span>][N];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) mn[<span class="number">0</span>][i] = mx[<span class="number">0</span>][i] = a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">18</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= n; j++) &#123;</span><br><span class="line">                mn[i][j] = min(mn[i - <span class="number">1</span>][j], mn[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)]);</span><br><span class="line">                mx[i][j] = max(mx[i - <span class="number">1</span>][j], mx[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)]);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = lg[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> min(mn[len][l], mn[len][r - (<span class="number">1</span> &lt;&lt; len) + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = lg[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> max(mx[len][l], mx[len][r - (<span class="number">1</span> &lt;&lt; len) + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; D;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SEG</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> l, r, mn, mx, tag;</span><br><span class="line">    &#125; T[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">        T[rt].mn = min(T[rt &lt;&lt; <span class="number">1</span>].mn, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mn);</span><br><span class="line">        T[rt].mx = max(T[rt &lt;&lt; <span class="number">1</span>].mx, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">        T[rt &lt;&lt; <span class="number">1</span>].mn += T[rt].tag, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mn += T[rt].tag;</span><br><span class="line">        T[rt &lt;&lt; <span class="number">1</span>].mx += T[rt].tag, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mx += T[rt].tag;</span><br><span class="line">        T[rt &lt;&lt; <span class="number">1</span>].tag += T[rt].tag, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].tag += T[rt].tag, T[rt].tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        T[rt].l = l, T[rt].r = r; </span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(rt &lt;&lt; <span class="number">1</span>, l, mid), build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) &#123;</span><br><span class="line">            T[rt].tag += x, T[rt].mn += x, T[rt].mx += x;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T[rt].tag) pushdown(rt);</span><br><span class="line">        <span class="keyword">if</span> (start &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, start, end, x);</span><br><span class="line">        <span class="keyword">if</span> (end &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, start, end, x);</span><br><span class="line">        pushup(rt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = T[rt].l, r = T[rt].r;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">if</span> (T[rt].tag) pushdown(rt);</span><br><span class="line">        <span class="keyword">if</span> (!T[rt &lt;&lt; <span class="number">1</span>].mn) <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Judge</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> D.Max(l, r) - D.Min(l, r) == r - l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stk1[N], stk2[N], tp1, tp2;</span><br><span class="line"><span class="keyword">int</span> stk[N], tp, L[N * <span class="number">2</span>], R[N * <span class="number">2</span>], M[N * <span class="number">2</span>], ncnt, type[N * <span class="number">2</span>], ch[N * <span class="number">2</span>];</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * L, R: 该连续段在排列中对应的下标</span></span><br><span class="line"><span class="comment"> * type: 1代表该点为合点，否则为析点</span></span><br><span class="line"><span class="comment"> * ch: 该点的儿子数量</span></span><br><span class="line"><span class="comment"> * stk1, stk2: 区间min, max的单调栈</span></span><br><span class="line"><span class="comment"> * M: 合点的最后一个儿子的左端点，用于判断是否能够合并</span></span><br><span class="line"><span class="comment"> * stk: 当前析合森林中所有的根</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (tp1 &amp;&amp; a[i] &lt;= a[stk1[tp1]]) </span><br><span class="line">            T.update(<span class="number">1</span>, stk1[tp1 - <span class="number">1</span>] + <span class="number">1</span>, stk1[tp1], a[stk1[tp1]]), tp1--;</span><br><span class="line">        <span class="keyword">while</span> (tp2 &amp;&amp; a[i] &gt;= a[stk2[tp2]]) </span><br><span class="line">            T.update(<span class="number">1</span>, stk2[tp2 - <span class="number">1</span>] + <span class="number">1</span>, stk2[tp2], -a[stk2[tp2]]), tp2--;</span><br><span class="line">        T.update(<span class="number">1</span>, stk1[tp1] + <span class="number">1</span>, i, -a[i]), T.update(<span class="number">1</span>, stk2[tp2] + <span class="number">1</span>, i, a[i]);</span><br><span class="line">        stk1[++tp1] = i, stk2[++tp2] = i;</span><br><span class="line">        <span class="keyword">int</span> nw = ++ncnt, Li = T.query(<span class="number">1</span>); L[nw] = R[nw] = i;</span><br><span class="line">        <span class="keyword">while</span> (tp &amp;&amp; L[stk[tp]] &gt;= Li) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type[stk[tp]] &amp;&amp; Judge(M[stk[tp]], i)) &#123;</span><br><span class="line">                R[stk[tp]] = i, ch[stk[tp]]++, nw = stk[tp--];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Judge(L[stk[tp]], i)) &#123;</span><br><span class="line">                ncnt++, type[ncnt] = <span class="number">1</span>, ch[ncnt] = <span class="number">2</span>;</span><br><span class="line">                L[ncnt] = L[stk[tp]], R[ncnt] = i, M[ncnt] = L[nw], tp--, nw = ncnt;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ncnt++, ch[ncnt] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    ch[ncnt]++, tp--;</span><br><span class="line">                &#125; <span class="keyword">while</span> (tp &amp;&amp; !Judge(L[stk[tp]], i));</span><br><span class="line">                L[ncnt] = L[stk[tp]], R[ncnt] = i, tp--, nw = ncnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++tp] = nw, T.update(<span class="number">1</span>, <span class="number">1</span>, i, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[N], y[N], id[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x[i], &amp;y[i]), id[i] = i;</span><br><span class="line">    sort(id + <span class="number">1</span>, id + n + <span class="number">1</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">        <span class="keyword">return</span> x[a] &lt; x[b];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = y[id[i]];</span><br><span class="line">    D.build(), T.build(<span class="number">1</span>, <span class="number">1</span>, n), build();</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ncnt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type[i]) res += (LL)ch[i] * (ch[i] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 析合树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF583E Superior Periodic Subarrays</title>
      <link href="/2020/03/13/cf583e-superior-periodic-subarrays/"/>
      <url>/2020/03/13/cf583e-superior-periodic-subarrays/</url>
      
        <content type="html"><![CDATA[<p>给出一个无限长的循环序列$a_0,a_1,\cdots,a_{n-1},\cdots$，循环节是$n$，即$a_i= a_{i\mod n}$</p><p>现在你要统计数对$(l,s)$的数量，满足$0\leq l&lt;n,1\leq s&lt;n$，且以$l$开头，循环节为$s$的无限序列的每一个元素都比原序列中它对应位置的那个数要大</p><p><img src="https://cdn.luogu.com.cn/upload/vjudge_pic/CF582C/3459142ae634f6d125367238083d1b99f717b1ba.png" alt=""></p><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>假如我们已经确定好了$l,s$，那么如何判断构造好的序列是否满足题意中的条件呢</p><p>取$s,n$的$\gcd=g$，显然$a_l$会与$a_{l},a_{l+g},a_{l+2g},\cdots$比较，即$a_l$必须是这些数中最大的哪个数</p><p>我们将$a_0\cdots a_n$按照下标$\mod g$的情况分类，那么选出的数必须要是它所在的那一类中最大的数</p><p>这启发我们枚举$g$，然后将原序列复制一份并且拼在其后面，将所有满足这个位置上的数是它所在类中的最大数的位置标成$1$，其余位置标成$0$，那么一个序列$l,s$需要满足$l$到$l+s-1$这些位置全部为$1$</p><p>然后就很简单了，我们从后向前枚举，同时处理出当前位置出发的极长$1$序列的长度，$s$的方案数只与$g$以及这个长度有关，可以预处理出来</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N], g[N], t[N], mx[N], len[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) g[i] = gcd(i, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) t[j] = t[j - <span class="number">1</span>] + (g[j] == i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) mx[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) mx[j % i] = max(mx[j % i], num[j]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[j % n] == mx[j % i]) len[j] = len[j + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> len[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) </span><br><span class="line">            res += t[min(n - <span class="number">1</span>, len[j])];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF568C New Language</title>
      <link href="/2020/03/13/cf568c-new-language/"/>
      <url>/2020/03/13/cf568c-new-language/</url>
      
        <content type="html"><![CDATA[<p>有一个长度为$n$的单词，每个字母要么是元音，要么是辅音。有$m$条规则，每条规则形如“如果$a$的字母类型为$t_1$，则$b$的字母类型为$t_2$”</p><p>你需要找到满足这$m$条限制的一个长度为$n$的单词，这个单词的字典序不能小于$s$</p><p>如果有多个单词满足条件，输出字典序最小的那个</p><script type="math/tex; mode=display">n\leq 200,m\leq 4n(n-1)</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>在<code>2SAT</code>中，如果$u$向$v$连了一条边，那么就意味着，如果$u$成立，那么$v$也成立</p><p>我们将每个字母拆成两个点，第一个点代表这个字母为元音，第二个点代表这个字母为辅音。我们将这两个点称为“对立点”</p><p>然后，对于题面中的每一条规则，假设这条规则是“如果$a$是元音，则$b$是辅音”</p><p>那么我们这样连边：从$a$的元音节点向$b$的辅音节点连边，从$b$的元音节点向$a$的辅音节点连边</p><p>前者的原因显然，后者成立的原因是如果原命题成立，那么它的逆否命题也成立</p><p>然后我们在建出的图上跑强连通分量，如果最后存在一个点，使得它与它的对立点在同一个强连通分量中，那么这个<code>2SAT</code>就无解。因为原命题和它的反命题不可能同时成立</p><p>回到这道题，我们从后到前枚举答案与$s$的$lcp$，然后判断后面的字母能否满足条件，遇到第一个满足条件的位置就<code>break</code></p><p>然后我们再从前到后依次贪心地确定每一位即可</p><p>由于这个题中规则的数量巨大，因此每一次暴力跑会T飞，在一开始的时候就将所有规则构成的强连通分量预处理出来，然后每次在这个强连通分量的基础上加边即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">410</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * N * <span class="number">2</span>], e2[N * N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt, vis[N], stk[N], top, dfn[N], low[N], dfsn, head2[N], ecnt2;</span><br><span class="line"><span class="keyword">int</span> scc, belong[N], Belong[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    from = Belong[from], to = Belong[to];</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde2</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e2[++ecnt2] = (edge)&#123;to, head2[from]&#125;, head2[from] = ecnt2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> ls)</span> </span>&#123;</span><br><span class="line">    stk[++top] = u, vis[u] = <span class="number">1</span>;</span><br><span class="line">    dfn[u] = low[u] = ++dfsn;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (i != ls) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[e[i].to]) Tarjan(e[i].to, i), low[u] = min(low[u], low[e[i].to]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (vis[e[i].to]) low[u] = min(low[u], dfn[e[i].to]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (low[u] == dfn[u]) &#123;</span><br><span class="line">        scc++; <span class="keyword">int</span> v = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (v != u) &#123;</span><br><span class="line">            v = stk[top--];</span><br><span class="line">            belong[v] = scc, vis[v] = <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Clear</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    fill(head + <span class="number">1</span>, head + n + <span class="number">1</span>, <span class="number">0</span>), fill(dfn + <span class="number">1</span>, dfn + n + <span class="number">1</span>, <span class="number">0</span>), scc = ecnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Just_DOIT</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    assert((n &amp; <span class="number">1</span>) ^ <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (!dfn[Belong[i]]) Tarjan(Belong[i], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; i++) </span><br><span class="line">        <span class="keyword">if</span> (belong[Belong[i]] == belong[Belong[i + n / <span class="number">2</span>]]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ID</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t * n + x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    adde(ID(t ^ <span class="number">1</span>, x), ID(t, x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> t1, <span class="keyword">int</span> t2, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    adde(ID(t1, x), ID(t2, y)), adde(ID(t2 ^ <span class="number">1</span>, y), ID(t1 ^ <span class="number">1</span>, x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nxt[<span class="number">30</span>][<span class="number">2</span>], vowel[<span class="number">30</span>]; <span class="keyword">char</span> s[N], t[N];</span><br><span class="line"><span class="keyword">int</span> T1[N * N], T2[N * N], from[N * N], to[N * N], m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">    Clear(n * <span class="number">2</span>);</span><br><span class="line">    ecnt = ecnt2, <span class="built_in">memcpy</span>(e, e2, <span class="keyword">sizeof</span>(edge) * (ecnt2 + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++) head[i] = head2[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cur; i++) mark(vowel[t[i] - <span class="string">'a'</span>], i);</span><br><span class="line">    <span class="keyword">return</span> Just_DOIT(n * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str + <span class="number">1</span>); <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> cur[<span class="number">2</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        nxt[i][<span class="number">0</span>] = cur[<span class="number">0</span>], nxt[i][<span class="number">1</span>] = cur[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (i) cur[str[i] == <span class="string">'V'</span>] = i - <span class="number">1</span>, vowel[i - <span class="number">1</span>] = str[i] == <span class="string">'V'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++) Belong[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1, c2; <span class="built_in">scanf</span>(<span class="string">"%d %c %d %c"</span>, &amp;from[i], &amp;c1, &amp;to[i], &amp;c2);</span><br><span class="line">        T1[i] = c1 == <span class="string">'V'</span>, T2[i] = c2 == <span class="string">'V'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) mark(T1[i], T2[i], from[i], to[i]);</span><br><span class="line">    <span class="keyword">if</span> (!Just_DOIT(n * <span class="number">2</span>)) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++) Belong[i] = belong[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head[i]; j; j = e[j].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = belong[i], b = belong[e[j].to];</span><br><span class="line">            <span class="keyword">if</span> (a != b) adde2(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>); </span><br><span class="line"><span class="comment">//    cout &lt;&lt; nxt[0][0] &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) t[j] = s[j];</span><br><span class="line">        <span class="keyword">if</span> (i != n) t[i + <span class="number">1</span>] = nxt[s[i + <span class="number">1</span>] - <span class="string">'a'</span> + <span class="number">1</span>][<span class="number">0</span>] + <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (t[i + <span class="number">1</span>] != <span class="string">'a'</span> - <span class="number">1</span> &amp;&amp; check(min(n, i + <span class="number">1</span>))) &#123;</span><br><span class="line">            pos = i; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i != n) t[i + <span class="number">1</span>] = nxt[s[i + <span class="number">1</span>] - <span class="string">'a'</span> + <span class="number">1</span>][<span class="number">1</span>] + <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (i != n &amp;&amp; t[i + <span class="number">1</span>] != <span class="string">'a'</span> - <span class="number">1</span> &amp;&amp; check(min(n, i + <span class="number">1</span>))) &#123;</span><br><span class="line">            pos = i; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!~pos) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pos; i++) t[i] = s[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pos + <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> a = i == pos + <span class="number">1</span> ? nxt[s[i] - <span class="string">'a'</span> + <span class="number">1</span>][<span class="number">0</span>] : nxt[<span class="number">0</span>][<span class="number">0</span>], b = i == pos + <span class="number">1</span> ? nxt[s[i] - <span class="string">'a'</span> + <span class="number">1</span>][<span class="number">1</span>] : nxt[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        a += <span class="string">'a'</span>, b += <span class="string">'a'</span>; </span><br><span class="line">        <span class="keyword">if</span> (a == <span class="string">'a'</span> - <span class="number">1</span>) a = <span class="string">'z'</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="string">'a'</span> - <span class="number">1</span>) b = <span class="string">'z'</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) swap(a, b);</span><br><span class="line">        t[i] = a;</span><br><span class="line">        <span class="keyword">if</span> (t[i] != <span class="string">'z'</span> + <span class="number">1</span> &amp;&amp; check(i)) <span class="keyword">continue</span>;</span><br><span class="line">        t[i] = b;</span><br><span class="line">        <span class="keyword">if</span> (t[i] &lt; <span class="string">'a'</span> || t[i] &gt; <span class="string">'z'</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">putchar</span>(t[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 2-SAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF585E Present for Vitalik the Philatelist</title>
      <link href="/2020/03/13/cf585e-present-for-vitalik-the-philatelist/"/>
      <url>/2020/03/13/cf585e-present-for-vitalik-the-philatelist/</url>
      
        <content type="html"><![CDATA[<p>给出一个长度为$n$的序列$A$，你需要统计<code>pair</code>$(X,S)$的数量</p><p>其中$X$是$A$中的一个数，$S$是$A$的一个子集，且$A$不属于$S$</p><p>要求$\gcd\{S\}\neq 1,\gcd\{X,S\}=1$</p><p>统计所有满足条件的<code>pair</code>的数量，对$10^9+7$取模</p><script type="math/tex; mode=display">n\leq 5\times 10^5,a_i\leq 10^7</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>设$F(x)$表示$S$的$\gcd$是$x$的倍数，且$X$不是$x$的倍数的<code>pair</code>的数量</p><p>$G(x)$表示$S$的$\gcd$恰好是$x$，且$X$不是$x$的倍数的<code>pair</code>的数量</p><p>那么$F,G$满足</p><script type="math/tex; mode=display">F(x)=\sum_{x|d}G(d)\\G(x)=\sum_{x|d}F(d)\mu(\frac{d}{x})</script><p>假设序列中$x$的倍数有$b_x$个</p><p>那么$F(x)=(2^{b_x}-1)(n-b_x)$</p><p>最后的答案就是</p><script type="math/tex; mode=display">\sum_{x\geq 2}G(x)=\sum_{x\geq 2}\sum_{x|d}F(d)\mu(\frac{d}{x})\\=\sum_{d\geq2}F(d)\sum_{x|d,x\geq 1}\mu(\frac{d}{x})\\=-\sum_{d\geq 2}F(d)\mu(d)</script><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buk[N], mu[N], flag[N], prime[N], pcnt, Pow2[<span class="number">500010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N - <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag[i]) prime[++pcnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pcnt &amp;&amp; i * prime[j] &lt;= N - <span class="number">10</span>; j++) &#123;</span><br><span class="line">            flag[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            mu[i * prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, mx = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), sieve();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), buk[a]++, mx = max(mx, a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= mx; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span>; j &lt;= mx; j += i) buk[i] += buk[j];</span><br><span class="line">    Pow2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) Pow2[i] = Pow2[i - <span class="number">1</span>] * <span class="number">2</span> % mod;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= mx; i++) &#123;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; buk[i] &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">int</span> t = (LL)(Pow2[buk[i]] - <span class="number">1</span>) * (n - buk[i]) % mod;</span><br><span class="line">        res = (res - mu[i] * t) % mod;</span><br><span class="line">    &#125;  </span><br><span class="line">    res = (res + mod) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 莫比乌斯反演 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF521D Shop</title>
      <link href="/2020/03/12/cf521d-shop/"/>
      <url>/2020/03/12/cf521d-shop/</url>
      
        <content type="html"><![CDATA[<p>给出$n$个数以及$m$个操作，有$3$种操作：</p><ul><li>将$x_i$改为$a_i$</li><li>将$x_i$加上$a_i$</li><li>将$x_i$乘上$a_i$</li></ul><p>第$i$个操作的编号为$i$，你可以从中选出最多$k$个操作并决定操作顺序，要使得$\prod x_i$最大</p><p>要求输出方案</p><script type="math/tex; mode=display">n,k,m\leq 10^5</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>假设我们已经确定好了要选哪些操作，现在要为这些操作决定顺序</p><p>那么显然操作$1$应该在操作$2$之前，操作$2$应该在操作$3$之前</p><p>同时，我们注意到，如果我们单独考虑一个操作$3$，那么这个操作无论作用于哪个数，最终的答案都是不变的</p><p>这启发我们将前两种操作也转换成操作$3$的形式</p><p>首先，$2$操作是可以被转化成$3$操作的</p><p>假设$2$操作之前这个数是$x$，操作之后变成了$x+a$，那么我们可以将它看作一次$a=\frac{x+a}{x}$的操作$3$</p><p>显然对于同一个数，如果有两个$2$操作，我们会选择$a_i$更大的那一个执行</p><p>因此对于所有$2$操作我们将其按照加的数排序，如果有一个$2$操作在最终方案中被选了，那么所有对$x_i$进行操作，并且加的数比当前操作大的那些操作在最终方案中都会被选</p><p>因此实际上，对于每一个$2$操作，它对所有数乘积的贡献已经确定好了</p><p>具体来说，我们将所有$2$操作按照加的数从大到小排序，同时维护每个数当前经过之前的操作之后变成了多少</p><p>假如此时这个数变成了$x’$，那么选当前操作对答案的贡献就是$\frac{x’+a_i}{x’}$，同时$x’+=a_i$</p><p>然后我们将转换后的$2$操作与$3$操作合在一起排序就可以了</p><p>现在考虑操作$1$</p><p>如果对于同一个数，多次进行操作$1$是没用的，我们只会选$a_i$最大的那一个执行</p><p>这里先说一个结论：<strong>所有操作$2$可以看作$a_i$为$a_i-x_i$</strong>的操作$2$</p><p>如果在最终排序中，这个操作排在所有操作$2$之前，显然没有问题</p><p>否则，可以注意到，所有选出的操作$2$的先后顺序是没有关系的。也就是说，即使我们是按照$a_i$从大到小排序，最后所有的操作$2$之间仍然是可以互换的，而答案显然不变</p><p>因此如果在最优方案中，我们选择了这个操作$1$，我们完全可以将它挪到最前面操作，就可以保证它恰好加上了$a_i-x_i$</p><p>需要注意的一个小细节是，如果当前乘的数$&lt;1$了，那么显然不操作更优秀</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    LL a, b; <span class="keyword">int</span> type, id;</span><br><span class="line">&#125; q[N * <span class="number">3</span>], q2[N * <span class="number">3</span>], q3[N * <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> type[N], x[N], y[N];</span><br><span class="line">LL a[N]; <span class="keyword">int</span> b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k, n, m, tot = <span class="number">0</span>, tot2 = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;type[i], &amp;x[i], &amp;y[i]);</span><br><span class="line">        <span class="keyword">if</span> (type[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (y[i] &gt; y[b[x[i]]]) b[x[i]] = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type[i] == <span class="number">2</span>) &#123;</span><br><span class="line">            q2[++tot2] = (node)&#123;y[i], x[i], <span class="number">2</span>, i&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> q[++tot] = (node)&#123;y[i], <span class="number">1</span>, <span class="number">3</span>, i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (b[i])</span><br><span class="line">        q2[++tot2] = (node)&#123;y[b[i]] - a[i], i, <span class="number">1</span>, b[i]&#125;;</span><br><span class="line">    sort(q2 + <span class="number">1</span>, q2 + tot2 + <span class="number">1</span>, [](node a, node b)&#123;<span class="keyword">return</span> a.a &gt; b.a;&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot2; i++) &#123;</span><br><span class="line">        q[++tot] = (node)&#123;q2[i].a + a[q2[i].b], a[q2[i].b], q2[i].type, q2[i].id&#125;;</span><br><span class="line">        a[q2[i].b] += q2[i].a;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q + <span class="number">1</span>, q + tot + <span class="number">1</span>, [](node a, node b)&#123;<span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">double</span>)a.a / a.b &gt; (<span class="keyword">long</span> <span class="keyword">double</span>)b.a / b.b;&#125;);</span><br><span class="line">    k = min(k, tot);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i].a &lt;= q[i].b) &#123;</span><br><span class="line">            k = i - <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q3[i] = q[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, k);</span><br><span class="line">    sort(q3 + <span class="number">1</span>, q3 + k + <span class="number">1</span>, [](node a, node b)&#123;<span class="keyword">return</span> a.type &lt; b.type;&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, q3[i].id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF708E Student&#39;s Camp</title>
      <link href="/2020/03/12/cf708e-students-camp/"/>
      <url>/2020/03/12/cf708e-students-camp/</url>
      
        <content type="html"><![CDATA[<p>有一堆长为$m$，高为$n-2$的砖块</p><p>每个白天，从海边会吹来一阵风，除了最上面以及最下面的两行，其余每行最左边的砖块都各自有$p=\frac ab$的概率会被吹走</p><p>每个晚上，有另一阵风会吹向海边，除了最上面以及最下面的两行，其余每行最右边的砖块也各自有$p$的概率会被吹走</p><p>一共有$k$天，求$k$天之后第一行与最后一行仍然连通的概率，对$10^9+7$取模</p><script type="math/tex; mode=display">n,m\leq 1500, a, b\leq 10^9, k\leq 10^5</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>显然每行最后剩下的砖块一定是一段连续的区间</p><p>设$p_i={k\choose i}p^i(1-p)^{k-i}$，那么一行最后剩下$[l,r]$的概率为$p_{l-1}\times p_{m-r}$，我们记这个概率为$p_{l,r}$</p><p>设$f_{i,l,r}$表示考虑了前$i+1$行，其中第$i$行最后剩下的砖块为$[l,r]$的概率</p><p>那么显然有</p><script type="math/tex; mode=display">f_{i,l,r}=p_{l,r}\sum_{[l',r']\cap[l,r]\neq \emptyset}f_{i-1,l',r'}</script><p>接着设$fr_{i,r}$表示第$i$行所有右端点等于$r$的$f_{i,l,r}$之和，设$fl_{i,l}$表示第$i$行所有左端点等于$l$的$f_{i,l,r}$之和</p><p>类似地，设$sr_{i,r}$表示第$i$行所有右端点小于等于$r$的$f_{i,l,r}$之和，$sl_{i,l}$表示第$i$行所有左端点大于等于$l$的$f_{i,l,r}$之和</p><p>那么可以将$f$的转移改写为</p><script type="math/tex; mode=display">f_{i,l,r}=p_{l,r}\times (sr_{i-1,m}-sr_{i-1,l-1}-sl_{i-1,r+1})</script><p>即，所有区间的和减去右端点在$l$左边的，再减去左端点在$r$右边的</p><p>然后有一个神奇的转化，注意到左右是完全对称的，即所有右端点$\leq i$的区间之和等于左端点$\geq m-i+1$的区间之和</p><p>这意味这我们可以直接将$fl,sl$这两个东西扔掉了，因此有</p><script type="math/tex; mode=display">\begin{aligned}fr_{i,r}&=fl_{i,m-r+1},sr_{i,r}=sl_{i,m-r+1}\\f_{i,l,r}&=p_{l,r}\times (sr_{i-1,m}-sr_{i-1,l-1}-sl_{i-1,r+1})\\&=p_{l,r}\times (sr_{i-1,m}-sr_{i-1,l-1}-sr_{i-1,m - r})\end{aligned}</script><p>现在考虑如何求$fr_{i,j}$，$sr_{i,j}$直接对$fr_{i,j}$求前缀和就好了</p><p>推一波式子</p><script type="math/tex; mode=display">\begin{aligned}fr_{i,r}&=\sum_{l=1}^rp_{l,r}\times (sr_{i-1,m}-sr_{i-1,l-1}-sr_{i-1,m-r})\\&=\sum_{l=1}^rp_{l-1}\times p_{m-r+1}\times (sr_{i-1,m}-sr_{i-1,l-1}-sr_{i-1,m-r})\\&=(sr_{i-1,m}-sr_{i-1,m-r})\times p_{m-r+1}\times \sum_{l=1}^r p_{l-1}\\&-p_{m-r+1}\times \sum_{l=1}^rsr_{i-1,l-1}\times p_{l-1}\end{aligned}</script><p>然后我们再求出$\sum sr_{i-1,l-1}\times p_{l-1}$的前缀和就行了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y = <span class="number">0</span>)</span> </span>&#123;x += y, x -= x &gt;= mod ? mod : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dec</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y = <span class="number">0</span>)</span> </span>&#123;x -= y, x += x &lt; <span class="number">0</span> ? mod : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;x += y; <span class="keyword">return</span> x &gt;= mod ? x - mod : x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;x -= y; <span class="keyword">return</span> x &lt; <span class="number">0</span> ? x + mod : x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar(); <span class="keyword">int</span> flg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) flg |= c == <span class="string">'-'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    <span class="keyword">if</span> (flg) x = -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    x &lt; <span class="number">10</span> ? <span class="built_in">putchar</span>(<span class="string">'0'</span> + x) : (print(x / <span class="number">10</span>), <span class="built_in">putchar</span>(<span class="string">'0'</span> + x % <span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[M], inv[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> P[M], P1[M], dp[N][N], sum[N], sum1[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, a, b, t; read(n), read(m), read(a), read(b), read(t);</span><br><span class="line">    frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    inv[t] = Pow(frac[t], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = t - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) inv[i] = (LL)inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">int</span> p = (LL)a * Pow(b, mod - <span class="number">2</span>) % mod, p1 = mod + <span class="number">1</span> - p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; i++) </span><br><span class="line">        P[i] = (LL)C(t, i) * Pow(p, i) % mod * Pow(p1, t - i) % mod;</span><br><span class="line">    P1[<span class="number">0</span>] = P[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) P1[i] = Add(P1[i - <span class="number">1</span>], P[i]);</span><br><span class="line">    dp[<span class="number">0</span>][m] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) sum[j] = Add(sum[j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) sum1[j] = Add(sum1[j - <span class="number">1</span>], (LL)sum[j] * P[j] % mod);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[i][j] = Sub((LL)P1[j - <span class="number">1</span>] * Sub(sum[m], sum[m - j]) % mod, sum1[j - <span class="number">1</span>]);</span><br><span class="line">            dp[i][j] = (LL)dp[i][j] * P[m - j] % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) Inc(res, dp[n][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC023F 01 on Tree</title>
      <link href="/2020/03/12/agc023f-01-on-tree/"/>
      <url>/2020/03/12/agc023f-01-on-tree/</url>
      
        <content type="html"><![CDATA[<p>给出一棵$N$个点的树，每个点上有一个$0$或$1$的数字。问在这$N$个节点构成的所有排列中，节点上的数形成的逆序对数最少是多少，规定父亲必须排在儿子前面</p><script type="math/tex; mode=display">N\leq 2\times 10^5</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这种题有一个经典的贪心模型</p><p>考虑维护$n$个集合，一开始第$i$个集合中的元素只有$i$</p><p>接着将所有集合排序，如果$A$集合中的元素排在$B$集合中的元素前面时得到的逆序对个数比$B$排在$A$前面时要少，那么我们认为$A&lt;B$</p><p>因此我们需要对每个集合维护这个集合内$0,1$的数量</p><p>注意这里我们只考虑集合与集合间的逆序对数</p><p>显然一开始当每个集合中都只有一个元素时我们会将所有标上$0$的点都排在标上$1$的点前面</p><p>接着我们取出最小的集合，如果没有“父亲必须排在儿子前面”这一条限制，我们可以将其直接加入到序列中</p><p>如果这个集合中最浅点的父亲被选了，那么这个集合也可以选了，此时我们一定会立即选择这个集合</p><p>因此我们将这个集合与其父亲所在的集合合并，表示“如果父亲的集合被选了，那么会立即选择这个集合”，然后将答案加上父亲所在的集合与这个集合之间的逆序对数</p><p>我们不停地重复这个过程，直到所有点都合并为一个点即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N], p[N], c0[N], c1[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> u, c0, c1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">    LL t1 = (LL)c1 * b.c0, t2 = (LL)c0 * b.c1;</span><br><span class="line">    <span class="keyword">if</span> (t1 != t2) <span class="keyword">return</span> t1 &lt; t2;</span><br><span class="line">    <span class="keyword">return</span> u &lt; b.u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : fa[x] = find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;node&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), c0[i] = a == <span class="number">0</span>, c1[i] = a == <span class="number">1</span>, fa[i] = i;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">1</span>) s.insert((node)&#123;i, c0[i], c1[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = s.begin()-&gt;u; s.erase(s.begin());</span><br><span class="line">        <span class="keyword">int</span> t = find(p[u]); </span><br><span class="line">        <span class="keyword">if</span> (t != <span class="number">1</span>) s.erase((node)&#123;t, c0[t], c1[t]&#125;);</span><br><span class="line">        res += (LL)c1[t] * c0[u], c1[t] += c1[u], c0[t] += c0[u];</span><br><span class="line">        fa[u] = t;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="number">1</span>) s.insert((node)&#123;t, c0[t], c1[t]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.10 省选集训day2</title>
      <link href="/2020/03/10/310-sheng-xuan-ji-xun-day2/"/>
      <url>/2020/03/10/310-sheng-xuan-ji-xun-day2/</url>
      
        <content type="html"><![CDATA[<p>day1太过自闭了，所以题解就先咕了</p><h1 id="T1-调兵遣将"><a href="#T1-调兵遣将" class="headerlink" title="T1 调兵遣将"></a>T1 调兵遣将</h1><p>给出一个序列，第$i$个元素为$w_i$</p><p>我们这样定义一种合法方案：选出原序列的若干个互不相交也互不包含的子区间，且至少选$1$个区间，使得这些区间的$\gcd$相等</p><p>你需要对于每个元素，求出它在多少种方案中被选中了</p><script type="math/tex; mode=display">n\leq 5\times 10^4,1\leq w_i\leq 10^9</script><a id="more"></a><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑一个区间的$\gcd$。如果我们固定这个区间的右端点，那么随着左端点向左不断移动的过程中，这个区间的$\gcd$只会变化$\log w_i$次</p><p>也就是说，如果此时左端点在某个范围内移动的话，区间的$\gcd$是不会变化的，这样的范围至多有$\log w_i$个</p><p>二分出这些范围，于是我们得到了若干个三元组$(l,r,p)$，表示右端点为$p$，左端点在$[l,r]$中的区间的$\gcd$是相等的</p><p>枚举最终方案中所有区间的$\gcd$，将$\gcd$等于这个的所有三元组拿出来$dp$</p><p>如果算方案数的话很简单，设$dp[i]$表示最后选择的区间的右端点为$i$的方案数，然后线段树优化即可</p><p>转移的时候分$i&lt;l$以及$l\leq i&lt; r$两种情况讨论，需要维护区间$dp[i]$的和以及区间$dp[i]\times i$的和</p><p>考虑如何计算当前枚举的$\gcd$对一个点的贡献</p><p>我们增加若干个三元组$(p,l,r)$，定义与上面的三元组相反，表示左端点是$p$，右端点在$[l,r]$中的区间的$\gcd$不变</p><p>对前缀的第一种三元组$dp$，对后缀的第二种三元组$dp$，然后用总方案数减去不包含当前点/当前区间的方案就可以了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a + b;</span><br><span class="line">    <span class="keyword">return</span> t &gt;= mod ? t - mod : t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a - b;</span><br><span class="line">    <span class="keyword">return</span> t &lt; <span class="number">0</span> ? t + mod : t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    a += b, a -= a &gt;= mod ? mod : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tree[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += x &amp; -x) Inc(tree[x], y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= x &amp; -x) Inc(res, tree[x]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Sub(query(r), query(l - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += x &amp; -x) tree[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; p1, p2, q1, q2, res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[<span class="number">17</span>][N], num[N], lg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) g[<span class="number">0</span>][i] = num[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">16</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= n; j++)</span><br><span class="line">            g[i][j] = gcd(g[i - <span class="number">1</span>][j], g[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = lg[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> gcd(g[len][l], g[len][r - (<span class="number">1</span> &lt;&lt; len) + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, p, ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;node&gt; &gt; mp, mp1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Just_DOIT</span><span class="params">(<span class="built_in">vector</span>&lt;node&gt; &amp;p, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : p) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = t.l, r = t.r, p = t.p, A = <span class="number">0</span>, B = <span class="number">0</span>, C = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!type) &#123;</span><br><span class="line">            A = p1.query(<span class="number">1</span>, l - <span class="number">1</span>) + <span class="number">1</span>, B = p2.query(l, r - <span class="number">1</span>), C = p1.query(l, r - <span class="number">1</span>); </span><br><span class="line">            res = ((LL)A * (r - l + <span class="number">1</span>) + (LL)C * r - B) % mod;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            A = q1.query(r + <span class="number">1</span>, n) + <span class="number">1</span>, B = q2.query(l + <span class="number">1</span>, r), C = q1.query(l + <span class="number">1</span>, r);</span><br><span class="line">            res = ((LL)A * (r - l + <span class="number">1</span>) + B - (LL)C * l) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        t.ans = res = (res + mod) % mod;</span><br><span class="line">        <span class="keyword">if</span> (!type) p1.update(p, res), p2.update(p, (LL)res * p % mod);</span><br><span class="line">        <span class="keyword">else</span> q1.update(p, res), q2.update(p, (LL)res * p % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : p) </span><br><span class="line">        <span class="keyword">if</span> (!type) p1.clear(t.p), p2.clear(t.p);</span><br><span class="line">        <span class="keyword">else</span> q1.clear(t.p), q2.clear(t.p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(num[i]);</span><br><span class="line">    pre(); <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val;</span><br><span class="line">    <span class="keyword">auto</span> getL = [&amp;](<span class="keyword">int</span> R, <span class="keyword">int</span> p) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> g = get(R, p), l = <span class="number">1</span>, r = R, mid, ans = <span class="number">-1</span>;</span><br><span class="line">        val.push_back(g);</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (get(mid = (l + r) &gt;&gt; <span class="number">1</span>, p) == g) ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> getR = [&amp;](<span class="keyword">int</span> L, <span class="keyword">int</span> p) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> g = get(p, L), l = L, r = n, mid, ans = <span class="number">-1</span>;</span><br><span class="line">        val.push_back(g);</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (get(p, mid = (l + r) &gt;&gt; <span class="number">1</span>) == g) ans = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = i;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = getL(cur, i); </span><br><span class="line">            mp[get(t, i)].push_back((node)&#123; t, cur, i, <span class="number">0</span> &#125;);</span><br><span class="line">            cur = t - <span class="number">1</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = i;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = getR(cur, i);</span><br><span class="line">            mp1[get(i, t)].push_back((node)&#123; cur, t, i, <span class="number">0</span> &#125;);</span><br><span class="line">            cur = t + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(val.begin(), val.end()), val.resize(unique(val.begin(), val.end()) - val.begin());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : val) &#123;</span><br><span class="line">        Just_DOIT(mp[v], <span class="number">0</span>), Just_DOIT(mp1[v], <span class="number">1</span>); <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos;</span><br><span class="line">        <span class="built_in">vector</span>&lt;node&gt; L = mp[v], R = mp1[v];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : L) pos.push_back(t.p);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : R) pos.push_back(t.p);</span><br><span class="line">        pos.push_back(<span class="number">0</span>), pos.push_back(n + <span class="number">1</span>);</span><br><span class="line">        sort(pos.begin(), pos.end()), pos.resize(unique(pos.begin(), pos.end()) - pos.begin());</span><br><span class="line">        Inc(L[<span class="number">0</span>].ans, <span class="number">1</span>), Inc(R[<span class="number">0</span>].ans, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; L.size(); i++) Inc(L[i].ans, L[i - <span class="number">1</span>].ans);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; R.size(); i++) Inc(R[i].ans, R[i - <span class="number">1</span>].ans);</span><br><span class="line">        <span class="keyword">int</span> all = L.rbegin() -&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, pre = <span class="number">-1</span>, suf = R.size() - <span class="number">1</span>; i + <span class="number">1</span> &lt; pos.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = pos[i] + <span class="number">1</span>, r = pos[i + <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (l &gt; r) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (pre + <span class="number">1</span> &lt; L.size() &amp;&amp; L[pre + <span class="number">1</span>].p &lt; l) pre++;</span><br><span class="line">            <span class="keyword">while</span> (suf &gt;= <span class="number">0</span> &amp;&amp; R[suf].p &lt;= r) suf--;</span><br><span class="line">            <span class="keyword">int</span> A = pre &gt;= <span class="number">0</span> ? L[pre].ans : <span class="number">1</span>, B = suf &gt;= <span class="number">0</span> ? R[suf].ans : <span class="number">1</span>, tmp = (all - (LL)A * B % mod + mod) % mod;</span><br><span class="line">            res.update(l, tmp), res.update(r + <span class="number">1</span>, mod - tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, pre = <span class="number">-1</span>, suf = R.size() - <span class="number">1</span>; i &lt; pos.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = pos[i];</span><br><span class="line">            <span class="keyword">if</span> (p &lt; <span class="number">1</span> || p &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (pre + <span class="number">1</span> &lt; L.size() &amp;&amp; L[pre + <span class="number">1</span>].p &lt; p) pre++;</span><br><span class="line">            <span class="keyword">while</span> (suf &gt;= <span class="number">0</span> &amp;&amp; R[suf].p &lt;= p) suf--;</span><br><span class="line">            <span class="keyword">int</span> A = pre &gt;= <span class="number">0</span> ? L[pre].ans : <span class="number">1</span>, B = suf &gt;= <span class="number">0</span> ? R[suf].ans : <span class="number">1</span>, tmp = (all - (LL)A * B % mod + mod) % mod;</span><br><span class="line">            res.update(p, tmp), res.update(p + <span class="number">1</span>, mod - tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, res.query(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-一掷千金"><a href="#T2-一掷千金" class="headerlink" title="T2 一掷千金"></a>T2 一掷千金</h1><p>有一棵$n\times m$个节点的树，每个节点有一个坐标$(i,j)$，其中$(1,1)$是根，而$(x,y)$的父亲是$(\max(1,x-1),\max(1,y-1))$</p><p>一开始每个节点是黑色或者白色，先手和后手轮流操作。每次轮到的人会选择一个白色节点，然后选择一个它的祖先（可以是它自己），接着翻转这条路径上所有点的颜色，不能操作的那一方输</p><p>输入会给出$K$个矩形，表示这些矩形里面的点都是白色，而其余的点是黑色</p><p>你需要输出当前局面的<code>SG</code>值</p><script type="math/tex; mode=display">K,n\leq 10^5,m\leq 10^9</script><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>很奇妙的一道题</p><p>首先有一个重要的结论：对于这种每个节点为黑/白色，翻转若干个节点，且最后一个节点必须是白色的博弈，我们可以将其看作若干个子游戏，每个子游戏有且仅有一个点是白色。原游戏的<code>SG</code>值等于这个子游戏的<code>SG</code>值</p><p>这个结论使用于所有翻转颜色，且对第一个/最后一个元素的颜色有限制的问题</p><p>比如，考虑一段序列<code>AABBABA</code>，每次可以选择一个右端点为<code>B</code>的区间翻转，那么这个游戏等价于三个子游戏，这三个子游戏分别为<code>AABAAAA</code>，<code>AAABAAA</code>，<code>AAAAABA</code></p><p>如何证明呢？我们将原来的游戏修改一下：每个点有若干个棋子，一开始所有的白色节点都有一个棋子。每次你可以选择一个有棋子的位置，再选择它的一个祖先，删去当前点的棋子，在到它祖先路径上的其它节点上都放一个棋子</p><p>容易发现每个棋子是互不影响的，因此可以将其拆成若干个子游戏，每个子游戏都只有一个棋子。而对于一个点来说，如果这个点上面有奇数个棋子，等价于只有一个棋子；如果这个点上有偶数个棋子，等价于没有棋子，这时因为在计算<code>SG</code>值的时候是异或，因此它们相互抵消了</p><p>回到这道题，考虑只有一个点是白色的情况，假如这个点是$x$，我们将这种局面记为$W(x)$</p><p>显然$W(x)$只与$x$的祖先个数有关，通过打表可以发现$W(x)$的<code>SG</code>为$lowbit(\max(i,j))$，其中$(i,j)$是$x$的坐标</p><p>因此，我们要计算所有被染成白色的点的$lowbit(\max(i,j))$的异或和</p><p>扫描线一下，考虑使用线段树维护区间$lowbit$异或和</p><p>直接维护有点麻烦，因为要计算区间$lowbit$异或，必须要借助数位$dp$</p><p>题解的做法非常奇妙：强制让这棵线段树的下标为$[0,2^d-1]$</p><p>这样的好处是，对于每个点所代表的区间，一定是形如$[a\times 2^b,a\times 2^b+2^c-1(c&lt;b)]$的形式</p><p>可以发现，对于满足这个条件的一个区间$[l,r]$，这个区间的$lowbit$异或和为$\frac{r-l+1}{2}\oplus lowbit(l)$，$\frac{r-l+1}{2}$之后的那些位都作为最低位出现了偶数次，被抵消了</p><p>然后我们在线段树上标记永久化一下就好了，注意一个点的标记永远都$\geq 0$，因为减操作总是撤销操作</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tag, sum, res, ls, rs;</span><br><span class="line">&#125; T[N * <span class="number">34</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ncnt, rt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((r - l + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) ^ (l &amp; -l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T[rt].tag) T[rt].res = get(l, r), T[rt].sum = r - l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        T[rt].sum = T[rt].res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (T[rt].ls) T[rt].sum += T[T[rt].ls].sum, T[rt].res ^= T[T[rt].ls].res;</span><br><span class="line">        <span class="keyword">if</span> (T[rt].rs) T[rt].sum += T[T[rt].rs].sum, T[rt].res ^= T[T[rt].rs].res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rt) rt = ++ncnt;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> T[rt].tag += x, pushup(rt, l, r);</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) update(T[rt].ls, l, mid, start, end, x);</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) update(T[rt].rs, mid + <span class="number">1</span>, r, start, end, x);</span><br><span class="line">    pushup(rt, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query1</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rt) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (T[rt].tag) <span class="keyword">return</span> min(end, r) - max(l, start) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> T[rt].sum;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) res += query1(T[rt].ls, l, mid, start, end);</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) res += query1(T[rt].rs, mid + <span class="number">1</span>, r, start, end);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query2</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> ok = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    ok |= T[rt].tag;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ok) <span class="keyword">return</span> get(l, r);</span><br><span class="line">        <span class="keyword">return</span> T[rt].res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) res ^= query2(T[rt].ls, l, mid, start, end, ok);</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) res ^= query2(T[rt].rs, mid + <span class="number">1</span>, r, start, end, ok);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P; </span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt; add[N], del[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, m, lim = <span class="number">1</span>, res = <span class="number">0</span>; read(k), read(n), read(m);</span><br><span class="line">    <span class="keyword">while</span> (lim &lt;= m) lim &lt;&lt;= <span class="number">1</span>; lim--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c, d; read(a), read(b), read(c), read(d);</span><br><span class="line">        add[a].push_back(P(b, d)), del[c + <span class="number">1</span>].push_back(P(b, d));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t : add[i]) update(rt, <span class="number">0</span>, lim, t.first, t.second, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t : del[i]) update(rt, <span class="number">0</span>, lim, t.first, t.second, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (query1(rt, <span class="number">0</span>, lim, <span class="number">1</span>, i) &amp; <span class="number">1</span>) res ^= i &amp; -i;</span><br><span class="line">        res ^= query2(rt, <span class="number">0</span>, lim, i + <span class="number">1</span>, lim);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-树拓扑序"><a href="#T3-树拓扑序" class="headerlink" title="T3 树拓扑序"></a>T3 树拓扑序</h1><p>给出一棵树，问这棵树的所有反拓扑序（即儿子必须排在父亲前面）的逆序对总数是多少</p><script type="math/tex; mode=display">n\leq 500</script><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>记$dp[i][j][k]$表示考虑$i$的子树中的节点构成的拓扑序，其中满足$j$排在第$k$个位置的序列有多少个</p><p>$F[i]$表示$i$的拓扑序总数，$G[i]$表示$i$的所有拓扑序的逆序对总数</p><p>假设现在要合并$u,v$，其中$u$是父亲，此时$u$的序列长度为$A$，$v$的序列长度为$B$</p><p>我们将所有的$j$分为两种，第一种$j$在$v$的子树里，第二种$j$不在$v$的子树里</p><p>如果$j$在$v$的子树中，我们枚举$u$之前的序列在最终的序列中有多少个元素插入到了$j$之前，假设有$t$个，那么方案数为</p><script type="math/tex; mode=display">{k-1+t\choose t}\times {B-k+A-t-1\choose B-k}</script><p>需要注意的是最后一个位置的元素是固定的，只能是根节点</p><p>如果$j$在$u$的子树中，转移类似</p><p>求出方案数之和，考虑如何计算逆序对个数</p><p>对于$dp[v][a][b]$来说，如果$u$构成的序列有$t$个插入到了$a$前面，那么$u$的所有满足$j&gt;a,k<t$或者$j<a,k>t$的$dp[u][j][k]$都将产生$1$个逆序对</p><p>因此我们对$dp$做一个二维前缀和就行了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[N][N][N], F[N], G[N]; <span class="comment">// i的子树内j排在第k位的序列数量; i子树的序列数量; i子树的答案</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[N][N]; <span class="comment">// dp的前缀和</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lst[N][N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nw = F[u], A = son[u].size(), B = son[v].size(), tmp = C(A + B - <span class="number">1</span>, B);</span><br><span class="line">    G[u] = ((LL)G[u] * F[v] + (LL)F[u] * G[v]) % mod * tmp % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= A; j++)</span><br><span class="line">            pre[i][j] = ((LL)pre[i][j - <span class="number">1</span>] + pre[i - <span class="number">1</span>][j] - pre[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[u][i][j] + mod) % mod,</span><br><span class="line">                lst[i][j] = dp[u][i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> j : son[u])</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= A; k++) dp[u][j][k] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= A; k++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> j : son[u]) <span class="keyword">if</span> (lst[j][k]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt;= B; t++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k == A &amp;&amp; t != B) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> val = (LL)C(t + k - <span class="number">1</span>, t) * C(max(<span class="number">0</span>, A - k - <span class="number">1</span>) + B - t, B - t) % mod;</span><br><span class="line">                dp[u][j][k + t] = (dp[u][j][k + t] + (LL)val * F[v] % mod * lst[j][k]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= B; k++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> j : son[v]) <span class="keyword">if</span> (dp[v][j][k]) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; A; t++) &#123;</span><br><span class="line">                <span class="keyword">int</span> val = (LL)C(t + k - <span class="number">1</span>, t) * C(B - k + A - t - <span class="number">1</span>, A - t - <span class="number">1</span>) % mod;</span><br><span class="line">                dp[u][j][k + t] = (dp[u][j][k + t] + (LL)val * dp[v][j][k] % mod * F[u]) % mod;</span><br><span class="line">                <span class="keyword">int</span> L = (pre[n][t] - pre[j][t] + mod) % mod, R = (pre[j][A] - pre[j][t] + mod) % mod;</span><br><span class="line">                G[u] = (G[u] + (LL)val * (L + R) % mod * dp[v][j][k]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">    F[u] = (LL)F[u] * F[v] % mod * tmp % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : son[v]) son[u].push_back(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123; to, head[from] &#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123; from, head[to] &#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    F[u] = <span class="number">1</span>, dp[u][u][<span class="number">1</span>] = <span class="number">1</span>, son[u].push_back(u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u), Merge(u, e[i].to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, G[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 博弈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC033E Go around a Circle</title>
      <link href="/2020/03/07/agc033e-go-around-a-circle/"/>
      <url>/2020/03/07/agc033e-go-around-a-circle/</url>
      
        <content type="html"><![CDATA[<p>一个圆上均匀分布着$N$个点，有$N$条弧连接着这些点。给出一个由<code>RB</code>构成的长度为$M$的串$S$，你需要给每条弧分配一个<code>R</code>或<code>B</code>的字符，使得从这个圆上任意一点开始走，都存在一种方案，每次将跨过弧的字符写下来，最终都能得到$S$</p><p>求合法方案数，对$10^9+7$取模</p><script type="math/tex; mode=display">N,M\leq 2\times 10^5</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>我们分几种情况讨论一下</p><p><strong>1.$S$中所有字符都相同</strong></p><p>我们不妨设这个字符为<code>R</code></p><p>如果存在一个点，连接这个点的两条弧都是<code>B</code>，那么从这个点开始走就凉了</p><p>否则我们可以在那条<code>R</code>边上来回走</p><p>此时相当于要给环上若干条边染成<code>B</code>，使得不存在相邻的<code>B</code></p><p>断环为链，枚举第一条边的颜色，然后$dp$一下就行了</p><p><strong>2.$S$中存在不相同字符</strong></p><p>为了方便起见，我们还是设$S$的第一个字符为<code>R</code></p><p>显然环上不能出现两个连续的<code>B</code></p><p>接下来我们证明一个结论：对于任意一段极长的<code>R</code>，它的长度一定是奇数</p><p>使用反证法，假设至少存在一段<code>R</code>，它的长度是偶数</p><p>我们把这一段<code>R</code>以及它左右两侧的<code>B</code>拉出来</p><p>将第一个<code>R</code>的左端点标记为圆点，第二个<code>R</code>的左端点标记为方点，第三个<code>R</code>的左端点又标记为圆点……以此类推</p><p>如果我们从一个圆点出发，可以发现它到左右两侧的<code>B</code>都需要走奇数步，这意味着$S$中的第一个<code>B</code>必须出现在奇数位置</p><p>如果我们从一个方点出发，可以发现它到左右两侧的<code>B</code>都需要走偶数步，这意味着$S$的的第一个<code>B</code>必须出现在偶数位置，矛盾</p><p>因此可以得出结论：每一段极长的<code>R</code>的长度必定是奇数</p><p>我们将每一段<code>R</code>与它右边的<code>B</code>匹配，长度为偶数，这意味着如果存在合法方案，那么$N$必须是偶数</p><p>如果$S$中第一个<code>B</code>前面有$a$个<code>R</code></p><p>如果$a$是奇数，那么连续的<code>R</code>的长度不能大于$a$，否则不能大于$a+1$</p><p>$a$是奇数的时候考虑这一段的第一个$R$的左端点，显然这一段的长度不能大于$a$</p><p>$a$是偶数的时候考虑这一段的第一个$R$右端点，它只能向右走，因此这一段的长度不能大于$a+1$</p><p>容易发现这样一个事实，从一个点开始走，当跨过第一个<code>B</code>的时候，所在的位置的唯一确定的</p><p>并且，对于每一个与<code>B</code>相连的位置，一定存在一个起点，从这个起点出发跨过第一个<code>B</code>的时候会到达这个点</p><p>因此，假如$S$中除了开头以外，存在一段连续的极长<code>R</code>的长度为$b$，且$b$为奇数，那么每一段极长的<code>R</code>的长度不能超过$b$</p><p>我们可以求出考虑了上面的所有约束之后，每一段<code>R</code>的最长的长度</p><p>问题转化为：给环上的每一条边染色，使得不存在连续的<code>B</code>，每一段<code>R</code>的长度是奇数且最大不超过$x$</p><p>可以进一步转化为将$\frac N2$分为若干段，每一段的长度不超过$\lceil\frac x2\rceil$的方案数</p><p>断环为链，设$f[i]$表示将$1\sim i$分成若干段，且$i$是最后一段的结尾的方案数</p><p>初值为$f[k]=2k$，即此时长度为$k$的段代表$2k-1$个<code>R</code>接上一个<code>B</code>，而这$2k$个端点都能成为起点</p><p>前缀和优化即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N], g[N], dp[<span class="number">2</span>][<span class="number">2</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;n, &amp;m, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">if</span> (s[i] != s[<span class="number">1</span>]) &#123;</span><br><span class="line">        flag = <span class="literal">true</span>; <span class="keyword">break</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fir = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">if</span> (s[i] != s[<span class="number">1</span>]) &#123;</span><br><span class="line">            fir = i - <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lim = fir | <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = fir + <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">if</span> (s[i] != s[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt;= m &amp;&amp; s[j] == s[<span class="number">1</span>]) j++;</span><br><span class="line">            <span class="keyword">if</span> (j &lt;= m &amp;&amp; (j - i - <span class="number">1</span>) % <span class="number">2</span> == <span class="number">1</span>) lim = min(lim, j - i - <span class="number">1</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        n /= <span class="number">2</span>, lim = (lim + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lim; i++) f[i] = i * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, diff = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            diff = (diff + g[i]) % mod, f[i] = (f[i] + diff) % mod;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt;= n) g[i + <span class="number">1</span>] = (g[i + <span class="number">1</span>] + f[i]) % mod;</span><br><span class="line">            <span class="keyword">if</span> (i + lim + <span class="number">1</span> &lt;= n) g[i + lim + <span class="number">1</span>] = (g[i + lim + <span class="number">1</span>] - f[i] + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[n]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">1</span>; t++) &#123;</span><br><span class="line">                dp[t][<span class="number">0</span>][i] = (dp[t][<span class="number">1</span>][i - <span class="number">1</span>] + dp[t][<span class="number">0</span>][i - <span class="number">1</span>]) % mod;</span><br><span class="line">                dp[t][<span class="number">1</span>][i] = dp[t][<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ((LL)dp[<span class="number">1</span>][<span class="number">0</span>][n] + dp[<span class="number">0</span>][<span class="number">0</span>][n] + dp[<span class="number">0</span>][<span class="number">1</span>][n]) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC034E Complete Compress</title>
      <link href="/2020/03/06/agc034e-complete-compress/"/>
      <url>/2020/03/06/agc034e-complete-compress/</url>
      
        <content type="html"><![CDATA[<p>给出一棵$N$个点的树，有些节点上有棋子，定义树上路径长度为经过的边数</p><p>每一轮，你可以选择两个距离至少为$2$的棋子$(u,v)$，然后将$u$向$v$挪动一步，同时将$v$向$u$挪动一步</p><p>问至少需要多少步才能让所有棋子都挪到一起，如果无解输出$-1$</p><script type="math/tex; mode=display">N\leq 2000</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>枚举最后所有棋子到达的点，将这个点提为根，容易发现挪动棋子只有两种情况</p><ul><li>选择两个互为祖先关系的棋子，然后让它们一个深度$+1$，一个深度$-1$</li><li>选择两个互不为祖先关系的棋子，让两个棋子的深度都$-1$</li></ul><p>接着有一个结论：所有$1$操作是没有用的</p><p>假如我们在某次操作中选择了$1$操作，接下来是一次$2$操作，可以发现这样一个性质，如果将这两个操作的顺序互换，对结果不会产生影响</p><p>因此，我们可以将所有的$1$操作都换到最后去，这样所有的$1$操作就没用了</p><p>现在就只剩下$2$操作了，那么如何判断是否合法呢</p><p>每次操作会导致所有棋子的深度之和$-2$，不会改变奇偶性，因此如果当前的深度总和为奇数，则经过若干次操作过后的深度之和不能低于$1$</p><p>假设某次都只能跨过根选择两个棋子，即选择的棋子必须在根的两棵子树中，我们假设根的每棵子树的棋子深度之和分别为$a_1,a_2,\cdots, a_m$，此时显然必须满足$\max\{a_1,\cdots a_m\}\leq \frac{\sum a_i}{2}$</p><p>如果$\max$过大，我们可以递归到这棵子树中继续进行$2$操作</p><p>我们对这棵树进行两次<code>dfs</code>，第一次<code>dfs</code>求出每个点子树中的棋子个数以及所有棋子的深度之和，第二次<code>dfs</code>求出当前子树所剩余的最小深度之和</p><p>在第二次<code>dfs</code>的时候，我们找到子树深度之和最大的儿子，如果这个儿子能得到的最小的深度之和仍然比其它儿子的深度之和要大，那么无论如何都消不完了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sum: 子树内棋子个数 dp: 子树内最少操作步数</span></span><br><span class="line"><span class="keyword">int</span> sum[N], dp[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> val[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    sum[u] = val[u], dp[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) &#123;</span><br><span class="line">            dfs(e[i].to, u);</span><br><span class="line">            sum[u] += sum[e[i].to], dp[u] += dp[e[i].to] + sum[e[i].to];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子树的最小剩余深度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) </span><br><span class="line">            <span class="keyword">if</span> (dp[e[i].to] &gt;= dp[mx]) </span><br><span class="line">                mx = e[i].to;</span><br><span class="line">    <span class="keyword">if</span> (!mx) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = dfs2(mx, u) + sum[mx];</span><br><span class="line">    <span class="keyword">if</span> (dp[u] - dp[mx] - sum[mx] &gt;= tmp) <span class="keyword">return</span> dp[u] &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp - (dp[u] - dp[mx] - sum[mx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d%s"</span>, &amp;n, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) val[i] = s[i] == <span class="string">'1'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dfs(i, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!dfs2(i, <span class="number">0</span>)) res = min(res, dp[i] / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">1e8</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC034D Manhattan Max Matching</title>
      <link href="/2020/03/06/agc034d-manhattan-max-matching/"/>
      <url>/2020/03/06/agc034d-manhattan-max-matching/</url>
      
        <content type="html"><![CDATA[<p>二维平面上有若干个数量相同的蓝点和红点</p><p>有$BC_i$个蓝点的坐标为$(BX_i, BY_i)$，有$RC_i$个红点的坐标为$(RX_i, RY_i)$</p><p>你需要将这些蓝点和红点配对，使得每一对的曼哈顿距离之和尽量大</p><script type="math/tex; mode=display">N\leq 1000, RX_i,RY_i,BX_i,BY_i<10^9,\sum BC_i=\sum RC_i</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>每个点的坐标在被计算的时候一共有四种情况，$(x,y),(-x,y),(x,-y),(-x,-y)$</p><p>注意到$A,B$两点的曼哈顿距离可以写成$\max\{X_A+Y_A-X_B-Y_B,X_A-Y_A-X_B+Y_B,\\ -X_A+Y_A+X_B-Y_B,-X_A-Y_A+X_B+Y_B\}$的形式</p><p>可以发现每个点当且仅当它的曼哈顿距离被正确计算的时候才是最大的，而这道题又要求每一对的曼哈顿距离之和最大</p><p>因此我们可以将所有点分成四类，其中$(x,y)$与$(-x,-y)$相匹配，$(x,-y)$与$(-x,-y)$相匹配</p><p>考虑如何建图</p><p>将图分为两侧，左侧为所有蓝点，右侧为所有红点</p><p>中间新建四个点，第一个点与左侧所有点的连边费用为$x+y$，与右侧的点的连边费用为$-x-y$</p><p>第二个点与左侧所有点的连边费用为$-x-y$，与右侧所有点的连边费用为$x+y$</p><p>剩下两个点同理</p><p>然后在这张图上跑一边最大费用流就是答案</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w, c;</span><br><span class="line">&#125; e[N * <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from], w, -c&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to], <span class="number">0</span>, c&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis[N], cur[N]; LL dis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis)), <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; q.push(t), vis[t] = <span class="number">1</span>, dis[t] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop(), vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">            <span class="keyword">if</span> (e[i ^ <span class="number">1</span>].w &amp;&amp; dis[e[i].to] &gt; dis[u] - e[i].c) &#123;</span><br><span class="line">                dis[e[i].to] = dis[u] - e[i].c;</span><br><span class="line">                <span class="keyword">if</span> (!vis[e[i].to]) q.push(e[i].to), vis[e[i].to] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[s] &lt; <span class="number">1e17</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == t || !f) <span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u], tmp; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to] &amp;&amp; e[i].w &amp;&amp; dis[u] - e[i].c == dis[e[i].to] &amp;&amp; </span><br><span class="line">            (tmp = DFS(e[i].to, t, min(f, e[i].w)))) &#123;</span><br><span class="line">                res += tmp, f -= tmp, e[i].w -= tmp, e[i ^ <span class="number">1</span>].w += tmp, ans += (LL)tmp * e[i].c;</span><br><span class="line">                <span class="keyword">if</span> (!f) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (SPFA(s, t)) <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span>(head)), DFS(s, t, <span class="number">1e9</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, s, t; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), s = n * <span class="number">2</span> + <span class="number">5</span>, t = s + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, c; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;c);</span><br><span class="line">        adde(s, i, c, <span class="number">0</span>);</span><br><span class="line">        adde(i, <span class="number">2</span> * n + <span class="number">1</span>, <span class="number">1e9</span>, -x - y), adde(i, <span class="number">2</span> * n + <span class="number">2</span>, <span class="number">1e9</span>, x + y);</span><br><span class="line">        adde(i, <span class="number">2</span> * n + <span class="number">3</span>, <span class="number">1e9</span>, y - x), adde(i, <span class="number">2</span> * n + <span class="number">4</span>, <span class="number">1e9</span>, x - y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, c; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;c);</span><br><span class="line">        adde(i + n, t, c, <span class="number">0</span>);</span><br><span class="line">        adde(<span class="number">2</span> * n + <span class="number">1</span>, i + n, <span class="number">1e9</span>, x + y), adde(<span class="number">2</span> * n + <span class="number">2</span>, i + n, <span class="number">1e9</span>, -x - y);</span><br><span class="line">        adde(<span class="number">2</span> * n + <span class="number">3</span>, i + n, <span class="number">1e9</span>, x - y), adde(<span class="number">2</span> * n + <span class="number">4</span>, i + n, <span class="number">1e9</span>, y - x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, -dinic(s, t));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC038E Gachapon</title>
      <link href="/2020/03/06/agc038e-gachapon/"/>
      <url>/2020/03/06/agc038e-gachapon/</url>
      
        <content type="html"><![CDATA[<p>有一个随机数生成器，在每个时刻会生成一个数</p><p>给出$N$对$A_i,B_i$，表示每个时刻生成$i$的概率为$\frac{A_i}{\sum A_i}$</p><p>当所有的$i$均满足$i$至少被生成了$B_i$次时停止生成，问期望停止时间</p><p>$N,\sum A_i, \sum B_i\leq 400$，对$998244353$取模</p><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先<code>min-max</code>容斥一下，将问题转化为求出对于每个$\{1,2,\cdots n\}$的子集，这个子集中至少有一个数满足条件的期望时间</p><p>设这个子集为$S$，如果只考虑生成出的$S$集合中的数，显然生成的数的总数不会超过$\sum_{i\in S}B_i$</p><p>如果要考虑生成出的其它数，那么期望时刻等于不考虑那些数时的期望再乘上$\frac{\sum A_i}{\sum_{i\in S}A_i}$</p><p>将期望转化为概率</p><p>停止的期望时间$=$第$0$次操作之后还未停止的概率$+$第$1$次操作之后还未停止的概率$+\cdots$第$\sum B_i$次操作之后还未停止的概率</p><p>先考虑暴力$dp$，枚举$S$集合，设$dp[i][j]$表示考虑了$S$集合中的前$i$个元素，当前凑出来的生成序列一共有$j$个元素，且所有数的生成次数均小于上界的概率</p><p>枚举当前数被生成了多少次，那么有</p><script type="math/tex; mode=display">dp[i][j]=\sum_{k=0}^{\min(j,b_i)}dp[i-1][j-k]\times \left(\frac{A_{S_i}}{\sum_{i\in S} A_{i}}\right)^k\times {j\choose k}</script><p>现在考虑一起算所有的$S$</p><p>设$dp[i][j][k][0/1]$表示当前考虑第$i$个数，序列中一共塞了$j$个数，此时我们所选择的数的$A_i$之和为$k$，选了奇数/偶数种数的概率</p><p>转移与上面类似</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">410</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][N][N][N], A[N], B[N], C[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, s = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A[i], &amp;B[i]), s = (s + A[i]) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">400</span>; i++) &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) C[i][j] = (C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t = <span class="number">0</span>, t1 = <span class="number">0</span>; i &lt;= n; t += B[i] - <span class="number">1</span>, t1 += A[i], i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= t; j++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= t1; k++) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i][j][k] = (dp[<span class="number">0</span>][i][j][k] + dp[<span class="number">0</span>][i - <span class="number">1</span>][j][k]) % mod;</span><br><span class="line">                dp[<span class="number">1</span>][i][j][k] = (dp[<span class="number">1</span>][i][j][k] + dp[<span class="number">1</span>][i - <span class="number">1</span>][j][k]) % mod;</span><br><span class="line">                <span class="keyword">int</span> p = (LL)k * Pow(k + A[i], mod - <span class="number">2</span>) % mod, p1 = Pow(p, j);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; B[i]; l++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> w = (LL)C[j + l][j] * p1 % mod * Pow(<span class="number">1</span> + mod - p, l) % mod;</span><br><span class="line">                    dp[<span class="number">0</span>][i][j + l][k + A[i]] = (dp[<span class="number">0</span>][i][j + l][k + A[i]] + (LL)dp[<span class="number">1</span>][i - <span class="number">1</span>][j][k] * w) % mod;</span><br><span class="line">                    dp[<span class="number">1</span>][i][j + l][k + A[i]] = (dp[<span class="number">1</span>][i][j + l][k + A[i]] + (LL)dp[<span class="number">0</span>][i - <span class="number">1</span>][j][k] * w) % mod;</span><br><span class="line">                    <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) dp[<span class="number">1</span>][i][l][A[i]] = (dp[<span class="number">1</span>][i][j + l][A[i]] + w) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">1</span>; t++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">400</span>; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">400</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = (LL)dp[t][n][j][k] * s % mod * Pow(k, mod - <span class="number">2</span>) % mod;</span><br><span class="line">                <span class="keyword">if</span> (t &amp; <span class="number">1</span>) ans = (ans + w) % mod;</span><br><span class="line">                <span class="keyword">else</span> ans = (ans - w + mod) % mod; </span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 容斥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC034F RNG and XOR</title>
      <link href="/2020/03/06/agc034f-rng-and-xor/"/>
      <url>/2020/03/06/agc034f-rng-and-xor/</url>
      
        <content type="html"><![CDATA[<p>一开始有一个为$0$的数$X$</p><p>对于$0\leq i\leq 2^N-1$，每次你会以$\frac{A_i}{\sum A_i}$的概率选择$i$，然后将$X$异或$i$</p><p>对于每一个$0\leq i\leq 2^N-1$，你需要求出$X$变成$i$的期望时刻</p><script type="math/tex; mode=display">N\leq 18</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>我们可以将问题转化为，对于每一个$i$，求出$i$变成$0$的期望时刻</p><p>记$p_i=\frac{A_i}{\sum A_i}$，$x_i$为$i$变成$0$的期望时刻</p><p>容易得出下面的转移</p><script type="math/tex; mode=display">x_i=\sum_{j=0}^{2^N-1}x_{i\oplus j}p_j+1\\x_i-1=\sum_{j=0}^{2^N-1}x_{i\oplus j}p_j</script><p>注意当$i=0$时这个转移是错的</p><p>因此，我们可以得出</p><script type="math/tex; mode=display">(x_0,x_1,x_2,\cdots,x_{2^N-1})\oplus (p_0,p_1,p_2,\cdots,p_{2^N-1})\\=(?,x_1-1,x_2-1,x_3-1,\cdots,x_{2^N-1}-1)</script><p>注意$?$部分不是$x_0-1$，而是$x_0$由上式转移而来的结果</p><p>如果我们对于等式右边的每一项求和，可以得到</p><script type="math/tex; mode=display">\sum_{i=0}^{2^N-1}\sum_{j=0}^{2^N-1}x_{i\oplus j}p_j\\=\sum_{i=0}^{2^N-1}x_i\sum_{j=0}^{2^N-1}p_{i\oplus j}\\=\sum_{i=0}^{2^N-1}x_i\sum_{j=0}^{2^N-1}p_j=\sum_{i=0}^{2^N-1}x_i</script><p>等式右边的所有数之和应该与等式左边的所有数之和相等，即变换之和和不变</p><p>那么有</p><script type="math/tex; mode=display">?=\sum_{i=0}^{2^N-1}x_i-\sum_{i=1}^{2^N-1}(x_i-1)\\=x_0+2^N-1\\(x_0,x_1,\cdots,x_{2^N-1})\oplus (p_0,p_1,\cdots,p_{2^N-1})\\=(x_0+2^N-1,x_1-1,x_2-1,\cdots,x_{2^N-1}-1)</script><p>我们可以想办法将等式右边中每一项的未知数删掉</p><p>注意到如果将$p_0$减$1$，那么右边的第$i$项收到的影响为$x_ip_0$，即减少了$x_i$</p><p>因此有</p><script type="math/tex; mode=display">(x_0,x_1,\cdots,x_{2^N-1})\oplus (p_0-1,p_1,\cdots,p_{2^N-1})\\=(2^N-1,-1,-1,\cdots,-1)</script><p><code>FWT</code>能做卷积，同样也能做卷积的逆变换</p><p>但是如果这样写，写完会发现答案不对，而且$x_0$求出来并不是$0$</p><p>事实上，这样的卷积方程是有通解的。如果我们将所有数全部加上$k$</p><script type="math/tex; mode=display">x_i=\sum_{j=0}^{2^N-1}x_{i\oplus j}p_j+1\\x_i+k=\sum_{j=0}^{2^N-1}(x_{i\oplus j}+k)p_j+1=\sum_{j=0}^{2^N-1}x_{i\oplus j}p_j+k+1</script><p>可以看出，给这个式子的每一项都加上相同的常数，方程仍然成立</p><p>显然，我们知道$x_0=0$，那么此时我们求出的$x_0$应该就是这个常数</p><p>所以将求出来的每一项减去$x_0$即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">18</span>, mod = <span class="number">998244353</span>, i2 = (mod + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + (mid &gt;&gt; <span class="number">1</span>); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = a[j]; a[j] = (t + a[j + (mid &gt;&gt; <span class="number">1</span>)]) % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (t - a[j + (mid &gt;&gt; <span class="number">1</span>)] + mod) % mod;</span><br><span class="line">                <span class="keyword">if</span> (!type) a[j] = (LL)a[j] * i2 % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (LL)a[j + (mid &gt;&gt; <span class="number">1</span>)] * i2 % mod;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N], B[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, sum = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), n = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]), B[i] = mod - <span class="number">1</span>, sum = (sum + A[i]) % mod;</span><br><span class="line">    sum = Pow(sum, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) A[i] = (LL)A[i] * sum % mod;</span><br><span class="line">    B[<span class="number">0</span>] = n - <span class="number">1</span>, A[<span class="number">0</span>] = (A[<span class="number">0</span>] + mod - <span class="number">1</span>) % mod;</span><br><span class="line">    FWT(A, n, <span class="number">1</span>), FWT(B, n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) B[i] = (LL)B[i] * Pow(A[i], mod - <span class="number">2</span>) % mod;</span><br><span class="line">    FWT(B, n, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (B[i] - B[<span class="number">0</span>] + mod) % mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> FWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF643G Choosing Ads</title>
      <link href="/2020/03/06/cf643g-choosing-ads/"/>
      <url>/2020/03/06/cf643g-choosing-ads/</url>
      
        <content type="html"><![CDATA[<p>给出一个序列$a$以及一个介于$20$到$100$之间的正整数$p$，需要支持两种操作</p><ul><li>将区间$[l,r]$修改为$x$</li><li>询问区间$[l,r]$有哪些数出现次数超过了$p\%$</li></ul><p>对于每一个询问，最多可以输出$\lfloor\frac{100}{p}\rfloor$个数，可以输出不正确的结果，但必须保证所有出现次数超过$p\%$的数都被输出了</p><script type="math/tex; mode=display">n,q\leq 1.5*10^5</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>我们先考虑$p\geq 51$怎么做</p><p>此时问题等价于，给出一个序列，支持区间赋值以及询问区间众数，保证众数出现次数超过了一半</p><p>区间出现次数超过一半的众数是一个很经典的问题，可以使用摩尔投票法解决</p><p>如果我们每次选择两个不同的数删去，那么最后留下来的数一定是众数</p><p>因为众数的出现次数超过了一半，就算每次选择众数以及另一个数删除，仍然能保证最后留下的是众数</p><p>那么我们可以将这个结论推广到$p\geq 20$的情况</p><p>举个例子，比如$p=34$</p><p>即保证有两种数出现次数严格大于$1/3$，求这两种数</p><p>我们将策略改为每次选择三个不同的数删去，同样可以得到正确的结果</p><p>如果删去的数至少有两个不是众数，那么这样一定不优秀，因为非众数被多抵消了一个</p><p>如果删去的数包含两个众数，那么最后剩下的一定还是这两个众数，因为它们出现次数大于$1/3$，就算把所有非众数全部抵消完，仍然不能将这两种数消完</p><p>因此，我们维护一段区间内每次将$\lfloor\frac{100}{p}\rfloor$个数删去，最后留下的哪些数即可</p><p>时间复杂度$O(k^2n\log n)$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">150010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    P num[<span class="number">5</span>];</span><br><span class="line">    Data() &#123;<span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));&#125;</span><br><span class="line">    Data(<span class="keyword">int</span> a) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line">        num[<span class="number">0</span>].first = a, num[<span class="number">0</span>].second = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lim;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Data <span class="title">Merge</span><span class="params">(<span class="keyword">const</span> Data &amp;a, <span class="keyword">const</span> Data &amp;b)</span> </span>&#123;</span><br><span class="line">    Data res = a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i++) <span class="keyword">if</span> (b.num[i].second) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j++)</span><br><span class="line">            <span class="keyword">if</span> (res.num[j].first == b.num[i].first) &#123;</span><br><span class="line">                res.num[j].second += b.num[i].second;</span><br><span class="line">                flag = <span class="literal">true</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j++)</span><br><span class="line">            <span class="keyword">if</span> (!res.num[j].second) &#123;</span><br><span class="line">                res.num[j] = b.num[i];</span><br><span class="line">                flag = <span class="literal">true</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> mn = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j++)</span><br><span class="line">            mn = min(mn, res.num[j].second);</span><br><span class="line">        <span class="keyword">if</span> (mn &gt;= b.num[i].second) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j++) res.num[j].second -= b.num[i].second;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lim; j++)</span><br><span class="line">            <span class="keyword">if</span> (res.num[j].second == mn &amp;&amp; !flag) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>, res.num[j].first = b.num[i].first;</span><br><span class="line">                res.num[j].second = b.num[i].second - mn;</span><br><span class="line">            &#125; <span class="keyword">else</span> res.num[j].second -= mn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, tag; Data val;</span><br><span class="line">&#125; T[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    T[rt].val = Merge(T[rt &lt;&lt; <span class="number">1</span>].val, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cover</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r;</span><br><span class="line">    T[rt].val = Data(x), T[rt].val.num[<span class="number">0</span>].second = r - l + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    cover(rt &lt;&lt; <span class="number">1</span>, T[rt].tag), cover(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, T[rt].tag);</span><br><span class="line">    T[rt &lt;&lt; <span class="number">1</span>].tag = T[rt].tag, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].tag = T[rt].tag, T[rt].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    T[rt].l = l, T[rt].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> T[rt].val = Data(a[l]), <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; build(rt &lt;&lt; <span class="number">1</span>, l, mid), build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> cover(rt, x), T[rt].tag = x, <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">if</span> (T[rt].tag) pushdown(rt);</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, start, end, x);</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, start, end, x);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Data <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> T[rt].val;</span><br><span class="line">    <span class="keyword">if</span> (T[rt].tag) pushdown(rt);</span><br><span class="line">    <span class="keyword">if</span> (end &lt;= mid) <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span>, start, end);</span><br><span class="line">    <span class="keyword">if</span> (start &gt; mid) <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, start, end);</span><br><span class="line">    <span class="keyword">return</span> Merge(query(rt &lt;&lt; <span class="number">1</span>, start, end), query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, start, end));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, q, p; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;q, &amp;p), lim = <span class="number">100</span> / p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, A, B, C; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;op, &amp;A, &amp;B);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;C), update(<span class="number">1</span>, A, B, C);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Data res = query(<span class="number">1</span>, A, B);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, lim);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lim; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, res.num[i - <span class="number">1</span>].first);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF704B Ant Man</title>
      <link href="/2020/03/05/cf704b-ant-man/"/>
      <url>/2020/03/05/cf704b-ant-man/</url>
      
        <content type="html"><![CDATA[<p>有$n$个元素，第$i$个元素有五个参数$x_i,a_i,b_i,c_i,d_i$</p><p>你需要求出一个$1\sim n$的排列$p$，使得$p_1=s,p_n=e$，同时最小化这个排列的权值</p><p>我们定义一个排列的权值和为$\sum f(p_i,p_{i+1})$，其中$f(i,j)$的值有两种情况</p><ul><li>$i&gt;j$，此时$f(i,j)=x_i-x_j+c_i+b_j$</li><li>$i&lt;j$，此时$f(i,j)=x_j-x_i+d_i+a_j$</li></ul><script type="math/tex; mode=display">n\leq 5\times 10^3,s\neq e,1\leq x_1<x_2<\cdots x_n\leq 10^9,a_i,b_i,c_i,d_i\leq 10^9</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>让$a_i,c_i$加上$x_i$，让$b_i,d_i$减去$x_i$</p><p>我们将在这个排列上行走的过程看做连边，对于路径排列中相邻的两个位置$p_i,p_{i+1}$，我们将其看做是从$p_i$向$p_{i+1}$连了一条有向边</p><p>我们将从左往右的边称为“前向边”，将从右往左的边称为“反向边”</p><p>可以看出，这其实是一个前向边与反向边匹配的过程</p><p>设$dp[i][j]$表示已经考虑了$1\sim i$这些位置，还有$j$条前向边等待匹配</p><p>从$e$向$s$也连接一条边，这样的话对于这个序列中的任意两个相邻的位置$(i,i+1)$，都应该满足这个条件：</p><ul><li>跨过这两个位置的前向边数量$=$跨过这两个位置的反向边数量</li></ul><p>接下来考虑从$dp[i-1][j]$转移出去</p><p>即$k$表示跨过$(i-1,i)$的正向边减去反向边有多少条</p><p>如果$i\leq \min(s,e)$或者$i&gt;\max(s,e)$，此时$k=j$</p><p>否则，如果$s<e$，此时相当于多了一条反向边，$k=j-1$；如果$s>e$，此时相当于多了一条正向边，$k=j+1$</p><p>如果$k<0$或者$k>n$，显然不合法</p><p>考虑接下来在$i$这个位置该如何转移，有四种情况</p><ul><li>一条正向边连向了$i$，同时$i$连出了一条反向边，未匹配的边减少$1$。代价为$a_i+c_i$（$d+b$已经在这条边的开头被计算过了）</li><li>一条正向边连向了$i$，同时$i$连出了一条正向边，未匹配的边不变。代价为$a_i+d_i$，同时要求$j&gt;0$（要不然哪来的未匹配的正向边）</li><li>钦定一条反向边会连向$i$，同时$i$连出了一条反向边，未匹配的边不变。代价为$b_i+c_i$，同时要求$k&gt;0$</li><li>钦定一条反向边会连向$i$，同时$i$连出了一条正向边，未匹配的边增加$1$。代价为$b_i+d_i$，同时要求$k&gt;0,j&gt;0$，否则这个序列左侧和右侧将不连通</li></ul><p>如果$i$是$s$或者$e$需要特殊转移</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line">LL dp[<span class="number">2</span>][N], A[N], B[N], C[N], D[N], dis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(LL &amp;x, LL y)</span> </span>&#123;<span class="keyword">if</span> (y &lt; x) x = y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, s, e; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;s, &amp;e);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;dis[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;A[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;B[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;C[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;D[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        C[i] += dis[i], B[i] -= dis[i], A[i] += dis[i], D[i] -= dis[i];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp)), dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = i &amp; <span class="number">1</span>; <span class="built_in">memset</span>(dp[cur], <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp[cur]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = j;</span><br><span class="line">            <span class="keyword">if</span> (min(s, e) &lt;= i &amp;&amp; i &lt; max(s, e)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s &lt; e) tmp--;</span><br><span class="line">                <span class="keyword">else</span> tmp++;</span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (tmp &lt; <span class="number">0</span> || tmp &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (i != s &amp;&amp; i != e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmp) update(dp[cur][j], dp[cur ^ <span class="number">1</span>][j] + C[i] + B[i]);</span><br><span class="line">                <span class="keyword">if</span> (j) update(dp[cur][j], dp[cur ^ <span class="number">1</span>][j] + A[i] + D[i]);</span><br><span class="line">                <span class="keyword">if</span> (j &amp;&amp; tmp) update(dp[cur][j], dp[cur ^ <span class="number">1</span>][j - <span class="number">1</span>] + B[i] + D[i]);</span><br><span class="line">                update(dp[cur][j], dp[cur ^ <span class="number">1</span>][j + <span class="number">1</span>] + A[i] + C[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == s) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j) update(dp[cur][j], dp[cur ^ <span class="number">1</span>][j - <span class="number">1</span>] + D[i]);</span><br><span class="line">                update(dp[cur][j], dp[cur ^ <span class="number">1</span>][j] + C[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                update(dp[cur][j], dp[cur ^ <span class="number">1</span>][j + <span class="number">1</span>] + A[i]);</span><br><span class="line">                update(dp[cur][j], dp[cur ^ <span class="number">1</span>][j] + B[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s &lt; e &amp;&amp; s &lt;= i &amp;&amp; i &lt; e || ((i &lt; min(s, e) || i &gt;= max(s, e)) &amp;&amp; i != n)) </span><br><span class="line">            dp[cur][<span class="number">0</span>] = <span class="number">1e18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[n &amp; <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF679E Bear and Bad Powers of 42</title>
      <link href="/2020/03/05/cf679e-bear-and-bad-powers-of-42/"/>
      <url>/2020/03/05/cf679e-bear-and-bad-powers-of-42/</url>
      
        <content type="html"><![CDATA[<p>我们称所有$42$的幂为<code>bad number</code>，其余的数为<code>good number</code></p><p>维护一个序列$A$，保证一开始每个数都是<code>good number</code>，支持三个操作</p><ul><li>$1\ i$ 输出$A_i$</li><li>$2\ a\ b\ x$ 将区间$[a,b]$都设为$x$，保证$x$是一个<code>good number</code></li><li>$3\ a\ b\ x$ 将区间$[a,b]$都加上$x$，如果操作结束之后这个区间至少存在一个<code>bad number</code>，则重复这一操作，直至所有数都变成<code>good number</code></li></ul><script type="math/tex; mode=display">n,q\leq 10^5,a_i,x\leq 10^9</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>$10^9$范围内$42$的幂是很少的，这意味着实际上$3$操作执行的总次数是$O(n)$级别的，我们可以模拟这个操作</p><p>那么如何快速判断当前区间是否需要再次操作呢</p><p>对于每个位置我们维护这个位置当前的数到下一个<code>bad number</code>所需要加的值，对于区间我们维护这个东西的最小值</p><p>如果当前区间的最小值$&lt; x$，这意味着有些数减爆了，我们递归下去处理减爆的数即可</p><p>因为一个数被减爆的次数不多，因此这样的势能线段树复杂度是对的</p><p>如果一次操作之后全局最小值等于$0$，这意味着当前至少有一个数是<code>bad number</code>，此时我们再次执行这个区间加操作，知道全局最小值大于$0$即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line">LL Pow[<span class="number">13</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Rank</span><span class="params">(<span class="keyword">const</span> LL &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lower_bound(Pow, Pow + <span class="number">12</span>, x) - Pow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, level; LL diff, tag, cover;</span><br><span class="line">&#125; T[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Cover</span><span class="params">(<span class="keyword">int</span> rt, LL val)</span> </span>&#123;</span><br><span class="line">    T[rt].level = Rank(val), T[rt].diff = Pow[T[rt].level] - val, T[rt].tag = <span class="number">0</span>, T[rt].cover = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Increase</span><span class="params">(<span class="keyword">int</span> rt, LL val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T[rt].cover) T[rt].cover += val;</span><br><span class="line">    <span class="keyword">else</span> T[rt].tag += val;</span><br><span class="line">    T[rt].diff -= val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T[rt].cover) Cover(rt &lt;&lt; <span class="number">1</span>, T[rt].cover), Cover(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, T[rt].cover), T[rt].cover = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (T[rt].tag) Increase(rt &lt;&lt; <span class="number">1</span>, T[rt].tag), Increase(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, T[rt].tag), T[rt].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    T[rt].diff = min(T[rt &lt;&lt; <span class="number">1</span>].diff, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].diff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    T[rt].l = l, T[rt].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> Cover(rt, t[l]), <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; </span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span>, l, mid), build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r), pushup(rt); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> val, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> type ? Cover(rt, val) : Increase(rt, val), <span class="keyword">void</span>();</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, start, end, val, type);</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, start, end, val, type);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T[rt].diff &gt;= <span class="number">0</span>) <span class="keyword">return</span> T[rt].diff;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        LL val = Pow[T[rt].level] - T[rt].diff;</span><br><span class="line">        T[rt].level = Rank(val), T[rt].diff = Pow[T[rt].level] - val;</span><br><span class="line">        <span class="keyword">return</span> T[rt].diff;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    LL res1 = query(rt &lt;&lt; <span class="number">1</span>), res2 = query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> pushup(rt), min(res1, res2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> Pow[T[rt].level] - T[rt].diff;</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span>, pos);</span><br><span class="line">    <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">11</span>; i++) Pow[i] = Pow[i - <span class="number">1</span>] * <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">int</span> n, q; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t[i]);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, a, b, c; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;op, &amp;a);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(<span class="number">1</span>, a));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;b, &amp;c), update(<span class="number">1</span>, a, b, c, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;b, &amp;c);</span><br><span class="line">            <span class="function"><span class="keyword">do</span> <span class="title">update</span><span class="params">(<span class="number">1</span>, a, b, c, <span class="number">0</span>)</span></span>; <span class="keyword">while</span> (!query(<span class="number">1</span>)); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF704D Captain America</title>
      <link href="/2020/03/05/cf704d-captain-america/"/>
      <url>/2020/03/05/cf704d-captain-america/</url>
      
        <content type="html"><![CDATA[<p>二维平面上有$n$个点，第$i$个点的坐标为$(x_i,y_i)$</p><p>你需要将每个点涂成红色或者蓝色，涂成红色的代价为$r$，涂成蓝色的代价为$b$</p><p>有$m$个限制，第$i$个限制可以描述为三个整数$(t_i,l_i,d_i)$，表示</p><ul><li>如果$t_i=1$，那么在直线$x=l_i$上红色与蓝色的点个数之差的绝对值不超过$d_i$</li><li>如果$t_i=2$，那么在直线$y=l_i$上红色与蓝色的点个数之差的绝对值不超过$d_i$</li></ul><p>你需要找出满足上述条件的最小代价，要求输出方案</p><script type="math/tex; mode=display">n,m\leq 10^5,r,b,l_i\leq 10^9</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>不妨设$r\leq b$</p><p>如果我们将每一行看做一个点，将每一列也看做一个点，然后将原来二维平面上的一个点看做连接所在行与所在列的一条边，显然得到的将会是一个二分图</p><p>每个限制等价于要求某一行/某一列红色的点数在一段区间内，可以看做是源点/汇点到这一行/这一列所代表的点的边的流量有一个上下界</p><p>由于$r\leq b$，我们想让红色的点尽量多，因此这实际上是一个上下界最大流问题</p><p>回忆一下上下界最大流是咋求的，如果一条边$u\rightarrow v$的流量限制为$[l,r]$，那么我们将这条边的容量改为$r-l$，同时将<code>extra[v]</code>加上$l$，将<code>extra[u]</code>减去$l$</p><p>同时需要从汇点向源点连一条容量为无穷大的边</p><p>这里<code>extra[i]</code>表示$i$点需要补偿的额外流量</p><p>如果最后<code>extra[u]</code>大于$0$，我们就从源点向这个点连边，容量为<code>extra[u]</code>，否则我们从这个点向汇点连边</p><p>求完可行流之后删去汇点向源点的连边，在残量网络上继续增广即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int LL</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;</span><br><span class="line">&#125; e[N * <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt = <span class="number">1</span>, extra[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from], w&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to], <span class="number">0</span>&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> down, <span class="keyword">int</span> up)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> delta = up - down; adde(from, to, delta);</span><br><span class="line">    extra[to] += down, extra[from] -= down;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dep[N], cur[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span>(dep)), dep[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; q.push(s);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">            <span class="keyword">if</span> (e[i].w &amp;&amp; !dep[e[i].to]) &#123;</span><br><span class="line">                assert(e[i].w &gt; <span class="number">0</span>);</span><br><span class="line">                dep[e[i].to] = dep[u] + <span class="number">1</span>, q.push(e[i].to);</span><br><span class="line">                <span class="keyword">if</span> (e[i].to == t) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == t || !f) <span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u], tmp; i; i = e[i].next) </span><br><span class="line">        <span class="keyword">if</span> (e[i].w &amp;&amp; dep[e[i].to] == dep[u] + <span class="number">1</span> &amp;&amp; (tmp = DFS(e[i].to, min(f, e[i].w), t))) &#123;</span><br><span class="line">            e[i].w -= tmp, e[i ^ <span class="number">1</span>].w += tmp, f -= tmp, res += tmp;</span><br><span class="line">            <span class="keyword">if</span> (!f) <span class="keyword">break</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (BFS(s, t)) <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span>(head)), res += DFS(s, <span class="number">1e18</span>, t);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">FUCKYPJ</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = T + <span class="number">1</span>, t = s + <span class="number">1</span>, tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">if</span> (extra[i] &gt; <span class="number">0</span>) </span><br><span class="line">            adde(s, i, extra[i]), tot += extra[i];</span><br><span class="line">        <span class="keyword">else</span> adde(i, t, -extra[i]);</span><br><span class="line">    adde(T, S, <span class="number">0</span>, <span class="number">1e9</span>);</span><br><span class="line">    <span class="keyword">if</span> (dinic(s, t) != tot) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[S]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to == T) res = e[i].w, e[i].w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> res + dinic(S, T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[N], y[N], id[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; X, Y, X1, Y1, X2, Y2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, r, b, flag = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>, &amp;n, &amp;m, &amp;r, &amp;b);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; b) swap(r, b), flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;x[i], &amp;y[i]), X[x[i]]++, Y[y[i]]++;</span><br><span class="line">    <span class="keyword">int</span> A = X.size(), B = Y.size(), s = A + B + <span class="number">1</span>, t = s + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t, l, d; <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;t, &amp;l, &amp;d);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!X1.count(l)) X1[l] = d;</span><br><span class="line">            <span class="keyword">else</span> X1[l] = min(X1[l], d);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Y1.count(l)) Y1[l] = d;</span><br><span class="line">            <span class="keyword">else</span> Y1[l] = min(Y1[l], d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ct = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : X) &#123;</span><br><span class="line">        <span class="keyword">int</span> t1 = t.first, all = t.second;</span><br><span class="line">        X2[t1] = ++ct; <span class="keyword">int</span> lim = X1.count(t1) ? X1[t1] : <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">int</span> L = (all - lim + <span class="number">1</span>) / <span class="number">2</span>, R = min(n, (all + lim) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span>;</span><br><span class="line">        adde(s, ct, L, R);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> T : Y) &#123;</span><br><span class="line">        <span class="keyword">int</span> t1 = T.first, all = T.second;</span><br><span class="line">        Y2[t1] = ++ct; <span class="keyword">int</span> lim = Y1.count(t1) ? Y1[t1] : <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">int</span> L = max(<span class="number">0l</span>l, (all - lim + <span class="number">1</span>) / <span class="number">2</span>), R = min(n, (all + lim) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span>;</span><br><span class="line">        adde(ct, t, L, R);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        adde(X2[x[i]], Y2[y[i]], <span class="number">0</span>, <span class="number">1</span>), id[i] = ecnt - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = FUCKYPJ(s, t, t);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (LL)res * r + (LL)(n - res) * b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = e[id[i]].w ^ flag;</span><br><span class="line">            <span class="keyword">if</span> (!t) <span class="built_in">putchar</span>(<span class="string">'r'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">'b'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC024D Isomorphism Freak</title>
      <link href="/2020/03/05/agc024d-isomorphism-freak/"/>
      <url>/2020/03/05/agc024d-isomorphism-freak/</url>
      
        <content type="html"><![CDATA[<p>定义一棵树$T$上两个点等价当且仅当以这两个点为根时得到的数同构</p><p>定义$T$的权值为$T$的等价类数量</p><p>$T$一开始有$N$个节点，你可以在这棵树上加若干个叶子，问加完之和这棵树的权值最小是多少，以及在满足权值最小的前提之下$T$中的最小叶子数</p><script type="math/tex; mode=display">N\leq 100</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>通过观察样例可以得出，如果这棵树的直径包含的点数为$d$，那么第一问的答案为$\lfloor\frac{d}{2}\rfloor$</p><p>容易看出这实际上是答案的下界，因为如果$a,b$两点在直径上不对称，那么从$a,b$出发的最长路径长度都不一样，因此这两个点不可能等价</p><p>而我们又一定能够构造出等价类个数恰好等于$\lfloor\frac{d}{2}\rfloor$的方案，因此第一问的答案就是这个</p><p>接下来考虑如何构造</p><p>如果直径中包含偶数个点，我们从这条直径最中间那条边将直径分为两半，左边和右边应当对称</p><p>我们根据到这条边两个端点中较近的那个点的距离将所有点分为$\frac{d}{2}$个等价类</p><p>可以发现此时左侧和右侧的子树的相同层的节点的儿子个数也应该是相同的</p><p>因此可以用类似<code>BFS</code>的方式确定第二问的答案，我们一层一层地<code>BFS</code>，每一层记录儿子个数最多的那个节点，然后将当前层所有点的儿子个数都整成这个最大值</p><p>如果直径中包含奇数个点，有两种构造方式</p><p>第一种是在直径上接一个点，转化为直径长度为偶数的情况，此时第一问的答案不会增加</p><p>第二种是我们找到直径最中间的那个点，然后将其它点到这个点的距离将所有点分为$\lfloor\frac{d}{2}\rfloor$个等价类</p><p>可以发现此时如果将这个点作为根，那么相同深度的点的儿子个数也应当相同</p><p>类似之前<code>BFS</code>的方法，找到每一层儿子个数最多的点即可</p><p>代码如下</p><p>``` cpp</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><p>using namespace std;</p><p>const int N = 110;</p><p>typedef long long LL;</p><p>vector<int> G[N];</p><p>int dep[N], mx, pos, tmp[N], fuck[N], n;</p><p>void dfs(int u, int f) {<br>    dep[u] = dep[f] + 1, tmp[u] = u, fuck[u] = dep[u];<br>    if (dep[u] &gt; mx) mx = dep[u], pos = u;<br>    for (auto v : G[u]) if (v != f) {<br>        dfs(v, u);<br>        if (fuck[v] &gt; fuck[tmp[u]]) tmp[u] = v;<br>        fuck[u] = max(fuck[u], fuck[v]);<br>    }<br>}</p><p>int ans1;</p><p>inline LL work1(int pos) {<br>    mx = 0, dfs(pos, 0);<br>    if (mx != ans1) return 1e18;<br>    vector<int> A, B; A.push_back(pos);<br>    for (auto v : G[pos]) B.push_back(v);<br>    LL nw = B.size();<br>    while (233) {<br>        swap(A, B), B.clear(); int t = 0;<br>        for (auto u : A) {<br>            t = max((int)G[u].size() - 1, t);<br>            for (auto v : G[u]) if (dep[v] &gt; dep[u])<br>                B.push_back(v);<br>        }<br>        if (!t) return nw;<br>        if (1e18 / t &lt; nw) return 1e18;<br>        nw *= t;<br>    }<br>}</p><p>inline LL work2(int A, int B) {<br>    int nw = n + 1;<br>    for (auto &amp;v : G[A]) if (v == B) { v = nw; break; }<br>    for (auto &amp;v : G[B]) if (v == A) { v = nw; break; }<br>    G[nw].push_back(A), G[nw].push_back(B);<br>    ans1++; LL ans = work1(nw); ans1—;<br>    for (auto &amp;v : G[A]) if (v == nw) { v = B; break; }<br>    for (auto &amp;v : G[B]) if (v == nw) { v = A; break; }<br>    G[nw].clear();<br>    return ans;<br>}</p><p>int main() {<br>    scanf(“%d”, &amp;n);<br>    for (int i = 1, a, b; i &lt; n; i++)<br>        scanf(“%d%d”, &amp;a, &amp;b), G[a].push_back(b), G[b].push_back(a);<br>    dfs(1, 0); int A = pos; mx = 0;<br>    dfs(A, 0); int B = pos;<br>    vector<int> hh;<br>    while (233) {<br>        hh.push_back(A);<br>        if (A == B) break;<br>        A = tmp[A];<br>    }<br>    printf(“%d “, ans1 = (hh.size() + 1) / 2);<br>    LL ans2 = 1e18;<br>    for (int i = 1; i &lt;= n; i++)<br>        for (auto j : G[i]) if (i &lt; j) ans2 = min(ans2, work2(i, j));<br>    if (hh.size() &amp; 1) {<br>        int mid = hh[hh.size() / 2];<br>        printf(“%lld\n”, min(work1(mid), ans2));<br>    } else {<br>        printf(“%lld\n”, ans2);<br>    }<br>    return 0;<br>}<br>``</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC024F Simple Subsequence Problem</title>
      <link href="/2020/03/05/agc024f-simple-subsequence-problem/"/>
      <url>/2020/03/05/agc024f-simple-subsequence-problem/</url>
      
        <content type="html"><![CDATA[<p>给出$N+1$个$01$串$S_0,S_1,\cdots S_N$，下标为$i$的串的长度为$2^i$</p><p>每个串的每一位都代表了一个二进制串，如果$S_i$的第$j$位为$1$，表示存在一个长度为$i$的二进制串，这个串是$j$的二进制表示，在最高位之前补$0$。注意这里认为一个字符串的下标是从$0$开始的</p><p>我们记表示出来的这些串构成的集合为$S$</p><p>你需要找到一个字典序最小的二进制串，使得这个串是$S$中至少$K$个串的子序列</p><script type="math/tex; mode=display">N\leq 20,K\leq |S|</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>如果判断$A$是否是$B$的子序列，我们可以建出子序列自动机。对于每一次匹配我们找到下一个$0$以及下一个$1$的位置，再根据$A$这一位是啥来决定跳到哪里</p><p>由于要求答案的字典序最小，显然我们需要逐位确定答案，难点在于不能快速确定当前状态是多少个串的子序列</p><p>考虑沿用之前子序列自动机的方法，但不同的是，这里我们枚举目标串还能用于匹配的后缀是啥。相当于我们将所有串分成了若干类，每一类在匹配完当前的答案串之和剩余的串是相同的</p><p>设$dp[s_1][s_2]$表示有多少个串满足，当前答案串为$s_1$，这个串还能用于匹配的后缀为$s_2$</p><p>每次我们枚举答案的下一位是$0$还是$1$。如果下一位是$0$，那么这就意味着$s_2$在第一个$0$之前的所有位都不能用于匹配了，此时我们需要将第一个$0$以及前面的所有位删去。如果下一位是$1$，那么我们需要把第一个$1$以及前面的所有位删去。用这种类似$dp$的方法，我们就能确定当前的答案串是多少个串的子串</p><p>由于$s_1$和$s_2$的长度之和不会超过$N+1$，因此状态总是是$2^{N+1}$。为了方便，我们用$s_2$的最高位来表示还未匹配的串的长度，当前串在匹配$0/1$之和的状态是可以预处理出来的</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最高位代表其长度 1 &lt;&lt; i -&gt; 长度为 i </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *dp[<span class="number">1</span> &lt;&lt; N], tp[<span class="number">2</span>][<span class="number">1</span> &lt;&lt; N], fir[<span class="number">1</span> &lt;&lt; N]; <span class="keyword">char</span> s[<span class="number">1</span> &lt;&lt; N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span> &lt;&lt; n + <span class="number">1</span>], dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1</span> &lt;&lt; n + <span class="number">1</span>; i++) fir[i] = fir[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s); <span class="keyword">int</span> base = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; base; j++) </span><br><span class="line">            dp[<span class="number">1</span>][base | j] = s[j] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> all = base - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; base; j++) </span><br><span class="line">            tp[<span class="number">1</span>][base | j] = j;</span><br><span class="line">        tp[<span class="number">0</span>][base * <span class="number">2</span> - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + <span class="number">1</span> &lt; base; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = all ^ j, pos = fir[t]; </span><br><span class="line">            tp[<span class="number">0</span>][base | j] = (<span class="number">1</span> &lt;&lt; pos - <span class="number">1</span>) | (j &amp; ((<span class="number">1</span> &lt;&lt; pos - <span class="number">1</span>) - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> base = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = base - <span class="number">1</span>; s &gt;= <span class="number">0</span>; s--) &#123;</span><br><span class="line">            dp[base + s] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span> &lt;&lt; n + <span class="number">1</span> - i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n + <span class="number">1</span> - i); j++) dp[base + s][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">1</span> &lt;&lt; (n + <span class="number">1</span> - (i - <span class="number">1</span>)); j++) <span class="keyword">if</span> (tp[s &amp; <span class="number">1</span>][j])</span><br><span class="line">                dp[base + s][tp[s &amp; <span class="number">1</span>][j]] += dp[(base + s) &gt;&gt; <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; (<span class="number">1</span> &lt;&lt; n + <span class="number">1</span> - i); j++) tot += dp[base + s][j];</span><br><span class="line">            <span class="keyword">if</span> (tot &gt;= k) res = base + s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = fir[res];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res &amp; (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)) <span class="built_in">putchar</span>(<span class="string">'1'</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 状态压缩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC021E Ball Eat Chameleons</title>
      <link href="/2020/03/05/agc021e-ball-eat-chameleons/"/>
      <url>/2020/03/05/agc021e-ball-eat-chameleons/</url>
      
        <content type="html"><![CDATA[<p>有$n$只神奇的变色龙，每只变色龙是红色或者蓝色，一开始所有变色龙都是蓝色的</p><p>如果一只红色的变色龙吃下的蓝球数严格大于其吃下的红球数，那么它会变成蓝色，蓝色变色龙同理</p><p>有$k$个红蓝球，定义一种颜色序列是合法的当且仅当存在一种给变色龙喂球的方式，使得最后所有的变色龙都是红色</p><p>给定$n,k$，求方案数，对$998244353$取模</p><script type="math/tex; mode=display">n,k\leq 5\times 10^5</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>对于一只变色龙来说，我们考虑它什么时候会是红色</p><ul><li>吃下的红球数大于其吃下的蓝球数</li><li>吃下的红球数等于其吃下的蓝球数，并且最后一个吃下的是蓝球</li></ul><p>第一种变色龙需要的红球数量比蓝球数量多$1$，而第二种变色龙需要的红球数量和蓝球数量相等</p><p>同时，我们知道这样一个结论：如果某个序列能使得所有变色龙都变成红色，那么将这个序列中的蓝球变为红球仍然能够满足条件</p><p>因此我们需要构造一种贪心策略，使得所有变色龙需要的红球数量更少</p><p>记$R,B$分别代表红球数量和蓝球数量，我们分几种情况讨论</p><ul><li>$R&lt;B$</li></ul><p>无论怎么分配，总会有一只变色龙吃到的红球比蓝球少，那么这只变色龙就无法变为红色，因此方案数为$0$</p><ul><li>$R=B$</li></ul><p>所有的变色龙都只能是第二种变色龙，因为没有红球可以拿来浪费</p><p>最后一个球肯定是某一只变色龙吃下的最后一个球，因此这个球只能是蓝色</p><p>我们构造这样一种贪心策略：找到$n$对匹配的$RB$，这里的匹配指的是$B$在$R$后面并且每个$B,R$只能用一次，然后喂给所有变色龙（用前$n$个$R$匹配最后$n$个$B$，可以保证最后一个$B$此时一定被一只变色龙吃掉）</p><p>接着，将所有剩下的球都塞给吃掉最后那个$B$的变色龙</p><p>接下来，我们证明上面贪心的正确性</p><p><strong>1.如果一只变色龙能够变为红色，那么它需要的红球数越少越好</strong></p><p>本来这只变色龙占用的第二个红球是有可能使得一只蓝色变色龙变为红色的，但是现在被浪费了，因此一定不优秀</p><p>因此我们要尽可能使得有尽量多的变色龙最后吃到球的序列是$RB$</p><p><strong>2.一种合法方案必须存在$n$个匹配</strong></p><p>如果匹配数小于$n$，我们消去所有匹配的位置之后剩下的是一串$BBB\cdots RRR\cdots$的序列，并且$RB$数量相等</p><p>但是此时，仍然有变色龙是蓝色的</p><p>此时如果我们要将一只蓝色的变色龙变成红色，必然会使得红球的数量比蓝球的数量多减少一个，然后剩下的红球数量就小于蓝球数量了</p><p>所以，我们可以得出当$R=B$时的充分必要条件</p><p>1.最后一个球是蓝色<br>2.存在至少$n$对匹配的$RB$</p><p>那么如何计数呢？考虑到卡特兰数实际上就是$R,B$存在完美匹配的方案数，那么我们可以考虑将序列变为折线</p><p>我们考虑这样一条折线：</p><p>一开始在原点，依次考虑序列中的每一个位置，如果某一个位置是红球，那么往右上走一步；如果某一个位置是蓝球，那么往右下走一步</p><p>当我们从第一象限走到了第四象限，这就意味着一个蓝球没能与之前的红球匹配，换句话说，这个蓝球被浪费掉了，等价于浪费一个红球（少了一组匹配）</p><p>因此，我们需要保证的条件是：没有被浪费的红球仍然大于等于$n$个，即被浪费的蓝球小于等于$B−n$个。这等价于折线不能跨越$y=−(B−n)$这条直线，并且最后走到了$(k−1,1)$这个点，最后再走一步到达$(k,0)$</p><p>那么有</p><script type="math/tex; mode=display">\begin{cases}R+B=k-1\\ R-B=2(-(B-n)-1)-1\end{cases}\Rightarrow R=2n-2</script><p>方案数为${k-1\choose R}-{k-1\choose 2n-2}={k-1\choose R}-{k-1\choose 2R-n+1}$</p><ul><li>$R&gt;B$</li></ul><p>稍微更改一下贪心策略</p><p>我们知道最多有$R−B$个红球可以被浪费掉，因此$RB$匹配的数量至少要是$n−(R−B)$个</p><p>因此策略为：选出$n−(R−B)$只变色龙吃$RB$，剩下的变色龙随便分配，只需要满足每只变色龙吃到的红球数大于蓝球数即可</p><p>如果$RB$对的数量少于这个数，那么剩下的每一只变色龙必然会浪费一个红球，不可能出现“红蓝相等，且最后一个是蓝球”的情况，因为这样的话必然会产生新的$RB$对，与尽量匹配这个条件矛盾</p><p>与$R=B$的情况类似，这等价与一条从$(0,0)$到$(k,0)$的折线，没有浪费的蓝球仍然大于等于$n−(R−B)$个，即浪费的蓝球小于等于$B−(n−(R−B))=R−n$个，不能跨越$y=−(R−n)$这条折线</p><p>计算与上面类似，可以算出方案数为${k\choose R}-{k\choose 2R-n+1}$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &gt; n || r &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, res = <span class="number">0</span>; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k; </span><br><span class="line">    frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> R = n; R &lt;= k; R++) <span class="keyword">if</span> (R &gt;= k - R) &#123;</span><br><span class="line">        <span class="keyword">if</span> (R == k - R) res = (res + C(k - <span class="number">1</span>, R) - C(k - <span class="number">1</span>, R * <span class="number">2</span> - n + <span class="number">1</span>)) % mod;</span><br><span class="line">        <span class="keyword">else</span> res = (res + C(k, R) - C(k, R * <span class="number">2</span> - n + <span class="number">1</span>)) % mod;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (res + mod) % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC029C Lexicographic constraints</title>
      <link href="/2020/03/05/agc029c-lexicographic-constraints/"/>
      <url>/2020/03/05/agc029c-lexicographic-constraints/</url>
      
        <content type="html"><![CDATA[<p>有$N$个字符串排成一行，第$i$个字符串是$S_i$，长度为$A_i$</p><p>现在要求任意相邻的两个字符串$S_{i},S_{i+1}$都满足$S_i&lt;S_{i+1}$，即$S_i$的字典序比$S_{i+1}$小，问构成$S_1,S_2,\cdots, S_N$的字符集大小至少是多少</p><script type="math/tex; mode=display">N\leq 2\times 10^5, A_i\leq 10^9</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>先二分答案$mid$，考虑如何从$S_i$推到$S_{i+1}$</p><p>如果$A_i&lt;A_{i+1}$，我们可以直接在$S_i$后面塞$A_{i+1}-A_i$个$0$</p><p>否则我们保留$S_i$的前$A_{i+1}$位，并给$S_i$在$mid$进制下$+1$即可</p><p>开个<code>set</code>维护$S_i$中所有非$0$的位置，这样的位置只有$O(N)$个</p><p>进位的时候我们不停地将$S_i$的最后一位拿出来，判断是否等于$mid-1$，如果不等于的话让它加$1$，同时进位结束，否则删去这个位置，继续尝试进位</p><p>如果一直进到了最高位都不够，那么$mid$就是不合法的</p><p>注意需要特判$1$进制，因为一进位就炸了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;P&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="keyword">if</span> (A[i] &lt;= A[i - <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">while</span> (s.size() &amp;&amp; s.rbegin() -&gt; first &gt; A[i]) s.erase(*s.rbegin());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = A[i]; ; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!j) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (s.size() &amp;&amp; j == s.rbegin() -&gt; first) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.rbegin() -&gt; second &lt; mid - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> t = *s.rbegin(); s.erase(t), t.second++;</span><br><span class="line">                    s.insert(t); <span class="keyword">break</span>;    </span><br><span class="line">                &#125; <span class="keyword">else</span> s.erase(*s.rbegin());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (mid == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                s.insert(P(j, <span class="number">1</span>)); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n, mid, ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid - <span class="number">1</span>, ans = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC024E Sequence Growing Hard</title>
      <link href="/2020/03/05/agc024e-sequence-growing-hard/"/>
      <url>/2020/03/05/agc024e-sequence-growing-hard/</url>
      
        <content type="html"><![CDATA[<p>统计序列$(A_0,A_1,\cdots,A_N)$的数量，其中$A_0,A_1,\cdots, A_N$也是序列，满足</p><ul><li>$A_i$的长度为$i$，且每个数都在$[1,K]$之间</li><li>$A_i$是$A_{i+1}$的子序列</li><li>$A_i$的字典序小于$A_{i+1}$</li></ul><p>对$M$取模</p><script type="math/tex; mode=display">N,K\leq 300, M\leq 10^9</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>由于$A_{i-1}$是$A_i$的子序列，并且$A_i$的长度恰好比$A_{i-1}$的长度多$1$</p><p>因此我们可以看做$A_i$在$A_{i-1}$的基础上插入了一个数</p><p>插入的这个数后面那个数一定小于这个数（如果后面那个数等于插入的数，则可以将当前数往后挪动）</p><p>因此这个序列可以看做一棵树，一开始我们让数的根节点为$0$，每次如果我们将$x$插入$y$之前，那么看做$y$作为父亲向$x$连了一条边</p><p>这棵树的儿子是有顺序的，可以发现一棵树唯一地对应了一个序列，因此我们只需要统计有多少种不同的树即可</p><p>唯一的限制是：父亲节点的权值必须小于儿子的权值</p><p>考虑从叶子向根$dp$，设$dp[i][j]$表示$j$的子树有$i$个节点的方案数</p><p>转移的时候枚举当前根最靠左的儿子所在的子树的大小，可以得到</p><script type="math/tex; mode=display">dp[i][j]=\sum_{k=1}^{i-1}dp[i-k][j]{i-2\choose k-1}\sum_{l\geq j+1} dp[k][l]</script><p>可以前缀和优化</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[N][N], C[N][N], sum[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, mod; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;k, &amp;mod), n++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) C[i][j] = (C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) sum[<span class="number">1</span>][i] = k - i + <span class="number">1</span>, dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt; i; t++) </span><br><span class="line">                dp[i][j] = (dp[i][j] + (LL)dp[i - t][j] * C[i - <span class="number">2</span>][t - <span class="number">1</span>] % mod * sum[t][j + <span class="number">1</span>]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &gt;= <span class="number">1</span>; j--) sum[i][j] = (sum[i][j + <span class="number">1</span>] + dp[i][j]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[n][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC028D Chords</title>
      <link href="/2020/03/05/agc028d-chords/"/>
      <url>/2020/03/05/agc028d-chords/</url>
      
        <content type="html"><![CDATA[<p>圆上有$2N$个点，你需要将它们两两配对，因此一共会连出$N$条边</p><p>这$N$条边中有$K$条边是已经确定好的，第$i$条边连接$A_i,B_i$</p><p>你需要求出剩下的所有配对方式中连通块个数的总和</p><p>$N\leq 300$，对$10^9+7$取模</p><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>考虑统计每一个连通块在多少种匹配里面出现过，将它们加起来就是答案</p><p>每个连通块中一定有一个编号最小的点$i$，也一定有一个编号最大的点$j$</p><p>考虑用$i,j$表示一个连通块，设$f[i][j]$表示仅考虑$i\leq k\leq j$的所有点的匹配，该连通块在多少种匹配里面出现过</p><p>如果这些点中至少有一条连到$[i,j]$之外的边，我们认为$f[i][j]=0$</p><p>直接统计$i,j$连通的方案数不是很好算，考虑用总数减去不合法的状态</p><p>记$g[i]$表示$i$个点匹配的方案数，显然有$g[i]=(i-1)\times(i-3)\times\cdots 1$，且$i$必须为偶数</p><p>记$h[i][j]$表示$[i,j]$中有多少个点没有连出的边</p><p>那么可以得到转移：</p><script type="math/tex; mode=display">f[i,j]=g[h[i,j]]-\sum_{k=i}^{j-1}f[i][k]\times g[h[k+1][j]]</script><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">610</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N][N], g[N], G[N], cnt[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k), n *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), G[a] = b, G[b] = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j++) </span><br><span class="line">            cnt[i][j] = cnt[i][j - <span class="number">1</span>] + !G[j];</span><br><span class="line">    g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">        g[i] = (LL)g[i - <span class="number">2</span>] * (i - <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j &amp;&amp; flag; k++)</span><br><span class="line">                <span class="keyword">if</span> (G[k] &amp;&amp; (G[k] &lt; i || G[k] &gt; j)) flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!flag) <span class="keyword">continue</span>;</span><br><span class="line">            f[i][j] = g[cnt[i][j]];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; k++) </span><br><span class="line">                f[i][j] = (f[i][j] - (LL)f[i][k] * g[cnt[k + <span class="number">1</span>][j]] % mod + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j++)</span><br><span class="line">            res = (res + (LL)f[i][j] * g[n - k * <span class="number">2</span> - cnt[i][j]]) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 容斥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARC102F Revenge of BBuBBBlesort!</title>
      <link href="/2020/03/05/arc102f-revenge-of-bbubbblesort/"/>
      <url>/2020/03/05/arc102f-revenge-of-bbubbblesort/</url>
      
        <content type="html"><![CDATA[<p>给出一个$1\sim N$的排列$p_1,p_2,\cdots,p_N$，每次你可以选择三个连续的位置$i-1,i,i+1$，满足$p_{i-1}&gt;p_i&gt;p_{i+1}$并交换$p_{i-1}$和$p_{i+1}$。问能否经过若干次操作使得最后的排列是$1,2,\cdots n$</p><script type="math/tex; mode=display">N\leq 3\times 10^5</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>将操作反过来，问题转化为对于$a=\{1,2,\cdots n\}$，判断能否通过交换若干次$i-1,i+1$，满足$a_{i-1}&lt;a_i&lt;a_{i+1}$，从而达到状态$p$</p><p>可以发现一个性质：如果我们以$i$为中心进行了一次翻转，那么$i-1,i+1$就永远都不能成为翻转的中心了</p><p>考虑证明这个性质，假设翻转了$i$，那么翻转之后$a_{i-2}<a_{i-1}>a_i&gt;a_{i+1}&lt;a_{i+2}$</p><p>考虑能否在$a_{i-1}$这个地方再进行一次翻转，要么需要把$a_i$换走，要么需要把$a_{i-1}$换走</p><p>如果要把$a_i$换走，那么就只能在$a_{i+1}$进行操作，因此$a_i$是换不走的</p><p>否则我们只能将$a_{i-1}$换走，但是这会导致换走之后$a_{i-2}&gt;a_{i-1}$，仍然不满足条件，因此结论成立</p><p>我们称此时$i-1,i+1$为不动点</p><p>因此，如果某一个位置上的数一开始就满足$p_i=i$，那么这个位置是无论如何都不能被换走的，因为换走之后就再也换不回来了</p><p>同理，如果一个数一开始往左换了，那么这个数会一直往左，如果这个数开始是往右换的，那么这个数会一直往右</p><p>因此，如果两个位置都需要往左/往右换，那么这两个数在换的过程中的相对顺序不会发生变化，否则必定有一个数跨过了另一个数，与上一行的结论矛盾</p><p>假设$a&lt;b&lt;c$，此时我们交换了$a,c$，并且这两个位置都变成了不动点，这意味着$b$换不走了，因此$a$无论如何都不可能换到$b$右边去</p><p>因此我们每次交换的中心都必定满足$p_i=i$</p><p>如果两个相邻的位置满足$p_i=i,p_{i+1}=i+1$，显然$i$左边的数永远无法换到$i+1$右边去，$i+1$右边的数也无法换到$i$左边来</p><p>考虑根据这个将原排列分成极长的若干段，每段必须满足所有偶数位置的数都满足$p_i=i$，且所有奇数位置的数都满足$p_i\neq i$</p><p>假设这一段为$[l,r]$，那么这一段区间中所有数的值都必须在$[l,r]$中，因为这一段是换不出去的</p><p>将所有奇数位置的数按照往左/往右换分成两类，往左换的必须递增，往右换的必须递减</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num[l] == l) l++;</span><br><span class="line">    <span class="keyword">if</span> (num[r] == r) r--;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i += <span class="number">2</span>) </span><br><span class="line">        <span class="keyword">if</span> (num[i] != i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i += <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (num[i] == i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> mn = <span class="number">1e9</span>, mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) </span><br><span class="line">        mn = min(mn, num[i]), mx = max(mx, num[i]);</span><br><span class="line">    <span class="keyword">if</span> (mn != l || mx != r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l, a = <span class="number">0</span>, b = <span class="number">0</span>; i &lt;= r; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[i] &lt; i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a &gt; num[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            a = num[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &gt; num[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            b = num[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fuck[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]), fuck[i] = num[i] == i;</span><br><span class="line">    <span class="keyword">int</span> ls = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fuck[i] &amp;&amp; fuck[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!check(ls, i - <span class="number">2</span>)) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No"</span>), <span class="number">0</span>;</span><br><span class="line">            ls = i + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!fuck[i] &amp;&amp; !fuck[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!check(ls, i - <span class="number">1</span>)) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No"</span>), <span class="number">0</span>;</span><br><span class="line">            ls = i;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!check(ls, n)) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No"</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC027E ABBreviate</title>
      <link href="/2020/03/05/agc027e-abbreviate/"/>
      <url>/2020/03/05/agc027e-abbreviate/</url>
      
        <content type="html"><![CDATA[<p>给出一个仅包含<code>a</code>和<code>b</code>的串$s$，你可以进行若干次如下的操作</p><ul><li>将两个相邻的<code>a</code>替换为<code>b</code></li><li>将两个相邻的<code>b</code>替换为<code>a</code></li></ul><p>问$s$经过若干次操作之后可能形成多少种不同的串</p><p>$|s|\leq 10^5$，对$10^9+7$取模</p><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>非常神仙的一道题</p><p>如果给出的串不能操作，即形如<code>abab...</code>，那么答案为$1$</p><p>如果我们令<code>a</code>$=1$，<code>b</code>$=2$，然后考虑$s$在模$3$意义下的和，可以发现在每次操作之后的和是不变的</p><p>不难得出这样一个结论：如果$s$经过若干次操作之后能变为一个字符$c$，那么要么$s=c$，要么$s$在模$3$意义下的和与$c$相等，且$s$中有相邻且相同的字符</p><p>现在考虑这样一个问题：给出串$t$，如何判断$s$经过若干次操作之后能否得到$t$？</p><p>显然$t$一定是这样得到的：将$s$划分为若干段，每段依次对应$t$中的一个字符</p><p>如果我们对$s$贪心地划分，即每次找到长度最短的一段，使得这一段在模$3$下的和与$t$的当前字符相等，接下来我们尝试证明这样一个结论：$s$能转化为$t$当且仅当最后剩余的一段在模$3$下的和为$0$</p><p>我们尝试将最后多余的一段与倒数第二段合并，如果合并之后的串能操作，那么结论成立</p><p>否则合并之后的串形如<code>abab...</code>，这说明倒数第二段一定只有一个字符且与$t$的对应字符相同，否则倒数第二段必然有两个相邻且相同的字符，与不能合并矛盾</p><p>我们不妨假设这个字符为<code>a</code>，由于最后一段的和为$0$，这意味着最后一个字符必然是$a$</p><p>此时我们可以留下最后一个字符与$t$的最后一个字符匹配，前面的串继续向前合并，显然这个向前合并的串的和也是$0$</p><p>由于$s$串至少存在一对相邻且相同的字符，因此当合并的过程接触到这个字符的时候合并就结束了，此时$s$的每一段都能操作且对应$t$的某个字符</p><p>考虑倒推，设$dp[i]$表示最后一段的结尾为$i$的方案数</p><p>如果$i+1\sim |s|$的和为$0$，那么$dp[i]$的初值为$1$，否则为$0$</p><p>由于是贪心匹配，因此我们需要记录从当前位置开始，至少要选多少个字符才能使得和为$1/2$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> pre[N], dp[N], nxt[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>); <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        pre[i] = (pre[i - <span class="number">1</span>] + s[i] - <span class="string">'a'</span> + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"1"</span>), <span class="number">0</span>;</span><br><span class="line">    nxt[<span class="number">0</span>] = nxt[<span class="number">1</span>] = nxt[<span class="number">2</span>] = n + <span class="number">1</span>, dp[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre[i - <span class="number">1</span>] == pre[n] &amp;&amp; i != <span class="number">1</span>) dp[i] = <span class="number">1</span>;</span><br><span class="line">        dp[i] = (dp[i] + dp[i + <span class="number">1</span>]) % mod;</span><br><span class="line">        <span class="keyword">int</span> nw = s[i] - <span class="string">'a'</span> + <span class="number">1</span>, t = (pre[i - <span class="number">1</span>] + <span class="number">3</span> - nw) % <span class="number">3</span>;</span><br><span class="line">        dp[i] = (dp[i] + dp[nxt[t] + <span class="number">1</span>]) % mod, nxt[pre[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC021F Trinity</title>
      <link href="/2020/03/04/agc021f-trinity/"/>
      <url>/2020/03/04/agc021f-trinity/</url>
      
        <content type="html"><![CDATA[<p>有一个$N\times M$的网格，每个格子被涂成了黑色或者白色</p><p>有三个数组$A,B,C$，其中$A$的长度为$N$，$B,C$的长度都是$M$</p><p>$A_i$表示第$i$行的所有黑色格子中列的最小值。如果这一行没有黑色格子，那么$A_i=M+1$</p><p>$B_i,C_i$分别表示第$i$列的所有黑色格子中行的最小值以及最大值。如果这一列没有黑色格子，那么$B_i=N+1,C_i=0$</p><p>你需要计算对于所有的染色方式，有多少种可能的$(A,B,C)$会出现</p><p>$N\leq 8000, M\leq 200$，对$998244353$取模</p><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>考虑一列一列地染色，并且我们只考虑那些出现过黑色格子的行</p><p>设$dp[i][j]$表示已经考虑了前$i$列，其中有$j$行被染成过黑色的方案数</p><p>假设现在要从$dp[i][j]$转移到$dp[i+1][j+k]$</p><p>如果$k=0$，这意味着这一列我们只能在那些已经出现过黑色格子的行染色。由于此时两种方案不同当且仅当这一列的$B,C$不同，因此方案数为${j+1\choose 2}+1$</p><p>如果$k\neq 0$，如果这$k$行和原来的$j$行已经排列好了，那么要么我们在新增的这$k$行之前/之后染色，要么这$k$行的第一行/最后一行对应$B_{i+1},C_{i+1}$</p><p>考虑在开头新增一行，在结尾新增一行，可以发现此时方案数为$j+k+2\choose k+2$。含义是，如果选的这$k+2$行没有选到开头或者结尾的那两行，那么我们将选择的第一行和最后一行看做是原来就有的，并在这一列被染黑的行。将中间的$k$行看做是本次新添加的行</p><p>如果选的这$k+2$行选到了开头或者结尾，代表本次添加的新的行成为了此列被染黑的行的最小值/最大值，同样对应着本次新添加的$k$行</p><p>可以发现这个东西是可以$FFT$优化的，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">8010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">210</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[M][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r[N &lt;&lt; <span class="number">2</span>], A[N &lt;&lt; <span class="number">2</span>], B[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, w = <span class="number">1</span>, t; j &lt; i + (mid &gt;&gt; <span class="number">1</span>); j++, w = (LL)w * Wn % mod)</span><br><span class="line">                t = (LL)a[j + (mid &gt;&gt; <span class="number">1</span>)] * w % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!type) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, inv = Pow(len, mod - <span class="number">2</span>); i &lt; len; i++)</span><br><span class="line">        a[i] = (LL)a[i] * inv % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">2</span>; i++) </span><br><span class="line">        frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n * <span class="number">2</span>) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) B[i] = inv[i + <span class="number">2</span>];</span><br><span class="line">    NTT(B, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) A[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) A[j] = (LL)dp[i - <span class="number">1</span>][j] * inv[j] % mod;</span><br><span class="line">        NTT(A, len, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) A[j] = (LL)A[j] * B[j] % mod;</span><br><span class="line">        NTT(A, len, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) </span><br><span class="line">            dp[i][j] = ((LL)frac[j + <span class="number">2</span>] * A[j] + (LL)dp[i - <span class="number">1</span>][j] * (<span class="number">1</span> + C(j + <span class="number">1</span>, <span class="number">2</span>))) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) res = (res + (LL)dp[m][i] * C(n, i)) % mod;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARC101F Robots and Exits</title>
      <link href="/2020/03/04/arc101f-robots-and-exits/"/>
      <url>/2020/03/04/arc101f-robots-and-exits/</url>
      
        <content type="html"><![CDATA[<p>数轴上有$N$个机器人，第$i$个机器人的坐标为$X_i$</p><p>有$M$个出口，第$i$个出口的坐标为$Y_i$</p><p>你可以给若干条指令，每次让所有机器人向左移动$1$个单位长度或者向右移动$1$个单位长度</p><p>当一个机器人到达出口时，这个机器人会从这个出口离开数轴。你需要求出有多少种让所有机器人都离开数轴的方案，两种方案不同当且仅当至少存在一个机器人，这个机器人在这两中方案中使用的出口不同</p><p>保证坐标互不相同</p><script type="math/tex; mode=display">N,M\leq 10^5,X_i,Y_i\leq 10^9</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>先将第一个出口左边以及最后一个出口右边所有的机器人删掉，对答案没有影响</p><p>接着对于剩余的机器人，我们求出它距离左边/右边离他最近的出口的距离，记为$(a_i,b_i)$</p><p>将每个机器人想象成二维平面上的一个点$(a_i,b_i)$，我们从起点开始走</p><p>如果当前操作使得$\max\{向左走的步数-向右走的步数\}$增大了，我们认为此时我们往右走了一步</p><p>如果当前操作使得$\max\{向右走的步数-向左走的步数\}$增大了，我们认为此时我们往上走了一步</p><p>这样走若干步之后，所形成的路径构成了一条折线，那么每个机器人对应的出口取决于这条折线是先与$x=a_i$相交还是先与$y=b_i$相交。我们将这两条线称为这个点的边界</p><p>记$dp[i]$表示考虑了$i$以及其左下角的所有点，并且折线与$i$对应的矩形的上边界相交的方案数</p><p>除了与上边界相交的点，其它的点与折线的交点均是右边界</p><p>容易得出这个转移：</p><script type="math/tex; mode=display">dp[i]=\sum_{a_j<a_i,b_j<b_i}dp[j]+1</script><p>扫描线+树状数组即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x += y, x -= x &gt;= mod ? mod : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    Inc(sum[rt], y);</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, x, y);</span><br><span class="line">    <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> sum[rt];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) Inc(res, query(rt &lt;&lt; <span class="number">1</span>, l, mid, start, end));</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) Inc(res, query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, start, end));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[N], y[N], val[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125; p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;y[i]);</span><br><span class="line">    sort(y + <span class="number">1</span>, y + m + <span class="number">1</span>); <span class="keyword">int</span> all = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = lower_bound(y + <span class="number">1</span>, y + m + <span class="number">1</span>, x[i]) - y;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; m || a == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        p[++all] = (Point)&#123;x[i] - y[a - <span class="number">1</span>], y[a] - x[i]&#125;, val[++tot] = y[a] - x[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(val + <span class="number">1</span>, val + tot + <span class="number">1</span>), tot = unique(val + <span class="number">1</span>, val + tot + <span class="number">1</span>) - val - <span class="number">1</span>; </span><br><span class="line">    sort(p + <span class="number">1</span>, p + all + <span class="number">1</span>, [](Point a, Point b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.x == b.x) <span class="keyword">return</span> a.y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">    &#125;);</span><br><span class="line">    update(<span class="number">1</span>, <span class="number">0</span>, tot, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= all; i++) &#123;</span><br><span class="line">        p[i].y = lower_bound(val + <span class="number">1</span>, val + tot + <span class="number">1</span>, p[i].y) - val;</span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; p[i].x == p[i - <span class="number">1</span>].x &amp;&amp; p[i].y == p[i - <span class="number">1</span>].y) <span class="keyword">continue</span>;</span><br><span class="line">        update(<span class="number">1</span>, <span class="number">0</span>, tot, p[i].y, query(<span class="number">1</span>, <span class="number">0</span>, tot, <span class="number">0</span>, p[i].y - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(<span class="number">1</span>, <span class="number">0</span>, tot, <span class="number">0</span>, tot));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARC093 Bichrome Spanning Tree</title>
      <link href="/2020/03/04/arc093-bichrome-spanning-tree/"/>
      <url>/2020/03/04/arc093-bichrome-spanning-tree/</url>
      
        <content type="html"><![CDATA[<p>给一张$N$个点$M$条边的图，每条边有权值$W_i$</p><p>给定$X$，你需要统计有多少种给每条边黑白染色的方式，使得最后满足所有边不同色的最小生成树的边权之和恰好为$X$</p><script type="math/tex; mode=display">N\leq 1000, M\leq 2000,W_i\leq 10^9,X\leq 10^{12}</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这题没什么好说的，分类讨论一下</p><p>首先求出这张图的最小生成树，假设这棵生成树为$T$，其边权之和为$Y$</p><p><strong>1.$X&lt;Y$</strong></p><p>此时显然无解，直接输出$0$即可</p><p><strong>2.$X=Y$</strong></p><p>设$a$表示不在$T$中，且至少在一棵最小生成树上的边的数量</p><p>设$b$表示不在任意一棵最小生成树上的边的数量</p><p>假设$T$的边没有全部被染成相同颜色，那么此时$T$就满足条件，方案数为$2^{N-1}\times 2^{M-N+1}$，即其它边可以随便染色</p><p>否则，只要$a$中存在一条边与$T$不同色就是合法的，方案数为$2\times (2^a-1)\times 2^b$</p><p><strong>3.$X&gt;Y$</strong></p><p>$T$中的边必须被染成相同的颜色</p><p>设$a$表示所在的最小生成树的边权之和$=X$的边的数量</p><p>设$b$表示所在的最小生成树的边权之和$&gt;X$的边的数量</p><p>$a$中的边至少有一条不与$T$同色，$b$中的边随便染色</p><p>方案数为$2\times (2^a-1)\times 2^b$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from], w&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to], w&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N][<span class="number">11</span>], mx[N][<span class="number">11</span>], dep[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = f, dep[u] = dep[f] + <span class="number">1</span>, mx[u][<span class="number">0</span>] = w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        mx[u][i] = max(mx[u][i - <span class="number">1</span>], mx[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u, e[i].w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[a] &lt; dep[b]) swap(a, b);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (dep[fa[a][i]] &gt;= dep[b]) </span><br><span class="line">        res = max(res, mx[a][i]), a = fa[a][i];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (fa[a][i] != fa[b][i]) &#123;</span><br><span class="line">        res = max(res, mx[a][i]), a = fa[a][i];</span><br><span class="line">        res = max(res, mx[b][i]), b = fa[b][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(res, max(mx[a][<span class="number">0</span>], mx[b][<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> from[M], to[M], t[M], w[M], id[M], F[N], pw2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == F[x] ? x : F[x] = find(F[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; LL X; <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>, &amp;n, &amp;m, &amp;X); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) F[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;from[i], &amp;to[i], &amp;w[i]), id[i] = i;</span><br><span class="line">    sort(id + <span class="number">1</span>, id + m + <span class="number">1</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> w[a] &lt; w[b];</span><br><span class="line">    &#125;);</span><br><span class="line">    LL mn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = from[id[i]], b = to[id[i]];</span><br><span class="line">        <span class="keyword">if</span> (find(a) != find(b)) </span><br><span class="line">            t[id[i]] = <span class="number">1</span>, adde(a, b, w[id[i]]), F[find(a)] = find(b), mn += w[id[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (X &lt; mn) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), pw2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) pw2[i] = pw2[i - <span class="number">1</span>] * <span class="number">2</span> % mod;</span><br><span class="line">    <span class="keyword">if</span> (X == mn) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">if</span> (!t[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w[i] == get(from[i], to[i])) a++;</span><br><span class="line">            <span class="keyword">else</span> b++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = (LL)(pw2[n - <span class="number">1</span>] - <span class="number">2</span>) * pw2[m - (n - <span class="number">1</span>)] % mod;</span><br><span class="line">        res = (res + (LL)<span class="number">2</span> * (pw2[a] - <span class="number">1</span>) * pw2[b]) % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">if</span> (!t[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> diff = w[i] - get(from[i], to[i]);</span><br><span class="line">            <span class="keyword">if</span> (diff == X - mn) a++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; X - mn) b++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (LL)<span class="number">2</span> * (pw2[a] - <span class="number">1</span>) * pw2[b] % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC026F Manju Game</title>
      <link href="/2020/03/04/agc026f-manju-game/"/>
      <url>/2020/03/04/agc026f-manju-game/</url>
      
        <content type="html"><![CDATA[<p>有一个长度为$N$的序列$a$，两个人轮流取数，遵循以下规则</p><ul><li>每个数只能取一次</li><li>在第一轮先手可以随意取，但之后的每一轮每个人只能取与前一个人取的位置相邻的位置。如果这样的位置不存在，那么可以随便选一个位置</li></ul><p>先手和后手都希望自己取出的数之和尽量大，问两人在都采取最优策略的情况下取出的数之和分别为多少</p><script type="math/tex; mode=display">N\leq 3\times 10^5,a_i\leq 1000</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先先手可以直接选择这个序列的第一个或者最后一个元素，这样后手的方案就是唯一的</p><p>当$N$为偶数的时候，先手可以取到所有奇数位置或者所有偶数位置</p><p>当$N$为奇数的时候，先手第一次可以取第二个数，此时如果后手取第一个数一定对后手不利，因此后手只能跟着先手取，此时先手也能取到所有偶数位置的数</p><p>先手除了这两种选择还可以选择这个序列中的任意一个元素，然后后手选择这个元素左边/右边与其相邻的元素，之后先手就只能跟着后手轮流选</p><p>如果后手选的那一侧有偶数个数（包括后手选的那一个），那么这一侧的最后一个元素一定是先手取走的。这就意味着接下来后手可以在另一侧随便选择一个数取走，对于先手来说还不如将所有奇数位置或者将所有偶数位置的数取走优秀</p><p>因此我们可以得到一个结论：如果先手选择了从中间开始取数，那么这个位置左边和右边都必定有奇数个数</p><p>显然当$N$为偶数的时候这样的位置是不存在的，因此此时答案就是奇数位置的和与偶数位置的和的最大值，接下来我们讨论当$N$为奇数的情况</p><p>可以发现此时实际上先手和后手不停地在干这样一件事：先手选择当前区间中的一个数-&gt;后手选择左/右的子区间-&gt;后手取走这个区间所有下标为奇数的数，先手取走这个区间所有下标为偶数的数-&gt;递归到另一边的子区间-&gt;…-&gt;先手取走当前区间所有奇数位置/偶数位置的数</p><p>这个过程等价于：初始时先手的分数为所有偶数位置的数之和，每次先手可以：</p><ul><li>将自己的分数加上当前区间奇数位置的数减去偶数位置的数之和，并结束游戏</li><li>取一个偶数位置的数，将区间划分为两个子区间，随后后手选择一个区间继续游戏</li></ul><p>我们可以将这个过程看做一棵二叉树：叶子节点的权值为这个区间奇数位置的数之和减去偶数位置的数之和，后手每次可以选择当前点的一个儿子走过去</p><p>显然后手可以走到这棵二叉树权值最小的那个叶子</p><p>问题等价于：先手要取走若干个偶数位置的数，使得剩下的每一段的奇数位置的数之和减去偶数位置的数之和的最小值尽可能大</p><p>记$sum$表示奇数位置减去偶数位置的前缀和</p><p>二分这个最小值，设其为$mid$</p><p>记$dp[i]$表示最后一段的结尾是否有可能是$i$，转移非常显然：</p><ul><li>$dp[-1]=1$</li><li>$dp[2i+1]|=dp<a href="sum[2i+1]-sum[2j+2]\geq mid">2j+1</a>$</li></ul><p>显然这里我们只需要记录当前为$1$的$dp$状态中，$sum[2i+2]$最小的状态就行了</p><p>时间复杂度$O(N\log N)$，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N], sum[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); <span class="keyword">int</span> A = <span class="number">0</span>, B = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]), sum[i] = sum[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>) sum[i] += num[i], A += num[i];</span><br><span class="line">        <span class="keyword">else</span> sum[i] -= num[i], B += num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, max(A, B), min(A, B));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](<span class="keyword">int</span> mid) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mn = <span class="number">0</span>; <span class="keyword">static</span> <span class="keyword">int</span> dp[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>) </span><br><span class="line">            <span class="keyword">if</span> (sum[i] - mn &gt;= mid) &#123;</span><br><span class="line">                mn = min(mn, sum[i + <span class="number">1</span>]), dp[i] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> dp[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = A + B, mid, res = B;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check(mid = (l + r) &gt;&gt; <span class="number">1</span>)) res = B + mid, l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, res, A + B - res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 博弈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC030D Inversion Sum</title>
      <link href="/2020/03/04/agc030d-inversion-sum/"/>
      <url>/2020/03/04/agc030d-inversion-sum/</url>
      
        <content type="html"><![CDATA[<p>给出$n$个数以及$m$个操作，每个操作都是“交换$X_i,Y_i$”，并且有$1/2$的概率执行，问所有操作执行完毕后序列的逆序对个数的期望</p><script type="math/tex; mode=display">n,m\leq 3000</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>不妨对每一对位置分开统计，即记$dp[i][j]$表示位置$i$的数比位置$j$的数大的概率</p><p>假如这一次操作交换了$i,j$两个位置，那么会影响到$dp[x][j],dp[x][i],dp[j][x],dp[i][x]$这四种位置的值</p><p>这一次操作之后，$j$比$x$大的概率应该与$i$比$x$大的概率相等，因为交换的概率是$1/2$</p><p>然后就很简单了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>, i2 = (mod + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, q, tot = <span class="number">1</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) tot &lt;&lt;= <span class="number">1</span>, tot %= mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            dp[i][j] = a[i] &gt; a[j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        dp[l][r] = dp[r][l] = (LL)(dp[l][r] + dp[r][l]) * i2 % mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span> (j != r &amp;&amp; j != l) &#123;</span><br><span class="line">            dp[j][r] = dp[j][l] = (LL)(dp[j][r] + dp[j][l]) * i2 % mod;</span><br><span class="line">            dp[l][j] = dp[r][j] = (LL)(dp[l][j] + dp[r][j]) * i2 % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            res = (res + dp[i][j]) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL)res * tot % mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARC103D Distance Sums</title>
      <link href="/2020/03/04/arc103d-distance-sums/"/>
      <url>/2020/03/04/arc103d-distance-sums/</url>
      
        <content type="html"><![CDATA[<p>给出$n$个互不相同的$D_i$，你需要构造一棵树，使得第$i$个点到全树的距离之和等于$D_i$，每条边的边权都是$1$</p><script type="math/tex; mode=display">n\leq 10^5,1\leq D_i\leq 10^{12}</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先要知道一个很重要的结论：一棵树的重心到全树的距离之和最小</p><p>这个结论比较显然，因为将当前点往$size$更大的那一边挪，距离之和会变小，最后一定会挪到重心</p><p>那么我们把重心提出来作为这棵树的根，此时有另一个结论：父亲节点的$D$一定比儿子小</p><p>每次我们将$D$最大的那个点拿出来删掉，同时维护其它节点子树的大小，根据当前拿出来的点的子树大小，我们可以算出它父亲的$D$。由于每个$D$都互不相同，我们可以确定它的父亲，然后更新父亲的$size$即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line">LL D[N]; <span class="keyword">int</span> id[N], sz[N];</span><br><span class="line"><span class="built_in">map</span>&lt;LL, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Fuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    G[from].push_back(to), G[to].push_back(from);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) <span class="keyword">if</span> (v != f) </span><br><span class="line">        res += dfs(v, u) + sz[v];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;D[i]), mp[D[i]] = i, sz[i] = <span class="number">1</span>, id[i] = i;</span><br><span class="line">    sort(id + <span class="number">1</span>, id + n + <span class="number">1</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> D[a] &gt; D[b];&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = id[i];</span><br><span class="line">        LL tmp = D[v] - n + sz[v] * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (!mp.count(tmp) || tmp &gt;= D[v]) Fuck();</span><br><span class="line">        adde(v, mp[tmp]), sz[mp[tmp]] += sz[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfs(id[n], <span class="number">0</span>) != D[id[n]]) Fuck();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[i]) <span class="keyword">if</span> (v &gt; i) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, i, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC023E Inversions</title>
      <link href="/2020/03/04/agc023e-inversions/"/>
      <url>/2020/03/04/agc023e-inversions/</url>
      
        <content type="html"><![CDATA[<p>给定一个长度为$N$的序列$A$，你需要统计所有满足$P_i\leq A_i$的排列的逆序对个数之和</p><p>$N\leq 2\times 10^5$，对$10^9+7$取模</p><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先考虑如何统计方案数</p><p>我们记$B_i$表示$A_k\geq i$的个数，即$i$能放的位置的数量，那么答案为</p><script type="math/tex; mode=display">\prod_{i=1}^nB_i-(n-i)</script><p>这个式子的含义是，考虑从大到小依次放入$n\sim 1$，比$i$大的数会占去$n-i$个位置，一共有$B_i$个位置可以容纳$i$以及比$i$大的数</p><p>接着我们枚举两个位置$i,j(i&lt;j)$，考虑这两个位置所形成的逆序对对答案的贡献</p><p>我们分三种情况讨论</p><p><strong>1.$A_i=A_j$</strong></p><p>这两个位置的数是对称的，即交换这两个位置的数对答案不会产生任何影响。因此在总方案中，有一半的情况满足$P_i&gt;P_j$，直接将总方案数除以$2$即可</p><p><strong>2.$A_i&lt;A_j$</strong></p><p>$P_i$的最大值不能超过$A_i$，这意味着如果这两个位置要形成逆序对的话，$P_j$的值也不能超过$A_i$，这样就转化为了$A_i=A_j$的情况</p><p><strong>3.$A_i&gt;A_j$</strong></p><p>用总数减去$P_i&lt;P_j$的情况，也可以转化为$A_i=A_j$</p><p>注意到这三种情况中，除了第一种情况，另外两种情况均会对$A_i$产生修改，如何快速维护修改并求出对应的方案数呢</p><p>假设我们要将$A_i$改成$A_j(A_j&lt;A_i)$</p><p>这会导致$B_{A_j}$到$B_{A_i}$减$1$</p><p>设$D_i=\frac{B_i-(n-i)-1}{B_i-(n-i)}$，那么这一次修改会导致答案乘上$\prod_{k=i+1}^{j}D_k$</p><p>记录一下$D$的前缀积$D’_i$，转化为答案乘以$\frac{D’_j}{D’_i}$</p><p>由于$D$可能为$0$，因此还要记录一下某个位置前面/后面第一个为$0$的位置</p><p>树状数组维护区间和就行了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inv2 = (mod + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FUCK</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> tree[N];</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += x &amp; -x) tree[x] = (tree[x] + y) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= x &amp; -x) res = (res + tree[x]) % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (query(r) - query(l - <span class="number">1</span>) + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; X, Y, Z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N], num[N], pre[N], lst[N], nxt[N], ct[N];</span><br><span class="line"><span class="keyword">bool</span> fuck[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), A[a]++, num[i] = a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--) A[i] += A[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span>; pre[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        A[i] -= n - i, tot = (LL)tot * A[i] % mod;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t = (LL)(A[i] - <span class="number">1</span>) * Pow(A[i], mod - <span class="number">2</span>) % mod;</span><br><span class="line">        <span class="keyword">if</span> (t) pre[i] = (LL)pre[i - <span class="number">1</span>] * t % mod;</span><br><span class="line">        <span class="keyword">else</span> pre[i] = pre[i - <span class="number">1</span>], fuck[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    nxt[n + <span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        nxt[i] = nxt[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (fuck[i]) nxt[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        lst[i] = lst[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (fuck[i]) lst[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        res = (res + (LL)ct[num[i]] * tot % mod * inv2) % mod;</span><br><span class="line">        <span class="keyword">if</span> (num[i] != <span class="number">1</span>) &#123;</span><br><span class="line">            res = (res + (LL)Y.query(max(<span class="number">1</span>, lst[num[i]]), num[i] - <span class="number">1</span>) * pre[num[i]] % mod</span><br><span class="line">                * tot % mod * inv2) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num[i] != n) &#123;</span><br><span class="line">            res = (res + (LL)Z.query(num[i] + <span class="number">1</span>, n) * tot) % mod;</span><br><span class="line">            res = (res - (LL)X.query(num[i] + <span class="number">1</span>, min(n, nxt[num[i] + <span class="number">1</span>] - <span class="number">1</span>)) * Pow(pre[num[i]], mod - <span class="number">2</span>) % mod</span><br><span class="line">                * tot % mod * inv2 % mod + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        X.update(num[i], pre[num[i]]), Y.update(num[i], Pow(pre[num[i]], mod - <span class="number">2</span>)), Z.update(num[i], <span class="number">1</span>), ct[num[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC023D Go Home</title>
      <link href="/2020/03/04/agc023d-go-home/"/>
      <url>/2020/03/04/agc023d-go-home/</url>
      
        <content type="html"><![CDATA[<p>在一条街上有$N$座公寓，第$i$座公寓的坐标为$X_i$，有$P_i$个人住在这座公寓里面</p><p>所有人都在一家公司里面上班，这家公司的坐标为$S$，下班的时候，所有人将会乘坐同一辆公交车回家</p><p>每一时刻所有在公交车上的人都会投一次票，以决定此时公交车应该往左开还是往右开。公交车会往票数更多的那个方向开，如果票数相同，则向左开。当公交车到达一座公寓的时候，住在这座公寓里面的人会马上下车</p><p>每个人都是自私的，希望自己能够尽早回家，但这并不意味着每次投票的时候总是投向自己家的方向，因为这样不一定最优</p><p>问当所有人都采取最优策略的时候，这辆公交车需要多久才能将所有人都送回家</p><script type="math/tex; mode=display">N\leq 10^5,S,X_i,P_i\leq 10^9</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>很有意思的一道题</p><p>考虑倒推</p><p>如果只有两座公寓，它们坐落在$S$的两侧，左侧的公寓有$a$个人，右侧的公寓有$b$个人，不妨设$a\geq b$</p><p>如果右侧的人在投票的时候希望往右开，肯定干不过左侧的人希望往左开，公交车仍然会朝左开而不是朝右</p><p>那么对于右侧的这些人来讲，他们还不如先投往左的票，帮助左侧的人到达他们的家，在到家之后再投朝右的票</p><p>于是我们可以将这两座公寓合并，只留下左侧的公寓，现在这座公寓里面一共有$a+b$个人</p><p>由于在某个时刻，还没有下车的人一定是一段前缀和一段后缀，因此这样倒推是对的</p><p>需要注意的是如果我们连续多次选择删去同一个方向的公寓，那么代价是没有必要计算的</p><p>比如左侧有一座公寓$a$，右侧有两座公寓$b,c$，我们依次删去了$c,b$</p><p>显然最终的方案是，公交车先到了$a$，然后开向$c$，在途中顺便经过$b$，显然$b$的代价不需要计算</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line">LL num[N]; <span class="keyword">int</span> pos[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, s; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>, &amp;pos[i], &amp;num[i]);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n, ls = <span class="number">0</span>; LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos[l] &gt; s) &#123; res += pos[r] - s; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos[r] &lt; s) &#123; res += s - pos[l]; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">int</span> nw;</span><br><span class="line">        <span class="keyword">if</span> (num[l] &gt;= num[r]) nw = <span class="number">1</span>, num[l] += num[r];</span><br><span class="line">        <span class="keyword">else</span> nw = <span class="number">-1</span>, num[r] += num[l];</span><br><span class="line">        <span class="keyword">if</span> (nw != ls) res += pos[r] - pos[l];</span><br><span class="line">        ls = nw;</span><br><span class="line">        <span class="keyword">if</span> (nw == <span class="number">-1</span>) l++; <span class="keyword">else</span> r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC022F Checkers</title>
      <link href="/2020/03/04/agc022f-checkers/"/>
      <url>/2020/03/04/agc022f-checkers/</url>
      
        <content type="html"><![CDATA[<p>令$X=10^{100}$，在一条数轴上有$N$个点，第$i$个点的坐标为$X^i$</p><p>每一轮，你会选择当前仍然存在的两个不同的点$A,B$，将$A$移动到其关于$B$的对称点，并把$B$删掉</p><p>容易发现这样进行$N-1$轮后会剩下一个点，你需要求出这个点的坐标有多少种可能的取值</p><p>$N\leq 50$，对$998244353$取模</p><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>神仙题</p><p>如果在一次操作中，$A$跨过了$B$，$B$被删掉了，那么我们将$A$作为父亲，$B$作为儿子，从$A$向$B$连一条边</p><p>我们最终会得到一棵树，这棵树的根节点就是最后被保留下来的点，我们会从叶子到根按照树的形态依次执行每个操作，直到最后剩下根节点</p><p>举个例子，考虑这样一棵树：根节点为$a$，它有两个儿子$b,c$</p><p>假设操作顺序是这样的：$a$先跨过并删去了$b$，接着跨过了$c$</p><p>第一次跨越时，$a$的坐标变为了$2b-a$；第二次跨越时，$a$的坐标变为了$a-2b+2c$</p><p>我们可以发现最终每个点对答案的贡献的系数一定是形如$\pm 2^d$的形式，其中$d$是这个点的深度</p><p>由于$X$非常大，因此我们认为两种方案中如果存在一个点它的贡献系数不一样，这两种方案就是不同的</p><p>深度很好考虑，但是如何确定一个点贡献的正负号呢</p><p>假设$a$节点是树根，考虑$a$的正负号会被哪些节点影响</p><p>每操作一次$a$的儿子会导致$a$的正负性变化一次，因此如果$a$有奇数个儿子，那么$a$<strong>此时</strong>的符号就为负，否则为正</p><p>操作完$a$的子树之后，我们考虑$a$的父亲对其的影响</p><p>$a$的父亲会将其所有儿子排列起来依次操作过去，此时若$a$节点之后一共排了偶数个儿子，$a$以及它的子树的贡献将被全部取反</p><p>这样每个点的正负性与它的每个祖先都有关系，很不好处理</p><p>考虑差分，即考虑$a$<strong>最终的贡献</strong>与其父亲<strong>最终的贡献</strong>是否相同，这样就可以很好地处理“将子树全部取反”这个操作</p><p>如果树的形态确定了，考虑从叶子到根依次求出差分值，假设当前已经求好了$u$的所有儿子以及它们所在的子树的差分，现在要加入$u$</p><p>如果$u$有奇数个儿子，那么$u$以及$u$的所有儿子的差分将会异或$1$</p><p>考虑$u$的儿子的操作顺序，如果$v$后面有偶数个儿子，将$v$的差分异或$1$</p><p>对于一个有$m$个儿子的点，显然必须有$\lfloor\frac{m}{2}\rfloor$个儿子的差分不需要异或$1$，$\lceil\frac{m}{2}\rceil$个儿子的差分需要异或$1$</p><p>然后我们就可以开始愉快地$dp$了</p><p>考虑从根往叶子递推，直接确定每个点最后的差分是啥</p><p>记$dp[i][k]$表示已经挂了$i$个节点，当前的最后一层有$k$个节点被钦定将会有奇数个儿子的本质不同的方案数</p><p>枚举当前这一层要挂的点数，假设为$m$</p><p>首先给每个被钦定有奇数个儿子的点都挂一个儿子，并将这个儿子作为这个点最先被操作的儿子。如果不考虑这个儿子的儿子，那么这个儿子的差分将为$1$</p><p>接着就转化成了每个点都要挂上偶数个儿子的情况（有奇数个儿子的点的第一个被操作的儿子已经被确定了，其所有儿子的差分将会被异或上两次$1$，等价于没有异或）</p><p>这意味着，$m-k$必须要是偶数，且其中有$\frac{m-k}{2}$个点的差分为$0$</p><p>但是此时我们还未考虑新挂上的这些点的儿子，也就是说此时我们求出来的差分值并不是最后每个点的差分值。如果这一次我们挂上的某个点将会有奇数个儿子，那么它的差分值将会异或$1$</p><p>枚举这一层实际上有多少个点的差分值是$1$，假设有$d$个</p><p>这意味着当前这一层至少会有$|d-\frac{m-k}{2}|$个点在之后会拥有奇数个儿子</p><p>实际上我们只能统计这一层恰有$|d-\frac{m-k}{2}|$个点有奇数个儿子的情况，在其它情况中，为了保持最后差分为$1$的点的数量不变，每次必然会钦定两个差分不同的儿子将会有奇数个儿子</p><p>此时我们直接交换这两个点的操作顺序，并将其中一个点的所有儿子合并到另一个点的儿子里面，可以保持所有点的符号不变，即答案不变。因此不能算这种情况，会导致重复计数</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">51</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[N][N]; <span class="comment">// 已经挂了i个点，最后一层有j个点有奇数个儿子，还未考虑儿子的挂法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = dp[<span class="number">1</span>][<span class="number">0</span>] = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n - i; j++) <span class="comment">// 当前这一层的点数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= j; k++) &#123; <span class="comment">// 上一层奇数个儿子的点的数量</span></span><br><span class="line">                <span class="keyword">if</span> ((j - k) &amp; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> delta = (j - k) / <span class="number">2</span>; <span class="comment">// 未考虑下一层时，这一层有多少个点与父亲符号不同</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt;= j; t++) &#123; <span class="comment">// 实际有多少个符号不同</span></span><br><span class="line">                    <span class="keyword">int</span> tmp = <span class="built_in">abs</span>(t - delta); <span class="comment">// 这一层有奇数个儿子的点的数量</span></span><br><span class="line">                    dp[i + j][tmp] = (dp[i + j][tmp] + (LL)dp[i][k] * C(n - i, j) % mod * C(j, t)) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[n][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC020F Arcs on a Circle</title>
      <link href="/2020/03/04/agc020f-arcs-on-a-circle/"/>
      <url>/2020/03/04/agc020f-arcs-on-a-circle/</url>
      
        <content type="html"><![CDATA[<p>有一个周长为$C$的圆，你有$N$条弧，第$i$条弧的长度为$L_i$</p><p>弧会在圆上独立且随机地放置，问整个圆都被覆盖的概率</p><script type="math/tex; mode=display">N\leq 6, C,L_i\leq 50</script><p>输入的每个数都是正整数</p><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先断环为链，我们选取这些弧中最长弧的起点作为链的起点</p><p>之所以选择最长弧，是因为这样可以保证，在最终的覆盖中一定不存在一条弧完全包含这条弧</p><p>注意到一个有趣的性质：所有弧的长度均为整数，圆的周长也是整数</p><p>假设所有弧的放置位置都已经确定下来了，那么如何判断两条弧的关系呢</p><p>显然这与两条弧的放置位置有关，但是由于放置位置可以是实数，不好处理</p><p>有一种神奇的思路是：我们将所有弧的起点离散化，即将一条长度为$l$的弧的起点$x$分为整数部分$a$和小数部分$b$。对于整数部分我们不需要特别处理，对于小数部分我们将其离散化，即$(n-1)!$地枚举所有弧起点小数部分的相对大小关系。特别地，第一条已经确定的弧不需要枚举</p><p>此时的端点总数变成了$NC$个</p><p>接下来我们只需要尝试在每个端点放弧就行了，设$dp[i][j][s]$表示已经考虑了左端点$\leq i$的位置，此时右端点最大覆盖到了$j$，已经放了$s$集合中的弧的方案数</p><p>注意转移的时候我们需要保证$j$始终不小于$i$，即圆上的每一条线段均被覆盖</p><p>最终的答案需要除以$(n-1)!$再除以$c^{n-1}$。除以$(n-1)!$是因为我们枚举了小数的相对顺序，除以$c^{n-1}$是因为每条弧的起点的整数部分是可以随便定的，每条弧有$c$种选法，因此总方案数为$c^{n-1}$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id[N], l[N]; <span class="keyword">double</span> dp[<span class="number">350</span>][<span class="number">1</span> &lt;&lt; <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, c, frac = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;c); <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;l[i]), id[i] = i;</span><br><span class="line">    sort(l + <span class="number">1</span>, l + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123; <span class="comment">// 枚举小数的相对大小</span></span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[l[n] * n][<span class="number">1</span> &lt;&lt; n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * c; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nw = id[(i - <span class="number">1</span>) % n + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nw == n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n * c; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> s = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; s &gt; <span class="number">0</span>; s--) <span class="keyword">if</span> (dp[j][s] &amp;&amp; !(s &amp; (<span class="number">1</span> &lt;&lt; nw - <span class="number">1</span>))) </span><br><span class="line">                    dp[min(n * c, max(j, i + l[nw] * n))][s | (<span class="number">1</span> &lt;&lt; nw - <span class="number">1</span>)] += dp[j][s];</span><br><span class="line">        &#125;</span><br><span class="line">        ans += dp[n * c][(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>], frac++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (next_permutation(id + <span class="number">1</span>, id + n));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.12lf\n"</span>, ans / frac / <span class="built_in">pow</span>(c, n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARC096F Sweet Alchemy</title>
      <link href="/2020/03/03/arc096f-sweet-alchemy/"/>
      <url>/2020/03/03/arc096f-sweet-alchemy/</url>
      
        <content type="html"><![CDATA[<p>有一棵$N$个点的树，第$i$个点的父亲是$p_i$，权值为$m_i$</p><p>给定两个整数$X,D$</p><p>你要为每个点分配$c_i$，使得</p><ul><li>$c_{p_i}\leq c_i\leq c_{p_i}+D$</li><li>$\sum m_ic_i\leq X$</li><li>$\sum c_i$尽可能大</li></ul><script type="math/tex; mode=display">N\leq 50, X,D,m_i\leq 10^9</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>第一个限制看起来很奇怪，每个点都必须比它的父亲大</p><p>我们将问题转换一下，将给每个点分配$c_i$看做对这棵树进行若干次子树加，这样就可以保证每个点的权值一定比其父亲权值大，且每个点作为根进行的加操作次数不能超过$D$</p><p>其实就是将原来的$c_i$差分了一下，记$a_i$为差分之后每个点的权值</p><p>接着，对于第$i$个点，我们将这个点的$m_i$变为其子树的$m_i$之和，含义是对这个点的子树进行一次加操作需要的代价</p><p>那么问题就变为了要给每个点分配$a_i$，使得</p><ul><li>对于$i\in [2,n]$，满足$a_i\leq D$</li><li>$\sum m_ia_i\leq X$</li><li>$\sum sz_ia_i$尽可能大，其中$sz_i$表示节点$i$的子树大小</li></ul><p>可以看出这就是普通的背包问题。但是与一般背包问题不同的是，这里每个物品的体积、背包总容量都特别大，物品总数和每个物品的价值都很小</p><p>有一种贪心是将所有物品按照价值/体积排序，但是显然直接这样贪心是错的，因为有可能一个物品的体积太大导致剩余的空间没有被很好地利用</p><p>注意到一件事情：如果这些物品价值的最大值为$k$，那么在最终方案中，如果两个物品$a,b$满足$a$的价值/体积大于$b$的价值/体积，那么$b$取的次数一定$k$</p><p>因为，$b$取$k$次耗费的代价和体积一定大于$a$再取一次需要耗费的代价和体积</p><p>所以我们可以将每个物品拿$k$个出来跑普通的背包，对于剩下的物品沿用那个错误的贪心就行了</p><p>在本问题中，$k=n$，背包中物品价值总和不会超过$n^3$</p><p>记$dp[i][j]$表示考虑了前$i$个物品，价值总和为$j$时最少需要多少空间，时间复杂度$O(n^5)$，但是跑不满，可以优化到$O(n^4\log n)$</p><p>注意爆<code>long long</code></p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">51</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line">LL dp[N][N * N * N], sum[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[N], w[N], id[N]; LL pre[N], pre1[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, d; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; sum[i], w[i] = <span class="number">1</span>, id[i] = i;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">1</span>) <span class="built_in">cin</span> &gt;&gt; p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) </span><br><span class="line">        sum[p[i]] += sum[i], w[p[i]] += w[i];</span><br><span class="line">    <span class="keyword">int</span> lim = min(d, n);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp)), dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= (i - <span class="number">1</span>) * lim * n; j++) <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] &lt;= m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= lim; k++) &#123;</span><br><span class="line">                dp[i][j + k * w[i]] = min(dp[i][j + k * w[i]], dp[i - <span class="number">1</span>][j] + k * sum[i]);</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j + k * w[i]] &gt; m) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(id + <span class="number">1</span>, id + n + <span class="number">1</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> w[a] * sum[b] &gt; w[b] * sum[a];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre[i - <span class="number">1</span>] &gt;= m) &#123;</span><br><span class="line">            pre[i] = pre[i - <span class="number">1</span>] + <span class="number">1</span>; <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> at = id[i], tmp = at == <span class="number">1</span> ? <span class="number">1e9</span> : d - lim;</span><br><span class="line">        <span class="keyword">if</span> (sum[at] &gt;= m &amp;&amp; tmp) pre[i] = m;</span><br><span class="line">        <span class="keyword">else</span> pre[i] = pre[i - <span class="number">1</span>] + tmp * sum[at], pre1[i] = pre1[i - <span class="number">1</span>] + (LL)tmp * w[at];</span><br><span class="line">    &#125;   </span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n * n * lim; i++) <span class="keyword">if</span> (dp[n][i] &lt;= m) &#123;</span><br><span class="line">        LL remain = m - dp[n][i];</span><br><span class="line">        <span class="keyword">int</span> pos = upper_bound(pre + <span class="number">1</span>, pre + n + <span class="number">1</span>, remain) - pre - <span class="number">1</span>;</span><br><span class="line">        res = max(res, i + pre1[pos] + w[id[pos + <span class="number">1</span>]] * ((remain - pre[pos]) / sum[id[pos + <span class="number">1</span>]]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC027D Modulo Matrix</title>
      <link href="/2020/03/03/agc027d-modulo-matrix/"/>
      <url>/2020/03/03/agc027d-modulo-matrix/</url>
      
        <content type="html"><![CDATA[<p>给定一个正整数$N$</p><p>你需要构造一个$N\times N$的矩阵$a$，并且满足如下条件</p><ul><li>$1\leq a_{i,j}\leq 10^{15}$</li><li>$a_{i,j}$互不相同</li><li>存在一个正整数$m$满足：对于任意的两个相邻的格子$x,y$，总有$\max(x,y)\mod \min(x,y)=m$</li></ul><script type="math/tex; mode=display">2\leq N\leq 500</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>考虑构造$m=1$</p><p>将所有格子按照奇偶性黑白染色，使得任意两个相邻的格子的颜色不同</p><p>接下来，我们钦定白色格子一定比其相邻的黑色格子大</p><p>如何保证$\max(x,y)\mod \min(x,y)=1$呢</p><p>一个很自然的想法是，对于每个白色格子，填上与其相邻的四个黑色格子所填的数的$\text{lcm}+1$</p><p>为了保证每个数互不相同，需要给每一个黑色格子分配一个质数</p><p>这样模出来显然是$1$</p><p>但是这样四个格子的乘积会超过$10^{15}$的上界，因为每个黑色格子分配的质数是$N^2$级别的</p><p>此时有一个巧妙的优化方法，对于每条主对角线，我们给它分配一个质数；对于每条副对角线，我们也给它分配一个质数，每个黑色格子的权值就是其所在的主对角线乘以其所在的副对角线</p><p>这样可以保证每个黑色格子里面的数都互不相同</p><p>白色格子的取值仍然是其周围的黑色格子的权值的$\text{lcm}+1$，这样白色格子的权值从原来的$N^8$级别下降到了$N^4$级别，就不会超过上界了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag[N], prime[N], pcnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N - <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag[i]) prime[++pcnt] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pcnt &amp;&amp; i * prime[j] &lt;= N - <span class="number">10</span>; j++) &#123;</span><br><span class="line">            flag[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL G[<span class="number">510</span>][<span class="number">510</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">lcm</span><span class="params">(LL a, LL b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / gcd(a, b) * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">lcm</span><span class="params">(LL a, T... b)</span> </span>&#123;</span><br><span class="line">    LL t = lcm(b...);</span><br><span class="line">    <span class="keyword">return</span> a / gcd(a, t) * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), sieve();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"4 7\n23 10"</span>), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n + <span class="number">1</span>; j++) G[i][j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span> ((i + j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = i + j, b = i - j; a = (a - <span class="number">1</span>) / <span class="number">2</span>, b = (b + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            G[i][j] = (LL)prime[a] * prime[b + n - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++, <span class="built_in">puts</span>(<span class="string">""</span>))</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!((i + j) &amp; <span class="number">1</span>)) G[i][j] = (LL)lcm(G[i - <span class="number">1</span>][j], G[i][j - <span class="number">1</span>], G[i + <span class="number">1</span>][j], G[i][j + <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld "</span>, G[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC025D Choosing Points</title>
      <link href="/2020/03/03/agc025-choosing-points/"/>
      <url>/2020/03/03/agc025-choosing-points/</url>
      
        <content type="html"><![CDATA[<p>给定$N,D_1,D_2$，你需要找到$N^2$个不同的整点，使得</p><ul><li>每个点的坐标$(i,j)$满足$0\leq i,j\leq 2N$</li><li>任意两个点的距离的平方都不是$D_1$或$D_2$</li></ul><script type="math/tex; mode=display">N\leq 300, D_1, D_2\leq 2\times 10^5</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先有一个结论：如果将网格图上所有距离为定值的点对互相连边，得到的图一定是二分图</p><p>接着我们根据$D_1,D_2$这两个限制对这$N^2$个点染两次色</p><p>那么最后每个点一共有四种情况：在第一次染色中被染了黑/白；在第二次染色中被染了黑/白</p><p>我们可以看做一共有四种颜色，并且相同颜色的点内部没有边</p><p>由于一共有$4N^2$个点可以选择，我们选这四种颜色中，点数最多的那个集合就可以了，这个集合里面的点数一定大于$N^2$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> G[<span class="number">2</span>][N * <span class="number">2</span>][N * <span class="number">2</span>], n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt; dir;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : dir) &#123;</span><br><span class="line">        <span class="keyword">int</span> tx = x + v.first, ty = y + v.second;</span><br><span class="line">        <span class="keyword">if</span> (tx &gt; n * <span class="number">2</span> || ty &gt; n * <span class="number">2</span> || tx &lt; <span class="number">1</span> || ty &lt; <span class="number">1</span> || G[t][tx][ty]) <span class="keyword">continue</span>;</span><br><span class="line">        G[t][tx][ty] = <span class="number">3</span> - G[t][x][y], dfs(tx, ty, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Just_DOIT</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    dir.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * n; j++)</span><br><span class="line">            <span class="keyword">if</span> ((LL)i * i + (LL)j * j == d) </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">4</span>; t++) </span><br><span class="line">                    dir.push_back(P(t &amp; <span class="number">1</span> ? i : -i, t &amp; <span class="number">2</span> ? j : -j));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n * <span class="number">2</span>; j++) <span class="keyword">if</span> (!G[t][i][j]) </span><br><span class="line">            G[t][i][j] = <span class="number">1</span>, dfs(i, j, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt; fuck[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d1, d2; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;d1, &amp;d2);</span><br><span class="line">    Just_DOIT(<span class="number">0</span>, d1), Just_DOIT(<span class="number">1</span>, d2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n * <span class="number">2</span>; j++)</span><br><span class="line">            fuck[G[<span class="number">0</span>][i][j] + G[<span class="number">1</span>][i][j] * <span class="number">2</span> - <span class="number">3</span>].push_back(P(i, j));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="keyword">if</span> (fuck[i].size() &gt;= n * n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n * n; j++) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, fuck[i][j].first - <span class="number">1</span>, fuck[i][j].second - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARC099F Eating Symbols Hard</title>
      <link href="/2020/03/03/arc099f-eating-symbols-hard/"/>
      <url>/2020/03/03/arc099f-eating-symbols-hard/</url>
      
        <content type="html"><![CDATA[<p>数轴上有$2\times 10^9+1$个位置：从$-10^9$到$10^9$，一开始这些位置上的数都是$0$</p><p>有一个指针$p$，一开始$p=0$</p><p>给定一个由<code>&lt;,&gt;,+,-</code>构成的序列$S$，我们根据这个序列对数轴进行如下操作：</p><ul><li>如果下一个字符为<code>+</code>，那么数轴上$p$这个位置的数会增加$1$</li><li>如果下一个字符为<code>-</code>，那么数轴上$p$这个位置的数会减少$1$</li><li>如果下一个字符为<code>&gt;</code>，那么$p$会增加$1$</li><li>如果下一个字符为<code>&lt;</code>，那么$p$会减少$1$</li></ul><p>你需要统计$S$有多少个非空子串，满足如果根据这个子串来进行操作，最终得到的数轴与根据$S$进行操作得到的数轴完全相同</p><script type="math/tex; mode=display">|S|\leq 2.5\times 10^5</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>考虑<code>hash</code>，假设最终数轴上第$i$个位置的数是$A_i$，那么可以将整个数轴压缩为</p><script type="math/tex; mode=display">\sum_{i}A_ix^i</script><p>序列$S$的<code>hash</code>值很好求出来，如何求出一个指定区间的<code>hash</code>值呢</p><p>假设需要求的区间是$[l,r]$，并且我们知道$[1,l-1]$与$[1,r]$的<code>hash</code>值</p><p>显然我们不能直接将这两个位置的<code>hash</code>值相减，因为指针$p$的起点不一样</p><p>假设在$l-1$时，指针为$p_1$；在$r$时，指针为$p_2$，$[1,i]$的<code>hash</code>值为$h_i$</p><p>那么$[l,r]$合法的条件是</p><script type="math/tex; mode=display">\frac{h_r-h_{l-1}}{x^{p_1}}=h_{|S|}\Rightarrow h_r=h_{|S|}x^{p_1}+h_{l-1}</script><p>将等式右边的数压入<code>map</code>即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">250010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod[] = &#123;<span class="number">1000000007</span>, <span class="number">1000000009</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P[] = &#123;<span class="number">131</span>, <span class="number">233</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Pow[<span class="number">2</span>][N * <span class="number">2</span>]; <span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">FUCK</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    Data(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>) &#123;val[<span class="number">0</span>] = a, val[<span class="number">1</span>] = b;&#125; </span><br><span class="line"></span><br><span class="line">    Data <span class="keyword">operator</span> + (<span class="keyword">const</span> Data &amp;b) &#123;</span><br><span class="line">        Data res;</span><br><span class="line">        res.val[<span class="number">0</span>] = (val[<span class="number">0</span>] + b.val[<span class="number">0</span>]) % mod[<span class="number">0</span>];</span><br><span class="line">        res.val[<span class="number">1</span>] = (val[<span class="number">1</span>] + b.val[<span class="number">1</span>]) % mod[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Data <span class="keyword">operator</span> - (<span class="keyword">const</span> Data &amp;b) &#123;</span><br><span class="line">        Data res;</span><br><span class="line">        res.val[<span class="number">0</span>] = (val[<span class="number">0</span>] - b.val[<span class="number">0</span>] + mod[<span class="number">0</span>]) % mod[<span class="number">0</span>];</span><br><span class="line">        res.val[<span class="number">1</span>] = (val[<span class="number">1</span>] - b.val[<span class="number">1</span>] + mod[<span class="number">1</span>]) % mod[<span class="number">1</span>]; </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Data <span class="keyword">operator</span> * (<span class="keyword">const</span> <span class="keyword">int</span> b) &#123;</span><br><span class="line">        Data res = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">int</span> a = b &gt;= <span class="number">0</span> ? Pow[<span class="number">0</span>][b] : FUCK(P[<span class="number">0</span>], (LL)(mod[<span class="number">0</span>] - <span class="number">2</span>) * (-b) % (mod[<span class="number">0</span>] - <span class="number">1</span>), mod[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> c = b &gt;= <span class="number">0</span> ? Pow[<span class="number">1</span>][b] : FUCK(P[<span class="number">1</span>], (LL)(mod[<span class="number">1</span>] - <span class="number">2</span>) * (-b) % (mod[<span class="number">1</span>] - <span class="number">1</span>), mod[<span class="number">1</span>]);</span><br><span class="line">        res.val[<span class="number">0</span>] = (LL)res.val[<span class="number">0</span>] * a % mod[<span class="number">0</span>];</span><br><span class="line">        res.val[<span class="number">1</span>] = (LL)res.val[<span class="number">1</span>] * c % mod[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Data &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (val[<span class="number">0</span>] != b.val[<span class="number">0</span>]) <span class="keyword">return</span> val[<span class="number">0</span>] &lt; b.val[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> val[<span class="number">1</span>] &lt; b.val[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;Data, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">(Data &amp;a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    a = a + (Data)&#123;Pow[<span class="number">0</span>][b], Pow[<span class="number">1</span>][b]&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">decrease</span><span class="params">(Data &amp;a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    a = a - (Data)&#123;Pow[<span class="number">0</span>][b], Pow[<span class="number">1</span>][b]&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d%s"</span>, &amp;n, s + <span class="number">1</span>); Data all;</span><br><span class="line">    Pow[<span class="number">0</span>][<span class="number">0</span>] = Pow[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n * <span class="number">2</span>; j++)</span><br><span class="line">            Pow[i][j] = (LL)Pow[i][j - <span class="number">1</span>] * P[i] % mod[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, ls = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'&lt;'</span>) ls--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'&gt;'</span>) ls++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'+'</span>) increase(all, ls + n);</span><br><span class="line">        <span class="keyword">else</span> decrease(all, ls + n);</span><br><span class="line">    &#125;</span><br><span class="line">    Data fuck; mp[all] = <span class="number">1</span>; LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, ls = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'&lt;'</span>) ls--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'&gt;'</span>) ls++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'+'</span>) increase(fuck, ls + n);</span><br><span class="line">        <span class="keyword">else</span> decrease(fuck, ls + n);</span><br><span class="line">        res += mp[fuck], mp[fuck + all * ls]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC020D Min Max Repetition</title>
      <link href="/2020/03/03/agc020d-min-max-repetition/"/>
      <url>/2020/03/03/agc020d-min-max-repetition/</url>
      
        <content type="html"><![CDATA[<p>定义$f(A,B)$为一个字符串，其中$A,B$是正整数，满足</p><ul><li>$f(A,B)$的长度为$A+B$</li><li>$f(A,B)$有$A$个<code>A</code>，有$B$个<code>B</code></li><li>$f(A,B)$的最长的由相同字符构成的子串的长度应该尽可能地小</li><li>$f(A,B)$是满足上述条件中字典序最小的一个</li></ul><p>$Q$次询问，每次给出$A_i,B_i,C_i,D_i$，要求输出$f(A_i,B_i)$从$C_i$开始，到$D_i$结束的子串</p><script type="math/tex; mode=display">Q\leq 10^3,A_i,B_i\leq 5\times 10^8,D_i-C_i+1\leq 100</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>不妨设$A\leq B$</p><p>如果最长的相同子串长度为$k$，那么我们可以得出</p><script type="math/tex; mode=display">\lceil\frac{B}{k}\rceil\leq A+1\Rightarrow k=\lceil\frac{B}{A+1}\rceil</script><p>即$B$最少能被划分为$\lceil\frac{B}{k}\rceil$段，$A$最多能提供$A+1$个位置</p><p>由于还要要求字典序最小，因此我们考虑贪心地构造这个串</p><p>我们一位一位地枚举，对于当前这一位我们优先尝试填<code>A</code>。如果填入<code>A</code>之后，剩余部分仍然满足最长相同子串长度$\leq k$，并且当前串的结尾的<code>A</code>不多于$k$个，那么在这里填<code>A</code>就是合法的，否则我们只能填<code>B</code></p><p>通过观察可以发现，答案一定长成这样：<code>AA...ABAA...ABA...ABB...BABB...BAB...B</code></p><p>即在某一位及这一位之前尽量填<code>A</code>，在这一位之后尽量填<code>B</code>，记这个位置为$p$</p><p>形式化地说，在$p$这一位以及之前的所有位，我们填字符的规则是每$k$个<code>A</code>一个<code>B</code></p><p>那么可以计算出这个位置之前<code>A</code>,<code>B</code>的数量</p><p>显然剩下还没有用的<code>B</code>有$B-\lfloor\frac{p}{k+1}\rfloor$个，从而可以推出<code>A</code>的数量</p><p>我们只需计算出剩下的<code>A</code>最多还能塞下多少个<code>B</code>即可</p><p>$p$这个位置显然越靠后越好，可以二分出这个位置</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int LL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> A, B, C, D; <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>, &amp;A, &amp;B, &amp;C, &amp;D);</span><br><span class="line">        <span class="keyword">int</span> len = (max(A, B) + min(A, B)) / (min(A, B) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1e9</span>, mid, pos = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> t1 = A - mid / (len + <span class="number">1</span>) * len - mid % (len + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> t2 = B - mid / (len + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> h1 = t1 * len + (mid % (len + <span class="number">1</span>) || !mid ? len : len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (t1 &gt;= <span class="number">0</span> &amp;&amp; t2 &gt;= <span class="number">0</span> &amp;&amp; h1 &gt;= t2) pos = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        assert(pos &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = C; i &lt;= min(D, pos); i++) </span><br><span class="line">            <span class="built_in">putchar</span>(i % (len + <span class="number">1</span>) ? <span class="string">'A'</span> : <span class="string">'B'</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = min(D, max(pos, C - <span class="number">1</span>)) + <span class="number">1</span>; i &lt;= D; i++) </span><br><span class="line">            <span class="built_in">putchar</span>((A + B - i + <span class="number">1</span>) % (len + <span class="number">1</span>) ? <span class="string">'B'</span> : <span class="string">'A'</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC020E Encoding Subsets</title>
      <link href="/2020/03/03/agc020e-encoding-subsets/"/>
      <url>/2020/03/03/agc020e-encoding-subsets/</url>
      
        <content type="html"><![CDATA[<p>对于一个仅包含$0,1$的串我们定义如下的“折叠”操作</p><ul><li>如果$A$能被表示成$P$，$B$能被表示成$Q$，那么$AB$可以被表示成$PQ$</li><li>如果$A$能被表示成$P$，那么$AA\cdots A(k个A)$能被表示成$(P\times K)$</li></ul><p>举个例子，串$001001001$能被表示成$001001001,00(1(0\times 2)\times 2)1,(001\times 3)$</p><p>定义串$A$是串$B$的子集当前仅当$A$中是$1$的所有位置在$B$中也是$1$</p><p>给定一个$01$串$S$，问$S$的所有子集的折叠方式的总和</p><p>对$998244353$取模，$|S|\leq 100$</p><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>考虑直接对$S$串$dp$</p><p>如果$S$串的长度为$0$，那么方案数只有一种</p><p>如果$S$的长度为$1$，如果$S$的第一个字符为$1$的话方案数就有两种，否则只有一种</p><p>对于其他情况，$S$的长度大于等于$2$</p><p>枚举$i$，表示在最终的拆分中，$S[i\sim |S|]$这些位置折叠在一起，前面的位置可折叠也可不折叠</p><p>如果$i=|S|$，我们认为最后一个字符没有折叠</p><p>我们记$solve(S)$表示$S$串的答案，$fold(S)$表示$S$串的最后一次操作为折叠操作的答案</p><p>那么有</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (s.size() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span> + (s[<span class="number">0</span>] == <span class="string">'1'</span>);</span><br><span class="line">    <span class="keyword">if</span> (g.count(s)) <span class="keyword">return</span> g[s];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">string</span> L, R;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s.size() - i; j++) L += s[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = s.size() - i + <span class="number">1</span>; j &lt;= s.size(); j++) R += s[j - <span class="number">1</span>];</span><br><span class="line">        res = (res + (LL)solve(L) * fold(R)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g[s] = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来考虑怎么计算$fold(S)$</p><p>枚举最后一次折叠的周期，显然这个周期必须是$|S|$的约数</p><p>假设周期是$j$，我们可以得到一个新的长度为$j$的串，我们记这个串为$s$，$s[i]$为$1$当且仅当$S[i],S[i+j],S[i+2j],\cdots$这些位置都为$1$</p><p>接着，你会发现这个转移似乎要用到$solve(s)$</p><p>于是你得到了两个互相递归调用的函数</p><p>但是实际上这个复杂度是不会爆炸的，因为有记忆化，而状态总数是很少的</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; f, g;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="built_in">string</span> s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; divs[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fold</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.size() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span> + (s[<span class="number">0</span>] == <span class="string">'1'</span>);</span><br><span class="line">    <span class="keyword">if</span> (f.count(s)) <span class="keyword">return</span> f[s];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> l : divs[s.size()]) &#123;</span><br><span class="line">        <span class="built_in">string</span> tmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; i++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; flag &amp;&amp; j &lt;= s.size(); j += l)</span><br><span class="line">                <span class="keyword">if</span> (s[j - <span class="number">1</span>] != <span class="string">'1'</span>) flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (flag) tmp += <span class="string">'1'</span>;</span><br><span class="line">            <span class="keyword">else</span> tmp += <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = (res + solve(tmp)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[s] = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (s.size() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span> + (s[<span class="number">0</span>] == <span class="string">'1'</span>);</span><br><span class="line">    <span class="keyword">if</span> (g.count(s)) <span class="keyword">return</span> g[s];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">string</span> L, R;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s.size() - i; j++) L += s[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = s.size() - i + <span class="number">1</span>; j &lt;= s.size(); j++) R += s[j - <span class="number">1</span>];</span><br><span class="line">        res = (res + (LL)solve(L) * fold(R)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g[s] = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s; <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N - <span class="number">10</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span>; j &lt;= N - <span class="number">10</span>; j += i) divs[j].push_back(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve(s));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGC100D Colorful Sequences</title>
      <link href="/2020/03/03/agc100d-colorful-sequences/"/>
      <url>/2020/03/03/agc100d-colorful-sequences/</url>
      
        <content type="html"><![CDATA[<p>给定两个正整数$N,K$，以及一个长度为$M$的数组$A$，保证$A$中的每一个数都是$1$到$K$之间的整数</p><p>我们认为一个序列是多彩的当且仅当这个序列至少存在一个长度为$K$的子串，使得这个子串中$1$到$K$均出现过</p><p>你需要统计所有长度为$N$的多彩的序列中，$A$作为子串一共出现了多少次</p><script type="math/tex; mode=display">N\leq 25000, K\leq 400, M\leq N</script><a id="more"></a><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>如果无视“存在一个长度为$K$的子串使得$1\sim K$均出现过”这一条件，$A$在所有长度为$N$的序列中一共出现了$(N-M+1)K^{N-M}$次</p><p>接下来考虑加上这一限制</p><p>直接统计不是很好做，可以考虑用总数减去不合法的情况，即$A$在所有序列中出现的总数减去在不满足条件的序列中的出现次数</p><p>我们分两种情况讨论</p><p><strong>1.$A$中没有重复元素</strong></p><p>记$f[i][j]$表示长度为$i$，且末尾共有$j$个不同的数的不合法序列个数</p><p>记$g[i][j]$表示长度为$i$，且末尾共有$j$个不同的数，的所有不合法序列中，包含$A$的总次数</p><p>此时答案仅与$M$有关，与$A$具体是什么无关</p><p>接下来我们考虑$f[i][j]$如何转移</p><p>第一种情况是接上一个与最后$j$个字符都不相同的字符，转移到的状态是$f[i+1][j+1]$，方案数为$K-j$</p><p>第二种情况是接上的字符会导致与最后的$j$个字符出现相同，转移到的状态是$f[i+1][1\sim j]$，方案数只有$1$种</p><p>$g$的转移需要$f$，与$f$的转移类似</p><p>直接$dp$是$O(N^2K)$的，前缀和优化一下可以做到$O(NK)$</p><p><strong>2.$A$中有重复元素</strong></p><p>如果$A$出现的位置确定了，那么$A$前后的序列不会互相影响</p><p>因此我们实际上要统计的是，有多少个序列在接上$A$之后仍然是不合法的</p><p>容易发现$A$只有它的最长不相同前缀以及最长不相同后缀是有用的，如果$A$本身就合法，那么不合法的方案数就是$0$</p><p>考虑沿用之前的$dp$，可以发现这样一件事情：对于$f[i][j]$来说，如果最后$j$个字符是确定的，那么方案数是$\frac{f[i][j]\times (K-j)!}{K!}$，即每个排列作为结尾的方案数是相等的</p><p>发现这个重要的性质之后就很简单了，我们考虑如何统计有多少个序列在接上$A$之和仍然是不合法的</p><p>假设原序列的长度是$i$，$A$的最长不相同前缀长度为$d$</p><p>那么贡献为</p><script type="math/tex; mode=display">\sum_{j=d}^{k-1}\frac{f[i+d][j]\times (K-d)!}{K!}</script><p>我们需要枚举$A$的出现位置以及$j$，因此时间复杂度为$O(nk)$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">25010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">410</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, f[N][M], g[N][M], p1[M], p2[M], frac[M], inv[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Just_DOIT</span><span class="params">(<span class="keyword">int</span> len = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        p1[<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>], p2[<span class="number">0</span>] = g[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= min(i - <span class="number">1</span>, k - <span class="number">1</span>); j++) &#123;</span><br><span class="line">            p1[j] = (p1[j - <span class="number">1</span>] + f[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">            p2[j] = (p2[j - <span class="number">1</span>] + g[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> A = p1[min(i - <span class="number">1</span>, k - <span class="number">1</span>)], B = p2[min(i - <span class="number">1</span>, k - <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= min(i, k - <span class="number">1</span>); j++) &#123;</span><br><span class="line">            f[i][j] = (LL)f[i - <span class="number">1</span>][j - <span class="number">1</span>] * (k - j + <span class="number">1</span>) % mod;</span><br><span class="line">            g[i][j] = (LL)g[i - <span class="number">1</span>][j - <span class="number">1</span>] * (k - j + <span class="number">1</span>) % mod;</span><br><span class="line">            f[i][j] = ((LL)f[i][j] + A - p1[j - <span class="number">1</span>] + mod) % mod, g[i][j] = ((LL)g[i][j] + B - p2[j - <span class="number">1</span>] + mod) % mod;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= len) g[i][j] = (g[i][j] + f[i][j]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Make_Your_Dream_COMETRUE</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, t = (LL)inv[k] * frac[k - len] % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; k; i++) &#123;</span><br><span class="line">        res = (res + (LL)f[left + len][i] * t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N], lst[M], hh[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;k, &amp;m), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lst[A[i]]) tmp = max(tmp, lst[A[i]]);</span><br><span class="line">        lst[A[i]] = i, mx = max(mx, i - tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> all = (LL)(n - m + <span class="number">1</span>) * Pow(k, n - m) % mod;</span><br><span class="line">    <span class="keyword">if</span> (mx &gt;= k) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, all);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mx == m) &#123;</span><br><span class="line">        Just_DOIT(mx); <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++) res = (res + g[n][i]) % mod;</span><br><span class="line">        <span class="keyword">int</span> tmp = (LL)frac[k] * inv[k - mx] % mod;</span><br><span class="line">        res = (LL)res * Pow(tmp, mod - <span class="number">2</span>) % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (all - res + mod) % mod);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Just_DOIT(); <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) </span><br><span class="line">            <span class="keyword">if</span> (A[j] == A[i]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            left = i - <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + m &lt;= n; i++) </span><br><span class="line">        hh[i] = Make_Your_Dream_COMETRUE(i, left);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m - i + <span class="number">2</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">if</span> (A[m - i + <span class="number">1</span>] == A[j]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            right = i - <span class="number">1</span>; <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = all;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + m &lt;= n; i++) </span><br><span class="line">        res = (res - (LL)hh[i] * Make_Your_Dream_COMETRUE(n - i - m, right) % mod + mod) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PKUWC2020 游记</title>
      <link href="/2019/12/26/PKUWC2020-%E6%B8%B8%E8%AE%B0/"/>
      <url>/2019/12/26/PKUWC2020-%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h1><p>WC前在机房待的最后一天了</p><p><del>不搓会osu怎么行呢</del></p><p><del>于是愉快地上了2100pp</del></p><p>成都最近好像有个什么中日韩的峰会，因此第二天需要特别早到机场</p><p>没管面试，晚上很早就睡了</p><h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>7点半的飞机，我5点起的床</p><p>有几位神仙在前几天就去北大参加精英集训了，听说前几天北京一直在下雪</p><p>大概10点的时候终于到了北京，天气很晴朗，路上的积雪都化得差不多了</p><p>入住的时候发现这次订的酒店在SC的酒店的对面</p><p>中午一起出去到酒店旁边恰了顿饭，<del>于是愉快地搓了会malody</del></p><p>下午报道前排了好长的队，顺便%了一波zjc学长</p><p>这次表格里面竟然有“是否能使用linux”这一项，作为linux菜鸡我果断填了否（然而卢爷填了“是”）</p><p>试机咕掉了，晚上继续颓malody</p><h1 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>开幕式似乎没啥好说的，就是结束之后又去酒店补了一波觉</p><p>SC的时候我们就已经体会到北大各大食堂之间深刻的差异，似乎网球场那边的食堂只卖面包</p><p>大概12:40到了机房，发现自己的位置是靠窗第一排？</p><p>没怎么敲模板（好像我也没啥好敲的），登录账号之后熟悉了一下键盘，发现<code>Fn</code>这个键的位置非常毒瘤</p><p>先看了下T1，感觉没什么思路，但是<code>1 2 3 1 3 2 / 2 1 3 2 3 1 / 3 1 2 3 2 1</code>这三段本质上来说似乎只是交换了一下矩阵的行列？</p><p>但是我的做法需要在$n!$个地方插入一个新的数，非常没救</p><p>刚了一个多小时之后决定先敲21分的暴力</p><p>忽然想起好早以前似乎在CF上做过一道很像的题，好像也是把排列拼在一起，但是题意记不太清了</p><p>然后复杂度好像是$O(n)$？而且代码特别短</p><p><del>事后证明我果然记错了</del></p><p>完了，T1不会，感觉心态有点炸裂</p><p>T2是一道998244353，但式子似乎比较良心？</p><p>一开始我把题意理解错了，以为是合并成一棵树型的结构，然后发现第二个样例过不去</p><p>仔细观察后发现好像是合并两个集合</p><p>我把自己的$n^3$随便改了改，然后就过掉了第二个样例，交上去之后只拿了$n\leq 7,n\leq 100$这两档分</p><p>至少式子没推错。然后这个$n^3$貌似是可以优化到$n^2$的？</p><p>似乎只需要预处理$A_t=\sum\limits_{j-i=t}(a[j]-a[i])^2$以及一个组合数就可以了？</p><p>然后我愉快地拿到了$n^2$这一档分</p><p>又仔细观察了一波之后发现这个似乎可以再NTT优化？但是要NTT三遍，而且第三遍的式子有点难推</p><p>冷静一下，先敲完了$l=1,n-1$这两档分数少的可怜的部分分，然后开始看T3，打算最后再来NTT</p><p>我在T3上似乎只花了30分钟时间，敲完前两个$n^2$暴力以及$m=1$的sb莫反就跑路了</p><p>此时离比赛结束还剩半个小时，然而我还没开始写NTT……</p><p>然后抱着试一试的心态果断敲出了4kb代码，最后一个NTT我放弃了，只敲了前两个，复杂度是$n\log n+(r-l+1)n$</p><p>在最后五分钟的时候 过 了 样 例 ！</p><p>果断提交，发现拿了62分。嗯？我$l=r=1$的点RE了？</p><p>检查之后发现sb的我<code>return</code>了<code>printf</code>的返回值，时间不够了，直接复制了我之前写过的特判代码</p><p>最后得分21 + 63 + 43 = 127？成功获得大众分</p><p><del>怎么泥萌都会T1啊</del></p><p>晚上听说第二天面试有英语自我介绍？慌得一批</p><p>赶紧补稿子，然后发现google翻译比自己翻译的好一万倍</p><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>早上面试，复习了一下稿子之后感觉 大 概 没有问题了（吧）</p><p>前两个老师都先让我自我介绍，没有要求英文，良心！</p><p>第一个老师问我怎么接触OI的，以及一个很恐怖的送命题“北大计算机系与清华计算机系的区别是什么”。第二个老师问我昨天/CSP考得如何以及我的文化课怎么样</p><p>第三个老师问了我之前的比赛情况之后就让我提问了</p><p>听说有个老师10：20的时候才面到9：20的学生？</p><p>不管了，滚回酒店睡觉</p><hr><p>12：40准时到机房，找座位找了好久，最后发现是在最左边那个教室的一个角落里，而且我左边没人（雾）</p><p>感觉Day2会比Day1毒得多（事实证明并不是</p><p>T1神TM打铁传说，发现$n^2$是送的，赶紧写</p><p>然后这大概是一个匹配的问题？然后要写线段树维护单调栈？</p><p>我越想感觉越毒瘤，然后在40min的时候发现自己sb了，直接扫一遍预处理出匹配就可以了</p><p>代码长度700B，终于有一道能让我签到的题了</p><p>T2看起来一脸不可做，仔细思考后发现每个数要么乘要么除，而且好像只与到$l$的单调栈元素个数有关？</p><p>如果每个数向它左边第一个比它大的数连边，那么此时每个数的单调栈元素个数等价于只考虑下标在$[l,n]$之间的这些节点时的深度</p><p>然后我马上就写了65那一档，就是更新的时候暴力dfs子树，然后复杂度貌似很优秀</p><p>这似乎是一个二维偏序，但是我不想写树套树</p><p>冷静一下之后发现一棵子树内对应的下标也是连续的，因此这个二维偏序本质上还是一个一维的东西，直接上线段树就好了</p><p>代码出人意料得好写，我一遍过了样例</p><p>顺便发现，暴力dfs在随机那一档分的表现比正解优秀233</p><p>根据SC“线弦图”的经验，我觉得吉老师会在T3放一道毒瘤题</p><p>赶紧写了19分暴力，这个时候离比赛结束还有两个小时，反正闲着也是闲着，还不如想一想T3</p><p>很快我发现似乎不用跑最大流，首先环上有两条边是必须要割的，然后枚举这两条割的边。于是只需要维护一个数据结构，支持矩阵取min？</p><p>我将自己的19分暴力改成了差分，发现$n=300$跑了3.5s</p><p>果断将<code>multiset</code>改成带删除的优先队列，瞬间快了一倍</p><p>在考试快结束的时候码了一个四分树，一开始<code>update</code>要传10个参数然后被无情卡T了，一气之下将10个参数压成5个，然后快了2/3</p><p>所以最后100 + 100 + 68 = 268，听说本校zyw神仙两个半小时就AK离场了</p><p><del>完了，听说人均300</del></p><p>晚上继续颓malody</p><h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h1><p>闭营仪式感觉还行，可惜吉老师咕咕咕了</p><p>似乎讲到D1T3的时候全场都在笑</p><p><img src="image-20191226101141171.png" alt="image-20191226101141171"></p><p>然后就是发约了，又是那两张熟悉的桌子，如愿拿了一等</p><p><strong>orz本校初二神仙cjz一等</strong></p><p>最后395，比CSP高得多，还是不虚此行吧</p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>组合计数</title>
      <link href="/2019/12/16/zu-he-ji-shu/"/>
      <url>/2019/12/16/zu-he-ji-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="非常基础的东西"><a href="#非常基础的东西" class="headerlink" title="非常基础的东西"></a>非常基础的东西</h2><ul><li>组合数</li></ul><script type="math/tex; mode=display">{n\choose m}=\frac{n !}{m ! \times(n-m) !}</script><ul><li><code>Pascal</code>公式</li></ul><script type="math/tex; mode=display">{n\choose m}={n-1\choose m}+{n-1\choose m-1}</script><ul><li>二项式定理</li></ul><script type="math/tex; mode=display">(x+y)^n=\sum_{i=0}^n{n\choose i}x^iy^{n-i}</script><ul><li><code>Lucas</code>定理</li></ul><script type="math/tex; mode=display">{n\choose m}\mod p=\prod {n_i\choose m_i}\mod p</script><p>这里$n_i,m_i$分别表示$n,m$在$p$进制下的第$i$位</p><a id="more"></a><h2 id="一些组合恒等式"><a href="#一些组合恒等式" class="headerlink" title="一些组合恒等式"></a>一些组合恒等式</h2><script type="math/tex; mode=display">\begin{gathered}{n\choose m}={n\choose n-m}\\  \sum_{i=0}^n{n\choose i}=2^n\\  \sum_{i=0}^n{n\choose i}[2\mid i]=\sum_{i=0}^n{n\choose i}[2\nmid i]=2^{n-1}\\  \sum_{i=0}^m{n+i\choose n}={n+m+1\choose m}\\  \sum_{i=m}^n{i\choose m}={n+1\choose m+1}\\  {n\choose m}{m\choose k}={n\choose k}{n-k\choose m-k}\\  \sum_{i=0}^k{n\choose i}{m\choose k-i}={n+m\choose k}\end{gathered}</script><p>这里解释一下最后四个恒等式</p><p>对于倒数第四个，我们可以认为每次钦定选择的最后一个位置，枚举$i$的时候代表最后一个取的位置是$n+i+1$，然后再在前面的位置随便选取$n$个</p><p>因此它的组合意义是，一共有$n+m+1$个数，我们要从中选出$n+1$个数，即${n+m+1\choose n+1}={n+m+1\choose m}$</p><p>对于倒数第三个同理，即枚举最后一个选择的位置</p><p>对于倒数第二个，我们可以认为它的组合意义是先从$n$个数里面选择$m$个数，再从这$m$个数中选择$k$个数</p><p>那么，这个过程等价于先从$n$个数里面选择$k$个数，再从剩下的数中选择$m−k$个数，就是等式右边</p><p>对于最后一个，我们可以认为它是将$n+m$个数分成了两部分，第一部分是前$n$个数，第二部分是后$m$个数。然后再在这$n+m$个数中选择$k$个数，而等式左边枚举了前$n$个数中被选出的数的个数，因此这两个过程是等价的</p><h2 id="常见数列"><a href="#常见数列" class="headerlink" title="常见数列"></a>常见数列</h2><ul><li>斐波那契数列</li></ul><script type="math/tex; mode=display">F_n=F_{n-1}+F_{n-2}</script><ul><li>错排数</li></ul><script type="math/tex; mode=display">\begin{gathered}D_n=(n-1)(D_{n-1}+D_{n-2})\\  D_n=n!\sum_{i=0}^n(-1)^i\frac{1}{i!}\end{gathered}</script><p>考虑递推式的意义：我们将错排写成轮换的形式，考虑第$n$个位置所在的循环，那么有两种可能：一是加入了前$n−1$个数的轮换，二是与另外某个数形成了一个大小为$2$的循环</p><p>第一种情况中，它可能排在任意一个数的后面，因此方案数是$n−1$</p><p>第二种情况中，另外一个数有$n−1$种选法，因此方案数也是$n−1$</p><p>接下来看下面这个通项公式，这里实际上容斥的是有哪些位置没有错排</p><p>那么显然有</p><script type="math/tex; mode=display">\begin{aligned} D_n&=\sum_{i=0}^n(-1)^i{n\choose i}(n-i)!\\  &=n!\sum_{i=0}^n(-1)^i\frac{1}{i!} \end{aligned}</script><ul><li>卡特兰数</li></ul><script type="math/tex; mode=display">\begin{gathered}C_n=\sum_{i=0}^{n-1}C_iC_{n-i-1}\\  C_n={2n\choose n}-{2n\choose n+1}=\frac{1}{n+1}{2n\choose n}\\  C_n=\frac{2(2n-1)}{n+1}C_{n-1}\end{gathered}</script><ul><li>斯特林数</li></ul><script type="math/tex; mode=display">\begin{gathered}\begin{bmatrix}n\\ m\end{bmatrix}=\begin{bmatrix}n-1\\ m-1\end{bmatrix}+(n-1)\begin{bmatrix}n-1\\ m\end{bmatrix}\\  \begin{Bmatrix}n\\ m\end{Bmatrix}=\begin{Bmatrix}n-1\\ m-1\end{Bmatrix}+m\begin{Bmatrix}n-1\\ m\end{Bmatrix}\\  \begin{Bmatrix}n\\ m\end{Bmatrix}=\frac{1}{m!}\sum_{k=0}^m(-1)^k{m\choose k}(m-k)^n\end{gathered}</script><p>第一类斯特林数代表将$n$个数分成$m$个圆排列的方案数</p><p>第二类斯特林数代表将$n$个数分成$m$个集合的方案数</p><p>通项公式实际上还是容斥，容斥哪些集合是空的，由于集合与集合是没有区别的，因此最后要除以$m!$</p><ul><li>贝尔数</li></ul><script type="math/tex; mode=display">B_n=\sum_{k=0}^n\begin{Bmatrix}n\\ k\end{Bmatrix}\\  B_{n+1}=\sum_{k=0}^n{n\choose k}B_k</script><p>即将$n$个数划分成若干个集合的方案数</p><p>递推公式表示枚举第$n+1$个数和哪些数不在同一个集合中</p><h2 id="自然数幂之和"><a href="#自然数幂之和" class="headerlink" title="自然数幂之和"></a>自然数幂之和</h2><script type="math/tex; mode=display">S_k(n)=\sum_{i=1}^ni^k</script><ul><li>拉格朗日插值</li></ul><p>它是一个$k+1$次多项式</p><ul><li>斯特林数</li></ul><p>我们知道</p><script type="math/tex; mode=display">n^m=\sum_{i=0}^m\begin{Bmatrix}m\\ i\end{Bmatrix}n^{\underline i}=\sum_{i=0}^m\begin{Bmatrix}m\\ i\end{Bmatrix}i!{n\choose i}</script><p>其中$n^{\underline i}$即$n$的$i$次下降幂，表示从$n$个数中有序地选出$i$个不同的数的方案数</p><p>考虑$nm$的组合意义，即有序地选$m$个$1\sim n$的数，可以相同的方案数</p><p>右边式子中枚举的$i$表示将选出来的相同的数缩在一起之后，有多少类数，显然方案数为将$m$个数划分成$i$个集合的方案数，乘以在$1\sim n$中有序地选出$i$个数的方案数</p><p>结合上面的式子以及斯特林反演，可以得到</p><script type="math/tex; mode=display">\begin{aligned} n^{\underline m}&=\sum_{i=0}^m(-1)^{m-i}\begin{bmatrix}m\\ i\end{bmatrix}n^i\\  &=\sum_{i=0}^{m-1}(-1)^{m-i}\begin{bmatrix}m\\ i\end{bmatrix}n^i+n^m\\  n^m&=n^{\underline m}-\sum_{i=0}^{m-1}(-1)^{m-i}\begin{bmatrix}m\\ i\end{bmatrix}n^i\\  S_m(n)&=m!\sum_{i=1}^n{i\choose m}-\sum_{i=1}^n\sum_{j=0}^{m-1}(-1)^{m-j}\begin{bmatrix}m\\ j\end{bmatrix}i^j\\  &=\frac{(n+1)^{\underline{m+1}}}{m+1}-\sum_{j=0}^{m-1}(-1)^{m-j}\begin{bmatrix}m\\ j\end{bmatrix}S_j(n) \end{aligned}</script><ul><li>伯努利数以及伯努利多项式</li></ul><p><code>I don&#39;t know, fuck you.</code></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="ARC102E-Stop-Otherwise…"><a href="#ARC102E-Stop-Otherwise…" class="headerlink" title="ARC102E Stop. Otherwise…"></a>ARC102E Stop. Otherwise…</h3><p>有$N$个不可区分的$K$面骰子，对于每个$i=2,3,⋯2K$，求有多少种方案使得：任意两个骰子朝上的面要么相同，要么和不为$i$。答案对$998244353$取模。</p><script type="math/tex; mode=display">2\leq N\leq 2000,1\leq K\leq 2000</script><p>假设固定了$i$，那么限制就相当于：出现第$1$面的骰子与出现第$i−1$面的骰子不能同时出现；出现第$2$面的骰子与出现第$i−2$面的骰子不能同时出现……，我们将这样不能同时出现的面归为一组</p><p>显然，一共有$l=\lfloor\frac i2\rfloor$组限制</p><p>我们枚举在最终的方案中，这些限制所影响的组中一共有多少组至少出现了一个骰子，假设有$i$个，那么方案数为${l\choose i}2^i$，即从$l$组中选出$i$组，每一组有两种选法</p><p>对于选出的$i$组，每一组至少要选一个，因此我们可以将$n$减去$i$，即预先给每一组都塞上一个</p><p>接下来问题等价于将$n−i$个骰子分配给$i+k−2l$种面的方案数，可空，使用插板法即可</p><p>那么答案为</p><script type="math/tex; mode=display">\sum_{i=0}^l{l\choose i}2^i{n+k-2l-1\choose i+k-2l-1}</script><h3 id="ARC101E-Ribbons-on-Tree"><a href="#ARC101E-Ribbons-on-Tree" class="headerlink" title="ARC101E Ribbons on Tree"></a>ARC101E Ribbons on Tree</h3><p>给出一棵n个点的树，你要统计将所有点匹配的方案数，使得每一条边都至少被一对匹配点的最短路径覆盖，答案$\mod 10^9+7$，保证$n$是偶数</p><p>$n≤5000$</p><p>先考虑暴力容斥</p><p>枚举哪些边不满足条件，假设边集为$S$，那么方案数就是原树将$S$集合中的边抠掉之后的匹配数，即每一个连通块的匹配数之积</p><p>一个连通块的匹配数显然只与这个连通块的大小有关，那么我们可以将这个容斥写成$dp$的形式，即$dp[u][i]$表示考虑$u$以及$u$的子树，当前连通块大小为$i$时的贡献之和</p><p>当我们考虑了$u$的所有子树之和，我们尝试割去$u$与其父亲的连边，注意此时贡献要取反，因为容斥系数是$(−1)^{|S|}$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[N][N], g[N], sz[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>, f[u][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != fa) &#123;</span><br><span class="line">            dfs(e[i].to, u);</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">int</span> tmp[N];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sz[e[i].to] + sz[u]; j++) tmp[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= sz[e[i].to]; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= sz[u]; k++)</span><br><span class="line">                    tmp[j + k] = (tmp[j + k] + (LL)f[e[i].to][j] * f[u][k]) % mod;</span><br><span class="line">            sz[u] += sz[e[i].to];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sz[u]; j++) f[u][j] = tmp[j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sz[u]; j++)    </span><br><span class="line">        f[u][<span class="number">0</span>] = (f[u][<span class="number">0</span>] - (LL)f[u][j] * g[j] % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>) g[i] = (LL)g[i - <span class="number">2</span>] * (i - <span class="number">1</span>) % mod;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mod - f[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ARC096E-Everything-on-it"><a href="#ARC096E-Everything-on-it" class="headerlink" title="ARC096E Everything on it"></a>ARC096E Everything on it</h3><p>求有多少个子集的集合，满足</p><ul><li>其中任意一个子集都是$\{1,2,\cdots n\}$的子集</li><li>任意两个子集不能相同</li><li>$1,2,\cdots n$每个数都至少出现了两次</li></ul><p>答案对质数$M$取模</p><script type="math/tex; mode=display">2\leq n\leq 3000,10^8\leq M\leq 10^9+9</script><p>考虑枚举有多少个数至多出现了一次，假设有$i$个</p><p>再假设这些数分到了$j$个集合中，由于每个数可能出现，也可能没有出现，因此我们可以添加一个数$0$，然后再将这些数划分为$j+1$个集合，与$0$在同一个集合的那些数表示没有出现</p><p>因此这一步的方案数为$\begin{Bmatrix}i+1\\ j+1\end{Bmatrix}$</p><p>其余的数可以出现，也可以不出现。受影响的集合一共有$j$个，方案数为$(2^{n-i})^j$</p><p>对于其余的集合，当前选出的i个数一定没有出现过，对应出来的每一种集合也可以选择出现或者不出现，因此方案数为$2^{2^{n-i}}$</p><p>因此答案为</p><script type="math/tex; mode=display">\sum_{i=0}^n(-1)^i{n\choose i}\begin{Bmatrix}i+1\\ j+1\end{Bmatrix}(2^{n-i})^j2^{2^{n-i}}</script><p>注意指数上是模$M−1$而不是$M$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3010</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> mod;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> mod = mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> S[N][N], C[N][N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    S[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) </span><br><span class="line">            C[i][j] = (C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        S[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            S[i][j] = (S[i - <span class="number">1</span>][j - <span class="number">1</span>] + (LL)S[i - <span class="number">1</span>][j] * j) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, res = <span class="number">0</span>; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; mod, init(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> other = Pow(<span class="number">2</span>, Pow(<span class="number">2</span>, n - i, mod - <span class="number">1</span>)), tmp = (LL)C[n][i] * other % mod, base = Pow(<span class="number">2</span>, n - i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, t = base; j &lt;= i; j++) &#123;</span><br><span class="line">            tmp = (tmp + (LL)C[n][i] * t % mod * other % mod * S[i + <span class="number">1</span>][j + <span class="number">1</span>]) % mod;</span><br><span class="line">            t = (LL)t * base % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>) res = (res - tmp + mod) % mod;</span><br><span class="line">        <span class="keyword">else</span> res = (res + tmp) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ARC093F-Dark-Horse"><a href="#ARC093F-Dark-Horse" class="headerlink" title="ARC093F Dark Horse"></a>ARC093F Dark Horse</h3><p>有$2^n$名选手，编号为$1$至$2^n$，现在这$2^n$名选手将进行$n$轮淘汰赛，决出胜者。若$x&lt;y$，则当$x$与$y$对决时，$x$能获胜。但是有$m$个例外，$1$号选手在与这$m$个人对决的时候会输。问有多少种排列方式使得最终$1$号选手能取得胜利，答案对$10^9+7$取模</p><p>对决的方式是每轮选择排列中的第$2i−1$与第$2i$名选手对决</p><script type="math/tex; mode=display">1\leq n\leq 16, 0\leq m\leq 16</script><p>首先我们钦定$1$在排列的第一个位置，由于对决是一棵二叉树的形式，因此$1$实际上放哪里都无所谓</p><p>接下来，$1$会分别与$p_2,\min\{p_3,p_4\},\min\{p_5,p_6,p_7,p_8\},\cdots$对决，那么限制就等价于：$p_2,\min\{p_3,p_4\},\min\{p_5,p_6,p_7,p_8\},\cdots$中都不能出现给定的$m$个数</p><p>考虑容斥，枚举有哪些集合的最小值是给出的$m$个数之一</p><p>将给定的$m$个数排序，记$dp[i][S]$表示以及考虑了$m$个数中的前$i$个数，这$i$个数占据了$S$集合的方案数</p><p>注意这里我们只给确定的集合分配其它数，即只有$S$集合内的数在此时的$dp$中是被考虑了的</p><p>假设我们现在要将第$k$大的限制加入某个集合，此时可以很方便地得到当前可以用的，并且比这个第$k$大的限制还要大的数的个数，将约束排序的作用就体现在这里</p><p>转移就是</p><script type="math/tex; mode=display">dp[i+1][S|2^j]=dp[i+1][S|2^j]+dp[i][S]\times{2^n-i-A_i\choose 2^j-1}\times2^j!</script><p>即从剩下的数中选择$2^j−1$个数填入当前集合，这$2^j−1$个数以及当前的限制$A_i$可以在集合内随便排列</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = (<span class="number">1</span> &lt;&lt; N) + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[M], inv[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fucked[<span class="number">17</span>], dp[<span class="number">17</span>][<span class="number">1</span> &lt;&lt; N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1</span> &lt;&lt; n; i++) </span><br><span class="line">        frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;fucked[i]);</span><br><span class="line">    sort(fucked + <span class="number">1</span>, fucked + m + <span class="number">1</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a &gt; b;&#125;), dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">                dp[i][j] = (dp[i][j] + dp[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">                <span class="keyword">int</span> upper = (<span class="number">1</span> &lt;&lt; n) - fucked[i] - j;</span><br><span class="line">                <span class="keyword">if</span> (upper &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">                    <span class="keyword">if</span> (!(j &amp; (<span class="number">1</span> &lt;&lt; k - <span class="number">1</span>))) </span><br><span class="line">                        dp[i][j | (<span class="number">1</span> &lt;&lt; k - <span class="number">1</span>)] = (dp[i][j | (<span class="number">1</span> &lt;&lt; k - <span class="number">1</span>)] + (LL)dp[i - <span class="number">1</span>][j] * C(upper, (<span class="number">1</span> &lt;&lt; k - <span class="number">1</span>) - <span class="number">1</span>)</span><br><span class="line">                            % mod * frac[<span class="number">1</span> &lt;&lt; k - <span class="number">1</span>]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">1</span> &lt;&lt; n; s++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = (LL)dp[m][s] * frac[(<span class="number">1</span> &lt;&lt; n) - s - <span class="number">1</span>] % mod;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_popcount(s) &amp; <span class="number">1</span>) res = (res - tmp + mod) % mod;</span><br><span class="line">        <span class="keyword">else</span> res = (res + tmp) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL)res * (<span class="number">1</span> &lt;&lt; n) % mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UOJ422-【集训队作业-2018】小Z的礼物"><a href="#UOJ422-【集训队作业-2018】小Z的礼物" class="headerlink" title="UOJ422 【集训队作业 2018】小Z的礼物"></a>UOJ422 【集训队作业 2018】小Z的礼物</h3><p>给定$n\times m$的方格，每个格子中都有一个礼物，其中有些礼物是小Z喜欢的</p><p>每次小Z会等概率地随机选取某两个相邻格子中的礼物（得到过的礼物可能会再次得到），求得到所有小Z喜欢的礼物的时间的期望</p><script type="math/tex; mode=display">n\leq 6,m\leq 100</script><p>格子对一共有$t=2(n−1)(m−1)+n+m−2$个</p><p>首先<code>min-max</code>容斥一下，考虑暴力容斥：枚举喜欢的礼物的子集，然后统计出与这些位置有关的“格子对”的数量，假设是$k$</p><p>那么，这种情况的<code>min</code>，即选出的格子至少有一个被选中的概率是$\frac{k}{t}$，期望次数就是$\frac{t}{k}$</p><p>因此我们轮廓线$dp$一下，记录$dp[i][s][j]$表示当前位置为$i$，最后$n$个格子状态为$s$，此时选出的格子与$j$个“格子对”有关时的贡献</p><p>注意新选一个格子的时候贡献要取反</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][<span class="number">1</span> &lt;&lt; N][<span class="number">1200</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> G[N + <span class="number">1</span>][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, G[i] + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = mod - <span class="number">1</span>; <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> all = <span class="number">2</span> * (n - <span class="number">1</span>) * (m - <span class="number">1</span>) + n - <span class="number">1</span> + m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            cur ^= <span class="number">1</span>, <span class="built_in">memset</span>(dp[cur], <span class="number">0</span>, <span class="keyword">sizeof</span>(dp[cur]));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">1</span> &lt;&lt; n; s++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> ls = <span class="number">0</span>; ls &lt;= all; ls++) <span class="keyword">if</span> (dp[cur ^ <span class="number">1</span>][s][ls]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> turn = (s &lt;&lt; <span class="number">1</span>) &amp; ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>), t = ((s &amp; <span class="number">1</span>) &amp;&amp; (j != <span class="number">1</span>)) + ((s &amp; <span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>) &amp;&amp; (i != <span class="number">1</span>))), t2 = (i != <span class="number">1</span>) + (j != <span class="number">1</span>);</span><br><span class="line">                    dp[cur][turn][ls + t] = (dp[cur][turn][ls + t] + dp[cur ^ <span class="number">1</span>][s][ls]) % mod;</span><br><span class="line">                    <span class="keyword">if</span> (G[j][i] == <span class="string">'*'</span>) dp[cur][turn | <span class="number">1</span>][ls + t2] = (dp[cur][turn | <span class="number">1</span>][ls + t2] - dp[cur ^ <span class="number">1</span>][s][ls] + mod) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">1</span> &lt;&lt; n; s++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ls = <span class="number">1</span>; ls &lt;= all; ls++) <span class="keyword">if</span> (dp[cur][s][ls]) </span><br><span class="line">            res = (res + (LL)dp[cur][s][ls] * all % mod * Pow(ls, mod - <span class="number">2</span>)) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="斯特林反演"><a href="#斯特林反演" class="headerlink" title="斯特林反演"></a>斯特林反演</h1><h2 id="几个引理以及推论"><a href="#几个引理以及推论" class="headerlink" title="几个引理以及推论"></a>几个引理以及推论</h2><script type="math/tex; mode=display">\begin{gathered}n^m=\sum_{i=0}^m\begin{Bmatrix}m\\ i\end{Bmatrix}n^{\underline i}\\  n^{\overline m}=\sum_{i=0}^m\begin{bmatrix}m\\ i\end{bmatrix}n^i\\  f(n)=\sum_{k=0}^m\begin{Bmatrix}n\\ k\end{Bmatrix}g(k)\Leftrightarrow g(n)=\sum_{k=0}^n(-1)^{n-k}\begin{bmatrix}n\\ k\end{bmatrix}f(k)\\  \sum_{k=m}^n(-1)^{n-k}\begin{bmatrix}n\\ k\end{bmatrix}\begin{Bmatrix}k\\ m\end{Bmatrix}=[m=n]\\  \sum_{k=m}^n(-1)^{n-k}\begin{Bmatrix}n\\ k\end{Bmatrix}\begin{bmatrix}k\\ m\end{bmatrix}=[m=n]\\  x^{\underline n}=(-1)^n(-x)^{\overline n},x^{\overline n}=(-1)^n(-x)^{\underline n}\end{gathered}</script><p>第一个式子我们之前证明过</p><p>接下来我们一个一个来</p><script type="math/tex; mode=display">n^{\overline m}=\sum_{i=0}^m\begin{bmatrix}m\\ i\end{bmatrix}n^i</script><p>采用数学归纳法证明</p><script type="math/tex; mode=display">\begin{aligned} n^{\overline m}&=(n+m-1)n^{\overline{m-1}}\\  &=(n+m-1)\sum_i\begin{bmatrix}m-1\\ i\end{bmatrix}n^i\\  &=\sum_i\begin{bmatrix}m-1\\ i\end{bmatrix}n^{i+1}+\sum_i\begin{bmatrix}m-1\\ i\end{bmatrix}n^i(m-1)\\  &=\sum_i\begin{bmatrix}m-1\\ i-1\end{bmatrix}n^i+\sum_i\begin{bmatrix}m-1\\ i\end{bmatrix}n^i(m-1)\\  &=\sum_i(\begin{bmatrix}m-1\\ i-1\end{bmatrix}+(m-1)\begin{bmatrix}m-1\\ i\end{bmatrix})n^i\\  &=\sum_{i=0}^m\begin{bmatrix}m\\ i\end{bmatrix}n^i \end{aligned}</script><p>反转公式</p><script type="math/tex; mode=display">\sum_{k=m}^n(-1)^{n-k}\begin{bmatrix}n\\ k\end{bmatrix}\begin{Bmatrix}k\\ m\end{Bmatrix}=[m=n]\\  \sum_{k=m}^n(-1)^{n-k}\begin{Bmatrix}n\\ k\end{Bmatrix}\begin{bmatrix}k\\ m\end{bmatrix}=[m=n]</script><p>需要用到上面列出的式子中的最后一个，就是那个上升下降幂互换的</p><script type="math/tex; mode=display">\begin{aligned} n^m&=\sum_{i=0}^m\begin{Bmatrix}m\\ i\end{Bmatrix}n^{\underline i}\\  &=\sum_{i=0}^m\begin{Bmatrix}m\\ i\end{Bmatrix}(-1)^i(-n)^{\overline i}\\  &=\sum_{i=0}^m\begin{Bmatrix}m\\ i\end{Bmatrix}(-1)^i\sum_{j=0}^i\begin{bmatrix}i\\ j\end{bmatrix}(-n)^j\\  &=\sum_{j=0}^mn^j\sum_{i=j}^m\begin{Bmatrix}m\\ i\end{Bmatrix}\begin{bmatrix}i\\ j\end{bmatrix}(-1)^{i-j} \end{aligned}</script><p>注意到第二个求和符号后面的式子是与n无关的。要保证上面的式子成立，必须满足</p><script type="math/tex; mode=display">\sum_{i=j}^m\begin{Bmatrix}m\\ i\end{Bmatrix}\begin{bmatrix}i\\ j\end{bmatrix}(-1)^{i-j}=[j=m]</script><p>就是第二个反转公式</p><p>第一个公式的证明同理</p><p>斯特林反演：</p><script type="math/tex; mode=display">f(n)=\sum_{k=0}^m\begin{Bmatrix}n\\ k\end{Bmatrix}g(k)\Leftrightarrow g(n)=\sum_{k=0}^n(-1)^{n-k}\begin{bmatrix}n\\ k\end{bmatrix}f(k)</script><p>我们假设有</p><script type="math/tex; mode=display">g(n)=\sum_{k=0}^n(-1)^{n-k}\begin{bmatrix}n\\ k\end{bmatrix}f(k)</script><p>那么</p><script type="math/tex; mode=display">\begin{aligned} f(n)&=\sum_{i=0}^n[i=n]f(i)\\  &=\sum_{i=0}^n\sum_{j=i}^n\begin{Bmatrix}n\\ j\end{Bmatrix}\begin{bmatrix}j\\ i\end{bmatrix}(-1)^{j-i}f(i)\\  &=\sum_{j=0}^n\begin{Bmatrix}n\\ j\end{Bmatrix}\sum_{i=0}^j\begin{bmatrix}j\\ i\end{bmatrix}(-1)^{j-i}f(i)\\  &=\sum_{j=0}^n\begin{Bmatrix}n\\ j\end{Bmatrix}g(j) \end{aligned}</script><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><h3 id="【2018-雅礼集训】方阵"><a href="#【2018-雅礼集训】方阵" class="headerlink" title="【2018 雅礼集训】方阵"></a>【2018 雅礼集训】方阵</h3><p>有一个$n\times m$的网格，每个格子要填上一个$[1,c]$的数，问任意两行或任意两列均不同的方案数</p><script type="math/tex; mode=display">n,m\leq 5000</script><p>行、列同时有限制，我们先只考虑行的限制</p><p>一行有$c^m$种填法，要求每行都不相同，因此n行就有$g(m)=(c^m)^{\underline n}$种填法</p><p>现在考虑列的限制，设$f(m)$表示$n\times m$的矩阵，行、列均满足条件的方案数</p><p>将相同的列缩在一起，枚举缩完之和的列的数量，那么有</p><script type="math/tex; mode=display">g(m)=\sum_{i=0}^m\begin{Bmatrix}m\\ i\end{Bmatrix}f(i)</script><p>根据斯特林反演，可以得到</p><script type="math/tex; mode=display">f(m)=\sum_{i=0}^m(-1)^{m-i}\begin{bmatrix}m\\ i\end{bmatrix}g(i)</script><p>时间复杂度$n^2$</p><h3 id="一道例题"><a href="#一道例题" class="headerlink" title="一道例题"></a>一道例题</h3><p>给出一棵$n$个点的树，从某个点出发开始随机游走：在点$u$时，有$p_u$的概率留在原地，否则等概率向相邻的节点移动，直到移动到$1$号节点</p><p>求从每个点出发直至停下所花费的时间的$k$次方的期望</p><script type="math/tex; mode=display">n\leq 10^5,k\leq 10^5,nk\leq 10^6</script><p>我们设$t_u$表示在某次随机中，节点$u$到达$1$号节点<strong>实际</strong>需要的时间</p><p>那么我们需要求的就等价于</p><script type="math/tex; mode=display">\begin{aligned} E(t_u^k)&=E[\sum_{i=0}^k\begin{Bmatrix}k\\ i\end{Bmatrix}{t_u\choose i}i!]\\  &=\sum_{i=0}^k\begin{Bmatrix}k\\ i\end{Bmatrix}i!E[{t_u\choose i}] \end{aligned}</script><p>因此问题的关键在于求出$E({t_u\choose i})$</p><p>我们考虑如下转移</p><script type="math/tex; mode=display">E[{t_u\choose i}]=P_uE[{t_u+1\choose i}]+\frac{1-P_u}{|v|}\sum_vE[{t_v+1\choose i}]</script><p>将组合数拆开</p><script type="math/tex; mode=display">E[{t_u\choose i}]=P_u(E[{t_u\choose i}]+E[{t_u\choose i-1}])+\frac{1-P_u}{|v|}\sum_vE[{t_v\choose i}]+E[{t_v\choose i-1}]</script><p>在算出$E[{t_u\choose i}]$之前，$E[{t_u\choose i-1}]$已经被算出了，我们设$dp_u=E[{t_u\choose i}],a_u=E[{t_u\choose i-1}]$</p><p>那么有</p><script type="math/tex; mode=display">dp_u=P_udp_u+P_ua_u+\frac{1-P_u}{|v|}\sum_vdp_v+a_v</script><p>注意到$v$可以取到$u$的父亲，我们将这种情况单独拿出来</p><p>根据套路，$dp_u$一定可以表示为$A_udp_f+B_u$</p><p>后面我就不推了，根据这个式子可以分别得出$A_u,B_u$</p><p>时间复杂度$O(nk)$</p><h3 id="另一道例题"><a href="#另一道例题" class="headerlink" title="另一道例题"></a>另一道例题</h3><p>求$n$个点的带标号无向图的联通块数$k$次方幂之和</p><script type="math/tex; mode=display">n\leq 10^5,k\leq 15</script><p>$n$个点带标号连通无向图的数量很好求</p><p>我们假设一张图有$m$个联通块，那么它对答案的贡献就是</p><script type="math/tex; mode=display">m^k=\sum_{i=0}^k\begin{Bmatrix}k\\ i\end{Bmatrix}i!{m\choose i}</script><p>因此我们需要计算的是从这$m$个联通块中选出$i$个联通块的方案数</p><p>构造$k$个生成函数</p><p>我们设$G(x)$为带标号连通无向图的EGF，$F(x)$为无向图的EGF</p><p>显然有</p><script type="math/tex; mode=display">F(x)=\sum_{i\geq 0}\frac{G(x)^i}{i!}=\exp G(x)\\ G(x)=\ln F(x)</script><p>那么设</p><script type="math/tex; mode=display">\begin{aligned} H_k(x)&=\sum_{i\geq 0}\frac{G(x)^i}{i!}{i\choose k}\\  &=\sum_{i\geq 0}\frac{G(x)^i}{i!}\frac{i!}{k!(i-k)!}\\  &=\frac{1}{k!}\sum_{i\geq 0}\frac{G(x)^i}{(i-k)!}\\  &=\frac{G(x)^k}{k!}\sum_{i\geq 0}\frac{G(x)^{i-k}}{(i-k)!}\\  &=\frac{G(x)^k}{k!}\exp G(x)\\  &=\frac{G(x)^k}{k!}F(x) \end{aligned}</script><p>递推即可</p><h3 id="【清华集训-2017】生成树计数"><a href="#【清华集训-2017】生成树计数" class="headerlink" title="【清华集训 2017】生成树计数"></a>【清华集训 2017】生成树计数</h3><p>在一个$s$个点的图中，存在$s−n$条边，使图中形成了$n$个连通块，第$i$个连通块中有$a_i$个点</p><p>现在我们需要再连接$n−1$条边，使该图变成一棵树。对于一种连边方案，设原图中第$i$个连通块连出了$d_i$条边，那么这棵树$T$的价值为</p><script type="math/tex; mode=display">\text{val}(T)=\left(\prod_{i=1}^nd_i^m\right)\left(\sum_{i=1}^nd_i^m\right)</script><p>求出所有可能的生成树的价值之和，对$998244353$取模</p><script type="math/tex; mode=display">n\leq 3\times 10^4,m\leq 30</script><p>首先我们知道</p><script type="math/tex; mode=display">ans=\sum_T\sum_{i=1}^nd_i^m\prod_{j=1}^nd_j^ma_j^{d_j}</script><p>乘这个$a_i^{d_i}$是因为每个连通块连出的边都可以从这个连通块内部的任意一个点连出去，因此一条边有$a_i$种选择端点的方案</p><p>将累乘中$i=j$的项提到前面来</p><script type="math/tex; mode=display">ans=\sum_T\sum_{i=1}^nd_i^{2m}a_i^{d_i}\prod_{i\neq j}d_j^ma_j^{d_j}</script><p>考虑将$T$去掉，改写成<code>prufer</code>序，我们枚举每个点在序列中的出现次数$c_i$，显然有$d_i=c_i+1$</p><p>对于一个确定的长度为$n−2$的prufer序，我们知道每个数的出现次数，那么对应的序列就有$\frac{(n-2)!}{\prod c_i!}$种</p><p>因此，有</p><script type="math/tex; mode=display">ans=\sum_{i=1}^n\sum_{\sum c_i=n-2}\frac{(n-2)!}{\prod c_i!}(c_i+1)^{2m}a_i^{c_i+1}\prod_{j\neq i}(c_j+1)^ma_j^{c_j+1}</script><p>考虑构造生成函数</p><script type="math/tex; mode=display">\begin{aligned} A_i(x)&=\sum_ka_i^{k+1}\frac{(k+1)^{2m}}{k!}x^k\\  B_i(x)&=\sum_ka_i^{k+1}\frac{(k+1)^m}{k!}x^k \end{aligned}</script><p>这样的好处是，我们现在可以通过$x$的指数控制$\sum c_i$</p><p>那么有</p><script type="math/tex; mode=display">ans=(n-2)![x^{n-2}]\sum_{i=1}^nA_i(x)\prod_{j\neq i}B_i(x)</script><p>考虑将$A_i(x),B_i(x)$化简</p><p>这里的做法是：先积分再求导<del>我也不知道怎么想到的</del></p><p>考虑设出$T(x)$表示$A_i(x)$的不定积分</p><script type="math/tex; mode=display">\begin{aligned} T(x)&=\int A_i(x)\text{ d}x=\sum_{k}a_i^{k+1}\frac{(k+1)^{2m}}{(k+1)!}x^{k+1}\\  &=\sum_{k}a_i^k\frac{k^{2m}}{k!}x^k\\  &=\sum_{k}a_i^k\sum_{j=0}^{2m}\begin{Bmatrix}2m\\ j\end{Bmatrix}\frac{k!}{(k-j)!}\times\frac{1}{k!}x^k\\  &=\sum_{j=0}^{2m}\begin{Bmatrix}2m\\ j\end{Bmatrix}a_i^jx^j\sum_k\frac{(a_ix)^{k-j}}{(k-j)!}\\  &=\sum_{j=0}^{2m}\begin{Bmatrix}2m\\ j\end{Bmatrix}a_i^jx^je^{a_ix} \end{aligned}</script><p>然后我们再求导回去</p><script type="math/tex; mode=display">\begin{aligned} A_i(x)&=T'(x)=\left[e^{a_ix}\left(\sum_{j=0}^{2m}\begin{Bmatrix}2m\\ j\end{Bmatrix}a_i^jx^j\right)\right]'\\  &=e^{a_ix}\sum_{j=0}^{2m}\begin{Bmatrix}2m\\ j+1\end{Bmatrix}a_i^{j+1}(j+1)x^j+a_i\sum_{j=0}^{2m}\begin{Bmatrix}2m\\ j\end{Bmatrix}a_i^jx^je^{a_ix}\\  &=e^{a_ix}\sum_{j=0}^{2m}a_i^{j+1}x^j\left(\begin{Bmatrix}2m\\ j+1\end{Bmatrix}(j+1)+\begin{Bmatrix}2m\\ j\end{Bmatrix}\right)\\  &=e^{a_ix}\sum_{j=0}^{2m}a_i^{j+1}x^j\begin{Bmatrix}2m+1\\ j+1\end{Bmatrix} \end{aligned}</script><p>这是一个只有$2m$项的多项式</p><p>同理，我们可以求出$B_i(x)$</p><script type="math/tex; mode=display">B_i(x)=e^{a_ix}\sum_{j=0}^{m}a_i^{j+1}x^j\begin{Bmatrix}m+1\\ j+1\end{Bmatrix}</script><p>再根据式子</p><script type="math/tex; mode=display">ans=\sum_{i=1}^nA_i(x)\prod_{j\neq i}B_i(x)</script><p>分治NTT解决即可</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 状态压缩 </tag>
            
            <tag> 容斥 </tag>
            
            <tag> 生成函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF626G Raffles</title>
      <link href="/2019/12/08/CF626G-Raffles/"/>
      <url>/2019/12/08/CF626G-Raffles/</url>
      
        <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>有$n$个奖池，每个奖池已经有$a_i$张彩票了，现在你有$t$张彩票，你可以自己选择要投入哪些奖池</p><p>每个奖池都有一个限制，你在这个奖池投入的彩票的数量不能超过此时这个奖池的彩票总数的一半</p><p>每个奖池会等概率抽取一张票送出奖金，第$i$个奖池的奖金为$p_i$，你想让自己获得的奖金最大</p><p>有$q$次操作，每次会将某一个池子的彩票数量加一或减一，要求在每次操作过后输出最优方案下的期望奖金</p><p>$n, t, q\leq 2*10^5, a_i,p_i\leq 1000$</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>先考虑没有修改操作怎么放最优秀</p><p>假设在当前的最优方案中，第$i$个奖池已经放入了$m$张彩票，那么如果我们再在这个奖池中放入一张彩票，对总奖金的贡献为</p><script type="math/tex; mode=display">p_i(\frac{m+1}{a_i+m+1}-\frac{m}{a_i+m})=p_i\frac{a_i}{(a_i+m)(a_i+m+1)}</script><p>放入这张彩票后抽到的概率是$\frac{m+1}{a_i+m+1}$，放入之前的概率是$\frac{m}{a_i+m}$</p><p>可以注意到，在一个奖池中投的彩票增加的时候，获得的贡献会递减</p><p>因此我们可以维护每一个奖池此时若增加一张，那么会得到多少贡献，然后贪心地每次取贡献较大的</p><p>现在考虑加上操作之后该怎么做</p><p>有一个结论就是每次操作之后，最优方案中最多只会撤销一张彩票，再放入另一张彩票</p><p>我们假设在操作之前，当前奖池的第$m,m+1$张彩票都被选了，并且此时最优方案中，贡献最小的那张彩票的贡献是$b_1$</p><p>记$x_1=p_i\frac{a_i}{(a_i+m-1)(a_i+m)},x_2=p_i\frac{a_i}{(a_i+m)(a_i+m+1)}$，即这两张彩票对答案的贡献</p><p>显然有$x_1&gt;x_2&gt;b_1$</p><p>现在在这个奖池中，我们加入一张彩票，设此时贡献最小的彩票的贡献是$b_2$</p><p>记$y_1=p_i\frac{a_i+1}{(a+m)(a+m+1)},y_2=p_i\frac{a_i+1}{(a_i+m+1)(a_i+m+2)}$，仍然是这两张彩票对答案的贡献</p><p>可以看出$y_1&gt;x_2$</p><p>此时有$b_1&gt;b_2$</p><p>我们假设第$m$张彩票现在没有被选</p><p>那么有$x_2&gt;b_1&gt;b_2&gt;y_1$，而这与$y_1&gt;x_2$矛盾</p><p>因此第$m$张彩票一定会被选，即每次操作之后最多只会影响两张彩票</p><p>接下来就很简单了，我们用线段树维护每个奖池当前如果再投入/撤销一张彩票时的贡献，每次修改之后尝试撤销一张彩票，再投入一张彩票</p><p>撤销一定是选择撤销之后对答案影响最小的撤销，投入则是选择贡献最大的投入</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 维护当前每个奖池多一张票/少一张票的贡献</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, fir, sec;</span><br><span class="line">    <span class="keyword">double</span> ans, inc, dec;</span><br><span class="line">&#125; T[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// num: 当前每个奖池已经取了多少张票</span></span><br><span class="line"><span class="keyword">int</span> p[N], num[N], l[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">const</span> node &amp;a, <span class="keyword">const</span> node &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.inc &gt; b.inc ? a.fir : b.fir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">const</span> node &amp;a, <span class="keyword">const</span> node &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.dec &lt; b.dec ? a.sec : b.sec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    T[rt].ans = T[rt &lt;&lt; <span class="number">1</span>].ans + T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].ans;</span><br><span class="line">    T[rt].inc = max(T[rt &lt;&lt; <span class="number">1</span>].inc, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].inc), T[rt].dec = min(T[rt &lt;&lt; <span class="number">1</span>].dec, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].dec);</span><br><span class="line">    T[rt].fir = Max(T[rt &lt;&lt; <span class="number">1</span>], T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]), T[rt].sec = Min(T[rt &lt;&lt; <span class="number">1</span>], T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = T[rt].l;</span><br><span class="line">    T[rt].ans = p[pos] * min((<span class="keyword">double</span>)num[pos] / (l[pos] + num[pos]), <span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">if</span> (num[pos] &lt; l[pos]) T[rt].inc = p[pos] * (<span class="keyword">double</span>)(num[pos] + <span class="number">1</span>) / (l[pos] + num[pos] + <span class="number">1</span>) - T[rt].ans;</span><br><span class="line">    <span class="keyword">else</span> T[rt].inc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (num[pos] &gt; <span class="number">0</span>) T[rt].dec = T[rt].ans - p[pos] * (<span class="keyword">double</span>)(num[pos] - <span class="number">1</span>) / (l[pos] + num[pos] - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> T[rt].dec = <span class="number">1e18</span>;</span><br><span class="line">    T[rt].dec = max(T[rt].dec, <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    T[rt].l = l, T[rt].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> T[rt].fir = T[rt].sec = l, reload(rt), <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span>, l, mid), build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r), pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> reload(rt), <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, pos);</span><br><span class="line">    <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, pos);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, t, q; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;t, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;l[i]);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) num[T[<span class="number">1</span>].fir]++, update(<span class="number">1</span>, T[<span class="number">1</span>].fir);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> t, a; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;t, &amp;a);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>) l[a]++; <span class="keyword">else</span> l[a]--;</span><br><span class="line">        update(<span class="number">1</span>, a);</span><br><span class="line">        <span class="keyword">while</span> (T[<span class="number">1</span>].inc - T[<span class="number">1</span>].dec &gt; <span class="number">1e-8</span>) &#123;</span><br><span class="line">            num[T[<span class="number">1</span>].fir]++, num[T[<span class="number">1</span>].sec]--;</span><br><span class="line">            update(<span class="number">1</span>, T[<span class="number">1</span>].fir), update(<span class="number">1</span>, T[<span class="number">1</span>].sec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.10lf\n"</span>, T[<span class="number">1</span>].ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集训队作业 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP赛前集训day18</title>
      <link href="/2019/11/10/CSP%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%ADday18/"/>
      <url>/2019/11/10/CSP%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%ADday18/</url>
      
        <content type="html"><![CDATA[<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><div class="pdfobject-container" data-target="problem.pdf" data-height="500px"></div><h1 id="T1-视频"><a href="#T1-视频" class="headerlink" title="T1 视频"></a>T1 视频</h1><p>码量题掠过</p><h1 id="T2-图论"><a href="#T2-图论" class="headerlink" title="T2 图论"></a>T2 图论</h1><p>假如现在要合并$u,v$两个点</p><p>我们找到$u,v$两个点当前所在的连通块，然后尝试将大小较小的那个连通块合并到大小较大的那个连通块中</p><p>也就是说，我们需要枚举小连通块中的所有出边，这些边的数量与小连通块的大小相等</p><p>如果小连通块的出边中包含大连通块，显然这次合并会失败</p><p>否则我们将所有连向小连通块的边全部挪到指向大连通块，然后再将这两个连通块合并即可</p><p>代码咕掉了</p><h1 id="T3-排队"><a href="#T3-排队" class="headerlink" title="T3 排队"></a>T3 排队</h1><p>如果一段区间中所有人都在同一个班，假如现在这个人要插入到这个区间中，那么显然这个人可以选择这一段区间中的任意一个位置插入</p><p>那么我们可以将这个区间缩成一个点，即每个极长的连续段都只用一个点来表示，同时在这个点中，我们维护两个信息：这个点所代表的所有人和人数，以及这个点是第几个极长连续段</p><p>然后对于当前这个人，首先我们可以二分出它必须在哪一个连续段之后加入，这个可以在线段树上查询得到</p><p>然后我们需要找到在这个连续段之后，第一个与这个人的班级相同的连续段，然后将这个人插入到这个连续段中即可</p><p>这样我们不可能在点与点之间插入点，我们只会在最后追加点</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sz[N &lt;&lt; <span class="number">2</span>], ncnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若新加入的人后面至多有w个人，则他应属于哪个块</span></span><br><span class="line"><span class="comment">// w最后的值为当前块在这个人之后的人数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> &amp;w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> t = sz[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (t &lt;= w) <span class="keyword">return</span> w -= t, query(rt &lt;&lt; <span class="number">1</span>, l, mid, w);</span><br><span class="line">    <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新某一个块内的人数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> at)</span> </span>&#123;</span><br><span class="line">    sz[rt]++;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (at &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, at);</span><br><span class="line">    <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, at);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于每个班级在每个极大连续段的第一个位置计算人数</span></span><br><span class="line"><span class="comment">// first表示当前段是第几段，second表示这一段的人数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt; data[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一段中有哪些人</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; peo[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> c, a; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;c, &amp;a);</span><br><span class="line">        <span class="keyword">int</span> block = query(<span class="number">1</span>, <span class="number">0</span>, n, a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二分出这个人应该插入到这个班级的哪个位置</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = data[c].size() - <span class="number">1</span>, ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (data[c][mid].first &gt;= block) ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找不到一个合法的位置，即在队伍最后插入</span></span><br><span class="line">        <span class="keyword">if</span> (!~ans) &#123;</span><br><span class="line">            ncnt++, update(<span class="number">1</span>, <span class="number">0</span>, n, ncnt);</span><br><span class="line">            data[c].push_back(P(ncnt, <span class="number">1</span>)), peo[ncnt].push_back(i); </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (block == data[c][ans].first) &#123; <span class="comment">// 当前段即合法</span></span><br><span class="line">            update(<span class="number">1</span>, <span class="number">0</span>, n, data[c][ans].first), data[c][ans].second++;</span><br><span class="line">            peo[data[c][ans].first].insert(peo[data[c][ans].first].begin() + data[c][ans].second - a - <span class="number">1</span>, i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 插入到后面第一个当前班级的段的段头</span></span><br><span class="line">            update(<span class="number">1</span>, <span class="number">0</span>, n, data[c][ans].first), data[c][ans].second++;</span><br><span class="line">            peo[data[c][ans].first].insert(peo[data[c][ans].first].begin(), i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ncnt; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : peo[i]) <span class="built_in">printf</span>(<span class="string">"%d "</span>, v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 启发式合并 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP赛前集训day17</title>
      <link href="/2019/11/08/CSP%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%ADday17/"/>
      <url>/2019/11/08/CSP%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%ADday17/</url>
      
        <content type="html"><![CDATA[<p>day16因为太过毒瘤，因此被咕掉了</p><h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><div class="pdfobject-container" data-target="problem.pdf" data-height="500px"></div><h1 id="T1-红黑树"><a href="#T1-红黑树" class="headerlink" title="T1 红黑树"></a>T1 红黑树</h1><p>这道题中的红黑树与普通红黑树的唯一区别是：这道题中的树的根节点可以是红色，也可以是黑色</p><p>显然不会影响红黑树的性质：黑高为$\log$级别</p><p>那么我们可以用$dp$的方式去构造，$dp[i][j][1/0]$表示是否能构造$i$的子树，满足黑高为$j$，并且$i$是否为黑色节点</p><p>转移比较显然</p><p>输出方案的时候找到根节点的一种合法情况，然后暴力往下倒推就可以了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> dp[<span class="number">2</span>][<span class="number">30</span>][N]; <span class="keyword">int</span> L[N], R[N], col[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!L[u] &amp;&amp; !R[u]) <span class="keyword">return</span> dp[<span class="number">1</span>][<span class="number">1</span>][u] = dp[<span class="number">0</span>][<span class="number">0</span>][u] = <span class="number">1</span>, <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">if</span> (!L[u] || !R[u]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = L[u] + R[u]; dfs(v);</span><br><span class="line">        <span class="keyword">if</span> (dp[<span class="number">0</span>][<span class="number">0</span>][v]) dp[<span class="number">1</span>][<span class="number">1</span>][u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(L[u]), dfs(R[u]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;= <span class="number">1</span>; a++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= <span class="number">1</span>; b++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a + b == <span class="number">2</span>) dp[<span class="number">0</span>][i][u] |= dp[a][i][L[u]] &amp; dp[b][i][R[u]];</span><br><span class="line">                dp[<span class="number">1</span>][i + <span class="number">1</span>][u] |= dp[a][i][L[u]] &amp; dp[b][i][R[u]];</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> bh, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    col[u] = c; <span class="keyword">if</span> (c) bh--;</span><br><span class="line">    <span class="keyword">if</span> (!L[u] &amp;&amp; !R[u]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!L[u] || !R[u]) &#123;</span><br><span class="line">        assert(!bh);</span><br><span class="line">        dfs2(L[u] + R[u], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;= <span class="number">1</span>; a++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= <span class="number">1</span>; b++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span> &amp;&amp; a + b != <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (dp[a][bh][L[u]] &amp;&amp; dp[b][bh][R[u]]) &#123;</span><br><span class="line">                dfs2(L[u], bh, a), dfs2(R[u], bh, b);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, rt = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> f; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;f);</span><br><span class="line">        <span class="keyword">if</span> (!f) rt = i;</span><br><span class="line">        <span class="keyword">if</span> (!L[f]) L[f] = i;</span><br><span class="line">        <span class="keyword">else</span> R[f] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(rt); <span class="keyword">int</span> res = <span class="number">0</span>, pos = <span class="number">-1</span>, c = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span> &amp;&amp; !res; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[<span class="number">0</span>][i][rt]) res = <span class="number">1</span>, pos = i, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (dp[<span class="number">1</span>][i][rt]) res = <span class="number">1</span>, pos = i, c = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!res) <span class="built_in">puts</span>(<span class="string">"Impossible"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        dfs2(rt, pos, c);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">putchar</span>(col[i] ? <span class="string">'B'</span> : <span class="string">'R'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-旅行"><a href="#T2-旅行" class="headerlink" title="T2 旅行"></a>T2 旅行</h1><p>一道好好的期望题在数据加强之后变成了一道特判题</p><p>对于每个航线我们可以算出它挂掉以及不挂掉的概率</p><p>显然对于一条航线最优的方案一定是将所有航班按照挂掉的概率从大到小排序，然后依次问下去</p><p>因此我们可以算出在这条航线挂掉的情况下，期望要问多少次才能确定</p><p>以及在这条航线不挂掉的情况下，期望要问多少次才能确定（就是全部问完）</p><p>如果将所有航线按照活下来的概率从大到小/从小到大排序，那么你会获得0分的好成绩</p><p>正确方法是，按照国王游戏的方法贪心</p><p>我们考虑在当前的“最优”方案中，相邻的两条航线</p><p>显然交换这两条航线之后对前面的航线以及后面的航线不会有任何影响，也就是说我们只需要单独考虑这两条航线</p><p>那么有3种情况</p><ul><li>第一条航线没有挂掉，那么我们只需要问这条航线即可，代价为活下来的概率乘以这条航线的航班数</li><li>第一条航线挂掉了，第二条航线没有挂掉</li><li>第一条和第二条航线都挂掉了</li></ul><p>将这三种情况的期望加起来再判断大小就可以了</p><p>注意：要特判以下三种情况</p><ul><li>有一条航班必定挂掉，那么这条航线都不用再问了</li><li>有一条航线必定不挂掉，那么答案就是0</li><li>有一条航班必定不挂掉，那么这个航班不用再问</li></ul><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> p[N], A[N], B[N]; <span class="keyword">double</span> tmp[N]; <span class="keyword">int</span> id[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> k; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k); p[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;tmp[j]);</span><br><span class="line">            <span class="keyword">if</span> (tmp[j] &lt; <span class="number">1e-8</span>) j--, k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!k) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span>;</span><br><span class="line">        sort(tmp + <span class="number">1</span>, tmp + k + <span class="number">1</span>, [](<span class="keyword">double</span> a, <span class="keyword">double</span> b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a &gt; b;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (tmp[<span class="number">1</span>] &gt; <span class="number">1</span> - <span class="number">1e-8</span>) &#123;</span><br><span class="line">            i--, n--; <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            A[i] += p[i] * tmp[j] * j;</span><br><span class="line">            p[i] *= <span class="number">1</span> - tmp[j];</span><br><span class="line">        &#125;</span><br><span class="line">        A[i] /= <span class="number">1</span> - p[i], B[i] = k, id[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(id + <span class="number">1</span>, id + n + <span class="number">1</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">double</span> t1 = p[a] * B[a] + (<span class="number">1</span> - p[a]) * p[b] * (A[a] + B[b]) + (<span class="number">1</span> - p[a]) * (<span class="number">1</span> - p[b]) * (B[a] + B[b]);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">double</span> t2 = p[b] * B[b] + (<span class="number">1</span> - p[b]) * p[a] * (A[b] + B[a]) + (<span class="number">1</span> - p[b]) * (<span class="number">1</span> - p[a]) * (B[b] + B[a]);</span><br><span class="line">        <span class="keyword">return</span> t1 &lt; t2;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> tp = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> at = id[i];</span><br><span class="line">        res += tp * (<span class="number">1</span> - p[at]) * A[at] + tp * p[at] * B[at];</span><br><span class="line">        tp *= <span class="number">1</span> - p[at];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.10Lf\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-数字"><a href="#T3-数字" class="headerlink" title="T3 数字"></a>T3 数字</h1><p>将规则转换以下：小D一开始就将这个数字循环位移1，然后小Y可以任意选择一个前缀（可以为空），然后将这个前缀中的数都循环位移1</p><p>我们可以处理出每一个前缀循环位移1之后异或的值，那么问题等价于，给你一堆数，现在你要选择一个数，使得这个数与这一堆数的异或最小值最大</p><p>将<code>trie</code>树建出来，然后在上面<code>dfs</code></p><p>记录以下每个节点能够获得的最大的最小异或值，以及方案数</p><p>如果当前节点只有一棵子树，那么显然这一位的异或最小值最大可以为1，即选择与所有数不同的那一位，而方案数就是这棵子树的方案数</p><p>否则这一位必然是0，答案为左右子树的最大值，因为小Y可以选择进入哪棵子树</p><p>这样做会T一些点，因此不必将<code>trie</code>树建出来，直接将所有数按照最高位分治即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function">P <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> dep, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep == <span class="number">-1</span>) <span class="keyword">return</span> P(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> tl = l - <span class="number">1</span>, tr = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = a[i] &gt;&gt; dep &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!t) tmp[++tl] = a[i];</span><br><span class="line">        <span class="keyword">else</span> tmp[--tr] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= tl; i++) a[i] = tmp[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt;= tr; i--) a[i] = tmp[i];</span><br><span class="line">    <span class="keyword">if</span> (tl &lt; l || tr &gt; r) &#123;</span><br><span class="line">        P res = dfs(dep - <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">return</span> P(res.first | (<span class="number">1</span> &lt;&lt; dep), res.second);</span><br><span class="line">    &#125;</span><br><span class="line">    P res1 = dfs(dep - <span class="number">1</span>, l, tl), res2 = dfs(dep - <span class="number">1</span>, tr, r), res = P(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    res.first = max(res1.first, res2.first);</span><br><span class="line">    <span class="keyword">if</span> (res1.first == res.first) res.second += res1.second;</span><br><span class="line">    <span class="keyword">if</span> (res2.first == res.first) res.second += res2.second;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, T, tot = <span class="number">0</span>; read(n), read(m), read(T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) read(num[i]), num[i] ^= num[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = (num[i] &lt;&lt; <span class="number">1</span>) | (num[i] &gt;&gt; (n - <span class="number">1</span>) &amp; <span class="number">1</span>); t = t &amp; ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>);</span><br><span class="line">        a[++tot] = t ^ num[m] ^ num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    P res = dfs(n - <span class="number">1</span>, <span class="number">1</span>, tot); <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res.first);</span><br><span class="line">    <span class="keyword">if</span> (T) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res.second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP赛前集训day14</title>
      <link href="/2019/11/06/CSP%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%ADday14/"/>
      <url>/2019/11/06/CSP%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%ADday14/</url>
      
        <content type="html"><![CDATA[<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><div class="pdfobject-container" data-target="problem.pdf" data-height="500px"></div><h1 id="T1-游戏"><a href="#T1-游戏" class="headerlink" title="T1 游戏"></a>T1 游戏</h1><p>一个比较容易得出的结论是小Y一定不会将棋子向父亲移动，因为在树上绕路显然不优秀，会使得小Y浪费了一些步数</p><p>设$dp[i]$表示只考虑以$i$为根的子树，如果小D想要赢，那么最少需要先染黑多少个叶子</p><p>显然叶子节点的$dp$值是$1$，因为小D必须提前将这个叶子染成黑色</p><p>考虑怎么转移，假如现在棋子在节点$u$，那么小D必须保证小Y无论向哪个儿子移动都不能赢，因此它必须保证在每一棵子树都能赢，那么$u$的$dp$值显然就是所有儿子的$dp$值之和</p><p>然后由于小Y需要移动一步到$u$的一个儿子，因此小D获得了一次操作机会，因此$dp[u]—$</p><p>最后只需要判断根节点的$dp$值是否不为$0$即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[N], p[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i]), vis[p[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; dp[p[i]] += dp[i], i--) </span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) dp[i] = <span class="number">1</span>; <span class="keyword">else</span> dp[i] = max(dp[i] - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(dp[<span class="number">1</span>] ? <span class="string">"Y"</span> : <span class="string">"D"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-面积"><a href="#T2-面积" class="headerlink" title="T2 面积"></a>T2 面积</h1><p>先将一个凸多边形的面积转化为总面积减去每个未包含的边界的面积之和</p><p>枚举这个边界的两个端点，现在需要统计的就是有多少种凸多边形没有包含这个边界</p><p>我们假设这两个端点以及中间一共有$m$个节点</p><p>那么方案数就是</p><script type="math/tex; mode=display">\frac{n-m\choose k-2}{n\choose k}</script><p>即，这两个端点必须选，不在两个端点之间的点要选出$k-2$个的方案数</p><p>由于各种奇妙的原因，直接用<code>long double</code>存组合数不会炸精度。但是如果担心炸精度的话可以倒推这个式子</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2510</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> x[N], y[N]; <span class="keyword">long</span> <span class="keyword">double</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">double</span> <span class="title">Abs</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span> ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k); <span class="keyword">long</span> <span class="keyword">double</span> all = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x[i], &amp;y[i]); x[n + <span class="number">1</span>] = x[<span class="number">1</span>], y[n + <span class="number">1</span>] = y[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) all += x[i] * y[i + <span class="number">1</span>] - y[i] * x[i + <span class="number">1</span>];</span><br><span class="line">    all = Abs(all) / <span class="number">2</span>;</span><br><span class="line">    f[n - <span class="number">3</span>] = (<span class="keyword">long</span> <span class="keyword">double</span>)(k - <span class="number">1</span>) / n * k / (n - <span class="number">1</span>) * (n - k) / (n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">4</span>; i &gt;= k - <span class="number">2</span>; i--) f[i] = f[i + <span class="number">1</span>] / (i + <span class="number">1</span>) * (i - k + <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">double</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">2</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            s += Abs((x[j - <span class="number">1</span>] - x[i]) * (y[j] - y[i]) - (y[j - <span class="number">1</span>] - y[i]) * (x[j] - x[i])) / <span class="number">2</span>;</span><br><span class="line">            ans += s * f[n - (j - i + <span class="number">1</span>)] + (all - s) * f[j - i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.7Lf\n"</span>, all - ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-删除"><a href="#T3-删除" class="headerlink" title="T3 删除"></a>T3 删除</h1><p>很奇妙的一道题</p><p>首先我们考虑暴力$dp$</p><p>我们将一个端点从小到大排序</p><p>$dp[i]$表示最后删除的边是$i$连出的，并且前$i$个点的边都被删除了的最小花费</p><p>可以做到$O(n^2)$，即枚举上一次删除的边是哪一条，假设是由$j$连出的</p><p>这要求$i$到$j$中，所有$p&lt;p_i$的哪些节点，都满足$p&lt;p_j$</p><p>这个转移怎么优化呢</p><p>我们将前$i-1$个点都拿出来，按照$p$排序，然后从大到小考虑</p><p>那么一个点$x$能够转移的条件就是，它的编号比所有$p&gt;p_x$的点的编号都要大</p><p>很像一个单调栈，我们考虑用线段树维护这个单调栈</p><p>我们用$x_i$表示$p_{x_i}=i$的点，在线段树上维护按照下标从小到大的顺序维护$x_i$</p><p>那么一个点$j&lt;i$能对$i$产生贡献，当且仅当$x_j$比下标为区间$[j+1,p_i)$中的$x$都要大</p><p>在单调栈线段树上维护每个点只考虑当且节点代表的区间时整棵子树能产生贡献的最小$dp$值，以及左子树能产生贡献的最小$dp$值</p><p>在<code>pushup</code>的时候用<code>query</code>更新，即用右子树的最大值去查左子树</p><p>由于根到叶子的路径上每个点都会分裂一次，因此总时间复杂度是$O(n\log^2n)$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, mx, dp, dp2;</span><br><span class="line">&#125; T[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    T[rt].l = l, T[rt].r = r, T[rt].mx = <span class="number">-1e9</span>, T[rt].dp = T[rt].dp2 = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; build(rt &lt;&lt; <span class="number">1</span>, l, mid), build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> mx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r;</span><br><span class="line">    <span class="keyword">if</span> (mx &gt;= T[rt].mx) <span class="keyword">return</span> <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> T[rt].dp;</span><br><span class="line">    <span class="keyword">if</span> (T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mx &gt; mx) <span class="keyword">return</span> min(T[rt &lt;&lt; <span class="number">1</span>].dp2, query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mx));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span>, mx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    T[rt].mx = max(T[rt &lt;&lt; <span class="number">1</span>].mx, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mx);</span><br><span class="line">    <span class="keyword">if</span> (T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mx &gt; T[rt &lt;&lt; <span class="number">1</span>].mx) T[rt].dp = T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].dp, T[rt &lt;&lt; <span class="number">1</span>].dp2 = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">else</span> T[rt].dp = min(T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].dp, T[rt &lt;&lt; <span class="number">1</span>].dp2 = query(rt &lt;&lt; <span class="number">1</span>, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mx));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> x, <span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> T[rt].dp = val, T[rt].mx = i, <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, x, i, val);</span><br><span class="line">    <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, i, val);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query1</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T[rt].mx &lt;= mx) <span class="keyword">return</span> <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = query(rt, mx); mx = max(mx, T[rt].mx);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (end &lt;= mid) <span class="keyword">return</span> query1(rt &lt;&lt; <span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">int</span> res = query1(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, end);</span><br><span class="line">    res = min(res, query(rt &lt;&lt; <span class="number">1</span>, mx));</span><br><span class="line">    mx = max(mx, T[rt &lt;&lt; <span class="number">1</span>].mx);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i]);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">0</span>, n), update(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v), mx = <span class="number">-2e9</span>, v += query1(<span class="number">1</span>, p[i]);</span><br><span class="line">        update(<span class="number">1</span>, p[i], i, v);</span><br><span class="line">    &#125;</span><br><span class="line">    mx = <span class="number">-2e9</span>, <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query1(<span class="number">1</span>, n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 博弈 </tag>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP赛前集训day13</title>
      <link href="/2019/11/02/CSP%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%ADday13/"/>
      <url>/2019/11/02/CSP%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%ADday13/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-二叉树"><a href="#T1-二叉树" class="headerlink" title="T1 二叉树"></a>T1 二叉树</h1><p><img src="image-20191102105659837.png" alt="image-20191102105659837"></p><p><img src="image-20191102105707119.png" alt="image-20191102105707119"></p><p>首先这个先序和后序遍历没有任何用处，给两个排列都可以</p><p>有一种比较显然的贪心是从高位到低位贪心地填$10$，可以证明这样一定最优秀，因为一个位置的贡献一定不会劣于后面任何一位的贡献</p><p>然后这个题就没了</p><h1 id="T2-子序列"><a href="#T2-子序列" class="headerlink" title="T2 子序列"></a>T2 子序列</h1><p><img src="image-20191102105911795.png" alt="image-20191102105911795"></p><p><img src="image-20191102105918755.png" alt="image-20191102105918755"></p><p>仔细观察最后构造出的串，会发现一个重要性质：如果每次将这个串的中间那个字符抠出来，那么左边和右边是完全一样的串</p><p>我们倒序模拟这个过程，每次迭代的时候先接上一个字符，再将上一次迭代的串复制一份接在后面</p><p>比如之前的串是$s$，这一次接上的字符是$a$，那么这一次迭代之后的串就是$sas$</p><p>由于询问的是本质不同的子序列，那么我们可以设计这样一个状态：$dp[i][j][k]$，表示在第$i$次迭代后，以字符$j$开头，并且可以接上字符$k$的子序列的数量</p><p>这里的“可以接上”指的是，在当前串的最后一个选择的字符后面没有字符$k$，这样当这个子序列尝试接上字符$k$时，才能选到新添加的字符</p><p>根据$dp$的定义，可以显然地看出转移就是矩阵乘法</p><p>现在我们只需要考虑对于一个字符$a$，它代表的矩阵是什么</p><p>我们构造$27\times 27$的矩阵，多出的一维代表已经决定在这个字符后不会再选择了，即在后面接上空串</p><p>那么当前的字符有两种转移：选择，或者不选</p><p>如果在上一次转移的时候已经决定了接上字符$a$，那么在这一次转移中就必须选</p><p>否则可以选，也可以不选</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x += y, x -= x &gt;= mod ? mod : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">27</span>][<span class="number">27</span>];</span><br><span class="line">    Matrix() &#123;<span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));&#125;</span><br><span class="line">    <span class="keyword">inline</span> Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp;b) &#123;</span><br><span class="line">        Matrix res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">27</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">27</span>; k++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">27</span>; j++)</span><br><span class="line">                    res.a[i][j] = (res.a[i][j] + (LL)a[i][k] * b.a[k][j]) % mod;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; f[N], base[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d%s"</span>, &amp;n, s + <span class="number">1</span>), reverse(s + <span class="number">1</span>, s + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">27</span>; j++) base[i].a[s[i] - <span class="string">'a'</span>][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">27</span>; j++) <span class="keyword">if</span> (s[i] - <span class="string">'a'</span> != j) base[i].a[j][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>] = base[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) </span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] * base[i] * f[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) Inc(res, f[n].a[i][<span class="number">26</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-小游戏"><a href="#T3-小游戏" class="headerlink" title="T3 小游戏"></a>T3 小游戏</h1><p><img src="image-20191102110658064.png" alt="image-20191102110658064"></p><p><img src="image-20191102110706373.png" alt="image-20191102110706373"></p><p>由于统计的是结果序列，因此考虑用类似子序列自动机的方法</p><p>抛开等级不管，结果序列一定是原序列的子序列</p><p>注意到每种类型的等级一共只有$12$种，也就是说我们最多只有$48$个不同的元素</p><p>并且结果序列是不能再合并的，即相邻的类型以及等级相同的元素最多只能有两个</p><p>假设我们现在已经枚举好了答案序列，如何判断原序列是否能消出这个序列呢</p><p>有一种比较显然的策略是贪心地匹配，即假如当前字符是$c$，等级是$k$，那么就在当前位置后匹配$3^k$个$c$，中间的其它字符都可以删掉</p><p>因此我们可以用$dp[i][j][k][0/1]$表示匹配到了原序列中的第$i$个位置，上一次选择的字符是$j$，等级是$k$，并且与上上个元素是否相同的方案数</p><p>写出来之后会发现过不去第二个样例</p><p>冷静分析之后会发现还有一种情况：相邻的两个元素类型相同，但是前面一个的等级小于后面那个的等级</p><p>如果这两个元素合并的字符在原序列中是相邻的，那么我们必须浪费一个当前字符</p><p>比如<code>aabaa</code>，最终的序列不能是<code>a(1)a(2)</code></p><p>因为要得到<code>a(2)</code>就必须消掉<code>b</code>，但是这样会导致后面两个<code>a</code>和前面的挨在一起，第二个位置就得不到<code>a(2)</code>了</p><p>如果这两个字符在原序列中不相邻，那么我们可以先合并后面的字符，再合并前面的字符，最后把中间的其它字符删除，可以得到答案序列</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x += y, x -= x &gt;= mod ? mod : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nxt[<span class="number">4</span>][<span class="number">13</span>][N], dp[<span class="number">4</span>][<span class="number">13</span>][N]; <span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d%s"</span>, &amp;n, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> cur[<span class="number">4</span>]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        cur[i] = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">12</span>; j++) nxt[i][j][n + <span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) nxt[j][<span class="number">0</span>][i] = cur[j];</span><br><span class="line">        <span class="keyword">if</span> (i) cur[s[i] - <span class="string">'A'</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">12</span>; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; k++) </span><br><span class="line">                nxt[i][j][k] = nxt[i][j - <span class="number">1</span>][nxt[i][j - <span class="number">1</span>][nxt[i][j - <span class="number">1</span>][k]]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= <span class="number">12</span>; l++) &#123;</span><br><span class="line">                sum = (sum + dp[k][l][nxt[k][l][i]]) % mod;</span><br><span class="line">                sum2 = (sum2 + dp[k][l][nxt[k][l][nxt[k][l][i]]]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">4</span>; c++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">12</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> t1 = (sum - dp[c][j][nxt[c][j][i]]) % mod, t2 = (sum2 - dp[c][j][nxt[c][j][nxt[c][j][i]]]) % mod;</span><br><span class="line">                <span class="keyword">if</span> (s[i + <span class="number">1</span>] == c + <span class="string">'A'</span>) </span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = j + <span class="number">1</span>; l &lt;= <span class="number">12</span>; l++) &#123;</span><br><span class="line">                        t1 = ((<span class="keyword">long</span> <span class="keyword">long</span>)t1 - dp[c][l][nxt[c][l][i]] + dp[c][l][nxt[c][<span class="number">0</span>][nxt[c][l][i]]]) % mod;</span><br><span class="line">                        t2 = ((<span class="keyword">long</span> <span class="keyword">long</span>)t2 - dp[c][l][nxt[c][l][nxt[c][l][i]]] +</span><br><span class="line">                            dp[c][l][nxt[c][<span class="number">0</span>][nxt[c][l][nxt[c][l][i]]]]) % mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                dp[c][j][i] = (t1 + t2 + <span class="number">1</span>) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">4</span>; c++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= <span class="number">12</span>; l++)</span><br><span class="line">            res = (res + dp[c][l][nxt[c][l][<span class="number">0</span>]] + (<span class="keyword">long</span> <span class="keyword">long</span>)dp[c][l][nxt[c][l][nxt[c][l][<span class="number">0</span>]]]) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (res + mod) % mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP赛前集训day7</title>
      <link href="/2019/10/25/CSP%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%ADday7/"/>
      <url>/2019/10/25/CSP%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%ADday7/</url>
      
        <content type="html"><![CDATA[<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><div class="pdfobject-container" data-target="problems.pdf" data-height="500px"></div><h1 id="T1-字符串"><a href="#T1-字符串" class="headerlink" title="T1 字符串"></a>T1 字符串</h1><p>首先考虑怎么求出长度最短的公共非子序列</p><p>对于两个串分别建子序列自动机，然后$dp[i][j]$表示当前在第一个串的第$i$个位置，在第二个串的第$j$个位置，最少还需要添加多少个字符才能构成公共非子序列</p><p>然后就比较简单了，从两个串的开头开始，每次先尝试放$0$，如果$0$不行就放$1$，要求是能够转移到$dp$值更小的那个位置</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nxt1[<span class="number">2</span>][N], nxt2[<span class="number">2</span>][N], dp[N][N], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> at1, <span class="keyword">int</span> at2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (at1 &gt; n &amp;&amp; at2 &gt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (~dp[at1][at2]) <span class="keyword">return</span> dp[at1][at2];</span><br><span class="line">dp[at1][at2] = min(DP(nxt1[<span class="number">0</span>][at1], nxt2[<span class="number">0</span>][at2]), DP(nxt1[<span class="number">1</span>][at1], nxt2[<span class="number">1</span>][at2])) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> dp[at1][at2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> at1, <span class="keyword">int</span> at2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (at1 &gt; n &amp;&amp; at2 &gt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> dp[at1][at2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> at1, <span class="keyword">int</span> at2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (at1 &gt; n &amp;&amp; at2 &gt; m) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> t1 = get(nxt1[<span class="number">0</span>][at1], nxt2[<span class="number">0</span>][at2]), t2 = get(nxt1[<span class="number">1</span>][at1], nxt2[<span class="number">1</span>][at2]);</span><br><span class="line"><span class="keyword">if</span> (t1 &lt;= t2) <span class="built_in">putchar</span>(<span class="string">'0'</span>), print(nxt1[<span class="number">0</span>][at1], nxt2[<span class="number">0</span>][at2]);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">'1'</span>), print(nxt1[<span class="number">1</span>][at1], nxt2[<span class="number">1</span>][at2]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N], t[N]; <span class="keyword">int</span> ls[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m + <span class="number">1</span>; j++) dp[i][j] = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, s + <span class="number">1</span>, t + <span class="number">1</span>);</span><br><span class="line">ls[<span class="number">0</span>] = ls[<span class="number">1</span>] = n + <span class="number">1</span>, nxt1[<span class="number">0</span>][n + <span class="number">1</span>] = nxt1[<span class="number">1</span>][n + <span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">nxt1[<span class="number">0</span>][i] = ls[<span class="number">0</span>], nxt1[<span class="number">1</span>][i] = ls[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">'1'</span>) ls[<span class="number">1</span>] = i;</span><br><span class="line"><span class="keyword">else</span> ls[<span class="number">0</span>] = i;</span><br><span class="line">&#125;</span><br><span class="line">ls[<span class="number">0</span>] = ls[<span class="number">1</span>] = m + <span class="number">1</span>, nxt2[<span class="number">0</span>][m + <span class="number">1</span>] = nxt2[<span class="number">1</span>][m + <span class="number">1</span>] = m + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">nxt2[<span class="number">0</span>][i] = ls[<span class="number">0</span>], nxt2[<span class="number">1</span>][i] = ls[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (t[i] == <span class="string">'1'</span>) ls[<span class="number">1</span>] = i;</span><br><span class="line"><span class="keyword">else</span> ls[<span class="number">0</span>] = i;</span><br><span class="line">&#125;</span><br><span class="line">DP(<span class="number">0</span>, <span class="number">0</span>), print(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-序列"><a href="#T2-序列" class="headerlink" title="T2 序列"></a>T2 序列</h1><p>考虑一种数$x$</p><p>当$x$第一次对答案贡献$1$，需要$1$个$x$</p><p>若$x$要再次对答案产生贡献，那么需要$2$个$x$，才能在二进制下多$1$</p><p>以此类推，若$x$要第$k$次对答案产生贡献，代价为$x2^{k-1}$</p><p>所以有一个显然的贪心策略：将每个数当前的贡献放入优先队列，每次贪心地取最小的</p><p>因此我们可以二分，找到最大的代价$p$，使得在将代价小于等于$p$的所有数全部取完之后，总和仍然$\leq n$</p><p>那么接下来的所有数的贡献一定是$p+1$，否则与$p$是最大值矛盾</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> P <span class="title">check</span><span class="params">(LL x, LL y)</span> </span>&#123;</span><br><span class="line">LL res = <span class="number">0</span>, ct = <span class="number">0</span>; <span class="keyword">int</span> tern = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (LL tmp = <span class="number">1</span>, tmp1 = <span class="number">1</span>; tmp; tmp = tmp * <span class="number">2</span>, tern++, tmp1 = tmp1 * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (tmp &gt; y) <span class="keyword">break</span>;</span><br><span class="line">LL l = y / (tmp * <span class="number">2</span>) + <span class="number">1</span>, r = y / tmp;</span><br><span class="line">res += (LL)(r + l) * (r - l + <span class="number">1</span>) / <span class="number">2</span> * tmp1, ct += tern * (r - l + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (res &gt;= x) <span class="keyword">return</span> P(<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> P(res, ct);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line">LL n; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1e9</span>, mid, ans = <span class="number">-1</span>; P ans1;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">P t = check(n, mid);</span><br><span class="line"><span class="keyword">if</span> (t.first != <span class="number">-1</span>) ans = mid, ans1 = t, l = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans1.second + (n - ans1.first) / (ans + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-交换"><a href="#T3-交换" class="headerlink" title="T3 交换"></a>T3 交换</h1><p>正睿以前考过的原题</p><p>从小到大考虑，每个数要么挪到最左边，要么挪到最右边，显然贪心地挪更优</p><p>由于考虑到当前数时，所有比它小的数都已经考虑完毕了，因此这个数的交换次数是它的逆序对以及顺序对的最小值</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tree[N], mx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (; x &lt;= mx; x += x &amp; -x)</span><br><span class="line">tree[x] += v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; x; x -= x &amp; -x) res += tree[x];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> query(r) - query(l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(tree, <span class="number">0</span>, <span class="keyword">sizeof</span>(tree));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N], L[N], R[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]), mx = max(mx, num[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        update(num[i], <span class="number">1</span>), L[i] = query(num[i] + <span class="number">1</span>, mx);</span><br><span class="line">    clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) </span><br><span class="line">        update(num[i], <span class="number">1</span>), R[i] = query(num[i] + <span class="number">1</span>, mx);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res += min(L[i], R[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP赛前集训day6</title>
      <link href="/2019/10/23/CSP%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%ADday6/"/>
      <url>/2019/10/23/CSP%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%ADday6/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-爬杆"><a href="#T1-爬杆" class="headerlink" title="T1 爬杆"></a>T1 爬杆</h1><p><img src="1571835788524.png" alt="1571835788524"></p><p><img src="1571835801443.png" alt="1571835801443"></p><p>对于第一问，显然答案为</p><script type="math/tex; mode=display">\sum_{i=1}^n\sum_{j=i}^nh_i+h_j+j-i-2\min_{i}^jh_i</script><p>现在考虑第二问，对于一个区间$l,r$，我们找到这个区间的最小值，那么对于任意一个左端点在最小值左边，右端点在最小值右边的两个竹竿，经过的路径只能先降再升</p><p>因此，我们考虑在当前区间中连接$r-l$个梯子，在最小值前面的梯子高度为所在杆子的前缀最小值，后面的梯子高度为所在杆子的后缀最小值，因为靠上放置梯子肯定更优秀</p><p>比如，对于样例$2$</p><p><img src="1571836243488.png" alt="1571836243488"></p><p>最小值为$1$，那么我们连接$10-1=9$个梯子</p><p><img src="1571836379445.png" alt="1571836379445"></p><p>这样即可使得所有最小值为当前区间最小值的两个杆子满足条件</p><p>同时，我们注意到，对于那些被当前梯子覆盖的杆子，越过它们，并且以它们为最小值的那些区间也满足条件了，不需要考虑</p><p>比如图中位置$8$就被梯子覆盖了，我们便不再考虑这根杆子</p><p>已经满足条件的杆子将这个区间分成了若干个小区间，对于每个小区间我们分治下去</p><p>比如上图就被分成了如下几个区间</p><p><img src="1571836750374.png" alt="1571836750374"></p><p>对于这几个区间再分别处理即可</p><p><img src="1571836856988.png" alt="1571836856988"></p><p>需要预处理每个数左边/右边第一个小于等于它的位置，单调栈即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N], L[N], R[N], R1[N], stk[N]; LL res, res1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    res += r - l;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="keyword">int</span> pos = r;</span><br><span class="line">    <span class="keyword">while</span> (pos &gt;= l) </span><br><span class="line">        tmp.push_back(pos), pos = L[pos];</span><br><span class="line">    pos = l;</span><br><span class="line">    <span class="keyword">while</span> (pos &lt;= r) </span><br><span class="line">        tmp.push_back(pos), pos = R[pos];</span><br><span class="line">    sort(tmp.begin(), tmp.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp.size() - <span class="number">1</span>; i++)</span><br><span class="line">        solve(tmp[i] + <span class="number">1</span>, tmp[i + <span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">1</span>; stk[top] = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &amp;&amp; num[i] &lt;= num[stk[top]]) L[stk[top]] = i, top--;</span><br><span class="line">        stk[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    top = <span class="number">1</span>, stk[top] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &amp;&amp; num[i] &lt;= num[stk[top]]) R[stk[top]] = i, top--;</span><br><span class="line">        stk[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= top; i++) R[stk[i]] = n + <span class="number">1</span>;</span><br><span class="line">    top = <span class="number">1</span>, stk[top] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &amp;&amp; num[i] &lt; num[stk[top]]) R1[stk[top]] = i, top--;</span><br><span class="line">        stk[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= top; i++) R1[stk[i]] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        res1 -= <span class="number">2</span> * (LL)(i - L[i]) * (R1[i] - i) * num[i];</span><br><span class="line">        res1 += (LL)num[i] * (n - i + <span class="number">1</span>);</span><br><span class="line">        res1 += (LL)num[i] * i;</span><br><span class="line">        res1 -= (LL)i * (n - i + <span class="number">1</span>);</span><br><span class="line">        res1 += (LL)i * i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld "</span>, res1);</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="number">2</span>) solve(<span class="number">1</span>, n), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-变换"><a href="#T2-变换" class="headerlink" title="T2 变换"></a>T2 变换</h1><p><img src="1571836966318.png" alt="1571836966318"></p><p><img src="1571836974475.png" alt="1571836974475"></p><p>考虑枚举$k$</p><p>对于一个确定的$k$来说，由于每次操作只有$\min,\max$，因此两个大于$k$的数取$\min$仍然大于$k$，两个小于$k$的数取$\max$仍然小于$k$。换言之，我们只关心每个数与$k$的大小关系，而不关心它具体的值</p><p>因此，我们可以用$0/1/-1$来替换每个数。如果它比$k$小，就是$-1$；如果它等于$k$，就是$0$；否则是$1$</p><p>序列中的$0$将这个序列分成了若干段，对于每一段我们的策略是从左往右一次拓展过去</p><p>我们现在只考虑某一个$0$右边的两个数</p><p>如果这两个数相同，即<code>0 1 1</code>或<code>0 -1 -1</code>，那么我们显然可以通过一次$\min/\max$就能将中间的数变成$0$</p><p>但是如果这两个数不同，即<code>0 1 -1</code>或<code>0 -1 1</code>，那么我们只能先取一次$\min$，再取一次$\max$来将中间的数变为$0$</p><p>如果有连续的三个数为<code>1 -1 1</code>或者<code>-1 1 -1</code>，我们需要预先对中间的数多操作一次，将这三个数变得相同</p><p>比如对于<code>0 1 -1 1 -1 1 0</code>这个序列</p><p>我们会先对第三个位置、第五个位置操作一次，将这个序列变为<code>0 1 1 1 1 1 0</code></p><p>接着再从左往右操作，每个数操作一次</p><p>因此，我们采取这样的策略：将被$0$分割出的子序列分成若干段极长的<code>1 -1</code>相间的段，每一段的答案为段长$+$段长除以$2$向上取整</p><p>代码就略了</p><h1 id="T3-游戏"><a href="#T3-游戏" class="headerlink" title="T3 游戏"></a>T3 游戏</h1><p><img src="1571837669113.png" alt="1571837669113"></p><p><img src="1571837677932.png" alt="1571837677932"></p><p>定义完美匹配为每个点都能找到它的一个未匹配的祖先匹配</p><p>那么后手必胜当且仅当这棵树存在完美匹配</p><p>如果存在完美匹配，那么很显然，当先手每选择一个点，后手就选择与它匹配的那一个点即可</p><p>否则，每当先手选择一个点，我们就将这个点以及后手选择的点删去，最后一定剩下若干个互不为祖先关系的点，先手只需要保证最后选择的点是存在匹配冲突的一个点，后手就凉了。</p><p>因此我们可以记$dp[i][j]$表示考虑了$i$的子树，其中有$j$个点未匹配，并且这棵子树不能全部不被选的方案数</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x += y, x -= x &gt;= mod ? mod : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[N][N], sz[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    dp[u][<span class="number">0</span>] = <span class="number">1</span>, sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) &#123;</span><br><span class="line">            dfs(e[i].to, u);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = sz[u]; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = sz[e[i].to]; k &gt;= <span class="number">0</span>; k--)</span><br><span class="line">                    Inc(dp[u][j + k], (LL)dp[u][j] * dp[e[i].to][k] % mod);</span><br><span class="line">            sz[u] += sz[e[i].to];        </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> t = dp[u][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz[u]; i++) Inc(dp[u][i], dp[u][i + <span class="number">1</span>]);</span><br><span class="line">    Inc(dp[u][<span class="number">1</span>], t), dp[u][<span class="number">0</span>]--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>); <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = res * <span class="number">2</span> % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (res - dp[<span class="number">1</span>][<span class="number">0</span>] - <span class="number">1</span> + mod) % mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 博弈 </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斯坦纳树</title>
      <link href="/2019/10/23/%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/"/>
      <url>/2019/10/23/%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>斯坦纳树可以解决这样一类问题：给出一张图，再给出这张图上的$k$个关键点，要求选出一些边使得这$k$个关键点联通，并且权值之和要最小</p><p>本质上来讲，斯坦纳树就是状压<code>dp</code>，只不过有一部分<code>dp</code>是通过<code>SPFA</code>实现而已</p><p>因此，斯坦纳树的时间复杂度是指数级别的</p><h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><p>斯坦纳树之所以被称为“树”，是因为在<code>dp</code>的过程中我们会给当前所有已经遍历的点确定一个根，之后的每次拓展都由这个根出发</p><p>我们记$f[i][S]$表示以$i$为根，并且当前已经将$S$集合中的关键点联通的最小代价</p><p>显然有两种转移方式</p><p>一种是不动根，合并两个不相交的集合</p><p>另一种是换根，即拓展一个点</p><p>第一种的转移比较显然，枚举$S$的子集即可</p><p>第二种的转移是有后效性的，即更新一次可能会影响到一堆点，很像最短路，因此我们使用<code>SPFA</code>来更新</p><h1 id="一道例题"><a href="#一道例题" class="headerlink" title="一道例题"></a>一道例题</h1><p><img src="1571834532220.png" alt="1571834532220"></p><p><img src="1571834541463.png" alt="1571834541463"></p><p>首先给每种颜色随机一个编号，由于$k$只有$7$，因此随机一次的正确率为$\frac{k!}{k^k}$，即答案的$k$种颜色被编为不同编号的概率</p><p>随机$1000$次的正确率还是比较高的</p><p>然后就是斯坦纳树板子题了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">230</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1</span> &lt;&lt; <span class="number">7</span>][N], col[N], val[N]; <span class="keyword">bool</span> vis[N]; <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = q.front(); q.pop(); vis[u] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line"><span class="keyword">if</span> (col[e[i].to] != <span class="number">-1</span> &amp;&amp; f[S][u] + val[e[i].to] &lt; f[S][e[i].to]) &#123;</span><br><span class="line">f[S][e[i].to] = f[S][u] + val[e[i].to];</span><br><span class="line"><span class="keyword">if</span> (!vis[e[i].to]) q.push(e[i].to), vis[e[i].to] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1e9</span>, k, n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ID</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x - <span class="number">1</span>) * m + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Just_DOIT</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f)); <span class="keyword">int</span> lim = n * m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lim; i++) <span class="keyword">if</span> (col[i] != <span class="number">-1</span>)</span><br><span class="line">f[<span class="number">1</span> &lt;&lt; col[i] - <span class="number">1</span>][i] = val[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> S = <span class="number">1</span>; S &lt; <span class="number">1</span> &lt;&lt; k; S++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lim; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = S; s; s = (s - <span class="number">1</span>) &amp; S) </span><br><span class="line">f[S][i] = min(f[S][i], f[s][i] + f[S ^ s][i] - val[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lim; i++) <span class="keyword">if</span> (f[S][i] &lt; <span class="number">1e9</span>)</span><br><span class="line">vis[i] = <span class="number">1</span>, q.push(i);</span><br><span class="line">SPFA(S);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lim; i++) res = min(res, f[(<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>][i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> G[N], to[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"graph.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"graph.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">srand((<span class="keyword">long</span> <span class="keyword">long</span>)<span class="keyword">new</span> <span class="keyword">char</span>); </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;G[ID(i, j)]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val[ID(i, j)]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i != n) adde(ID(i, j), ID(i + <span class="number">1</span>, j));</span><br><span class="line"><span class="keyword">if</span> (j != m) adde(ID(i, j), ID(i, j + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t = clock();</span><br><span class="line"><span class="keyword">while</span>(clock() - t &lt;= <span class="number">1.8</span> * CLOCKS_PER_SEC) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * m; i++) to[i] = rand() % k + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * m; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (G[i] == <span class="number">-1</span>) col[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> col[i] = to[G[i]];</span><br><span class="line">&#125;</span><br><span class="line">Just_DOIT();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斯坦纳树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP赛前集训day5</title>
      <link href="/2019/10/23/CSP%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%ADday5/"/>
      <url>/2019/10/23/CSP%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%ADday5/</url>
      
        <content type="html"><![CDATA[<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><div class="pdfobject-container" data-target="problems.pdf" data-height="500px"></div><h1 id="T1-染色"><a href="#T1-染色" class="headerlink" title="T1 染色"></a>T1 染色</h1><p>如果这张图是一棵树，那么答案显然为$0$</p><p>在每一轮中，所有的叶子节点都会被删掉，然后一直重复这个操作直到整棵树被删掉</p><p>而对于所有的非树边，它必须被染黑，即如果我们将所有被染黑的边删去，那么剩下的一定没有环</p><p>因此答案就很显然了，对于一个连通块，最优的方案一定是将它的一棵生成树染成白色，剩下的所有边都染成黑色</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">bool</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type) <span class="built_in">printf</span>(<span class="string">"%d "</span>, u);</span><br><span class="line">    <span class="keyword">bool</span> t = type;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u, t ^ <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!type) <span class="built_in">printf</span>(<span class="string">"%d "</span>, u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-乘方"><a href="#T2-乘方" class="headerlink" title="T2 乘方"></a>T2 乘方</h1><p>首先考虑暴力容斥，枚举有哪些条件被同时满足了，然后再二分</p><p>如果一个数既能被某一个数的$a$次方表示，又能被某个数的$b$次方表示，那么它一定能被某个数的$\text{lcm}(a,b)$次方表示</p><p>如果暴力$2^k$枚举有哪些条件被同时满足，那么限制就等价于这些条件的$\text{lcm}$，容斥系数显然是$-1$的条件个数次方$-1$</p><p>因此，我们可以将这个容斥写成$dp$的形式，注意到答案只与$\text{lcm}$有关，因此可以提前将每种$\text{lcm}$的容斥系数之和计算出来</p><p>$2^{60}$次方就已经超过答案上界了，因此$\text{lcm}$不超过$60$个</p><p>注意$1$必须从所有集合中去掉，否则只考虑前$60$的$\text{lcm}$会错</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">61</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Pow</span><span class="params">(LL x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x *= x) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res *= x;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">calc</span><span class="params">(LL lim, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="built_in">pow</span>(lim, <span class="number">1.0</span> / k) + <span class="number">0.05</span>;</span><br><span class="line">    <span class="keyword">while</span> (Pow(res, k) &gt; lim) res--;</span><br><span class="line">    <span class="keyword">return</span> res - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lcm[N][N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">calc</span><span class="params">(LL lim)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) <span class="keyword">if</span> (f[i]) </span><br><span class="line">        res += f[i] * calc(lim, i);</span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        LL m; <span class="keyword">int</span> k; <span class="built_in">scanf</span>(<span class="string">"%lld%d"</span>, &amp;m, &amp;k);</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)); <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), flag |= x == <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = N - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--) <span class="keyword">if</span> (f[j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = j * x / gcd(j, x);</span><br><span class="line">                <span class="keyword">if</span> (t &lt; N) f[t] -= f[j];</span><br><span class="line">            &#125;</span><br><span class="line">            f[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, m); <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m--; LL l = <span class="number">1</span>, r = <span class="number">1e17</span>, mid, res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (calc(mid) &gt;= m) res = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个题用莫比乌斯反演也是可以做的</p><p>对于一个数$x$，我们考虑能表示它的最大指数，即对于最大的指数$b$存在一个$a$使得$a^b=x$，我们在$b$这个位置统计答案</p><p>我们考虑上面代码中的<code>calc</code>是什么，即统计所有能被表示成$a^k$的数的个数，那么这些数的最大指数一定是$k$倍数</p><p>那么设$F(x)$表示最大指数为$x$或$x$的倍数的个数，$G(x)$表示最大指数恰好是$x$的个数</p><p>显然有</p><script type="math/tex; mode=display">F(x)=\sum_{x|d}G(d)\\G(x)=\sum_{x|d}F(d)\mu(\frac{d}{x})</script><p>那么答案就是给出的所有指数以及它们的倍数的$G(x)$之和</p><p>特别的，如果给出的数是$2-k$，那么$F(x)$容斥系数就是$-\mu(x)$</p><p>莫比乌斯反演的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Pow</span><span class="params">(LL x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x *= x) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res *= x;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Just_DOIT</span><span class="params">(LL lim, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="built_in">pow</span>(lim, <span class="number">1.0</span> / k) + <span class="number">0.05</span>;</span><br><span class="line">    <span class="keyword">while</span> (Pow(res, k) &gt; lim) res--;</span><br><span class="line">    <span class="keyword">return</span> res - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[M], mu[M], flag[M], prime[M], pcnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">calc</span><span class="params">(LL lim)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">60</span>; i++) <span class="keyword">if</span> (f[i]) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= <span class="number">60</span>; j += i)</span><br><span class="line">            res += Just_DOIT(lim, j) * mu[j / i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= M - <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag[i]) prime[++pcnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pcnt &amp;&amp; i * prime[j] &lt;= M - <span class="number">5</span>; j++) &#123;</span><br><span class="line">            flag[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            mu[i * prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T), sieve();</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        LL m, k; <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;m, &amp;k), m--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= k; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = x; j &lt;= <span class="number">60</span>; j += x) f[j] = <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (f[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, m + <span class="number">1</span>); <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LL l = <span class="number">1</span>, r = <span class="number">1e17</span>, mid, ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            LL res = calc(mid);</span><br><span class="line">            <span class="keyword">if</span> (res &gt;= m) ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-位运算"><a href="#T3-位运算" class="headerlink" title="T3 位运算"></a>T3 位运算</h1><p>暴力<code>FWT</code>即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT1</span><span class="params">(LL a[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + (mid &gt;&gt; <span class="number">1</span>); j++) </span><br><span class="line">                a[j + (mid &gt;&gt; <span class="number">1</span>)] += a[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IFWT1</span><span class="params">(LL a[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + (mid &gt;&gt; <span class="number">1</span>); j++) </span><br><span class="line">                a[j + (mid &gt;&gt; <span class="number">1</span>)] -= a[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT2</span><span class="params">(LL a[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + (mid &gt;&gt; <span class="number">1</span>); j++) </span><br><span class="line">                a[j] += a[j + (mid &gt;&gt; <span class="number">1</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IFWT2</span><span class="params">(LL a[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + (mid &gt;&gt; <span class="number">1</span>); j++) </span><br><span class="line">                a[j] -= a[j + (mid &gt;&gt; <span class="number">1</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT3</span><span class="params">(LL a[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + (mid &gt;&gt; <span class="number">1</span>); j++) &#123;</span><br><span class="line">                LL x = a[j], y = a[j + (mid &gt;&gt; <span class="number">1</span>)];</span><br><span class="line">                a[j] = x + y, a[j + (mid &gt;&gt; <span class="number">1</span>)] = x - y;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IFWT3</span><span class="params">(LL a[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + (mid &gt;&gt; <span class="number">1</span>); j++) &#123;</span><br><span class="line">                LL x = a[j], y = a[j + (mid &gt;&gt; <span class="number">1</span>)];</span><br><span class="line">                a[j] = (x + y) &gt;&gt; <span class="number">1</span>, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (x - y) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL a[N], b[N]; <span class="keyword">int</span> input[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, mx = <span class="number">0</span>, len = <span class="number">1</span>, op; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;op);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), a[x]++, b[x]++, mx = max(mx, x), input[i] = x;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= mx) len &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">        FWT2(a, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) a[i] = a[i] * a[i];</span><br><span class="line">        IFWT2(a, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (a[i]) &#123;</span><br><span class="line">            LL res = (a[i] - b[i]) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (res) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n%lld"</span>, i, res), <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) </span><br><span class="line">            <span class="keyword">if</span> (input[i] != input[<span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"0\n%lld"</span>, (LL)n * (n + <span class="number">1</span>) / <span class="number">2</span>), <span class="number">0</span>;</span><br><span class="line">        FWT3(a, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) assert(a[i] &lt;= n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) a[i] = a[i] * a[i];</span><br><span class="line">        IFWT3(a, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (a[i]) </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n%lld"</span>, i, a[i] &gt;&gt; <span class="number">1</span>), <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        FWT1(a, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) a[i] = a[i] * a[i];</span><br><span class="line">        IFWT1(a, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (a[i]) &#123;</span><br><span class="line">            LL res = (a[i] - b[i]) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (res) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n%lld"</span>, i, res), <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FWT </tag>
            
            <tag> 莫比乌斯反演 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP赛前集训day4</title>
      <link href="/2019/10/21/CSP%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%ADday4/"/>
      <url>/2019/10/21/CSP%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%ADday4/</url>
      
        <content type="html"><![CDATA[<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><div class="pdfobject-container" data-target="problems.pdf" data-height="500px"></div><h1 id="T1-路径"><a href="#T1-路径" class="headerlink" title="T1 路径"></a>T1 路径</h1><p>这个题的大致思路是：对于一棵没有访问过的子树，先找一条路径跳下去，并且给上来的时候留好空位，然后继续访问其它子树</p><p>一种比较优秀的想法是，将一条路径按照奇偶分类，进来的时候跳奇数点，出去的时候跳偶数点</p><p>但是如果在子树之间切换怎么办呢</p><p>我们发现，仍然可以按照奇偶性分类</p><p><img src="1571658466588.png" alt="1571658466588"></p><p>这样，我们仍然可以做到黑色点在向下<code>dfs</code>的时候被访问，白色点在向上回溯的时候被访问，并且没有超过最短路为$3$的限制</p><p>代码非常简洁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">bool</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type) <span class="built_in">printf</span>(<span class="string">"%d "</span>, u);</span><br><span class="line">    <span class="keyword">bool</span> t = type;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u, t ^ <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!type) <span class="built_in">printf</span>(<span class="string">"%d "</span>, u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-魔法"><a href="#T2-魔法" class="headerlink" title="T2 魔法"></a>T2 魔法</h1><p>先对每一个匹配串跑一遍<code>KMP</code>，求出它在原串中的每一个匹配位置</p><p>对于每一个位置我们记录一个$l$，表示所有以这个位置结尾的串中，起点最靠右的是什么</p><p>然后问题就转化为给你若干个区间，每个区间至少要选择一个数，你要让选择的数的总和尽量小</p><p><code>dp[i]</code>表示最后一个选择的位置在$i$，在$i$之前不包含$i$的区间已经满足条件时选择的数总和的最小值</p><p>将区间按照右端点排序，考虑相邻的两个区间$a,b$，我们只需要更新$a_r-b_r$这段的<code>dp</code>值</p><p><code>dp</code>的时候记录当前区间前面的所有区间的左端点最靠右能到哪里，假设是<code>ls</code>，那么转移的时候只能从$ls-r_i$转移过来，因为如果上一个选择的位置在<code>ls</code>之前，那么必定有一个区间不满足条件</p><p>同样可以使用线段树优化，单调队列也可以</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nxt[N], mn[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ls = nxt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (ls &amp;&amp; s[ls + <span class="number">1</span>] != s[i]) ls = nxt[ls];</span><br><span class="line">        nxt[i] = ls + (s[ls + <span class="number">1</span>] == s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">KMP</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">char</span> t[], <span class="keyword">int</span> len2, <span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> at = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (at &amp;&amp; at &lt;= len2 &amp;&amp; s[at + <span class="number">1</span>] != t[i]) at = nxt[at];</span><br><span class="line">        <span class="keyword">if</span> (at &lt; len2 &amp;&amp; s[at + <span class="number">1</span>] == t[i]) at++;</span><br><span class="line">        <span class="keyword">if</span> (at == len2) mn[i] = min(mn[i], len2); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N], t[N]; <span class="keyword">int</span> val[N], dp[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, mn;</span><br><span class="line">&#125; T[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    T[rt].mn = min(T[rt &lt;&lt; <span class="number">1</span>].mn, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    T[rt].l = l, T[rt].r = r, T[rt].mn = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; build(rt &lt;&lt; <span class="number">1</span>, l, mid), build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> at, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> T[rt].mn = x, <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">if</span> (at &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, at, x);</span><br><span class="line">    <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, at, x);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> T[rt].mn;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) res = min(res, query(rt &lt;&lt; <span class="number">1</span>, start, end));</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) res = min(res, query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, start, end));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;n, &amp;m, s + <span class="number">1</span>);    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val[i]), mn[i] = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, t + <span class="number">1</span>); <span class="keyword">int</span> len = <span class="built_in">strlen</span>(t + <span class="number">1</span>);</span><br><span class="line">        Build(len, t), KMP(n, s, len, t);</span><br><span class="line">    &#125;</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">0</span>, n), update(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), mn[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">int</span> l = <span class="number">0</span>, ls = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (mn[i] &lt; <span class="number">1e9</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = query(<span class="number">1</span>, l, ls);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = ls + <span class="number">1</span>; j &lt;= i; j++) update(<span class="number">1</span>, j, res + val[j]);</span><br><span class="line">        ls = i, l = max(l, i - mn[i] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(<span class="number">1</span>, l, ls));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-交集"><a href="#T3-交集" class="headerlink" title="T3 交集"></a>T3 交集</h1><p>一开始把题看错了，以为要统计的是集合的数量</p><p>我们将$u,v$分开考虑，如果能求出所有左端点序列的方案数，再求出右端点序列的方案数，那么把它们相乘就是答案</p><p>由于这些路径的交是$u,v$，因此对于所有路径的左端点（就是$u$的那边），应该满足如下条件</p><ul><li>不能出现在以$u$为根时，$v$的子树中</li><li>$u$的每个儿子代表的子树中最多只能选择一个点，方案是该儿子的$sz$</li><li>可以有任意多个端点是$u$</li></ul><p>这时有一个很显然的$ql^2$做法，即每次询问暴力$dp$，$dp[i][j]$表示考虑了前$i$棵子树，并且选择了$j$个点的方案数</p><p>如果用生成函数将这个$dp$写出来，那么就是若干个形如$1+ax$这样的一次项的乘积</p><p>我们可以将每个点对应的多项式预处理出来</p><p>注意到$v$所在的那颗子树是不能被考虑的，我们需要从这个多项式中去除这棵子树带来的影响</p><p>也就是除去一个一次项，由于只有两项，暴力大除法即可</p><p>最后再枚举有多少个端点是$u$</p><p>那么答案就是</p><script type="math/tex; mode=display">\sum_{i\geq 0}{k\choose i}i!dp[i]</script><p>即从$k$个位置选出$i$个放不是$u$的点，这些点可以任意排列，并且选出这些点的方案数是$dp[i]$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sz[N], n, dp[N][<span class="number">510</span>], tmp[<span class="number">510</span>], ans[<span class="number">510</span>]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hh[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N][<span class="number">18</span>], dep[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>, fa[u][<span class="number">0</span>] = f, dep[u] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">17</span>; i++) fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) &#123;</span><br><span class="line">            dfs(e[i].to, u);</span><br><span class="line">            hh[u].push_back(sz[e[i].to]), sz[u] += sz[e[i].to];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (sz[u] != n) hh[u].push_back(n - sz[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[a] &lt; dep[b]) swap(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (dep[fa[a][i]] &gt;= dep[b]) a = fa[a][i];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i];</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> lca)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (dep[fa[a][i]] &gt; dep[lca]) a = fa[a][i];</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    dp[u][<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">int</span> lim = hh[u].size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lim; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = lim; j &gt;= <span class="number">1</span>; j--) <span class="keyword">if</span> (dp[u][j - <span class="number">1</span>])</span><br><span class="line">            dp[u][j] = (dp[u][j] + (LL)dp[u][j - <span class="number">1</span>] * hh[u][i - <span class="number">1</span>]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> inv[N], ifrac[<span class="number">510</span>], frac[<span class="number">510</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * ifrac[r] % mod * ifrac[n - r] % mod;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Just_DOIT</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lim = hh[u].size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lim; i++) ans[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lim; i++) tmp[i] = dp[u][i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lim; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        ans[i - <span class="number">1</span>] = (LL)tmp[i] * inv[t] % mod;</span><br><span class="line">        tmp[i] = <span class="number">0</span>, tmp[i - <span class="number">1</span>] = (tmp[i - <span class="number">1</span>] - ans[i - <span class="number">1</span>] + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= min(k, lim); i++) res = (res + (LL)frac[i] * ans[i] % mod * C(k, i)) % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen("test.in", "r", stdin), freopen("test.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">int</span> q, L; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;q, &amp;L), frac[<span class="number">0</span>] = ifrac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= L; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, ifrac[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) inv[i] = Pow(i, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) work(i);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, k; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;k);</span><br><span class="line">        <span class="keyword">if</span> (dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line">        <span class="keyword">int</span> lca = LCA(u, v);</span><br><span class="line">        <span class="keyword">if</span> (lca != v) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL)Just_DOIT(u, k, n - sz[u]) * </span><br><span class="line">            Just_DOIT(v, k, n - sz[v]) % mod);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> t = jump(u, v);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL)Just_DOIT(u, k, n - sz[u]) * </span><br><span class="line">                Just_DOIT(v, k, sz[t]) % mod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 多项式 </tag>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP赛前集训day3</title>
      <link href="/2019/10/17/CSP%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%ADday3/"/>
      <url>/2019/10/17/CSP%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%ADday3/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-比大小"><a href="#T1-比大小" class="headerlink" title="T1 比大小"></a>T1 比大小</h1><p><img src="1571656232945.png" alt="1571656232945"></p><p><img src="1571656239632.png" alt="1571656239632"></p><p>首先有一个结论：对于每一个$01$切换的位置$i,i+1$，$1-i$的值域必定是$1-2i$</p><p>如果到了位置$i$，我们假设此时<code>Bob</code>的数字更大，并且当前取的数没有将$1-2i$填满。那么在第$i+1$轮中，<code>Bob</code>必须选择一个比他之前还要大的数，这个数不可能在$1-2i$中，而此时<code>Alice</code>必须选择一个比<code>Bob</code>大的数。也就是说，对于$1-2i$中那些没有取到的数，之后就再也取不到了</p><p>因此我们将每一个$01$切换的位置分开，这些位置将序列划分成了若干个连续段，对于每个连续段我们只需要将它划分成两个上升子序列，并且第一个序列的每一个元素都要大于第二个序列的对应元素。通过打表可以发现，方案恰好是卡特兰数。答案就是每一段对应的卡特兰数的乘积</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Catalan</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)C(n * <span class="number">2</span>, n) * frac[n] % mod * inv[n + <span class="number">1</span>] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d%s"</span>, &amp;n, s + <span class="number">1</span>), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    inv[n * <span class="number">2</span>] = Pow(frac[n * <span class="number">2</span>], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n * <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) inv[i] = (LL)inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, r; i &lt;= n; i = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = i;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n &amp;&amp; s[r + <span class="number">1</span>] == s[i]) r++;</span><br><span class="line">        res = (LL)res * Catalan(r - i + <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-玩游戏"><a href="#T2-玩游戏" class="headerlink" title="T2 玩游戏"></a>T2 玩游戏</h1><p><img src="1571656656841.png" alt="1571656656841"></p><p><img src="1571656664383.png" alt="1571656664383"></p><p>每一棵树都有$4$种状态：</p><ul><li>先手进，先手出</li><li>先手进，后手出</li><li>先手进，并且先手可以选择是先手出还是后手出</li><li>先手进，并且后手可以选择是先手出还是后手出</li></ul><p>显然，只要存在一棵树满足情况$3$，那么先手必胜。因为如果先手败了，那么先手完全可以切换他出这棵树时候的状态将局面变为必胜</p><p>对于情况$4$，选择这棵树的人一定凉，因此无论是先手还是后手都尽量不会选这棵树</p><p>此时如果第二种情况的树有奇数棵，先手必胜，否则后手必胜</p><p>分类讨论一下就行了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N], cnt[<span class="number">5</span>], f[N][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x += y, x -= x &gt;= mod ? mod : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot[<span class="number">4</span>], state[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f[u], <span class="number">0</span>, <span class="keyword">sizeof</span>(f[u]));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next) </span><br><span class="line">        <span class="keyword">if</span> (e[i].to != fa) dfs(e[i].to, u), f[u][state[e[i].to]]++;</span><br><span class="line">    <span class="keyword">if</span> (!(f[u][<span class="number">0</span>] + f[u][<span class="number">1</span>] + f[u][<span class="number">2</span>] + f[u][<span class="number">3</span>])) <span class="keyword">return</span> state[u] = <span class="number">0</span>, <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">if</span> (f[u][<span class="number">3</span>] || (f[u][<span class="number">0</span>] &amp;&amp; f[u][<span class="number">1</span>])) <span class="keyword">return</span> state[u] = <span class="number">2</span>, <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">if</span> (f[u][<span class="number">0</span>]) <span class="keyword">return</span> state[u] = <span class="number">1</span>,<span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">if</span> (f[u][<span class="number">1</span>]) <span class="keyword">return</span> state[u] = <span class="number">0</span>,<span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">if</span> (f[u][<span class="number">2</span>]) <span class="keyword">return</span> state[u] = <span class="number">3</span>,<span class="keyword">void</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, LL y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pre</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) </span><br><span class="line">        frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    inv[m] = Pow(frac[m], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        inv[i] = (LL)inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m), Pre(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), ecnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) head[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, fa; i &lt;= n; i++) </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;fa), adde(i, fa);</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (state[<span class="number">1</span>] == <span class="number">3</span>) state[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state[<span class="number">1</span>] == <span class="number">2</span>) state[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">        cnt[state[<span class="number">1</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (cnt[<span class="number">2</span>]) res = (LL)(Pow(<span class="number">2</span>, cnt[<span class="number">2</span>]) - <span class="number">1</span>) * (Pow(<span class="number">2</span>, cnt[<span class="number">0</span>] + cnt[<span class="number">1</span>] + cnt[<span class="number">3</span>])) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt[<span class="number">1</span>]; i += <span class="number">2</span>) </span><br><span class="line">        Inc(res, (LL)C(cnt[<span class="number">1</span>], i) * Pow(<span class="number">2</span>, cnt[<span class="number">0</span>]) % mod * Pow(<span class="number">2</span>, cnt[<span class="number">3</span>]) % mod);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-数个数"><a href="#T3-数个数" class="headerlink" title="T3 数个数"></a>T3 数个数</h1><p><img src="1571657095830.png" alt="1571657095830"></p><p><img src="1571657102862.png" alt="1571657102862"></p><p>首先考虑暴力容斥</p><p>$2^m$枚举有哪些限制没有被满足，也就是这些区间中的每一个数都是$b_i$，容斥系数就是$-1$的区间个数</p><p>次方</p><p>将区间按照右端点排序，并去掉相同颜色并且存在包含关系的区间，大区间显然是没用的</p><p>我们可以将这个容斥写成$dp$的形式，即$dp[i]$表示只考虑了前$i$个区间，这些区间对答案算上容斥系数的贡献</p><p>先考虑$O(n)$转移</p><p>枚举上一次选的区间是啥，如果上一次选的区间与当前区间的$b$不同，那么这两个区间一定没有交，因为当前区间中的数不可能同时等于两个数</p><p>否则可以与当前区间有交</p><p>容易发现这两个转移可以用线段树优化，然后这个题就完了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lson[N * <span class="number">80</span>], rson[N * <span class="number">80</span>], sum[N * <span class="number">80</span>], ncnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x += y, x -= x &gt;= mod ? mod : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> at, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rt) rt = ++ncnt, sum[rt] = <span class="number">0</span>;</span><br><span class="line">    Inc(sum[rt], x);</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (at &lt;= mid) update(lson[rt], l, mid, at, x);</span><br><span class="line">    <span class="keyword">else</span> update(rson[rt], mid + <span class="number">1</span>, r, at, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!rt) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> sum[rt];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) Inc(res, query(lson[rt], l, mid, start, end));</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) Inc(res, query(rson[rt], mid + <span class="number">1</span>, r, start, end));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tree[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n + <span class="number">1</span>; x += x &amp; -x) Inc(tree[x], y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">que</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= x &amp; -x) Inc(res, tree[x]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, b, flg;</span><br><span class="line">&#125; l[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Query&gt; l1[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> RT[N], tot, dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">const</span> Query &amp;a, <span class="keyword">const</span> Query &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.l != b.l) <span class="keyword">return</span> a.l &lt; b.l;</span><br><span class="line">        <span class="keyword">return</span> a.r &gt; b.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(<span class="keyword">const</span> Query &amp;a, <span class="keyword">const</span> Query &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stk[N], top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, S; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        l1[c].push_back((Query)&#123;a, b, c, <span class="number">0</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S; i++) <span class="keyword">if</span> (l1[i].size()) &#123;</span><br><span class="line">        sort(l1[i].begin(), l1[i].end(), cmp1), top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, ls = <span class="number">0</span>; j &lt; l1[i].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (top &amp;&amp; l1[i][j].r &lt;= l1[i][stk[top]].r) &#123;</span><br><span class="line">                l1[i][stk[top]].flg = <span class="number">1</span>, top--;</span><br><span class="line">            &#125;</span><br><span class="line">            stk[++top] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; l1[i].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!l1[i][j].flg) l[++tot] = l1[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s[i] = (LL)s[i - <span class="number">1</span>] * S % mod;</span><br><span class="line">    inv[n] = Pow(s[n], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) inv[i] = (LL)inv[i + <span class="number">1</span>] * S % mod;</span><br><span class="line">    upd(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    sort(l + <span class="number">1</span>, l + tot + <span class="number">1</span>, cmp2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = (LL)s[l[i].l - <span class="number">1</span>] * que(l[i].l) % mod;</span><br><span class="line">        dp[i] = mod - t;</span><br><span class="line">        Inc(dp[i], mod - query(RT[l[i].b], <span class="number">1</span>, n, l[i].l, n)); </span><br><span class="line">        update(RT[l[i].b], <span class="number">1</span>, n, l[i].r, dp[i]);</span><br><span class="line">        upd(l[i].r + <span class="number">1</span>, (LL)dp[i] * inv[l[i].r] % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = Pow(S, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">        Inc(res, (LL)dp[i] * s[n - l[i].r] % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 博弈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP赛前集训day2</title>
      <link href="/2019/10/17/CSP%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%ADday2/"/>
      <url>/2019/10/17/CSP%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%ADday2/</url>
      
        <content type="html"><![CDATA[<div class="pdfobject-container" data-target="problems.pdf" data-height="500px"></div><h1 id="T1-石子"><a href="#T1-石子" class="headerlink" title="T1 石子"></a>T1 石子</h1><p>分开考虑每堆石子对$1$号石子的贡献。由于答案等于$1$号石子前面的石子堆数，因此将每堆石子排在$1$号石子之前的概率加起来就是答案</p><p>如果$1$号石子有$a$个，现在考虑的这堆石子有$b$个，那么这个概率显然是$\frac{b}{a+b}$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, a; <span class="keyword">double</span> res = <span class="number">1</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;a);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, b; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b), res += (<span class="keyword">double</span>)b / (a + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常简短</p><h1 id="T2-内存"><a href="#T2-内存" class="headerlink" title="T2 内存"></a>T2 内存</h1><p>$nm\log n$的方法非常简单</p><p>首先有一个结论，对于一个随机的序列，它的上升序列长度的期望只有$\log n$</p><p>如果将$1-m$随机排列，那么它们的最优答案也是一个随机的序列，期望上升的长度也只有$\log$</p><p>因此我们可以维护当前的最优答案，每次先<code>check</code>一下有没有取到更优答案的可能，如果有再二分</p><p>这样的时间复杂度是$nm+n\log m\log m$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>, ct = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> t = a[i] + x; <span class="keyword">if</span> (t &gt;= m) t -= m;</span><br><span class="line"><span class="keyword">if</span> (t &gt; mid) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp + t &gt; mid) ct++, tmp = t;</span><br><span class="line"><span class="keyword">else</span> tmp += t;</span><br><span class="line"><span class="keyword">if</span> (ct &gt; k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k); <span class="keyword">int</span> lst = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]), lst += a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) id[i] = i - <span class="number">1</span>;</span><br><span class="line">random_shuffle(id + <span class="number">1</span>, id + m + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> t = id[i];</span><br><span class="line"><span class="keyword">if</span> (!check(t, lst - <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = lst - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (check(t, mid)) lst = mid, r = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-子集"><a href="#T3-子集" class="headerlink" title="T3 子集"></a>T3 子集</h1><p>显然答案只与$n$分解后每个质因子的指数有关</p><p>也就是说，我们要找到若干个数，使得每个质因子的最小指数是$0$，最大指数是$n$对应的指数</p><p>由于$n\leq 10^{18}$，因此质因子至多只有$15$个</p><p>枚举有哪些质因子的指数没有达到上界，再套一层容斥枚举哪些质因子没有达到下界即可，可以计算出此时能选的数的种数，然后每种数可以选也可以不选</p><p>时间复杂度玄学，理论上来讲是$4$的质因子个数次方，实际上跑得飞快</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RP(i,a,b) for(register int i=a;i&lt;=b;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRP(i,a,b) for(register int i=a;i&gt;=b;--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fre(z) freopen(z<span class="meta-string">".in"</span>,<span class="meta-string">"r"</span>,stdin),freopen(z<span class="meta-string">".out"</span>,<span class="meta-string">"w"</span>,stdout)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lll __int128</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class type_name&gt; <span class="keyword">inline</span> type_name <span class="title">qr</span><span class="params">(type_name sample)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    type_name ret=<span class="number">0</span>,sgn=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> cur=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(cur))</span><br><span class="line">        sgn=(cur==<span class="string">'-'</span>?<span class="number">-1</span>:<span class="number">1</span>),cur=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(cur))</span><br><span class="line">        ret=(ret&lt;&lt;<span class="number">1</span>)+(ret&lt;&lt;<span class="number">3</span>)+cur-<span class="string">'0'</span>,cur=getchar();</span><br><span class="line">    <span class="keyword">return</span> sgn==<span class="number">-1</span>?-ret:ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll max_factor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qp</span><span class="params">(ll x,ll p,ll mod = <span class="number">998244353</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p&amp;<span class="number">1</span>)</span><br><span class="line">            ans=(lll)ans*x%mod;</span><br><span class="line">        x=(lll)x*x%mod;</span><br><span class="line">        p&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">mr</span><span class="params">(ll x,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll k=x<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        ll cur=qp(b,k,x);</span><br><span class="line">        <span class="keyword">if</span>(cur!=<span class="number">1</span> &amp;&amp; cur!=x<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>((k&amp;<span class="number">1</span>)==<span class="number">1</span> || cur==x<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">prime</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">46856248255981l</span>l || x&lt;<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">2</span> || x==<span class="number">3</span> || x==<span class="number">7</span> || x==<span class="number">61</span> || x==<span class="number">24251</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> mr(x,<span class="number">2</span>)&amp;&amp;mr(x,<span class="number">61</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">f</span><span class="params">(ll x,ll c,ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((lll)x*x+c)%n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">PR</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll s=<span class="number">0</span>,t=<span class="number">0</span>,c=<span class="number">1l</span>l*rand()%(x<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> stp=<span class="number">0</span>,goal=<span class="number">1</span>;</span><br><span class="line">    ll val=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(goal=<span class="number">1</span>;;goal&lt;&lt;=<span class="number">1</span>,s=t,val=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(stp=<span class="number">1</span>;stp&lt;=goal;++stp)</span><br><span class="line">        &#123;</span><br><span class="line">            t=f(t,c,x);</span><br><span class="line">            val=(lll)val*<span class="built_in">abs</span>(t-s)%x;</span><br><span class="line">            <span class="keyword">if</span>((stp%<span class="number">127</span>)==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ll d=gcd(val,x);</span><br><span class="line">                <span class="keyword">if</span>(d&gt;<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll d=gcd(val,x);</span><br><span class="line">        <span class="keyword">if</span>(d&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fac</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=max_factor || x&lt;<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(prime(x))</span><br><span class="line">    &#123;</span><br><span class="line">        max_factor=max_factor&gt;x?max_factor:x;</span><br><span class="line">        <span class="keyword">return</span>;     </span><br><span class="line">    &#125;</span><br><span class="line">    ll p=x;</span><br><span class="line">    <span class="keyword">while</span>(p&gt;=x)</span><br><span class="line">        p=PR(x);</span><br><span class="line">    <span class="keyword">while</span>((x%p)==<span class="number">0</span>)</span><br><span class="line">        x/=p;</span><br><span class="line">    fac(x),fac(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">20</span>], top, tmp[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;ULL, <span class="keyword">int</span>&gt; dp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Just_DOIT</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= top; i++)</span><br><span class="line">tmp[i] = cnt[i] - !!(s &amp; (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>));</span><br><span class="line">sort(tmp + <span class="number">1</span>, tmp + top + <span class="number">1</span>);</span><br><span class="line">ULL nw = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= top; i++) nw = nw * <span class="number">131</span> + tmp[i] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (dp.count(nw)) <span class="keyword">return</span> dp[nw];</span><br><span class="line"><span class="keyword">int</span> all = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= top; i++) <span class="keyword">if</span> (tmp[i])</span><br><span class="line">all |= <span class="number">1</span> &lt;&lt; i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s1 = all; ; s1 = (s1 - <span class="number">1</span>) &amp; all) &#123;</span><br><span class="line">LL sum = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= top; i++)</span><br><span class="line">sum = sum * (tmp[i] + <span class="number">1</span> - !!(s1 &amp; (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)));</span><br><span class="line">sum = qp(<span class="number">2</span>, sum) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (__builtin_popcount(s1) &amp; <span class="number">1</span>) res = (res - sum + mod) % mod;</span><br><span class="line"><span class="keyword">else</span> res = (res + sum) % mod;</span><br><span class="line"><span class="keyword">if</span> (!s1) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[nw] = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">srand((<span class="keyword">long</span> <span class="keyword">long</span>)<span class="keyword">new</span> <span class="keyword">char</span>);</span><br><span class="line">LL n; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"1"</span>), <span class="number">0</span>;</span><br><span class="line">fac(n), top = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (n % max_factor == <span class="number">0</span>) n /= max_factor, cnt[top]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++) <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">top++;</span><br><span class="line"><span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i, cnt[top]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n != <span class="number">1</span>) cnt[++top] = <span class="number">1</span>;</span><br><span class="line">sort(cnt + <span class="number">1</span>, cnt + top + <span class="number">1</span>); <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">1</span> &lt;&lt; top; s++) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp = Just_DOIT(s);</span><br><span class="line"><span class="keyword">if</span> (__builtin_popcount(s) &amp; <span class="number">1</span>) res = (res - tmp + mod) % mod;</span><br><span class="line"><span class="keyword">else</span> res = (res + tmp) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (res + mod) % mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有：<strong>千万不要使用博客园的板子！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容斥 </tag>
            
            <tag> Pollard Rho </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP赛前集训day1</title>
      <link href="/2019/10/17/CSP%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%ADday1/"/>
      <url>/2019/10/17/CSP%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%ADday1/</url>
      
        <content type="html"><![CDATA[<div class="pdfobject-container" data-target="problems.pdf" data-height="500px"></div><h1 id="T1-序列"><a href="#T1-序列" class="headerlink" title="T1 序列"></a>T1 序列</h1><p>首先奇数和偶数是相互独立的</p><p>如果不考虑字典序，那么显然有一种花费代价最小的方式就是对应匹配</p><p>如果$i$的匹配位置是$p_i$，我们将$i$向$p_i$连一条边，我们称两个相交的区间“联通”，那么显然每个连通块中，$p_i$与$i$的关系是确定好了的，我们可以分开统计</p><p><img src="1571316485395.png" alt="1571316485395"></p><p>观察图中的情况，由于第三个位置匹配到了前面的待匹配位置，因此这种匹配方法非常不优秀</p><p>我们可以得出一个结论：对于一个连通块，如果要使得它的答案不变，那么每个位置只能匹配到它后面第一个待匹配位置之后的位置。也就是说，每个起始位置能选择的匹配位置是一段连续的后缀</p><p>由于是后缀，我们就可以用优先队列维护当前可以选择的起始位置，贪心地放最小的就行了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[N], n, p[N], at[N], appear[N], num[N], ok[N], ans[N], <span class="keyword">final</span>[<span class="number">2</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s; priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">if</span> (t) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt;= l; i--) &#123;</span><br><span class="line">s.insert(p[i]);</span><br><span class="line"><span class="keyword">while</span> (*s.rbegin() &gt; at[i]) s.erase(*s.rbegin());</span><br><span class="line">appear[i] = *s.rbegin();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = r, cur = r; i &gt;= l; i--) &#123;</span><br><span class="line"><span class="keyword">while</span> (cur &gt;= l &amp;&amp; appear[cur] &gt;= p[i]) q.push(num[at[cur]]), cur--;</span><br><span class="line">ok[i] = q.top(), q.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">s.insert(p[i]);</span><br><span class="line"><span class="keyword">while</span> (*s.begin() &lt; at[i]) s.erase(s.begin());</span><br><span class="line">appear[i] = *s.begin();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l, cur = l; i &lt;= r; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (cur &lt;= r &amp;&amp; appear[cur] &lt;= p[i]) q.push(-num[at[cur]]), cur++;</span><br><span class="line">ok[i] = -q.top(), q.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">solve</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ct = <span class="number">0</span>; LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (A[i]) </span><br><span class="line">ct++, p[ct] = <span class="number">2</span> * ct - <span class="number">1</span> + type, at[ct] = i, res += <span class="built_in">abs</span>(p[ct] - at[ct]);</span><br><span class="line"><span class="keyword">if</span> (p[ct] &gt; n) <span class="keyword">return</span> <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, r; i &lt;= ct; i = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = i;</span><br><span class="line"><span class="keyword">if</span> (at[i] == p[i]) &#123;</span><br><span class="line">ans[at[i]] = num[at[i]]; <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t = p[i] &lt; at[i];</span><br><span class="line"><span class="keyword">while</span> (r &lt; ct &amp;&amp; at[r + <span class="number">1</span>] != p[r + <span class="number">1</span>] &amp;&amp; t == (p[r + <span class="number">1</span>] &lt; at[r + <span class="number">1</span>])) r++;</span><br><span class="line">work(i, r, t);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= r; j++) ans[p[j]] = ok[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Just_DOIT</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) A[i] = num[i] &amp; <span class="number">1</span>;</span><br><span class="line">res += solve(type);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) A[i] ^= <span class="number">1</span>;</span><br><span class="line">res += solve(type ^ <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">LL t1 = Just_DOIT(<span class="number">0</span>); <span class="built_in">memcpy</span>(<span class="keyword">final</span>[<span class="number">0</span>], ans, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">LL t2 = Just_DOIT(<span class="number">1</span>); <span class="built_in">memcpy</span>(<span class="keyword">final</span>[<span class="number">1</span>], ans, <span class="keyword">sizeof</span>(ans));</span><br><span class="line"><span class="keyword">int</span> flg = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (<span class="keyword">final</span>[<span class="number">1</span>][i] != <span class="keyword">final</span>[<span class="number">0</span>][i]) &#123;</span><br><span class="line">flg = <span class="keyword">final</span>[<span class="number">1</span>][i] &lt; <span class="keyword">final</span>[<span class="number">0</span>][i]; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (t1 &gt; t2 || (t1 == t2 &amp;&amp; flg)) swap(<span class="keyword">final</span>[<span class="number">0</span>], <span class="keyword">final</span>[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, <span class="keyword">final</span>[<span class="number">0</span>][i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-灯泡"><a href="#T2-灯泡" class="headerlink" title="T2 灯泡"></a>T2 灯泡</h1><p>由于答案统计的是有多少极长的亮灯区间，因此我们可以想到将原数组差分，显然最后差分数组中$1$的个数除以$2$向上取整就是答案</p><p>同样，我们可以将每个集合转成差分数组，问题转化为给你$n$个集合，每个集合有一些位置，每次操作可以选一个集合，将它包含的所有位置异或$1$，求序列中$1$的个数</p><p>这个信息很不好维护，因此可以考虑分块。将集合按照大小分成两类，大于$\sqrt n$为一类，否则为另一类。对于每个小集合，我们可以直接暴力更新。对于大集合，我们维护每两个大集合的交中$1/0$的个数、每个大集合中$1/0$的个数。更新大集合的时候就暴力枚举另一个大集合，将这两个信息取反并更新另一个大集合中$1$的个数就可以了</p><p>这个做法常数不是很优秀，需要卡一下常才能过</p><p><code>vector</code>是真的慢</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>, M = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> val[M][M][<span class="number">2</span>], cnt[M][<span class="number">2</span>], num[N], col[N], ct[N], tag[M], id[N], big[N], st, cover[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar();</span><br><span class="line"><span class="keyword">while</span> (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, q, k; read(n), read(q), read(k); <span class="keyword">int</span> sz = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">read(col[i]), ct[col[i]]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, r; i &lt;= n; i = r + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> c = col[i]; r = i;</span><br><span class="line"><span class="keyword">while</span> (r &lt; n &amp;&amp; col[r + <span class="number">1</span>] == c) r++;</span><br><span class="line">pos[c].push_back(i);</span><br><span class="line"><span class="keyword">if</span> (r &lt; n) pos[c].push_back(r + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ncnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) <span class="keyword">if</span> (ct[i] &gt;= sz) &#123;</span><br><span class="line">id[i] = ++ncnt, big[++st] = ncnt;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pos[i].size(); j++) &#123;</span><br><span class="line"><span class="keyword">int</span> v = pos[i][j];</span><br><span class="line"><span class="keyword">if</span> (!cover[v][<span class="number">0</span>]) cover[v][<span class="number">0</span>] = ncnt;</span><br><span class="line"><span class="keyword">else</span> cover[v][<span class="number">1</span>] = ncnt;</span><br><span class="line">cnt[ncnt][<span class="number">0</span>]++; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (cover[i][<span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">int</span> A = cover[i][<span class="number">0</span>], B = cover[i][<span class="number">1</span>];</span><br><span class="line">val[A][B][<span class="number">0</span>]++, val[B][A][<span class="number">0</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (q--) &#123;</span><br><span class="line"><span class="keyword">int</span> a; read(a);</span><br><span class="line"><span class="keyword">if</span> (ct[a] &lt; sz) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos[a].size(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> p = pos[a][i], t = num[p];</span><br><span class="line">t ^= tag[cover[p][<span class="number">0</span>]] ^ tag[cover[p][<span class="number">1</span>]], t ^= <span class="number">1</span>, num[p] ^= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (t) ans++; <span class="keyword">else</span> ans--;</span><br><span class="line"><span class="keyword">if</span> (cover[p][<span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">int</span> A = cover[p][<span class="number">0</span>], B = cover[p][<span class="number">1</span>];</span><br><span class="line">val[A][B][t ^ <span class="number">1</span>]--, val[B][A][t ^ <span class="number">1</span>]--, val[A][B][t]++, val[B][A][t]++;</span><br><span class="line">&#125;</span><br><span class="line">cnt[cover[p][<span class="number">0</span>]][t ^ <span class="number">1</span>]--, cnt[cover[p][<span class="number">0</span>]][t]++;</span><br><span class="line">cnt[cover[p][<span class="number">1</span>]][t ^ <span class="number">1</span>]--, cnt[cover[p][<span class="number">1</span>]][t]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">a = id[a], tag[a] ^= <span class="number">1</span>, ans -= cnt[a][<span class="number">1</span>], ans += cnt[a][<span class="number">0</span>], swap(cnt[a][<span class="number">1</span>], cnt[a][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t; i &lt;= st; i++) <span class="keyword">if</span> ((t = big[i]) != a) &#123;</span><br><span class="line">cnt[t][<span class="number">0</span>] = cnt[t][<span class="number">0</span>] - val[a][t][<span class="number">0</span>] + val[a][t][<span class="number">1</span>];</span><br><span class="line">cnt[t][<span class="number">1</span>] = cnt[t][<span class="number">1</span>] - val[a][t][<span class="number">1</span>] + val[a][t][<span class="number">0</span>]; </span><br><span class="line">swap(val[a][t][<span class="number">0</span>], val[a][t][<span class="number">1</span>]);</span><br><span class="line">swap(val[t][a][<span class="number">0</span>], val[t][a][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (ans + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-比赛"><a href="#T3-比赛" class="headerlink" title="T3 比赛"></a>T3 比赛</h1><p>以前纪中考过的原题</p><p>先考虑暴力$dp$</p><p>有两种$dp$方式：一种是编号从大到小$dp$，另一种是编号从小到大$dp$</p><p>记$dp[i][j]$表示考虑了$i$个人，可以给$j$个选手颁奖的概率</p><p>对于第一种方式，显然有</p><script type="math/tex; mode=display">dp[i][j]=dp[i-1][j-1]*p^{i-j}+dp[i-1][j]*(1-p)^j</script><p>对于第二种方式，显然有</p><script type="math/tex; mode=display">dp[i][j]=dp[i-1][j-1]*(1-p)^{i-j}+dp[i-1][j]*p^j</script><p>根据$dp$的定义，这两种方法求出来的$dp$值应当是相同的</p><p>所以</p><script type="math/tex; mode=display">dp[i-1][j-1]*p^{i-j}+dp[i-1][j]*(1-p)^j=dp[i-1][j-1]*(1-p)^{i-j}+dp[i-1][j]*p^j\\dp[i][j]*[(1-p)^j-p^j]=dp[i][j-1]*[(1-p)^{i-j+1}-p^{i-j+1}]</script><p>然后就可以$O(n)$递推了</p><p>注意当$p=1/2$的时候这个递推会除以$0$，需要特判</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> val[N], A[N], B[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, p; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), p = (LL)a * Pow(b, mod - <span class="number">2</span>) % mod;</span><br><span class="line"><span class="keyword">if</span> (p == (mod + <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">inv[n] = Pow(frac[n], mod - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) inv[i] = (LL)inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">val[i] = (LL)C(n, i) * Pow(Pow(p, n - i), i) % mod;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">A[<span class="number">0</span>] = B[<span class="number">0</span>] = <span class="number">1</span>, A[<span class="number">1</span>] = p, B[<span class="number">1</span>] = (mod + <span class="number">1</span> - p) % mod;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) </span><br><span class="line">A[i] = (LL)A[i - <span class="number">1</span>] * A[<span class="number">1</span>] % mod, B[i] = (LL)B[i - <span class="number">1</span>] * B[<span class="number">1</span>] % mod;</span><br><span class="line">val[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">val[i] = (LL)val[i - <span class="number">1</span>] * (A[n - i + <span class="number">1</span>] - B[n - i + <span class="number">1</span>] + mod) % mod * Pow((A[i] - B[i] + mod) % mod, mod - <span class="number">2</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line">f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) f[i] = (LL)f[i - <span class="number">1</span>] * f[i - <span class="number">1</span>] % mod + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">res = (res + (LL)val[i] * f[i]) % mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次比赛本来有希望拿满分，但是最后一道题由于没有特判$p=0$的情况导致输出了负数，又由于子任务依赖所以爆零了；倒数第二题由于一个细节错误也丢了很多分。看来我还是很不稳，需要加油</p>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.12停课集训</title>
      <link href="/2019/10/12/10-12%E5%81%9C%E8%AF%BE%E9%9B%86%E8%AE%AD/"/>
      <url>/2019/10/12/10-12%E5%81%9C%E8%AF%BE%E9%9B%86%E8%AE%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-数值修改"><a href="#T1-数值修改" class="headerlink" title="T1 数值修改"></a>T1 数值修改</h1><p><img src="1570885585398.png" alt="1570885585398"></p><p><img src="1570885609849.png" alt="1570885609849"></p><p>一道很奇妙的题</p><p>通过观察和打表可以发现，最优的方案一定是每次减去最大的那一位</p><p>因此对于$30\%$的分数，直接模拟即可</p><p>对于$60\%$的数据，我们将这个数分成前一半和后一半，即前$6$位和后$6$位</p><p>注意到前$6$位只会被修改$\sqrt n$次，因此我们可以模拟前$6$位的修改</p><p>对于后$6$位，考虑前$6$位对它的影响，这个影响只与前$6$位的最大值有关</p><p>我们可以记$f[i][j]$表示前$6$位的最大值为$6$，后$6$位为$j$时至少需要多少步才能让后$6$位变成负数，同时记录一下此时的个位是多少</p><p>对于$100\%$的数据，我们使用同样的思路。注意到前面$f$的状态中$j$在被清空一次之后，只有最后一位需要考虑，前面的位都是$9$</p><p>因此我们可以设$f[i][j][k]$表示只考虑后$i$位，其中前$i-1$位全部为$9$，最后一位为$j$，并且这$i$位之前的最大值为$k$时，最少需要多少步才能减成负数，同时记录一下此时最后一位变成了多少，记为$g[i][j][k]$</p><p>转移的时候这样考虑：</p><script type="math/tex; mode=display">\begin{aligned}9&|99\cdots9x\\8&|99\cdots9x'\\7&|99\cdots9x''\\&\cdots\\0&|99\cdots9x'''\Rightarrow f[i-1][x'''][k]\end{aligned}</script><p>怎么统计答案呢？同样是模拟这个过程，我们从低位到高位依次考虑</p><p>将当前这一位后面的所有位全部减成负数之后，当前这一位后面就变成了$x999\cdots 9y$的形式，直接使用$f$的值，并更新此时的$y$，同时模拟退位</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>, M = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">LL f[N][M][M], g[N][M][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Just_DOIT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) f[<span class="number">1</span>][i][j] = <span class="number">2</span>, g[<span class="number">1</span>][i][j] = <span class="number">10</span> - j;</span><br><span class="line">            <span class="keyword">else</span> f[<span class="number">1</span>][i][j] = <span class="number">1</span>, g[<span class="number">1</span>][i][j] = <span class="number">10</span> + i - j;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">9</span>; k++) &#123;</span><br><span class="line">                g[i][j][k] = j;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> fir = <span class="number">9</span>; fir &gt;= <span class="number">0</span>; fir--) &#123;</span><br><span class="line">                    f[i][j][k] += f[i - <span class="number">1</span>][g[i][j][k]][max(fir, k)];</span><br><span class="line">                    g[i][j][k] = g[i - <span class="number">1</span>][g[i][j][k]][max(fir, k)];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> len, num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Make_YourDream_COMETRUE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>, ls = num[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= len; j++) mx = max(mx, num[j]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = num[i]; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = max(mx, j);</span><br><span class="line">            res += f[i - <span class="number">1</span>][ls][tmp], ls = g[i - <span class="number">1</span>][ls][tmp];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i != len) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (cur &lt;= len &amp;&amp; num[cur] == <span class="number">0</span>) num[cur] = <span class="number">9</span>, cur++;</span><br><span class="line">            num[cur]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL n; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">sprintf</span>(s + <span class="number">1</span>, <span class="string">"%lld"</span>, n), len = <span class="built_in">strlen</span>(s + <span class="number">1</span>), reverse(s + <span class="number">1</span>, s + len + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) num[i] = s[i] - <span class="string">'0'</span>;</span><br><span class="line">    Just_DOIT(), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Make_YourDream_COMETRUE());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-覆盖"><a href="#T2-覆盖" class="headerlink" title="T2 覆盖"></a>T2 覆盖</h1><p><img src="1570886546321.png" alt="1570886546321"></p><p><img src="1570886557274.png" alt="1570886557274"></p><p>很久以前，<code>lyc</code>曾经胡过这道题</p><p>比较简单</p><p>对于每条路径，考虑有多少条路径覆盖了它</p><p>我们假设这条路径的两个端点分别为$u,v$，并且$u,v$不为祖先关系</p><p>那么一条覆盖它的路径$a,b$，一定是$a$落在$u$的子树中，并且$b$落在$v$的子树中</p><p>这对应着一个矩形，因此我们只需要支持单点加，矩形查就可以了，可以扫描线或者主席树</p><p>如果$u,v$存在祖先关系，实际上还是对应矩形查询</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lson[N * <span class="number">80</span>], rson[N * <span class="number">80</span>], sum[N * <span class="number">80</span>], ncnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    ncnt++; <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ncnt;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">return</span> build(l, mid), build(mid + <span class="number">1</span>, r), ncnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> at)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nw = ++ncnt; </span><br><span class="line">    lson[nw] = lson[rt], rson[nw] = rson[rt], sum[nw] = sum[rt] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ncnt;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">if</span> (at &lt;= mid) lson[nw] = update(lson[nw], l, mid, at);</span><br><span class="line">    <span class="keyword">else</span> rson[nw] = update(rson[nw], mid + <span class="number">1</span>, r, at);</span><br><span class="line">    <span class="keyword">return</span> nw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt1, <span class="keyword">int</span> rt2, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> sum[rt2] - sum[rt1];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) res += query(lson[rt1], lson[rt2], l, mid, start, end);</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) res += query(rson[rt1], rson[rt2], mid + <span class="number">1</span>, r, start, end);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[N], ed[N], dfsn, fa[N][<span class="number">18</span>], dep[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    dfn[u] = ++dfsn, fa[u][<span class="number">0</span>] = f, dep[u] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">17</span>; i++) fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u);</span><br><span class="line">    ed[u] = dfsn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[a] &lt; dep[b]) swap(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (dep[fa[a][i]] &gt;= dep[b]) a = fa[a][i];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i];</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> from[N], to[N], RT[N], tree[N], n; </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hh[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (dep[fa[a][i]] &gt; dep[b]) a = fa[a][i];</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += x &amp; -x) tree[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">que</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= x &amp; -x) res += tree[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;P, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span> </span>&#123;<span class="keyword">return</span> b ? gcd(b, a % b) : a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen("painting.in", "r", stdin), freopen("painting.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">int</span> q; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>), RT[<span class="number">0</span>] = build(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;from[i], &amp;to[i]);</span><br><span class="line">        <span class="keyword">if</span> (from[i] &gt; to[i]) swap(from[i], to[i]);</span><br><span class="line">        mp[P(from[i], to[i])]++;</span><br><span class="line">        hh[dfn[from[i]]].push_back(dfn[to[i]]);</span><br><span class="line">        <span class="keyword">int</span> lca = LCA(from[i], to[i]);</span><br><span class="line">        upd(dfn[from[i]], <span class="number">1</span>), upd(dfn[to[i]], <span class="number">1</span>), upd(dfn[lca], <span class="number">-1</span>), upd(dfn[fa[lca][<span class="number">0</span>]], <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        RT[i] = RT[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y : hh[i]) RT[i] = update(RT[i], <span class="number">1</span>, n, y);</span><br><span class="line">    &#125;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = from[i], b = to[i];</span><br><span class="line">        <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">            res += que(to[a]) - que(dfn[a] - <span class="number">1</span>), res--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dep[a] &lt; dep[b]) swap(a, b);</span><br><span class="line">        <span class="keyword">if</span> (LCA(a, b) == b) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = jump(a, b);</span><br><span class="line">            res += query(RT[dfn[a] - <span class="number">1</span>], RT[ed[a]], <span class="number">1</span>, n, <span class="number">1</span>, n)</span><br><span class="line">                - query(RT[dfn[a] - <span class="number">1</span>], RT[ed[a]], <span class="number">1</span>, n, dfn[t], ed[t]);</span><br><span class="line">            res += query(RT[<span class="number">0</span>], RT[n], <span class="number">1</span>, n, dfn[a], ed[a]) </span><br><span class="line">                - query(RT[dfn[t] - <span class="number">1</span>], RT[ed[t]], <span class="number">1</span>, n, dfn[a], ed[a]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res += query(RT[dfn[a] - <span class="number">1</span>], RT[ed[a]], <span class="number">1</span>, n, dfn[b], ed[b])</span><br><span class="line">                + query(RT[dfn[b] - <span class="number">1</span>], RT[ed[b]], <span class="number">1</span>, n, dfn[a], ed[a]);</span><br><span class="line">        &#125;</span><br><span class="line">        res--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : mp) res -= (LL)v.second * (v.second - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    LL res2 = (LL)q * (q - <span class="number">1</span>) / <span class="number">2</span>, g = gcd(res, res2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld/%lld"</span>, res / g, res2 / g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-机器人"><a href="#T3-机器人" class="headerlink" title="T3 机器人"></a>T3 机器人</h1><p><img src="1570886808887.png" alt="1570886808887"></p><p><img src="1570886819306.png" alt="1570886819306"></p><p><img src="1570886827528.png" alt="1570886827528"></p><p>题目等价于给$n$条直线，每条直线有一个出现时间的区间，多次询问某个时刻所有直线的$y$的最大值/最小值</p><p>由于时限有$9s$，我的做法是直接对询问分块，每个块跑一遍斜率优化</p><p>听说是李超线段树板题</p><p>题解给的做法如下</p><div class="pdfobject-container" data-target="day7_solution.pdf" data-height="500px"></div><p>分块代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">600010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">    LL b, k; <span class="keyword">int</span> st, ed;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Line &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> st &lt; b.st;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; l1[N * <span class="number">2</span>], q1[N * <span class="number">2</span>], hh[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">LL x[N], y[N], ls[N], T[N], ans[N]; <span class="keyword">char</span> s[<span class="number">20</span>]; <span class="keyword">int</span> tot;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; add[N], del[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">calc</span><span class="params">(Line a, Line b, Line c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (c.b - a.b) * (a.k - b.k) &lt;= (b.b - a.b) * (a.k - c.k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Abs</span><span class="params">(<span class="keyword">const</span> LL &amp;x)</span> </span>&#123;<span class="keyword">return</span> x &gt; <span class="number">0</span> ? x : -x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">int</span> flg = <span class="number">1</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'-'</span>) flg = <span class="number">-1</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">    x *= flg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen("robot10.in", "r", stdin), freopen("robot.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n, q; read(n), read(q), <span class="built_in">memset</span>(T, <span class="number">-1</span>, <span class="keyword">sizeof</span>(T));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(x[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t; read(t), <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">'c'</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b; read(a), read(b);</span><br><span class="line">            l1[++tot] = (Line)&#123;x[a], y[a], ls[a], i - <span class="number">1</span>&#125;;</span><br><span class="line">            x[a] = x[a] + t * y[a], y[a] = b, x[a] -= (LL)t * b, ls[a] = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> T[i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) l1[++tot] = (Line)&#123;x[i], y[i], ls[i], q&#125;;</span><br><span class="line">    sort(l1 + <span class="number">1</span>, l1 + tot + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) add[l1[i].st].push_back(i), del[l1[i].ed + <span class="number">1</span>].push_back(i);</span><br><span class="line">    <span class="keyword">int</span> SZ = <span class="built_in">sqrt</span>(q) * <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r = l + SZ; l &lt;= q; l += SZ + <span class="number">1</span>, r += SZ + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ct1 = <span class="number">0</span>; r = min(r, q);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot &amp;&amp; l1[i].st &lt; l; i++) <span class="keyword">if</span> (l1[i].ed &gt;= r) q1[++ct1] = l1[i];</span><br><span class="line">        sort(q1 + <span class="number">1</span>, q1 + ct1 + <span class="number">1</span>, [](<span class="keyword">const</span> Line &amp;a, <span class="keyword">const</span> Line &amp;b)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a.k != b.k) <span class="keyword">return</span> a.k &lt; b.k;</span><br><span class="line">            <span class="keyword">return</span> a.b &gt; b.b;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">1</span>, tail = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ct1; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">1</span> &amp;&amp; q1[i].k == q1[i - <span class="number">1</span>].k) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (head &lt; tail &amp;&amp; calc(hh[tail - <span class="number">1</span>], hh[tail], q1[i])) tail--;</span><br><span class="line">            hh[++tail] = q1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) <span class="keyword">if</span> (~T[i]) &#123;</span><br><span class="line">            <span class="keyword">while</span> (head &lt; tail &amp;&amp; hh[head].b + hh[head].k * T[i] &lt;= hh[head + <span class="number">1</span>].b + hh[head + <span class="number">1</span>].k * T[i]) head++;</span><br><span class="line">            <span class="keyword">if</span> (head &lt;= tail) ans[i] = Abs(hh[head].b + hh[head].k * T[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(q1 + <span class="number">1</span>, q1 + ct1 + <span class="number">1</span>, [](<span class="keyword">const</span> Line &amp;a, <span class="keyword">const</span> Line &amp;b)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a.k != b.k) <span class="keyword">return</span> a.k &gt; b.k;</span><br><span class="line">            <span class="keyword">return</span> a.b &lt; b.b;</span><br><span class="line">        &#125;);</span><br><span class="line">        head = <span class="number">1</span>, tail = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ct1; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">1</span> &amp;&amp; q1[i].k == q1[i - <span class="number">1</span>].k) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (head &lt; tail &amp;&amp; calc(hh[tail - <span class="number">1</span>], hh[tail], q1[i])) tail--;</span><br><span class="line">            hh[++tail] = q1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) <span class="keyword">if</span> (~T[i]) &#123;</span><br><span class="line">            <span class="keyword">while</span> (head &lt; tail &amp;&amp; hh[head].b + hh[head].k * T[i] &gt;= hh[head + <span class="number">1</span>].b + hh[head + <span class="number">1</span>].k * T[i]) head++;</span><br><span class="line">            <span class="keyword">if</span> (head &lt;= tail) ans[i] = max(ans[i], Abs(hh[head].b + hh[head].k * T[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : add[i]) <span class="keyword">if</span> (l1[v].ed &lt; r) s.insert(v);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : del[i]) s.erase(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (add[i].size()) <span class="keyword">for</span> (<span class="keyword">auto</span> v : add[i]) s.insert(v);</span><br><span class="line">            <span class="keyword">if</span> (del[i].size()) <span class="keyword">for</span> (<span class="keyword">auto</span> v : del[i]) s.erase(v);</span><br><span class="line">            <span class="keyword">if</span> (~T[i]) <span class="keyword">for</span> (<span class="keyword">auto</span> v : s) ans[i] = max(ans[i], Abs(l1[v].b + l1[v].k * T[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) <span class="keyword">if</span> (~T[i]) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 斜率优化 </tag>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018集训队作业1</title>
      <link href="/2019/10/05/2018%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A1/"/>
      <url>/2019/10/05/2018%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A1/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-AGC014D-Black-and-White-Tree"><a href="#T1-AGC014D-Black-and-White-Tree" class="headerlink" title="T1 AGC014D Black and White Tree"></a>T1 AGC014D Black and White Tree</h1><p>比较简单的一个题</p><p>首先有一个结论：如果这棵树存在完美匹配，那么后手胜，否则先手胜</p><p>如果有完美匹配，那么先手每选一个点，后手就能选择跟它匹配的那个点，这样无论如何每个点都会与一个黑色点相邻，因此后手必胜</p><p>如果没有完美匹配，那么先手每次可以选择一个叶子节点的父亲染白，这样后手就必须染叶子。此时先手可以删除这两个点，对结果没有影响，最后一定会留下若干个只有一个点的连通块，先手就赢了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt, mark[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    mark[u] = <span class="number">1</span>; <span class="keyword">int</span> ct = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u), ct += mark[e[i].to];</span><br><span class="line">    <span class="keyword">if</span> (ct &gt; <span class="number">1</span> || (u == <span class="number">1</span> &amp;&amp; ct == <span class="number">0</span>)) <span class="built_in">puts</span>(<span class="string">"First"</span>), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ct == <span class="number">1</span>) mark[u] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">puts</span>(<span class="string">"Second"</span>);</span><br><span class="line">&#125;<span class="comment">//</span></span><br></pre></td></tr></table></figure><h1 id="T2-AGC012F-Prefix-Median"><a href="#T2-AGC012F-Prefix-Median" class="headerlink" title="T2 AGC012F Prefix Median"></a>T2 AGC012F Prefix Median</h1><p>首先$b_n$是已经确定好了的，一定是$a$序列的中位数</p><p>由于$a$的顺序无关紧要，因此我们可以先将$a$排好序</p><p>考虑$b_{n+1}$与$b_{n}$的大小关系</p><p>$b_n$是$2n-1$个数的中位数，而$b_{n+1}$是$2n+1$个数的中位数，多了两个数</p><p>因此如果我们从右往左考虑$b$，那么$b_n$与$b_{n+1}$的排名至多相差$1$</p><p>所以有$a_i\leq b_i\leq a_{2n-i}$</p><p>这也就意味着，对于任意的$i$，不存在$j<i$使得$b_i<b_j<b_{i+1}$或$b_i>b_j&gt;b_{i+1}$</p><p>因此我们可以设计一个$dp$状态：$dp[i][j][k]$表示当前已经填好了$b_i-b_n$，在当前$b$可以取的集合中，有$j$个数$\leq b_i$，有$k$个数$&gt;b_i$</p><p>转移的时候枚举当前数的排名就行了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">60</span>;</span><br><span class="line"><span class="keyword">int</span> a[N * <span class="number">2</span>], dp[N][N * <span class="number">2</span>][N * <span class="number">2</span>]; <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;x += y, x -= x &gt;= mod ? mod : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, res = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n - <span class="number">1</span>; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    sort(a + <span class="number">1</span>, a + <span class="number">2</span> * n), dp[n][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> tl = a[i] != a[i + <span class="number">1</span>], tr = a[<span class="number">2</span> * n - i - <span class="number">1</span>] != a[<span class="number">2</span> * n - i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span> * n - <span class="number">1</span>; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; j + k &lt;= <span class="number">2</span> * n - <span class="number">1</span>; k++) <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j][k]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= tl + j; t++) </span><br><span class="line">                    Inc(dp[i][j + tl - (t - <span class="number">1</span>)][k + tr + (t != <span class="number">1</span>)], dp[i + <span class="number">1</span>][j][k]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= tr + k; t++)</span><br><span class="line">                    Inc(dp[i][j + tl + <span class="number">1</span>][k + tr - t], dp[i + <span class="number">1</span>][j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span> * n - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; i + j &lt;= <span class="number">2</span> * n - <span class="number">1</span>; j++) Inc(res, dp[<span class="number">1</span>][i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10.1三地联考</title>
      <link href="/2019/10/02/10-1%E4%B8%89%E5%9C%B0%E8%81%94%E8%80%83/"/>
      <url>/2019/10/02/10-1%E4%B8%89%E5%9C%B0%E8%81%94%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-幸福"><a href="#T1-幸福" class="headerlink" title="T1 幸福"></a>T1 幸福</h1><p><img src="1569979426788.png" alt="1569979426788"></p><p><img src="1569979450222.png" alt="1569979450222"></p><p>将那个卷积的式子写出来，然后这题就完了。。。</p><script type="math/tex; mode=display">\begin{aligned}F_n&=f_0f_n+f_1f_{n-1}+f_2f_{n-2}+\cdots\\F_{n-1}&=\quad\quad\quad f_0f_{n-1}+f_{1}f_{n-2}+\cdots\\F_n-F_{n-1}&=f_0f_n+\quad\quad\quad \quad f_0f_{n-2}+f_1f_{n-3}+\cdots\\&=f_n+F_{n-2}\\F_n&=F_{n-1}+F_{n-2}+f_n\end{aligned}</script><p>写成矩阵的形式就是</p><script type="math/tex; mode=display">\begin{bmatrix}1&1&1&1&0\\1&0&0&0&0\\0&0&1&1&0\\0&0&1&0&0\\1&1&1&1&1\end{bmatrix}^{n-1}\begin{bmatrix}F_1\\F_0\\f_1\\f_0\\S_1\end{bmatrix}=\begin{bmatrix}F_n\\F_{n-1}\\f_n\\f_{n-1}\\S_n\end{bmatrix}</script><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;x += y, x -= x &gt;= mod ? mod : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">    Matrix() &#123;<span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));&#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp;b) &#123;</span><br><span class="line">        Matrix res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">5</span>; k++) <span class="keyword">if</span> (a[i][k])</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">                    Inc(res.a[i][j], (LL)a[i][k] * b.a[k][j] % mod);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Matrix <span class="title">Pow</span><span class="params">(Matrix x, LL y)</span> </span>&#123;</span><br><span class="line">    Matrix res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) res.a[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = x * x) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = res * x;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp[] = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Matrix base; base.a[<span class="number">0</span>][<span class="number">0</span>] = base.a[<span class="number">0</span>][<span class="number">1</span>] = base.a[<span class="number">0</span>][<span class="number">2</span>] = base.a[<span class="number">0</span>][<span class="number">3</span>] = base.a[<span class="number">1</span>][<span class="number">0</span>] = base.a[<span class="number">2</span>][<span class="number">2</span>] = base.a[<span class="number">2</span>][<span class="number">3</span>] = base.a[<span class="number">3</span>][<span class="number">2</span>] = base.a[<span class="number">4</span>][<span class="number">0</span>] = base.a[<span class="number">4</span>][<span class="number">1</span>] = base.a[<span class="number">4</span>][<span class="number">2</span>] = base.a[<span class="number">4</span>][<span class="number">3</span>] = base.a[<span class="number">4</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">    LL n; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n), base = Pow(base, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) Inc(res, (LL)base.a[<span class="number">4</span>][i] * tmp[i] % mod);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-树链剖分"><a href="#T2-树链剖分" class="headerlink" title="T2 树链剖分"></a>T2 树链剖分</h1><p><img src="1569979918027.png" alt="1569979918027"></p><p><img src="1569979928689.png" alt="1569979928689"></p><p>比较简单的一道题</p><p>首先可以通过树上差分算出每条边被覆盖了多少次，问题就可以转化为在确定根的情况下，每个点不选一条连向儿子的边，使得总边权最小。等价于每个点选择一条来自儿子的最长的边</p><p>先求出以$1$号节点为根的答案，对于每个点维护到子树以及到全树的最大/次大边权，<code>dfs</code>两次就可以了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to, next;&#125; e[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt, dep[N], fa[N][<span class="number">18</span>], sum[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = f, dep[u] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">17</span>; i++) fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[a] &lt; dep[b]) swap(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (dep[fa[a][i]] &gt;= dep[b]) a = fa[a][i];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>; i &gt;= <span class="number">0</span>; i--) <span class="keyword">if</span> (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i];</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;sum[u]++, sum[v]++, sum[LCA(u, v)] -= <span class="number">2</span>;&#125;</span><br><span class="line">LL dp[N], mx[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) &#123;</span><br><span class="line">            dfs1(e[i].to, u), dp[u] += dp[e[i].to];</span><br><span class="line">            <span class="keyword">if</span> (sum[e[i].to] &gt; mx[u][<span class="number">0</span>]) mx[u][<span class="number">1</span>] = mx[u][<span class="number">0</span>], mx[u][<span class="number">0</span>] = sum[e[i].to];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum[e[i].to] &gt; mx[u][<span class="number">1</span>]) mx[u][<span class="number">1</span>] = sum[e[i].to];</span><br><span class="line">            sum[u] += sum[e[i].to];</span><br><span class="line">        &#125;</span><br><span class="line">    dp[u] += mx[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) &#123;</span><br><span class="line">            dp[e[i].to] = dp[u];</span><br><span class="line">            <span class="keyword">if</span> (sum[e[i].to] == mx[u][<span class="number">0</span>]) dp[e[i].to] -= mx[u][<span class="number">0</span>] - mx[u][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (sum[e[i].to] &gt; mx[e[i].to][<span class="number">0</span>]) dp[e[i].to] += sum[e[i].to] - mx[e[i].to][<span class="number">0</span>], mx[e[i].to][<span class="number">1</span>] = mx[e[i].to][<span class="number">0</span>], mx[e[i].to][<span class="number">0</span>] = sum[e[i].to];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum[e[i].to] &gt; mx[e[i].to][<span class="number">1</span>]) mx[e[i].to][<span class="number">1</span>] = sum[e[i].to];</span><br><span class="line">            dfs2(e[i].to, u);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), mark(a, b);</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>), dfs2(<span class="number">1</span>, <span class="number">0</span>); LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = max(res, dp[i]);</span><br><span class="line">    res = -res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res += sum[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-小E和小F-strikes-again"><a href="#T3-小E和小F-strikes-again" class="headerlink" title="T3 小E和小F strikes again"></a>T3 小E和小F strikes again</h1><p><img src="1569980769821.png" alt="1569980769821"></p><p><img src="1569980777984.png" alt="1569980777984"></p><p>首先有一点题目没说清楚：<strong>每张牌有编号，即颜色相同的两张牌也被认为是不同的</strong></p><p>我们先计算在选定了前$x$张牌，并且小E已经选定了一种颜色$c$时的胜率</p><p>记$b_c$表示此时前$x$张牌中，花色为$c$的牌的数量，$S=\sum a_i$</p><p>假设我们确定了后$y$张牌中，颜色为$c$的牌有$j$张，那么后面$y$张牌的排列方法为</p><script type="math/tex; mode=display">{a_c-b_c\choose j}{S-x-(a_c-b_c)\choose y-j}y!</script><p>排列总数为</p><script type="math/tex; mode=display">{S-x\choose y}y!</script><p>因此胜率为</p><script type="math/tex; mode=display">\sum_{j\leq b_c-z}\frac{ {a_c-b_c\choose j} {S-x-(a_c-b_c)\choose y-j} }{S-x\choose y}</script><p>注意到这个只与$b_c$有关，因此我们可以处理出$p[i][j]$表示选择花色$i$，并且前$x$张牌中花色为$i$的一共有$j$张的胜率</p><p>假设我们已经确定了前$x$张牌每种花色有多少张，那么这件事情发生的概率为</p><script type="math/tex; mode=display">\frac{\prod{a_i\choose b_i} x!} { {S\choose x} x!}=\frac{\prod a_i\choose b_i} {S\choose x}</script><p>现在我们需要强制小E选择这种花色，即其它花色的胜率不能大于这个</p><p>将$p$从小到大排序，每次强制选择当前枚举的花色，可以处理出此时其它花色最多选择多少张。$dp[i][j]$表示当前已经考虑了$i$种花色，并且已经放了$j$个位置的概率，然后更新答案就可以了</p><p>由于$S\leq 100$，因此<code>__int128</code>即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Int</span> &#123;</span></span><br><span class="line">    __int128 A; <span class="keyword">int</span> B;</span><br><span class="line">    Int(<span class="keyword">int</span> x = <span class="number">0</span>): A(x), B(x) &#123;&#125;</span><br><span class="line">    Int <span class="keyword">operator</span> + (<span class="keyword">const</span> Int &amp;b) &#123;</span><br><span class="line">        Int res; res.A = A + b.A, res.B = (B + b.B) % mod;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Int <span class="keyword">operator</span> - (<span class="keyword">const</span> Int &amp;b) &#123;</span><br><span class="line">        Int res; res.A = A - b.A, res.B = (B - b.B + mod) % mod;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Int <span class="keyword">operator</span> * (<span class="keyword">const</span> Int &amp;b) &#123;</span><br><span class="line">        Int res; res.A = A * b.A, res.B = (LL)B * b.B % mod;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Int &amp;b) <span class="keyword">const</span> &#123;<span class="keyword">return</span> A &lt; b.A;&#125;</span><br><span class="line">&#125; C[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Int <span class="title">Pow</span><span class="params">(Int x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="function">Int <span class="title">res</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = x * x) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = res * x;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FUCK</span> &#123;</span></span><br><span class="line">    __int128 P; <span class="keyword">int</span> cnt, id, p;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> FUCK &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (P != b.P) <span class="keyword">return</span> P &lt; b.P;</span><br><span class="line">        <span class="keyword">return</span> cnt &lt; b.cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; t[N * N];</span><br><span class="line"><span class="keyword">int</span> cnt[N], tot, dp[N][N], mx[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, x, y, z, S = <span class="number">0</span>, res = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;x, &amp;y, &amp;z);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;cnt[i]), S += cnt[i];</span><br><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>] = Int(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S; i++) &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = Int(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) C[i][j] = C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= min(cnt[i], x); j++) &#123;</span><br><span class="line">            Int p;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= y &amp;&amp; j + k &lt;= cnt[i] &amp;&amp; k &lt;= j - z; k++)</span><br><span class="line">                p = p + C[cnt[i] - j][k] * C[S - x - (cnt[i] - j)][y - k];</span><br><span class="line">            t[++tot] = (FUCK)&#123;p.A, j, i, p.B&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    sort(t + <span class="number">1</span>, t + tot + <span class="number">1</span>), <span class="built_in">memset</span>(mx, <span class="number">-1</span>, <span class="keyword">sizeof</span>(mx));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp)), dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == t[i].id) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k + t[i].cnt &lt;= x; k++)</span><br><span class="line">                    dp[j][k + t[i].cnt] = (LL)dp[j - <span class="number">1</span>][k] * C[cnt[j]][t[i].cnt].B % mod;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= mx[j]; k++)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l + k &lt;= x; l++)</span><br><span class="line">                        dp[j][k + l] = (dp[j][k + l] + (LL)dp[j - <span class="number">1</span>][l] * C[cnt[j]][k].B) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = (res + (LL)t[i].p * dp[n][x]) % mod, mx[t[i].id] = t[i].cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL)res * Pow(C[S][x].B, mod - <span class="number">2</span>).B % mod * Pow(C[S - x][y].B, mod - <span class="number">2</span>).B % mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Say Goodbye 题解</title>
      <link href="/2019/09/14/Say-Goodbye-%E9%A2%98%E8%A7%A3/"/>
      <url>/2019/09/14/Say-Goodbye-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>这是一道比最后一题温暖得多的送分题，只需<code>3kb</code>就能拿到相当于最后一题<code>14kb</code>的分数</p><h2 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h2><p>直接按照题意模拟，$n^{n-1}$枚举出边以及每个点对应的颜色即可</p><p>期望得分$5$分</p><h2 id="算法2"><a href="#算法2" class="headerlink" title="算法2"></a>算法2</h2><p>颜色数量只有一种</p><p>我们首先不管基环树，单独考虑一棵树的情况</p><p>如果两棵子树不同构，也就对应着括号序的不同</p><p>因此一棵树的方案数就是长度为$2n-2$的括号序列数量，即第$n-1$项卡特兰数</p><p>众所周知，$h(n)=\frac{2n\choose n}{n+1}$，其中$h$代表卡特兰数</p><p>考虑将其拓展到基环树上，<code>Polya</code>即可</p><p>枚举基环上有多少条边，再枚举将环旋转多少次，可以通过简单的$n^2$<code>dp</code>求出不动点的数量</p><p>时间复杂度$O(n^2)$，期望得分$10$分</p><h2 id="算法3"><a href="#算法3" class="headerlink" title="算法3"></a>算法3</h2><p>考虑在算法2的基础上拓展</p><p>我们还是来考虑一棵树的情况</p><p>假设只有两种颜色</p><p>仔细思考一下可以发现，此时的方案数就等于只有一种颜色时的方案数乘以一个组合数</p><p>具体来说，假设一共有$n$个点，其中$a$个点是第一种颜色，$n-a$个点是第二种颜色，那么方案数就等于$h(n-1)\times {n\choose a}$，即选出$a$个点涂上第一种颜色</p><p>由于颜色不同的子树会被看作不同的子树，因此这样计算是不会算重的</p><p>拓展到$k$种颜色的话，就是原来的方案数乘上$k$个组合数，即</p><script type="math/tex; mode=display">{n\choose a_1}{n-a_1\choose a_2}{n-a_1-a_2\choose a_3}\cdots{a_n\choose a_n}</script><p>直接在算法2<code>Polya</code>的过程中乘上相应的组合数即可</p><p>时间复杂度$O(n^2)$，期望得分$30$分</p><h2 id="算法4"><a href="#算法4" class="headerlink" title="算法4"></a>算法4</h2><p>数据范围较算法2有所增大</p><p>考虑只有一种颜色时，树的方案数的<code>OGF</code>$F(x)$，使用<code>NTT</code>优化算法2</p><p>推一波式子</p><script type="math/tex; mode=display">\sum_{k\geq 1}\frac{1}{k}\sum_{i=1}^kF(x)^{\gcd(i,k)}[x^{\frac{n\gcd(i,k)}{k}}]\\=\sum_{k\geq 1}\frac{1}{k}\sum_{i=1}^kF(x^{\frac{k}{\gcd(i,k)}})^{\gcd(i,k)}[x^n]\\=\sum_{k\geq 1}\frac{1}{k}\sum_{i|k}\varphi(i)F(x^i)^{\frac{k}{i}}[x^n]\\=\sum_{i\geq 1}\varphi(i)\sum_{j\geq 1}\frac{F(x^i)^j}{ij}[x^n]</script><p>这里$k$枚举的是基环上的点数，$i$枚举的是转多少次</p><p>注意到如果最终的式子中，$i,j$要对$x^n$产生贡献，那么$i,j$都必须为$n$的约数</p><p>而$n$的约数大约是$\sqrt{n}$级别的，实际上还远比这个规模小</p><p>因此我们只需要计算出最多$\sqrt{n}$个多项式，再枚举$n$的约数计算即可</p><p>时间复杂度约为$O(n\log^2 n)$，期望得分$30$分</p><h2 id="算法5"><a href="#算法5" class="headerlink" title="算法5"></a>算法5</h2><p>结合算法4与算法3</p><p>时间复杂度$O(n\log^2n)$，期望得分$80$分</p><h2 id="算法6"><a href="#算法6" class="headerlink" title="算法6"></a>算法6</h2><p>考虑优化算法5</p><p>时间复杂度的瓶颈在于求出$\sqrt{n}$个多项式，我们考虑优化这一部分</p><p>继续观察之前的式子</p><script type="math/tex; mode=display">\sum_{i\geq 1}\varphi(i)\sum_{j\geq 1}\frac{F(x^i)^j}{ij}[x^n]\\=\sum_{i\geq 1}\frac{\varphi(i)}{i}\sum_{j\geq 1}\frac{F(x^i)^j}{j}[x^n]</script><p>后面的那个式子特别像$-\ln(1-x)$的展开式</p><p>实际上有</p><script type="math/tex; mode=display">\sum_{j\geq 1}\frac{F(x^i)^j}{j}=-\ln(1-F(x^i))</script><p>这样我们就不需要算出$\sqrt{n}$个多项式了，只需要计算$-\ln(1-F(x))$，然后取第$\frac{n}{i}$项的系数即可</p><p>时间复杂度为$O(n\log n)$，期望得分$100$分</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">600010</span>;</span><br><span class="line"><span class="keyword">int</span> r[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, w = <span class="number">1</span>, t; j &lt; i + (mid &gt;&gt; <span class="number">1</span>); j++, w = (LL)w * Wn % mod)</span><br><span class="line">                t = (LL)w * a[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!type) <span class="keyword">for</span> (<span class="keyword">int</span> inv = Pow(len, mod - <span class="number">2</span>), i = <span class="number">0</span>; i &lt; len; i++) a[i] = (LL)a[i] * inv % mod;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> A[], <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">void</span>(B[<span class="number">0</span>] = Pow(A[<span class="number">0</span>], mod - <span class="number">2</span>));</span><br><span class="line">    Inv(A, B, (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>); <span class="keyword">static</span> <span class="keyword">int</span> tmpa[N]; <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n * <span class="number">2</span>) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) tmpa[i] = A[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; len; i++) tmpa[i] = <span class="number">0</span>;</span><br><span class="line">    NTT(tmpa, len, <span class="number">1</span>), NTT(B, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) B[i] = (LL)(<span class="number">2</span> - (LL)tmpa[i] * B[i] % mod + mod) * B[i] % mod;</span><br><span class="line">    NTT(B, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; len; i++) B[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tinv[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ln</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> A[], <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> tmpa[N], inva[N]; <span class="built_in">memset</span>(tmpa, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmpa)), <span class="built_in">memset</span>(inva, <span class="number">0</span>, <span class="keyword">sizeof</span>(inva));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) tmpa[i] = (LL)A[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    Inv(A, inva, n); <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n * <span class="number">2</span>) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    NTT(tmpa, len, <span class="number">1</span>), NTT(inva, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) tmpa[i] = (LL)tmpa[i] * inva[i] % mod;</span><br><span class="line">    NTT(tmpa, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) B[i] = (LL)tmpa[i - <span class="number">1</span>] * tinv[i] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n / i; i++) <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">        res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="number">1</span>) res = res / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[N], A[N], B[N], n, k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = (LL)phi(t) * tinv[t] % mod, tmp = n / t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) res = (LL)res * C(tmp, a[i] / t) % mod, tmp -= a[i] / t;</span><br><span class="line">    <span class="keyword">return</span> (LL)res * (mod - B[n / t]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> b ? gcd(b, a % b) : a;&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k); <span class="keyword">int</span> g = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]), g = gcd(g, a[i]);</span><br><span class="line">    frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = tinv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span> + <span class="number">2</span>; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, tinv[i] = Pow(i, mod - <span class="number">2</span>);</span><br><span class="line">    inv[n * <span class="number">2</span> + <span class="number">2</span>] = Pow(frac[n * <span class="number">2</span> + <span class="number">2</span>], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n * <span class="number">2</span> + <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) inv[i] = (LL)inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) A[i + <span class="number">1</span>] = mod - (LL)C(<span class="number">2</span> * i, i) * tinv[i + <span class="number">1</span>] % mod;</span><br><span class="line">    A[<span class="number">0</span>] = <span class="number">1</span>, A[<span class="number">1</span>] = mod - <span class="number">1</span>, Ln(A, B, n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, tmp = <span class="number">1</span>, t = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= g; i++) <span class="keyword">if</span> (g % i == <span class="number">0</span>) </span><br><span class="line">        res = (res + work(i)) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) tmp = (LL)tmp * C(t, a[i]) % mod, t -= a[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (res + (LL)tmp * A[n]) % mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
            <tag> Polya </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOI赛前集训day2</title>
      <link href="/2019/08/20/NOI%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%ADday2/"/>
      <url>/2019/08/20/NOI%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%ADday2/</url>
      
        <content type="html"><![CDATA[<h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><div class="pdfobject-container" data-target="problem_842.pdf" data-height="500px"></div><p>我的方法做麻烦了</p><p>考虑枚举$S$中<strong>最远</strong>的两个点的横纵坐标之差$(w,h)$</p><p>我们强制让这两个点必须选</p><p>答案为</p><script type="math/tex; mode=display">2\sum_{w=1}^W\sum_{h=1}^H{\gcd(w,h)-1\choose n-2}(W-w)(H-h)+H{W\choose N}+W{H\choose N}</script><p>显然最后两项是常数，先不管</p><p>接着枚举$\gcd$，开始反演</p><script type="math/tex; mode=display">=2\sum_{d=1} ^ {w} {d-1\choose n-2} \sum_{w=1}^{\lfloor\frac{W}{d}\rfloor} \sum_{h=1} ^ {\lfloor\frac{H}{d}\rfloor}[\gcd(w,h)=1] (W-wd)(H-hd)\\=2\sum_{d=1}^w{d-1\choose n-2}\sum_{l=1}^{\lfloor\frac {W}{d}\rfloor}\mu(l)F(dl)</script><p>其中$F(x)=\sum_{i=1}^{\frac {W}{x}}\sum_{j=1}^{\frac {H}{x}}(W-i)(H-j)$，可以$O(1)$计算</p><p>设$T=dl$</p><p>那么原式为</p><script type="math/tex; mode=display">=2\sum_{T=1}^WF(T)\sum_{d|T}{d-1\choose n-2}\mu(\frac Td)</script><p>然后就可以$O(n\log n)$计算了</p><p>这里贴一下我考试时的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> flag[N], prime[N], mu[N], pcnt, frac[N], inv[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!flag[i]) prime[++pcnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pcnt &amp;&amp; i * prime[j] &lt;= n; j++) &#123;</span><br><span class="line">flag[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">mu[i * prime[j]] = -mu[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">323232323</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">sieve(n), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">inv[n] = Pow(frac[n], mod - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) inv[i] = (LL)inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">S</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;<span class="keyword">return</span> (LL)a * (a + <span class="number">1</span>) / <span class="number">2</span> % mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = n / d;</span><br><span class="line"><span class="keyword">return</span> ((LL)n * len - (LL)S(len) * d + len) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp[N], ans[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m, p, orz, res = <span class="number">0</span>; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; p;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">cout</span> &lt;&lt; (LL)n * m % mod, <span class="number">0</span>;</span><br><span class="line">pre(max(n, m)), p--, n--, m--, orz = min(n, m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = orz, sum = <span class="number">0</span>, sum2 = <span class="number">0</span>; i &gt;= p; i--) &#123;</span><br><span class="line">tmp[i] = (LL)F(n, i) * F(m, i) % mod; <span class="keyword">int</span> hh = <span class="number">0</span>, t;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= orz; j += i) hh = (hh + mu[j / i] * tmp[j]) % mod;</span><br><span class="line">ans[i] = hh;</span><br><span class="line">ans[i] = (ans[i] - sum2 + (LL)(i - <span class="number">1</span>) * sum) % mod;</span><br><span class="line">sum2 = (sum2 + (LL)ans[i] * i) % mod, sum = (sum + ans[i]) % mod;</span><br><span class="line">res = (res + (LL)ans[i] * C(i + <span class="number">1</span>, p + <span class="number">1</span>)) % mod;</span><br><span class="line">&#125;</span><br><span class="line">res = res * <span class="number">2</span> % mod, res = (res + (LL)C(n + <span class="number">1</span>, p + <span class="number">1</span>) * (m + <span class="number">1</span>) + (LL)C(m + <span class="number">1</span>, p + <span class="number">1</span>) * (n + <span class="number">1</span>)) % mod;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><div class="pdfobject-container" data-target="problem_843.pdf" data-height="500px"></div><p>我们先考虑第一问</p><p>显然我们可以贪心，每次选择未被覆盖的区间中右端点最靠左的区间，选择这个区间的右端点覆盖</p><p>考虑如何才能保证“包含的点数最少”</p><p>之前我们选出的点将数轴划分成了很多段，除了最靠右的那一段，其它每段都应选择恰好一个点</p><p>如果一段中没有被点覆盖，那么至少存在一个区间没有被覆盖</p><p>如果一段中的点数多余1，那么选中的点数就不是最少的</p><p>考虑最终答案中相邻的两个被选出的点$i,j$</p><p>对于所有中点在$(j,i]$的区间，重点小于等于$\frac{i+j}{2}$的区间会被$j$覆盖，否则被$i$覆盖</p><p>我们在计算$i$时考虑这个贡献，计算最终答案时要考虑那些中点在最后一个点右边的区间</p><p>用<code>query(p, l, r)</code>表示仅考虑中点在$[l,r]$的区间，如果选择$p$这个点覆盖的代价</p><p>从而我们可以计算出<code>cost(i, j)</code>表示这次选择的代价</p><p>注意到<code>cost</code>满足四边形不等式</p><p>因此我们可以使用决策单调性优化</p><p>对每一段我们都单独拿出来做决策单调性，从上一段转移而来</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>, M = N * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zjk</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> zjk &amp;b) <span class="keyword">const</span> &#123;<span class="keyword">return</span> r &lt; b.r;&#125;</span><br><span class="line">&#125; d[N];</span><br><span class="line"><span class="keyword">int</span> n, fuck[M]; LL sum[<span class="number">2</span>][M], dp[M]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">pos.push_back(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, ls = <span class="number">0</span>; i &lt;= n; i++) </span><br><span class="line"><span class="keyword">if</span> (d[i].l &gt; ls) ls = d[i].r, pos.push_back(d[i].r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pos.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">abs</span>(sum[<span class="number">1</span>][r] - sum[<span class="number">1</span>][l] - (sum[<span class="number">0</span>][r] - sum[<span class="number">0</span>][l]) * <span class="number">2</span> * p);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">cost</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (a + b) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> query(a, a, mid) + query(b, mid, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">dp[l] = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; i++) dp[l] = min(dp[l], dp[i] + cost(i, l));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, pos = L; dp[mid] = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = max(fuck[mid], L); i &lt;= R; i++) &#123;</span><br><span class="line">LL tmp = dp[i] + cost(i, mid);</span><br><span class="line"><span class="keyword">if</span> (tmp &lt; dp[mid]) dp[mid] = tmp, pos = i;</span><br><span class="line">&#125;</span><br><span class="line">solve(l, mid - <span class="number">1</span>, L, pos), solve(mid + <span class="number">1</span>, r, pos, R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">mx = max(mx, d[i].r);</span><br><span class="line">fuck[d[i].r + <span class="number">1</span>] = max(fuck[d[i].r + <span class="number">1</span>], d[i].l);</span><br><span class="line"><span class="keyword">int</span> mid = (d[i].l + d[i].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">sum[<span class="number">0</span>][mid]++, sum[<span class="number">1</span>][mid] += d[i].r + d[i].l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mx; i++) &#123;</span><br><span class="line">fuck[i] = max(fuck[i], fuck[i - <span class="number">1</span>]);</span><br><span class="line">sum[<span class="number">0</span>][i] += sum[<span class="number">0</span>][i - <span class="number">1</span>], sum[<span class="number">1</span>][i] += sum[<span class="number">1</span>][i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> s = pos.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pos[<span class="number">1</span>]; i++) dp[i] = query(i, <span class="number">1</span>, i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; s; i++) solve(pos[i - <span class="number">1</span>] + <span class="number">1</span>, pos[i], pos[i - <span class="number">2</span>] + <span class="number">1</span>, pos[i - <span class="number">1</span>]);</span><br><span class="line">LL ans = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pos[s - <span class="number">2</span>] + <span class="number">1</span>; i &lt;= pos[s - <span class="number">1</span>]; i++) ans = min(ans, dp[i] + query(i, i, mx));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;d[i].l, &amp;d[i].r), d[i].l *= <span class="number">2</span>, d[i].r *= <span class="number">2</span>;</span><br><span class="line">sort(d + <span class="number">1</span>, d + n + <span class="number">1</span>), solve(), solve2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><div class="pdfobject-container" data-target="problem_844.pdf" data-height="500px"></div><p>不太会啊。。。</p><p>贴一下题解</p><p><img src="https://i.loli.net/2019/08/20/TuakgLzUWSQxvXC.png" alt="1566303942295"></p>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 莫比乌斯反演 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOI赛前集训day1</title>
      <link href="/2019/08/17/NOI%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%ADday1/"/>
      <url>/2019/08/17/NOI%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%ADday1/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-挖矿题"><a href="#T1-挖矿题" class="headerlink" title="T1 挖矿题"></a>T1 挖矿题</h1><p><img src="https://i.loli.net/2019/08/17/GTt4QKodSAZWq3a.png" alt="1566044093694.png"></p><p><img src="https://i.loli.net/2019/08/17/taCQWzSgA2byPrj.png" alt="1566044184132.png"></p><p>首先我们将这个三角形的图转成正方形，空白处补0</p><p>当$k=1$的时候答案就是第一行与第一列的前缀最大值之和</p><p>接下来我们讨论$k=2$的情况</p><p>最终的答案一定是每行每列选出一个前缀，使得这些前缀互不相交</p><p>我们枚举最后第一行与第一列选了哪个前缀，那么剩下的前缀一定是挂在这一行一列上面的</p><p><code>dp[i][j]</code>表示只考虑左上角$[2\cdots i][2\cdots j]$的这个矩阵，选出的前缀不相交且不超过$i,j$边界的最大值</p><p>转移的时候枚举最后一行/最后一列</p><p><img src="https://i.loli.net/2019/08/17/j8IAFCDrdg1v4PY.png" alt="1566045014578.png"></p><p>注意只有在枚举出的那个第一行与第一列的前缀下面才能挂另外的前缀</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">55</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> v[N][N]; LL mx[<span class="number">2</span>][N][N], sum[<span class="number">2</span>][N][N], dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen("biggest.in", "r", stdin), freopen("biggest.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, k; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">        <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span>(v)), <span class="built_in">memset</span>(mx, <span class="number">0</span>, <span class="keyword">sizeof</span>(mx)), <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v[i - j + <span class="number">1</span>][j]);</span><br><span class="line">        LL ans = <span class="number">0</span>, t1 = <span class="number">0</span>, t2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) t1 = v[<span class="number">1</span>][i] + max(<span class="number">0l</span>l, t1), t2 = v[i][<span class="number">1</span>] + max(<span class="number">0l</span>l, t2);</span><br><span class="line">        ans = t1 + t2;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sum[<span class="number">0</span>][<span class="number">1</span>][i] = sum[<span class="number">0</span>][<span class="number">1</span>][i - <span class="number">1</span>] + v[<span class="number">1</span>][i], sum[<span class="number">1</span>][i][<span class="number">1</span>] = sum[<span class="number">1</span>][i - <span class="number">1</span>][<span class="number">1</span>] + v[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                sum[<span class="number">0</span>][i][j] = sum[<span class="number">1</span>][i][j] = v[i][j];</span><br><span class="line">                <span class="keyword">if</span> (j != <span class="number">2</span>) sum[<span class="number">0</span>][i][j] += sum[<span class="number">0</span>][i][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">2</span>) sum[<span class="number">1</span>][i][j] += sum[<span class="number">1</span>][i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                mx[<span class="number">0</span>][i][j] = max(mx[<span class="number">0</span>][i][j - <span class="number">1</span>], sum[<span class="number">0</span>][i][j]);</span><br><span class="line">                mx[<span class="number">1</span>][i][j] = max(mx[<span class="number">1</span>][i - <span class="number">1</span>][j], sum[<span class="number">1</span>][i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= n; l++) &#123;</span><br><span class="line">                        dp[k][l] = max(dp[k - <span class="number">1</span>][l], dp[k][l - <span class="number">1</span>]);</span><br><span class="line">                        <span class="keyword">if</span> (k &lt;= i) dp[k][l] = max(dp[k][l], mx[<span class="number">0</span>][k][l] + dp[k - <span class="number">1</span>][l]);</span><br><span class="line">                        <span class="keyword">if</span> (l &lt;= j) dp[k][l] = max(dp[k][l], mx[<span class="number">1</span>][k][l] + dp[k][l - <span class="number">1</span>]);</span><br><span class="line">                        ans = max(ans, sum[<span class="number">0</span>][<span class="number">1</span>][j] + sum[<span class="number">1</span>][i][<span class="number">1</span>] + dp[k][l]);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-大水题"><a href="#T2-大水题" class="headerlink" title="T2 大水题"></a>T2 大水题</h1><p><img src="https://i.loli.net/2019/08/17/t4rXfkeI1AhxoNQ.png" alt="1566045230745.png"></p><p><img src="https://i.loli.net/2019/08/17/VX7FrSlZbTd6mKf.png" alt="1566045266642.png"></p><p>一道很有趣的题</p><p>我们采用这样的策略：枚举最终水形成的连通块，二分出这个连通块的最高水位</p><p>我们现在要将这个区间左边以及右边的水全部汇聚到这个区间，但是有可能出现下面的情况</p><p><img src="https://i.loli.net/2019/08/17/eqgJThBWzavwr9Y.png" alt="1566045577068.png"></p><p>蓝色代表水，灰色代表泥土，现在要将水运到最右边的区间内</p><p>显然中间的橙色部分需要被挖去，才能让水流过去</p><p>因此，我们找到最左边以及最右边的水，然后依次扫过去，用一个变量记录当前最低高度，如果下一块泥土大于当前最低高度则需要被挖走</p><p>于是我们可以得出最终需要挖走的泥土的数量，对于区间外的泥土直接计算，对于区间内的泥土，数量为总水量加上区间内的泥土数量减去区间长度乘以水位高度</p><p>由于时间复杂度为$n^2\log n$，需要卡一下常</p><p>未卡常的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5010</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], d[N], n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">double</span> &amp;mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; l; i++) tmp += d[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; r; i--) tmp += d[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) </span><br><span class="line">        <span class="keyword">if</span> (h[i] + d[i] &lt; mid) tmp -= mid - h[i] - d[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (h[i] &lt; mid) tmp += h[i] + d[i] - mid;</span><br><span class="line">        <span class="keyword">else</span> tmp += d[i];</span><br><span class="line">    <span class="keyword">return</span> tmp &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n; <span class="keyword">double</span> ans = <span class="number">1e18</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= <span class="number">800</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; h[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; d[i];</span><br><span class="line">        h[<span class="number">0</span>] = h[n + <span class="number">1</span>] = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> hh = <span class="number">1e9</span>; <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; i; k++) <span class="keyword">if</span> (d[k]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> ls = h[k];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = k + <span class="number">1</span>; l &lt; i; l++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (h[l] &gt; ls) res += h[l] - ls;</span><br><span class="line">                        <span class="keyword">else</span> ls = h[l];</span><br><span class="line">                    &#125;</span><br><span class="line">                    hh = min(hh, ls);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = n; k &gt; j; k--) <span class="keyword">if</span> (d[k]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> ls = h[k];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = k - <span class="number">1</span>; l &gt; j; l--) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (h[l] &gt; ls) res += h[l] - ls;</span><br><span class="line">                        <span class="keyword">else</span> ls = h[l];</span><br><span class="line">                    &#125;</span><br><span class="line">                    hh = min(hh, ls);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">double</span> l = <span class="number">-1e9</span>, r = min(hh, min(h[i - <span class="number">1</span>], h[j + <span class="number">1</span>])), mid, tot;</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">fabs</span>(r - l) &gt; <span class="number">1e-6</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (check(i, j, mid = (l + r) / <span class="number">2</span>)) l = mid;</span><br><span class="line">                    <span class="keyword">else</span> r = mid; </span><br><span class="line">                &#125;</span><br><span class="line">                tot = -l * (j - i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k &lt; i || k &gt; j) tot += d[k];</span><br><span class="line">                    <span class="keyword">else</span> tot += h[k] + d[k];</span><br><span class="line">                &#125;</span><br><span class="line">                res += tot;</span><br><span class="line">                ans = min(ans, res);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.4f\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>卡常之后的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5010</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], d[N], n, sum[<span class="number">2</span>][<span class="number">1010</span>][N], zjk, mn[<span class="number">2</span>][N], w[<span class="number">2</span>][N], pre[N]; <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">double</span> &amp;mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> tmp = zjk; <span class="keyword">int</span> hh = <span class="built_in">floor</span>(mid);</span><br><span class="line">    tmp += sum[<span class="number">1</span>][hh][r] - sum[<span class="number">1</span>][hh][l - <span class="number">1</span>] - mid * (sum[<span class="number">0</span>][hh][r] - sum[<span class="number">0</span>][hh][l - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> tmp &gt;= -eps;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RG register</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), zjk = <span class="number">0</span>; <span class="keyword">double</span> ans = <span class="number">1e18</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;h[i]), pre[i] = pre[i - <span class="number">1</span>] + h[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d[i]), zjk += d[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (RG <span class="keyword">int</span> j = h[i]; j &lt;= <span class="number">1000</span>; ++j) sum[<span class="number">0</span>][j][i] = sum[<span class="number">0</span>][j][i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (RG <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; h[i]; ++j) sum[<span class="number">0</span>][j][i] = sum[<span class="number">0</span>][j][i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (RG <span class="keyword">int</span> j = h[i]; j &lt;= <span class="number">1000</span>; ++j) sum[<span class="number">1</span>][j][i] = sum[<span class="number">1</span>][j][i - <span class="number">1</span>] + h[i];</span><br><span class="line">            <span class="keyword">for</span> (RG <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; h[i]; ++j) sum[<span class="number">1</span>][j][i] = sum[<span class="number">1</span>][j][i - <span class="number">1</span>];</span><br><span class="line">        &#125;    </span><br><span class="line">        mn[<span class="number">0</span>][<span class="number">0</span>] = mn[<span class="number">1</span>][n + <span class="number">1</span>] = <span class="number">1e3</span>, w[<span class="number">0</span>][<span class="number">0</span>] = w[<span class="number">1</span>][n + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, flg = <span class="literal">false</span>, ls = <span class="number">1e3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!flg &amp;&amp; d[i]) flg = <span class="literal">true</span>, ls = h[i];</span><br><span class="line">            mn[<span class="number">0</span>][i] = h[i], w[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!flg) <span class="keyword">continue</span>;</span><br><span class="line">            ls = min(ls, h[i]), mn[<span class="number">0</span>][i] = ls, w[<span class="number">0</span>][i] = w[<span class="number">0</span>][i - <span class="number">1</span>] + h[i] - ls;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n, flg = <span class="literal">false</span>, ls = <span class="number">1e3</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!flg &amp;&amp; d[i]) flg = <span class="literal">true</span>, ls = h[i];</span><br><span class="line">            mn[<span class="number">1</span>][i] = h[i], w[<span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!flg) <span class="keyword">continue</span>;</span><br><span class="line">            ls = min(ls, h[i]), mn[<span class="number">1</span>][i] = ls, w[<span class="number">1</span>][i] = w[<span class="number">1</span>][i + <span class="number">1</span>] + h[i] - ls;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">double</span> res = w[<span class="number">0</span>][i - <span class="number">1</span>] + w[<span class="number">1</span>][j + <span class="number">1</span>] + zjk + pre[j] - pre[i - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">double</span> l = <span class="number">0</span>, r = min(mn[<span class="number">0</span>][i - <span class="number">1</span>], mn[<span class="number">1</span>][j + <span class="number">1</span>]), mid, tot, p = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (res - r * (j - i + <span class="number">1</span>) &gt;= ans) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">fabs</span>(r - l) &gt; eps) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (check(i, j, mid = (l + r) / <span class="number">2</span>)) l = mid + eps, p = mid;</span><br><span class="line">                    <span class="keyword">else</span> r = mid - eps; </span><br><span class="line">                &#125;</span><br><span class="line">                res += -p * (j - i + <span class="number">1</span>), ans = min(ans, res);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.4f\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-套路题"><a href="#T3-套路题" class="headerlink" title="T3 套路题"></a>T3 套路题</h1><p><img src="https://i.loli.net/2019/08/17/fGxLsintTqjAwIF.png" alt="1566046100283.png"></p><p><img src="https://i.loli.net/2019/08/17/qjdNvcmaxK3bP4W.png" alt="1566046133223.png"></p><p>不会啊。。先贴上题解吧</p><div class="pdfobject-container" data-target="tutorial_785.pdf" data-height="500px"></div>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Minimum Palindromic Factorization</title>
      <link href="/2019/08/10/Minimum-Palindromic-Factorization/"/>
      <url>/2019/08/10/Minimum-Palindromic-Factorization/</url>
      
        <content type="html"><![CDATA[<h1 id="Minimum-Palindromic-Factorization"><a href="#Minimum-Palindromic-Factorization" class="headerlink" title="Minimum Palindromic Factorization"></a>Minimum Palindromic Factorization</h1><p><strong>定义</strong>：</p><ol><li>$S$：将要被分割的字符串，其中$S[i]$表示$S$第$i$个位置的字符，$S[l\cdots r]$表示$S$从$l$开始，到$r$结束的子串</li><li>$PL(S)$表示将$S$划分成回文串的最小数量，比如$PL(abaab)=3$</li><li>$P_j$表示所有以位置$j$结尾的回文串的起始位置的集合</li></ol><h1 id="一个简单的算法"><a href="#一个简单的算法" class="headerlink" title="一个简单的算法"></a>一个简单的算法</h1><p>我们先尝试在$O(n^2)$的时间内解决这个问题，对于$PL$，显然有</p><script type="math/tex; mode=display">PL(S[1\cdots j])=\min_{i\in P_j}\{PL(S[1\cdots i-1])+1\}</script><p>定义$PL[i]=PL(S[1\cdots i])$，我们可以依次计算并保存下$PL$的值，显然当$S=a^n$的时候这个算法的时间复杂度为$O(n^2)$</p><h1 id="更快地计算回文串"><a href="#更快地计算回文串" class="headerlink" title="更快地计算回文串"></a>更快地计算回文串</h1><p>在这一节中，我们将尝试用一个大小为$O(\log j)$的集合$G_j$来代替$P_j$，并且$G_j$可以在$O(\log j)$的时间内由$G_{j-1}$递推而来</p><p><strong>定义：</strong>字符串$y$是字符串$x$的<code>border</code>当且仅当$y$同时是$x$的前缀和后缀，如果$y\not=x$，我们称$y$是<strong>非平凡</strong>的。下面的定理建立了<code>border</code>与回文串的联系</p><h2 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h2><blockquote><p>令$y$是回文串$x$的一个后缀，$y$是$x$的<code>border</code>当且仅当$y$是一个回文串</p></blockquote><p>证明显然</p><h2 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h2><blockquote><p>假设$y$是$x$的一个<code>border</code>，并且$|x|\leq 2|y|$，那么$x$是一个回文串当且仅当$y$是一个回文串</p></blockquote><p>证明也很显然</p><p><strong>定义：</strong>当正整数$p$满足$p\leq |x|$且存在一个长度为$p$的字符串$w$，使得$x$是$w^\infty$的子串时，我们称$p$是$x$的一个<strong>周期</strong></p><p>一个众所周知的事实是当$y$是$x$的一个非平凡<code>border</code>时，$|x|-|y|$是$x$的一个周期</p><p>根据以上的两个定理，我们可以得出定理3</p><h2 id="定理3"><a href="#定理3" class="headerlink" title="定理3"></a>定理3</h2><blockquote><p>令$y$是回文串$x$的一个非平凡<code>border</code>，那么$|x|-|y|$是$x$的一个周期当且仅当$y$是回文的。</p><p>特别地，$|x|-|y|$是$x$的最小周期当且仅当$y$是$x$的最长非平凡<code>border</code></p></blockquote><h2 id="定理4"><a href="#定理4" class="headerlink" title="定理4"></a>定理4</h2><blockquote><p>$x$是一个回文串，$y$是$x$的最长非平凡<code>border</code>，$z$是$y$的最长非平凡<code>border</code>，令$u,v$是满足$x=uy,y=vz$的两个字符串，那么有</p><ol><li>$|u|\geq|v|$</li><li>如果$|u|&gt;|v|$，则$|u|&gt;|z|$</li><li>如果$|u|=|v|$，则$u=v$</li></ol></blockquote><p><img src="https://i.loli.net/2019/08/10/dePGkKgiTH8IRwV.png" alt=""></p><p><img src="https://i.loli.net/2019/08/10/hA8YVoKgqumtcSw.png" alt="1565428566073.png"></p><p><strong>证明：</strong></p><ol><li><p>根据<strong>定理3</strong>，$|u|=|x|-|y|$是$x$的最小周期，$|v|=|y|-|z|$是$y$的最小周期。由于$y$是$x$的子串，因此，要么$|u|&gt;|y|&gt;|v|$，要么$|u|$也是$|y|$的一个周期，并且$|u|\geq|v|$</p><p> 由于$y$是$x$的<code>border</code>，因此当$|y|\geq|u|$时可以得出$u$是$y$的<code>border</code>，由于$z$是$y$的最长非平凡<code>border</code>，根据<strong>定理3</strong>，$v$是$y$的最小周期，故此时$|u|\geq|v|$</p></li><li><p>显然$v$是$x$的前缀，我们设$x=vw$，那么$|z|$是$w$的周期，并且$|w|=|z|+|u|$。假设$|z|\geq|u|$，那么有$|w|\leq 2|z|$，根据<strong>定理2</strong>，可以得出$w$是回文串，这与$y$是$x$的最长回文后缀矛盾。因此$|u|&gt;|z|$</p></li><li><p>根据2可以得到$v$是$x$的前缀，如果$|u|=|v|$，显然有$u=v$</p></li></ol><p><strong>定义：</strong>令$P_j=\{p_1,p_2,\cdots,p_m\}$，其中$p_1&lt;p_2&lt;\cdots&lt;p_m$。我们定义$p_i-p_{i-1}$为一个<strong>间隔</strong>，注意这里是向前差分</p><h2 id="定理5"><a href="#定理5" class="headerlink" title="定理5"></a>定理5</h2><blockquote><p>$P_j$的间隔序列是递减的，并且最多只有严格$O(\log j)$个不同的间隔</p></blockquote><p><strong>证明：</strong>对于任意的$i\in[2\cdots m-1]$，我们令$x=S[p_{i-1}\cdots j],y=S[p_j\cdots j],z=S[p_{j+1}\cdots j]$，这三个串的间隔为$|u|,|v|$。根据<strong>定理4</strong>，如果在这里间隔改变了，那么一定有$|u|&gt;|v|$，则$|x|&gt;|u|+|z|&gt;2|z|$，回文后缀的长度至少会减少一半，因此这样的情形最多发生$O(\log j)$次</p><p>我们会根据$P_j$的间隔将其划分成$O(\log j)$个连续的子集。对于正整数$\Delta$，我们<strong>定义</strong>$P_{j,\Delta}=\{p_i:1&lt;i\leq m,p_i-p_{i-1}=\Delta\}$，且$P_{j,\infty}=\{p_1\}$。每个非空的$P_{j,\Delta}$都可以被三元组$(\min P_{j,\Delta},\Delta,|P_{j,\Delta}|)$表示。我们<strong>定义</strong>$G_j$表示这些三元组按照$\Delta$构成的递减序列。</p><p>列表$G_j$仅用$O(\log j)$的空间就完全代表了$P_j$，我们会证明$G_j$可以在$O(|G_{j-1}|)$的时间内由$G_{j-1}$递推而来。在这个算法中，对于$P_{j-1}$中的每一个元素$i$，在$P_j$中要么被淘汰，要么被$i-1$替换。下面的定理说明了如何同时决定$P_{j-1,\Delta}$中的所有元素哪些应该被淘汰，哪些应该被替换。</p><h2 id="定理6"><a href="#定理6" class="headerlink" title="定理6"></a>定理6</h2><blockquote><p>$p_i,p_{i+1}$是$P_{j-1,\Delta}$中的两个连续的元素，那么$p_i-1\in P_j$当且仅当$p_{i+1}-1\in P_j$</p></blockquote><p><strong>证明：</strong>根据定义，$p_{i+1}-p_i=\Delta$，$p_i$的前驱是$p_{i-1}=p_i-\Delta$。根据<strong>定理4</strong>，这意味着$S[p_i-1]=S[p_{i+1}-1]=c$，从而$p_i-1\in P_j$当且仅当$S[j]=c$，即$p_{i+1}-1\in P_j$ </p><p>因此，当我们计算$G_j$时，每一个三元组$(i,\Delta,k)\in G_{j-1}$要么被淘汰，要么被替换成$(i-1,\Delta,k)$，最终得到的序列为</p><script type="math/tex; mode=display">G'_j=\{(i-1,\Delta,k):(i,\Delta,k)\in G_{j-1},i>1且S[i-1]=S[j]\}</script><p>这表示了在$P_j$中所有长度大于$2$的回文串</p><p>但是，这些$G’_j$中的三元组不一定完美地与最终的$P_{j,\Delta}$对应，因为有些间隔可能改变了。特别地，如果在$P_{j-1,\Delta}$中最小的元素$p_i$被替换成了$p_i-1$，但是它的前驱$p_{i-1}=p_i-\Delta$被淘汰了，那么$p_i-1$就不应该出现在$P_{j,\Delta}$中，因为间距变化了。注意只有每个组中最小的元素可能被影响，因此我们将第一个元素分裂出来。即，将$(p_i-1,\Delta,k)$分裂成$(p_i-1,\Delta’,1)$和$(p_i-1+\Delta,\Delta,k-1)$，这里的$\Delta’$表示$p_i-1$在$P_j$中的新的间隔。我们还会添加单独的三元组来表示长度为$1,2$的回文串</p><p>我们令$G’’_j$表示经过上述操作之后的$G’_j$，它恰好代表了每一个在$P_j$中的回文串，并且此时$\Delta$的值是正确的，但是$G’’_j$中可能有一些三元组的$\Delta$相同。因此我们将$G’’_j$中$\Delta$相同的三元组合并来得到最终的$G_j$</p><p><img src="https://i.loli.net/2019/08/10/WOnfGmRlDtUVKsc.png" alt="1565432215207"></p><h2 id="定理7"><a href="#定理7" class="headerlink" title="定理7"></a>定理7</h2><blockquote><p>$G_j$可以在$O(|G_{j-1}|)$的时间内由$G_{j-1}$转移而来</p></blockquote><h1 id="更快地求解"><a href="#更快地求解" class="headerlink" title="更快地求解"></a>更快地求解</h1><p>在这一节中，我们会展示如何在$O(|G_{j}|)$的时间内根据$PL[0\cdots j-1]$计算$PL[j]$。快速计算$G_j$的关键是利用$P_{j,\Delta}$与$P_{j-1,\Delta}$之间的密切关系，现在我们会依赖于由以下结论所揭示的$P_j,\Delta$与$P_{j-\Delta,\Delta}$之间的关系</p><h2 id="定理8"><a href="#定理8" class="headerlink" title="定理8"></a>定理8</h2><blockquote><p>如果$(i,\Delta,k)\in G_j$，且$k\geq 2$，则$(i,\Delta,k-1)\in G_{j-\Delta}$</p></blockquote><p><strong>证明：</strong>根据定义，$(i,\Delta,k)\in G_j$等价于$P_{j,\Delta}=\{i,i+\Delta,\cdots,i+(k-1)\Delta\}$，我们需要证明$P_{j-\Delta,\Delta}=\{i,i+\Delta,\cdots,i+(k-2)\Delta\}$。我们会先证明$P_{j-\Delta,\Delta}\cap|i-\Delta+1\cdots j-\Delta|=\{i,i+\Delta,\cdots,i+(k-2)\Delta\}$，接着我们会证明$P_{j-\Delta,\Delta}\cap|1\cdots i-\Delta|=\emptyset$</p><p><img src="https://i.loli.net/2019/08/10/hIdClEXD9So8Bqy.png" alt="1565433244361"></p><p>我们知道$y=S[i\cdots j]$与$x=S[i-\Delta\cdots j]$都是回文的，并且$y$是$x$的最长非平凡<code>border</code>，$S[i-\Delta\cdots j-\Delta]=y=S[i\cdots j]$。因此对于任意的$l\in[i\cdots j]$，$i\in P_j$当且仅当$l-\Delta\in P_{j-\Delta,\Delta}$。所以我们可以得出$P_{j-\Delta,\Delta}\cap|i-\Delta+1\cdots j-\Delta|=\{i,i+\Delta,\cdots,i+(k-2)\Delta\}$</p><p>我们还需要证明$P_{j-\Delta,\Delta}\cap|1\cdots i-\Delta|=\emptyset$，当且仅当$i-2\Delta\not\in P_{j-\Delta}$时成立。我们使用反证法，假设$i-2\Delta\in P_{j-\Delta}$，那么$S[i-2\Delta\cdots j-\Delta]$是回文串。我们令$w=S[i-2\Delta\cdots i-\Delta-1]$，那么$S[j-2\Delta+1\cdots j-\Delta]=w^R$，即$w$的反串。令$z=S[i-\Delta\cdots j-\Delta]$，而$S[i-\Delta\cdots j]$也是一个回文串，因此有$S[i-\Delta\cdots i-1]=w$以及$S[j-\Delta+1\cdots j]=w^R$。最后，$z$也是一个回文串，$S[i-2\Delta\cdots j]=wzw^R$是回文串，这意味着$i-\Delta\in P_j$，与$(i,\Delta,k)\in G_j$矛盾</p><p>根据以上的定理，$P_{j,\Delta}=P_{j-\Delta,\Delta}\cup\{\max P_{j,\Delta}\}$在$|P_{j,\Delta}|\geq2$时成立。那么我们可以在常数时间内计算$PL_{j,\Delta}=\min\{PL[i-1]+1:i\in P_{j,\Delta}\}$，让其由$PL_{j-\Delta,\Delta}$转移而来。我们会将$PL_{j,\Delta}$的值保存在数组$GPL[1\cdots n]$的第$m=\min P_{j,\Delta}-\Delta$项中。注意到$m$是$\min P_{j,\Delta}$在$P_j$中的前驱，并且当$|P_{j,\Delta}|\geq 2$时，$PL_{j-\Delta,\Delta}$也是保存在这个位置。接下来的定理说明了这个位置在第$j-\Delta$轮至第$j$轮中，不会被其他数覆写。</p><h2 id="定理9"><a href="#定理9" class="headerlink" title="定理9"></a>定理9</h2><blockquote><p>令$m=\min P_{j,\Delta}-\Delta$，那么对于任意的$l\in[j-\Delta+1\cdots j-1],m\not\in P_l$</p></blockquote><p><img src="https://i.loli.net/2019/08/10/IkzS8O4lF3oLANG.png" alt="1565441130156"></p><p><strong>证明：</strong>使用反证法，假设存在$l\in[j-\Delta+1\cdots j-1]$使得$m\in P_l$，即$S[m\cdots l]$是回文的。令$h=l-j+\Delta$，那么$S[m+h\cdots l-h]$是回文的，而$m&lt;m+h&lt;m+\Delta=\min P_{j-\Delta,\Delta}$，这意味着$m+h$是$\min P_{j-\Delta,\Delta}$的前驱，而非$m$，且$\min P_{j-\Delta,\Delta}\not\in P_{j-\Delta,\Delta}$，矛盾</p><h2 id="定理10"><a href="#定理10" class="headerlink" title="定理10"></a>定理10</h2><blockquote><p>可以在$O(n\log n)$的时间，以及$O(n)$的空间内得出一个串的最小回文划分数</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6.5NOI模拟</title>
      <link href="/2019/06/11/6-5NOI%E6%A8%A1%E6%8B%9F/"/>
      <url>/2019/06/11/6-5NOI%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-最长公共子序列"><a href="#T1-最长公共子序列" class="headerlink" title="T1 最长公共子序列"></a>T1 最长公共子序列</h1><p><img src="https://i.loli.net/2019/06/11/5cff9430cc66062737.png" alt="1560253480597"></p><p><img src="https://i.loli.net/2019/06/11/5cffa44b2d0d654429.png" alt="1560257600238"></p><p>注意到前三个串中每个数字最多出现两次，因此我们可以枚举第四个串的匹配位置，用一个三位的二进制数来表示前三个串的匹配情况</p><p><code>dp[i][2][2][2]</code>表示在第四个串中匹配到了第$i$个字符，在第一个串中处于这个串的第一/第二个位置，后两维类似</p><p>于是我们得到了一个$n^2$的做法，现在考虑优化</p><p>注意到对于$dp[i]$，有用的都是在它前面的项，并且后三位都小于它的$dp$</p><p>这是一个四维偏序</p><p>第一层<code>CDQ</code>可以按照$i$排序，第二层<code>CDQ</code>就按照后面的分治</p><p>时间复杂度$n\log^2 n$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">80010</span>, M = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span><span class="keyword">int</span> d, a, b, c, id, type;&#125; q[N], p[N], tmp[N];</span><br><span class="line"><span class="keyword">int</span> tree[N], n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">for</span> (;x &lt;= n;x += x &amp; -x) tree[x] = max(tree[x], y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clr</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">for</span> (;x &lt;= n;x += x &amp; -x) tree[x] = <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">que</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;x;x -= x &amp; -x) res = max(res, tree[x]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp0</span><span class="params">(<span class="keyword">const</span> Data &amp;a, <span class="keyword">const</span> Data &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.a != b.a) <span class="keyword">return</span> a.a &lt; b.a;</span><br><span class="line">    <span class="keyword">if</span> (a.b != b.b) <span class="keyword">return</span> a.b &lt; b.b;</span><br><span class="line">    <span class="keyword">if</span> (a.c != b.c) <span class="keyword">return</span> a.c &lt; b.c;</span><br><span class="line">    <span class="keyword">return</span> a.type &lt; b.type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">const</span> Data &amp;a, <span class="keyword">const</span> Data &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.b != b.b) <span class="keyword">return</span> a.b &lt; b.b;</span><br><span class="line">    <span class="keyword">if</span> (a.c != b.c) <span class="keyword">return</span> a.c &lt; b.c;</span><br><span class="line">    <span class="keyword">return</span> a.type &lt; b.type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, L, R; CDQ1(l, mid), CDQ1(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">for</span> (L = l, R = mid + <span class="number">1</span>;R &lt;= r;R++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (L &lt;= mid &amp;&amp; p[L].b &lt;= p[R].b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[L].type == <span class="number">0</span>) upd(p[L].c, dp[p[L].id]);</span><br><span class="line">            L++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (p[R].type == <span class="number">1</span>) dp[p[R].id] = max(dp[p[R].id], que(p[R].c) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l;i &lt; L;i++) <span class="keyword">if</span> (p[i].type == <span class="number">0</span>) clr(p[i].c);</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (L = l, R = mid + <span class="number">1</span>;L &lt;= mid;tmp[++top] = p[L++]) </span><br><span class="line">        <span class="keyword">while</span> (R &lt;= r &amp;&amp; cmp1(p[R], p[L])) tmp[++top] = p[R++];</span><br><span class="line">    <span class="keyword">for</span> (;R &lt;= r;R++) tmp[++top] = p[R];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= top;i++) p[i + l - <span class="number">1</span>] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, top = <span class="number">0</span>; CDQ2(l, mid);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l;i &lt;= mid;i++) p[++top] = q[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>;i &lt;= r;i++) p[++top] = q[i], p[top].type = <span class="number">1</span>, p[top].a--, p[top].b--, p[top].c--;</span><br><span class="line">    sort(p + <span class="number">1</span>, p + top + <span class="number">1</span>, cmp0), CDQ1(<span class="number">1</span>, top);</span><br><span class="line">    CDQ2(mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> buk[<span class="number">3</span>][M], at[<span class="number">2</span>][<span class="number">3</span>][M];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"lcs.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"lcs.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">3</span>;k++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a;i &lt;= n;i++) </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), at[buk[k][a]][k][a] = i, buk[k][a]++;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">7</span>, A, B, C;k &gt;= <span class="number">0</span>;k--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(A = at[k &amp; <span class="number">1</span>][<span class="number">0</span>][a]) || !(B = at[k &gt;&gt; <span class="number">1</span> &amp; <span class="number">1</span>][<span class="number">1</span>][a]) || !(C = at[k &gt;&gt; <span class="number">2</span> &amp; <span class="number">1</span>][<span class="number">2</span>][a])) <span class="keyword">continue</span>;</span><br><span class="line">            id++, q[id] = (Data)&#123;i, A, B, C, id, <span class="number">0</span>&#125;, dp[id] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CDQ2(<span class="number">1</span>, id); <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= id;i++) res = max(res, dp[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-树"><a href="#T2-树" class="headerlink" title="T2 树"></a>T2 树</h1><p><img src="https://i.loli.net/2019/06/13/5d01f899b0fe177795.png" alt="1560410233726"></p><p><img src="https://i.loli.net/2019/06/13/5d01f8bf1062327053.png" alt="1560410289809"></p><p>如果枚举$B$的根，那么$B$中的父子关系就确定了，我们让$A$中选出的点也满足这样的父子关系</p><p><code>g[u][i]</code>表示$A$中的$u$以及$u$的子树，对应$B$中的$i$的方案数</p><p><code>f[u][s]</code>表示$u$的儿子（不是子树），对应$B$中$i$的集合为$s$的儿子的方案数</p><p>枚举$u$对应的点，那么这两个东西是很好转移的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> F[N * <span class="number">2</span>], G[<span class="number">13</span>][N], m, res, rt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="keyword">if</span> (!ch[i].size()) G[i][u] = <span class="number">1</span>; <span class="keyword">else</span> G[i][u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = ch[i].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>;s &lt; <span class="number">1</span> &lt;&lt; sz;s++) F[s] = <span class="number">0</span>;</span><br><span class="line">        F[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head[u], v;j;j = e[j].next)</span><br><span class="line">            <span class="keyword">if</span> ((v = e[j].to) != f) </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span> &lt;&lt; sz;s &gt;= <span class="number">0</span>;s--) </span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>, son;k &lt; ch[i].size();k++) <span class="keyword">if</span> (s &amp; (<span class="number">1</span> &lt;&lt; k))</span><br><span class="line">                        F[s] = (F[s] + (LL)F[s ^ (<span class="number">1</span> &lt;&lt; k)] * G[ch[i][k]][v]) % mod;</span><br><span class="line">        G[i][u] = F[(<span class="number">1</span> &lt;&lt; sz) - <span class="number">1</span>];</span><br><span class="line">    &#125;    </span><br><span class="line">    res = (res + G[rt][u]) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样会算重</p><p>我们考虑什么时候会重复计数</p><p>首先对于两个根$u,v$，如果$B$选择这两个根形成的有根树是同构的，那么枚举了$u$之后就不能枚举$v$</p><p>对于一个点$u$，假设它有$k$棵完全相同的子树。那么我们在$dp$的时候会考虑这些子树的先后顺序，顺序不同的方案我们认为是不同的。然而它的儿子没有顺序，因此总方案数应该除以$k!$</p><p>因此，我们在进行$dp$之前，先对这个有根树$B$<code>dfs</code>一遍，处理出这棵树的<code>hash</code>以及<code>dp</code>应该乘上的系数</p><p>用个<code>set</code>统计一下这棵树是否与之前的某棵树同构，然后<code>dp</code>就可以了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ch[<span class="number">13</span>], B[<span class="number">13</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to, next;&#125; e[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> F[N * <span class="number">2</span>], G[<span class="number">13</span>][N], m, res, rt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="keyword">if</span> (!ch[i].size()) G[i][u] = <span class="number">1</span>; <span class="keyword">else</span> G[i][u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = ch[i].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>;s &lt; <span class="number">1</span> &lt;&lt; sz;s++) F[s] = <span class="number">0</span>;</span><br><span class="line">        F[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head[u], v;j;j = e[j].next)</span><br><span class="line">            <span class="keyword">if</span> ((v = e[j].to) != f) </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span> &lt;&lt; sz;s &gt;= <span class="number">0</span>;s--) </span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>, son;k &lt; ch[i].size();k++) <span class="keyword">if</span> (s &amp; (<span class="number">1</span> &lt;&lt; k))</span><br><span class="line">                        F[s] = (F[s] + (LL)F[s ^ (<span class="number">1</span> &lt;&lt; k)] * G[ch[i][k]][v]) % mod;</span><br><span class="line">        G[i][u] = F[(<span class="number">1</span> &lt;&lt; sz) - <span class="number">1</span>];</span><br><span class="line">    &#125;    </span><br><span class="line">    res = (res + G[rt][u]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line">ULL h[N], P = <span class="number">131</span>, pw[<span class="number">13</span>]; <span class="keyword">int</span> sz[<span class="number">13</span>], inv[<span class="number">13</span>], fuck;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    ULL tmp[<span class="number">13</span>]; <span class="keyword">int</span> top = <span class="number">0</span>, len = <span class="number">1</span>; sz[u] = <span class="number">1</span>, ch[u].clear(), h[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : B[u]) <span class="keyword">if</span> (v != f) dfs2(v, u), tmp[++top] = h[v], sz[u] += sz[v], ch[u].push_back(v);</span><br><span class="line">    <span class="keyword">if</span> (!top) <span class="keyword">return</span> h[u] = <span class="number">1</span>, <span class="keyword">void</span>();</span><br><span class="line">    sort(tmp + <span class="number">1</span>, tmp + top + <span class="number">1</span>), tmp[<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= top;i++) &#123;</span><br><span class="line">        h[u] += pw[i - <span class="number">1</span>] * tmp[i];</span><br><span class="line">        <span class="keyword">if</span> (tmp[i] == tmp[i - <span class="number">1</span>]) len++;</span><br><span class="line">        <span class="keyword">else</span> fuck = (LL)fuck * inv[len] % mod, len = <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    h[u] *= sz[u], fuck = (LL)fuck * inv[len] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span>&lt;ULL&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"tree.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"tree.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n, ans = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), pw[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">12</span>;i++) pw[i] = pw[i - <span class="number">1</span>] * P, inv[i] = inv[i - <span class="number">1</span>] * i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">12</span>;i++) inv[i] = Pow(inv[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b;i &lt; m;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), B[a].push_back(b), B[b].push_back(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">        fuck = <span class="number">1</span>, dfs2(rt = i, <span class="number">0</span>); </span><br><span class="line">        <span class="keyword">if</span> (s.count(h[i])) <span class="keyword">continue</span>;</span><br><span class="line">        s.insert(h[i]), res = <span class="number">0</span>, dfs(<span class="number">1</span>, <span class="number">0</span>), ans = (ans + (LL)res * fuck) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-子图"><a href="#T3-子图" class="headerlink" title="T3 子图"></a>T3 子图</h1><p><img src="https://i.loli.net/2019/06/13/5d01fb01b079629122.png" alt="1560410872830"></p><p><img src="https://i.loli.net/2019/06/13/5d01fb234b18e12052.png" alt="1560410906797"></p><p>比较妙的一道题</p><p>其实题解说得挺清楚的</p><div class="pdfobject-container" data-target="sol_subgraph.pdf" data-height="500px"></div><p>注意对于情况3需要减去的是4次情况5，而不是2次</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N], G2[N];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>; <span class="keyword">int</span> n, cnt[N], sum, vis[N], case4, sum2, tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">triple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : G2[i]) vis[v] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : G2[i]) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> t : G2[v]) <span class="keyword">if</span> (vis[t] == i) sum++, cnt[i]++, cnt[v]++, cnt[t]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">four</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>;u &lt;= n;u++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) <span class="keyword">if</span> (v &lt; u)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> t : G[v]) <span class="keyword">if</span> (t &lt; u)</span><br><span class="line">                sum2 = (sum2 + tmp[t]) % mod, tmp[t]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) <span class="keyword">if</span> (v &lt; u)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> t : G[v]) <span class="keyword">if</span> (t &lt; u) tmp[t]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">triple1</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) case4 = (case4 + (LL)cnt[i] * (G[i].size() - <span class="number">2</span>)) % mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">gen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>;u &lt;= n;u++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) <span class="keyword">if</span> (u &lt; v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (G[u].size() &gt;= G[v].size()) G2[u].push_back(v);</span><br><span class="line">            <span class="keyword">else</span> G2[v].push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) res = (res + (LL)G[i].size() * (G[i].size() - <span class="number">1</span>) / <span class="number">2</span>) % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; gen();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) res = (res + (LL)G[i].size() * (G[i].size() - <span class="number">1</span>) * (G[i].size() - <span class="number">2</span>) / <span class="number">6</span>) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>;u &lt;= n;u++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) <span class="keyword">if</span> (v &gt; u) </span><br><span class="line">            res = (res + (LL)(G[u].size() - <span class="number">1</span>) * (G[v].size() - <span class="number">1</span>)) % mod;</span><br><span class="line">    triple(); <span class="keyword">return</span> (res - <span class="number">2</span> * sum + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; gen(); <span class="keyword">int</span> inv = Pow(<span class="number">24</span>, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) res = (res + (LL)G[i].size() * (G[i].size() - <span class="number">1</span>) * (G[i].size() - <span class="number">2</span>) % mod * (G[i].size() - <span class="number">3</span>) % mod * inv) % mod;</span><br><span class="line">    triple(), triple1();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>;u &lt;= n;u++) <span class="keyword">if</span> (G[u].size() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = (LL)(G[u].size() - <span class="number">1</span>) * (G[u].size() - <span class="number">2</span>) / <span class="number">2</span> % mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) res = (res + (LL)(G[v].size() - <span class="number">1</span>) * t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    res = (res - <span class="number">2</span> * case4 + (LL)<span class="number">2</span> * mod) % mod, four();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>, hh = <span class="number">0</span>;u &lt;= n;u++, hh = <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) res = (res + (LL)hh * (G[v].size() - <span class="number">1</span>)) % mod, hh = (hh + G[v].size() - <span class="number">1</span>) % mod;</span><br><span class="line">    res = (res - (LL)<span class="number">4</span> * sum2 - <span class="number">2</span> * case4 - <span class="number">3</span> * sum) % mod, res = (res + mod) % mod;</span><br><span class="line">    res = (res + (LL)case4 + sum2) % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"subgraph.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"subgraph.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> m, k; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b;i &lt;= m;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), G[a].push_back(b), G[b].push_back(a);</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, m), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve2()), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">3</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve3()), <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">4</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve4()), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.3NOI模拟</title>
      <link href="/2019/06/11/6-3NOI%E6%A8%A1%E6%8B%9F/"/>
      <url>/2019/06/11/6-3NOI%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-下棋"><a href="#T1-下棋" class="headerlink" title="T1 下棋"></a>T1 下棋</h1><p><img src="https://i.loli.net/2019/06/11/5cff906021dbc63619.png" alt="1560252502006"></p><p>对这道题无语了，真的是下棋</p><p><img src="https://i.loli.net/2019/06/11/5cff90c5d1d7061853.png" alt="1560252598982"></p><h1 id="T2-大树"><a href="#T2-大树" class="headerlink" title="T2 大树"></a>T2 大树</h1><p><img src="https://i.loli.net/2019/06/11/5cff90f93b26384674.png" alt="1560252657648"></p><p><img src="https://i.loli.net/2019/06/11/5cff911376f7b68917.png" alt="1560252685028"></p><p>出题人需要谢罪</p><p>题目中漏了一个重要条件：<strong>每条边最多只能被经过两次</strong></p><p>那么这样的话，每一次一定是走完一棵子树，然后再去走其它子树</p><p>因此对于一个点，我们只需要确定它的子树的遍历顺序</p><p>由于答案只与每个点的第一次到达时间有关，因此往回走是没有问题的，即这棵树的每条边都会被经过两次</p><p>考虑两棵子树$a,b$</p><p>如果先遍历$a$再去遍历$b$，那么$b$中每个点的到达时间都会延后$s_a$，这个$s_a$表示以$a$为根的子树，加上$a$与父亲的那条边的边权之和，总共增加$size_bs_a$</p><p>同样，如果先遍历$b$再去遍历$a$，到达时间总共会增加$size_as_b$</p><p>按照国王游戏的套路，按照这个东西排序即可获得每个点子树的遍历顺序，然后模拟即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to, next, w;&#125; e[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt, fa[N][<span class="number">17</span>], dis[N], dep[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from], w&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to], w&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = f, dep[u] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">16</span>;i++) fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f)</span><br><span class="line">            dis[e[i].to] = dis[u] + e[i].w, dfs(e[i].to, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[a] &lt; dep[b]) swap(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">16</span>;i &gt;= <span class="number">0</span>;i--) <span class="keyword">if</span> (dep[fa[a][i]] &gt;= dep[b]) a = fa[a][i];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">16</span>;i &gt;= <span class="number">0</span>;i--) <span class="keyword">if</span> (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i];</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">DIS</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dis[a] + dis[b] - <span class="number">2</span> * dis[LCA(a, b)];</span><br><span class="line">&#125;</span><br><span class="line">LL tot, ans, sum[N];</span><br><span class="line"><span class="keyword">int</span> sz[N], tf[N];</span><br><span class="line"><span class="keyword">int</span> id[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>, sum[u] = tf[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f)</span><br><span class="line">            tf[e[i].to] = e[i].w, dfs1(e[i].to, u), sz[u] += sz[e[i].to], sum[u] += sum[e[i].to];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    ans += tot;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) tmp.push_back(e[i].to);</span><br><span class="line">    sort(tmp.begin(), tmp.end(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;<span class="keyword">return</span> sum[a] * sz[b] &lt; sum[b] * sz[a];&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : tmp) tot += tf[v], dfs2(v, u), tot += tf[v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"tree.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"tree.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b, c;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c), adde(a, b, c);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) id[i] = i;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">8</span>) &#123;</span><br><span class="line">        LL res = <span class="number">1e18</span>;</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            LL tmp = <span class="number">0</span>, tmp2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) tmp += DIS(id[i - <span class="number">1</span>], id[i]), tmp2 += tmp;</span><br><span class="line">            res = min(res, tmp2);</span><br><span class="line">        &#125; <span class="keyword">while</span> (next_permutation(id + <span class="number">2</span>, id + n + <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, (<span class="keyword">double</span>)res / (n - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dfs1(<span class="number">1</span>, <span class="number">0</span>), dfs2(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, (<span class="keyword">double</span>)ans / (n - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-数轴"><a href="#T3-数轴" class="headerlink" title="T3 数轴"></a>T3 数轴</h1><p><img src="https://i.loli.net/2019/06/11/5cff92915818246248.png" alt="1560253063717"></p><p><img src="https://i.loli.net/2019/06/11/5cff92b67efb614838.png" alt="1560253101971"></p><p>注意到“好数”的个数实际上是很少的，因此可以将所有的好数都预处理出来</p><p>枚举区间交的右端点$R$，二分左端点$L$</p><p>首先这个区间的长度不能大于最短的那个区间</p><p>对于所有$r$在$R$左侧的区间，需要移动$R-r$次</p><p>对于所有$l$在$L$右侧的区间，需要移动$l-L$次</p><p>将左右端点分开处理，其实就是预处理前缀和后缀，这样就可以扫描线了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> __int128 LLL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line">LL num[N * <span class="number">6</span>]; <span class="keyword">int</span> tot; <span class="built_in">queue</span>&lt;LL&gt; zjk, zjk2;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">gen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    num[++tot] = <span class="number">4</span>, num[++tot] = <span class="number">7</span>, zjk.push(<span class="number">4</span>), zjk.push(<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">18</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!zjk.empty()) &#123;</span><br><span class="line">            LL v = zjk.front(); zjk.pop();</span><br><span class="line">            num[++tot] = v * <span class="number">10</span> + <span class="number">4</span>, num[++tot] = v * <span class="number">10</span> + <span class="number">7</span>;</span><br><span class="line">            zjk2.push(num[tot]), zjk2.push(num[tot - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(zjk, zjk2);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(num + <span class="number">1</span>, num + tot + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcurts</span> &#123;</span>LL l, r;&#125; l[N];</span><br><span class="line"><span class="keyword">int</span> n; LL k, mn;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, LLL&gt; P;</span><br><span class="line">P pre[N * <span class="number">6</span>], suf[N * <span class="number">6</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(l + <span class="number">1</span>, l + n + <span class="number">1</span>, [](tcurts a, tcurts b) &#123;<span class="keyword">return</span> a.r &lt; b.r;&#125;);</span><br><span class="line">    <span class="function">P <span class="title">tmp</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, cur = <span class="number">1</span>;i &lt;= tot;i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt;= n &amp;&amp; l[cur].r &lt;= num[i]) tmp.second += l[cur].r, tmp.first++, cur++;</span><br><span class="line">        pre[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = P(<span class="number">0</span>, <span class="number">0</span>), sort(l + <span class="number">1</span>, l + n + <span class="number">1</span>, [](tcurts a, tcurts b) &#123;<span class="keyword">return</span> a.l &lt; b.l;&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tot, cur = n;i &gt;= <span class="number">1</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur &gt;= <span class="number">1</span> &amp;&amp; l[cur].l &gt;= num[i]) tmp.second += l[cur].l, tmp.first++, cur--;</span><br><span class="line">        suf[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tot;i++) &#123;</span><br><span class="line">        LLL t = (LLL)num[i] * pre[i].first - pre[i].second;</span><br><span class="line">        <span class="keyword">if</span> (t &gt; k) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = i, mid, ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (num[i] - num[mid] &gt; mn) &#123;l = mid + <span class="number">1</span>; <span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span> (t + suf[mid].second - (LLL)num[mid] * suf[mid].first &gt; k) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (~ans) res = max(res, i - ans + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"number.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"number.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    gen(), <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>, &amp;n, &amp;k), mn = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;l[i].l, &amp;l[i].r), mn = min(mn, l[i].r - l[i].l);</span><br><span class="line">    solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 交互 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.31NOI模拟</title>
      <link href="/2019/06/11/5-31NOI%E6%A8%A1%E6%8B%9F/"/>
      <url>/2019/06/11/5-31NOI%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-Exchange"><a href="#T1-Exchange" class="headerlink" title="T1 Exchange"></a>T1 Exchange</h1><p><img src="https://i.loli.net/2019/06/11/5cff8c2c30dd993097.png" alt="1560251422229"></p><p><img src="https://i.loli.net/2019/06/11/5cff8c4b80cca95283.png" alt="1560251458216"></p><p>题目中的交换，实际上是将自己手中的菜换成那颗菜，而不是真正的交换</p><p>如果将$i$与$i$右侧第一个大于$i$的点连边，那么最终会形成一棵树</p><p>通过观察可以得出，这棵树的某一棵子树一定是一个连续的区间</p><p>用线段树维护每个点到这个点所在的树根的距离，查询就是查区间最大值</p><p>预处理出每个点的所有儿子，然后扫描线就可以了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1500010</span>;</span><br><span class="line"><span class="keyword">int</span> tag[N &lt;&lt; <span class="number">2</span>], mx[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;mx[rt] = Max(mx[rt &lt;&lt; <span class="number">1</span>], mx[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;mx[rt &lt;&lt; <span class="number">1</span>] += tag[rt], mx[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += tag[rt], tag[rt &lt;&lt; <span class="number">1</span>] += tag[rt], tag[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] += tag[rt], tag[rt] = <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> mx[rt]++, tag[rt]++, <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">if</span> (tag[rt]) pushdown(rt); <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, start, end);</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, start, end);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mx[rt] &lt;= res) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> res = mx[rt], <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tag[rt]) pushdown(rt);</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) query(rt &lt;&lt; <span class="number">1</span>, l, mid, start, end);</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, start, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num[N], st[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> stk[N], top = <span class="number">0</span>; stk[++top] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;stk[++top] = i++)</span><br><span class="line">        <span class="keyword">while</span> (top &amp;&amp; num[stk[top]] &lt; num[i]) st[i] = min(st[i], st[stk[top]]), top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt; Q[N]; <span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        update(<span class="number">1</span>, <span class="number">1</span>, n, st[i], i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> q : Q[i]) res = <span class="number">0</span>, query(<span class="number">1</span>, <span class="number">1</span>, n, q.first, i), ans[q.second] = res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUF_SIZE = <span class="number">100000</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">nc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *p2 = buf + BUF_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) p1 = buf, p2 = buf + fread(buf, <span class="number">1</span>, BUF_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">return</span> *p1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> c = nc();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = nc();</span><br><span class="line">    <span class="keyword">while</span> (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = nc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="built_in">putchar</span>(<span class="string">'0'</span>), <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) write(x / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'0'</span> + x % <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"exchange.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"exchange.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n, q; read(n), read(q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) read(num[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b;i &lt;= q;i++) read(a), read(b), Q[b].push_back(P(a, i));</span><br><span class="line">    pre(n), solve(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= q;<span class="built_in">puts</span>(<span class="string">""</span>), i++) write(ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-Tree"><a href="#T2-Tree" class="headerlink" title="T2 Tree"></a>T2 Tree</h1><p><img src="https://i.loli.net/2019/06/11/5cff8d487d80934937.png" alt="1560251709537"></p><p><img src="https://i.loli.net/2019/06/11/5cff8d6d7ec8199885.png" alt="1560251747428"></p><p>比较简单的一道题</p><p>首先将$1$号点定为根节点，可以通过$n$次询问确定每个点的深度</p><p>此时每个点的父亲是唯一的，可以通过二分依次确定每个点的父亲</p><p>比如要确定$u$的父亲，那么就在$u$的上一层二分，每次询问一个前缀是否在$1$到$u$的路径上即可</p><h1 id="T3-Hanoi"><a href="#T3-Hanoi" class="headerlink" title="T3 Hanoi"></a>T3 Hanoi</h1><p><img src="https://i.loli.net/2019/06/11/5cff8df7e516b98445.png" alt="1560251888055"></p><p><img src="https://i.loli.net/2019/06/11/5cff8e1276a9f46967.png" alt="1560251913722"></p><p>神仙题</p><p>首先不管$a,b$的限制，那么我们可以发现如下性质：</p><ol><li>放入三号塔的圆盘必须严格按照顺序</li><li>对于二号塔或者一号塔顶端的连续一段与三号塔顶端匹配的圆盘，必须立刻移动到三号塔上</li><li>在二号塔中，如果存在$x,y$，使得$x$是$y$的上一个圆盘并且$x&lt;y-1$，那么一定无解</li></ol><p>其实题解说得很清楚</p><p><img src="https://i.loli.net/2019/06/11/5cff8f669c81252530.png" alt="1560252208598"></p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p, q, p1, q1; <span class="keyword">int</span> a, b; <span class="built_in">vector</span>&lt;P&gt; ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; q.size();) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; q.size() - <span class="number">1</span> &amp;&amp; q[j + <span class="number">1</span>] == q[j] - <span class="number">1</span>) j++;</span><br><span class="line">        <span class="keyword">if</span> (j - i + <span class="number">1</span> &gt; b || (j != q.size() - <span class="number">1</span> &amp;&amp; q[j + <span class="number">1</span>] &lt; q[j])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        i = j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> type = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (type) ans.push_back(P(<span class="number">1</span>, x));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p.size() - x;i &lt; p.size();i++) q.push_back(p[i]);</span><br><span class="line">    p.resize(p.size() - x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fuck</span><span class="params">()</span> </span>&#123;<span class="built_in">puts</span>(<span class="string">"NO"</span>), <span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">single</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x;i &lt; p.size() - <span class="number">1</span>;i++) <span class="keyword">if</span> (p[i + <span class="number">1</span>] != p[i] - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"hanoi.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"hanoi.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;a, &amp;b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, v;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v), p.push_back(v);</span><br><span class="line">    reverse(p.begin(), p.end());</span><br><span class="line">    <span class="keyword">while</span> (!p.empty() || !q.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!check()) fuck();</span><br><span class="line">        <span class="keyword">int</span> mx = p.size() + q.size(), pos = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; q.size();i++) <span class="keyword">if</span> (q[i] == mx) &#123;pos = i; <span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;ans.push_back(P(<span class="number">2</span>, q.size() - pos)), q.resize(pos); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; p.size();i++) <span class="keyword">if</span> (p[i] == mx) &#123;pos = i; <span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (single(pos)) &#123;move(<span class="number">1</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        pos = p.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (pos &gt; <span class="number">0</span> &amp;&amp; p[pos - <span class="number">1</span>] &lt;= p[pos] + <span class="number">1</span>) pos--;</span><br><span class="line">        <span class="keyword">int</span> sz = p.size() - pos;</span><br><span class="line">        <span class="keyword">if</span> (single(pos)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sz &lt;= a) move(sz);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= sz;i++) move(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> Mx = <span class="number">0</span>, Mn = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos;i &lt; p.size();i++) Mx = max(Mx, p[i]), Mn = min(Mn, p[i]);</span><br><span class="line">        <span class="keyword">if</span> (Mx - Mn + <span class="number">1</span> != p.size() - pos) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sz &gt; a) fuck();</span><br><span class="line">            move(sz); <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tot = <span class="number">0</span>, zjk = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos + <span class="number">1</span>;i &lt; p.size();i++)</span><br><span class="line">            <span class="keyword">if</span> (p[i] != p[i - <span class="number">1</span>] - <span class="number">1</span>) tot++, len = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> zjk = max(zjk, ++len);</span><br><span class="line">        <span class="keyword">if</span> (tot &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (zjk &gt; a || sz &gt; b) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sz &gt; a) fuck();</span><br><span class="line">                move(sz); <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = p.size() - <span class="number">1</span>, j;i &gt;= pos;i--) &#123;</span><br><span class="line">                j = i; <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &gt; pos &amp;&amp; p[j] == p[j - <span class="number">1</span>] - <span class="number">1</span>) j--, tmp++;</span><br><span class="line">                move(tmp), i = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pos2 = p.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p[pos2] == p[pos2 - <span class="number">1</span>] - <span class="number">1</span>) pos2--;</span><br><span class="line">        <span class="keyword">int</span> A = p.size() - pos2, B = sz - A;</span><br><span class="line">        <span class="keyword">if</span> (A + B &lt;= b &amp;&amp; max(A, B) &lt;= a) &#123;move(A), move(B); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> div = <span class="number">1</span>, tmp;div &lt;= sz;div++) <span class="keyword">if</span> (max(div, sz - div) &lt;= a) &#123;</span><br><span class="line">            <span class="keyword">if</span> (div &lt;= A) tmp = max(div + B, sz - div - B);</span><br><span class="line">            <span class="keyword">else</span> tmp = max(div - A, sz - div + A);</span><br><span class="line">            <span class="keyword">if</span> (tmp &lt;= b) &#123;flag = <span class="literal">true</span>, move(div), move(sz - div); <span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) fuck();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"YES\n%d\n"</span>, ans.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : ans) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, v.first, v.second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 交互 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.30NOI模拟</title>
      <link href="/2019/06/09/5-30NOI%E6%A8%A1%E6%8B%9F/"/>
      <url>/2019/06/09/5-30NOI%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-Duliu"><a href="#T1-Duliu" class="headerlink" title="T1 Duliu"></a>T1 Duliu</h1><p><img src="https://i.loli.net/2019/06/09/5cfceb450952c71096.png" alt="1560079114508"></p><p><img src="https://i.loli.net/2019/06/09/5cfceb60a551d88644.png" alt="1560079188983"></p><p>首先显然有</p><script type="math/tex; mode=display">f(l,r)=2(r-l+1)\sum_{i=l}^rd_i</script><p>将询问离线，按照$x$从大到小排序，对于每个$i$维护以$i$为左端点的区间中，右端点最靠左能取到哪个位置，使得这个区间的权值大于等于$x$</p><p>预处理出每个数作为一个区间的最大值时，这个区间的左端点与右端点最远可以取到哪里</p><p>对于每个数我们都找到这样的一个区间，求出这个区间的权值，按照这个权值排序</p><p>对于一个这样的极长区间$[L,R]$，在加入这个区间的时候我们只需要更新$L$的值，更新为这个区间最大值</p><p>我们这样考虑</p><p>对于每个询问，答案可能有三种情况：</p><ol><li>左端点是$L$</li><li>右端点是$R$</li><li>左右端点都在$L,R$中间</li></ol><p>前两种情况可以直接二分出第一个满足条件的端点</p><p>在纸上画一画，可以发现，我们只更新这个$L$是不会出问题的</p><p>考虑以下几种情况：</p><ol><li>答案取到的区间的左端点大于$L$，并且$L$在询问的$l$左方</li></ol><p>那么我们取$[l,R]$这个区间同样可以满足条件，并且最小值与$[L,R]$相等</p><ol><li>答案取到的区间的左端点大于$L$，并且$L$在询问的$l$右方</li></ol><p>取$[L,R]$这个区间即可</p><p>因此，这样是可以的</p><p>现在考虑询问的第三种情况</p><p>假如右端点取$R$时，左端点最靠右要取到$pos$才能使得这个区间的和$\geq x$</p><p>事实上，我们只需要查询$[L,pos]$的区间最小值即可</p><p>考虑以下三种区间</p><ol><li>左端点在$[L,pos]$，右端点在$[L,R]$</li></ol><p>显然这种区间是合法的</p><ol><li>左端点在$[pos+1,L]$，右端点在$[L,R]$</li></ol><p>如果这样的区间有一个是合法的，那么就不满足$pos$的定义了，$pos$还可以继续向右移动</p><p>因此，这样就考虑了所有的情况</p><p>用一个单调栈求出每个数成为最大值的范围，然后开一棵支持单点修改，区间查$min$的线段树以及一个区间查最大值的<code>st</code>表即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> mn[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;mn[rt] = min(mn[rt &lt;&lt; <span class="number">1</span>], mn[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> at, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> mn[rt] = x, <span class="keyword">void</span>();</span><br><span class="line">    <span class="keyword">if</span> (at &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, at, x); <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, at, x);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, res = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> mn[rt];</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) res = min(res, query(rt &lt;&lt; <span class="number">1</span>, l, mid, start, end));</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) res = min(res, query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, start, end));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> st[<span class="number">30</span>][N], lg[N], num[N], L[N], R[N]; LL s[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = r - l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> max(st[lg[len]][l], st[lg[len]][r - (<span class="number">1</span> &lt;&lt; lg[len]) + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(mn, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(mn));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) st[<span class="number">0</span>][i] = num[i], s[i] = s[i - <span class="number">1</span>] + num[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= lg[n];i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= n;j++)</span><br><span class="line">            st[i][j] = max(st[i - <span class="number">1</span>][j], st[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)]);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> stk[N], top = <span class="number">0</span>;</span><br><span class="line">    stk[top = <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;stk[++top] = i++) </span><br><span class="line">        <span class="keyword">while</span> (top &amp;&amp; num[stk[top]] &lt; num[i]) R[stk[top]] = i - <span class="number">1</span>, top--;</span><br><span class="line">    <span class="keyword">while</span> (top) R[stk[top--]] = n;</span><br><span class="line">    stk[top = <span class="number">1</span>] = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">1</span>;stk[++top] = i--)</span><br><span class="line">        <span class="keyword">while</span> (top &amp;&amp; num[stk[top]] &lt; num[i]) L[stk[top]] = i + <span class="number">1</span>, top--;</span><br><span class="line">    <span class="keyword">while</span> (top) L[stk[top--]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">f</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;<span class="keyword">return</span> <span class="number">2</span> * (s[r] - s[l - <span class="number">1</span>]) * (r - l + <span class="number">1</span>);&#125;</span><br><span class="line">LL ans[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id; LL x;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Query &amp;b) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x &gt; b.x;&#125;</span><br><span class="line">&#125; q[N], d[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]); pre(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) d[i] = (Query)&#123;L[i], R[i], i, f(L[i], R[i])&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>, &amp;q[i].l, &amp;q[i].r, &amp;q[i].x), q[i].id = i;</span><br><span class="line">    sort(d + <span class="number">1</span>, d + n + <span class="number">1</span>), sort(q + <span class="number">1</span>, q + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, cur = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt;= n &amp;&amp; d[cur].x &gt;= q[i].x) update(<span class="number">1</span>, <span class="number">1</span>, n, d[cur].l, num[d[cur].id]), cur++;</span><br><span class="line">        <span class="keyword">int</span> l = q[i].l, r = q[i].r, mid, pos1 = <span class="number">-1</span>, pos2 = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (f(q[i].l, mid) &gt;= q[i].x) pos1 = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        l = q[i].l, r = q[i].r;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (f(mid, q[i].r) &gt;= q[i].x) pos2 = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos1 == <span class="number">-1</span> || pos2 == <span class="number">-1</span>) &#123;ans[q[i].id] = <span class="number">-1</span>; <span class="keyword">continue</span>;&#125;</span><br><span class="line">        ans[q[i].id] = min(min(get(q[i].l, pos1), get(pos2, q[i].r)), query(<span class="number">1</span>, <span class="number">1</span>, n, q[i].l, pos2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-Gre"><a href="#T2-Gre" class="headerlink" title="T2 Gre"></a>T2 Gre</h1><p><img src="https://i.loli.net/2019/06/09/5cfcf3445fe4a87821.png" alt="1560081208980"></p><p><img src="https://i.loli.net/2019/06/09/5cfcf363c186e37336.png" alt="1560081240778"></p><p>事实上，这道题我是爆搜+肉眼找规律做出来的</p><p>只要找出了满足出现了$k$种字符的最短的串，再在这个串的开头填<code>a</code>就是答案</p><p>观察$k$比较小的时候的解</p><p>$k=1$:<code>a</code></p><p>$k=2$:<code>aabaa</code></p><p>$k=3$:<code>aababacbabaa</code></p><p>就以$k=2,k=3$为例</p><p>假设我们已经构造出了$k=2$时的答案<code>aabaa</code></p><p>将<code>a</code>换成<code>b</code>，<code>b</code>换成<code>c</code>，得到<code>bbcbb</code></p><p>现在我们要向里面插入尽量少的<code>a</code>，使得它满足条件</p><p>方法是，先插入两个<code>a</code>，然后指针向后移动，如果在上一个<code>a</code>与当前指针的位置之间，有一个字母出现了两次，那么就在当前指针前面插入一个<code>a</code>，最后再在结尾插入一个<code>a</code></p><p><code>bbcbb -&gt; aabbcbb -&gt; aababbcbb -&gt; aabababcbb -&gt; aabababcabb -&gt; aabababcabab -&gt; aabababcababa -&gt; aababacbabaa</code></p><p>这样可以保证，在任意时刻，<code>a</code>的数量总比第二多的字符的数量大，并且从前往后，从后往前都满足条件</p><p>然后这道题就完了</p><p>代码如下（其实我是打表过的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> ans[<span class="number">27</span>] = &#123;</span><br><span class="line">    <span class="string">""</span>, <span class="string">"a"</span>,</span><br><span class="line">    <span class="string">"aabaa"</span>,</span><br><span class="line">    <span class="string">"aababacbabaa"</span>,</span><br><span class="line">    <span class="string">"aababacbacbadcbacbabaa"</span>,</span><br><span class="line">    <span class="string">"aababacbacbadcbadcbaedcbadcbacbabaa"</span>,</span><br><span class="line">    <span class="string">"aababacbacbadcbadcbaedcbaedcbafedcbaedcbadcbacbabaa"</span>,</span><br><span class="line">    <span class="string">"aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbafedcbaedcbadcbacbabaa"</span>,</span><br><span class="line">    <span class="string">"aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa"</span>,</span><br><span class="line">    <span class="string">"aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa"</span>,</span><br><span class="line">    <span class="string">"aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa"</span>,</span><br><span class="line">    <span class="string">"aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa"</span>,</span><br><span class="line">    <span class="string">"aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa"</span>,</span><br><span class="line">    <span class="string">"aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbalkjihgfedcbamlkjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa"</span>,</span><br><span class="line">    <span class="string">"aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbalkjihgfedcbamlkjihgfedcbamlkjihgfedcbanmlkjihgfedcbamlkjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa"</span>,</span><br><span class="line">    <span class="string">"aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbalkjihgfedcbamlkjihgfedcbamlkjihgfedcbanmlkjihgfedcbanmlkjihgfedcbaonmlkjihgfedcbanmlkjihgfedcbamlkjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa"</span>,</span><br><span class="line">    <span class="string">"aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbalkjihgfedcbamlkjihgfedcbamlkjihgfedcbanmlkjihgfedcbanmlkjihgfedcbaonmlkjihgfedcbaonmlkjihgfedcbaponmlkjihgfedcbaonmlkjihgfedcbanmlkjihgfedcbamlkjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa"</span>,</span><br><span class="line">    <span class="string">"aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbalkjihgfedcbamlkjihgfedcbamlkjihgfedcbanmlkjihgfedcbanmlkjihgfedcbaonmlkjihgfedcbaonmlkjihgfedcbaponmlkjihgfedcbaponmlkjihgfedcbaqponmlkjihgfedcbaponmlkjihgfedcbaonmlkjihgfedcbanmlkjihgfedcbamlkjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa"</span>,</span><br><span class="line">    <span class="string">"aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbalkjihgfedcbamlkjihgfedcbamlkjihgfedcbanmlkjihgfedcbanmlkjihgfedcbaonmlkjihgfedcbaonmlkjihgfedcbaponmlkjihgfedcbaponmlkjihgfedcbaqponmlkjihgfedcbaqponmlkjihgfedcbarqponmlkjihgfedcbaqponmlkjihgfedcbaponmlkjihgfedcbaonmlkjihgfedcbanmlkjihgfedcbamlkjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa"</span>,</span><br><span class="line">    <span class="string">"aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbalkjihgfedcbamlkjihgfedcbamlkjihgfedcbanmlkjihgfedcbanmlkjihgfedcbaonmlkjihgfedcbaonmlkjihgfedcbaponmlkjihgfedcbaponmlkjihgfedcbaqponmlkjihgfedcbaqponmlkjihgfedcbarqponmlkjihgfedcbarqponmlkjihgfedcbasrqponmlkjihgfedcbarqponmlkjihgfedcbaqponmlkjihgfedcbaponmlkjihgfedcbaonmlkjihgfedcbanmlkjihgfedcbamlkjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa"</span>,</span><br><span class="line">    <span class="string">"aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbalkjihgfedcbamlkjihgfedcbamlkjihgfedcbanmlkjihgfedcbanmlkjihgfedcbaonmlkjihgfedcbaonmlkjihgfedcbaponmlkjihgfedcbaponmlkjihgfedcbaqponmlkjihgfedcbaqponmlkjihgfedcbarqponmlkjihgfedcbarqponmlkjihgfedcbasrqponmlkjihgfedcbasrqponmlkjihgfedcbatsrqponmlkjihgfedcbasrqponmlkjihgfedcbarqponmlkjihgfedcbaqponmlkjihgfedcbaponmlkjihgfedcbaonmlkjihgfedcbanmlkjihgfedcbamlkjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa"</span>,</span><br><span class="line">    <span class="string">"aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbalkjihgfedcbamlkjihgfedcbamlkjihgfedcbanmlkjihgfedcbanmlkjihgfedcbaonmlkjihgfedcbaonmlkjihgfedcbaponmlkjihgfedcbaponmlkjihgfedcbaqponmlkjihgfedcbaqponmlkjihgfedcbarqponmlkjihgfedcbarqponmlkjihgfedcbasrqponmlkjihgfedcbasrqponmlkjihgfedcbatsrqponmlkjihgfedcbatsrqponmlkjihgfedcbautsrqponmlkjihgfedcbatsrqponmlkjihgfedcbasrqponmlkjihgfedcbarqponmlkjihgfedcbaqponmlkjihgfedcbaponmlkjihgfedcbaonmlkjihgfedcbanmlkjihgfedcbamlkjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa"</span>,</span><br><span class="line">    <span class="string">"aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbalkjihgfedcbamlkjihgfedcbamlkjihgfedcbanmlkjihgfedcbanmlkjihgfedcbaonmlkjihgfedcbaonmlkjihgfedcbaponmlkjihgfedcbaponmlkjihgfedcbaqponmlkjihgfedcbaqponmlkjihgfedcbarqponmlkjihgfedcbarqponmlkjihgfedcbasrqponmlkjihgfedcbasrqponmlkjihgfedcbatsrqponmlkjihgfedcbatsrqponmlkjihgfedcbautsrqponmlkjihgfedcbautsrqponmlkjihgfedcbavutsrqponmlkjihgfedcbautsrqponmlkjihgfedcbatsrqponmlkjihgfedcbasrqponmlkjihgfedcbarqponmlkjihgfedcbaqponmlkjihgfedcbaponmlkjihgfedcbaonmlkjihgfedcbanmlkjihgfedcbamlkjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa"</span>,</span><br><span class="line">    <span class="string">"aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbalkjihgfedcbamlkjihgfedcbamlkjihgfedcbanmlkjihgfedcbanmlkjihgfedcbaonmlkjihgfedcbaonmlkjihgfedcbaponmlkjihgfedcbaponmlkjihgfedcbaqponmlkjihgfedcbaqponmlkjihgfedcbarqponmlkjihgfedcbarqponmlkjihgfedcbasrqponmlkjihgfedcbasrqponmlkjihgfedcbatsrqponmlkjihgfedcbatsrqponmlkjihgfedcbautsrqponmlkjihgfedcbautsrqponmlkjihgfedcbavutsrqponmlkjihgfedcbavutsrqponmlkjihgfedcbawvutsrqponmlkjihgfedcbavutsrqponmlkjihgfedcbautsrqponmlkjihgfedcbatsrqponmlkjihgfedcbasrqponmlkjihgfedcbarqponmlkjihgfedcbaqponmlkjihgfedcbaponmlkjihgfedcbaonmlkjihgfedcbanmlkjihgfedcbamlkjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa"</span>,</span><br><span class="line">    <span class="string">"aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbalkjihgfedcbamlkjihgfedcbamlkjihgfedcbanmlkjihgfedcbanmlkjihgfedcbaonmlkjihgfedcbaonmlkjihgfedcbaponmlkjihgfedcbaponmlkjihgfedcbaqponmlkjihgfedcbaqponmlkjihgfedcbarqponmlkjihgfedcbarqponmlkjihgfedcbasrqponmlkjihgfedcbasrqponmlkjihgfedcbatsrqponmlkjihgfedcbatsrqponmlkjihgfedcbautsrqponmlkjihgfedcbautsrqponmlkjihgfedcbavutsrqponmlkjihgfedcbavutsrqponmlkjihgfedcbawvutsrqponmlkjihgfedcbawvutsrqponmlkjihgfedcbaxwvutsrqponmlkjihgfedcbawvutsrqponmlkjihgfedcbavutsrqponmlkjihgfedcbautsrqponmlkjihgfedcbatsrqponmlkjihgfedcbasrqponmlkjihgfedcbarqponmlkjihgfedcbaqponmlkjihgfedcbaponmlkjihgfedcbaonmlkjihgfedcbanmlkjihgfedcbamlkjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa"</span>,</span><br><span class="line">    <span class="string">"aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbalkjihgfedcbamlkjihgfedcbamlkjihgfedcbanmlkjihgfedcbanmlkjihgfedcbaonmlkjihgfedcbaonmlkjihgfedcbaponmlkjihgfedcbaponmlkjihgfedcbaqponmlkjihgfedcbaqponmlkjihgfedcbarqponmlkjihgfedcbarqponmlkjihgfedcbasrqponmlkjihgfedcbasrqponmlkjihgfedcbatsrqponmlkjihgfedcbatsrqponmlkjihgfedcbautsrqponmlkjihgfedcbautsrqponmlkjihgfedcbavutsrqponmlkjihgfedcbavutsrqponmlkjihgfedcbawvutsrqponmlkjihgfedcbawvutsrqponmlkjihgfedcbaxwvutsrqponmlkjihgfedcbaxwvutsrqponmlkjihgfedcbayxwvutsrqponmlkjihgfedcbaxwvutsrqponmlkjihgfedcbawvutsrqponmlkjihgfedcbavutsrqponmlkjihgfedcbautsrqponmlkjihgfedcbatsrqponmlkjihgfedcbasrqponmlkjihgfedcbarqponmlkjihgfedcbaqponmlkjihgfedcbaponmlkjihgfedcbaonmlkjihgfedcbanmlkjihgfedcbamlkjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa"</span>,</span><br><span class="line">    <span class="string">"aababacbacbadcbadcbaedcbaedcbafedcbafedcbagfedcbagfedcbahgfedcbahgfedcbaihgfedcbaihgfedcbajihgfedcbajihgfedcbakjihgfedcbakjihgfedcbalkjihgfedcbalkjihgfedcbamlkjihgfedcbamlkjihgfedcbanmlkjihgfedcbanmlkjihgfedcbaonmlkjihgfedcbaonmlkjihgfedcbaponmlkjihgfedcbaponmlkjihgfedcbaqponmlkjihgfedcbaqponmlkjihgfedcbarqponmlkjihgfedcbarqponmlkjihgfedcbasrqponmlkjihgfedcbasrqponmlkjihgfedcbatsrqponmlkjihgfedcbatsrqponmlkjihgfedcbautsrqponmlkjihgfedcbautsrqponmlkjihgfedcbavutsrqponmlkjihgfedcbavutsrqponmlkjihgfedcbawvutsrqponmlkjihgfedcbawvutsrqponmlkjihgfedcbaxwvutsrqponmlkjihgfedcbaxwvutsrqponmlkjihgfedcbayxwvutsrqponmlkjihgfedcbayxwvutsrqponmlkjihgfedcbazyxwvutsrqponmlkjihgfedcbayxwvutsrqponmlkjihgfedcbaxwvutsrqponmlkjihgfedcbawvutsrqponmlkjihgfedcbavutsrqponmlkjihgfedcbautsrqponmlkjihgfedcbatsrqponmlkjihgfedcbasrqponmlkjihgfedcbarqponmlkjihgfedcbaqponmlkjihgfedcbaponmlkjihgfedcbaonmlkjihgfedcbanmlkjihgfedcbamlkjihgfedcbalkjihgfedcbakjihgfedcbajihgfedcbaihgfedcbahgfedcbagfedcbafedcbaedcbadcbacbabaa"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("gre.in", "r", stdin), freopen("gre.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, k; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; ans[k].size()) <span class="built_in">printf</span>(<span class="string">"CiYe\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n - ans[k].size();i++) <span class="built_in">putchar</span>(<span class="string">'a'</span>);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans[k] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-Tetris"><a href="#T3-Tetris" class="headerlink" title="T3 Tetris"></a>T3 Tetris</h1><p><img src="https://i.loli.net/2019/06/09/5cfcf6d92b90e50283.png" alt="1560082126092"></p><p>一道很好玩的提交答案题</p><p>除了第8号点以外都挺简单的</p><p>我写的是<code>A*</code>，每次保留最优秀的前$1000$个解</p><p>难点在于估价函数</p><p>第6个点需要单独设计估价函数，第8个点我不会，其余的点可以使用通用估价函数</p><p>可以将最大高度、连续段个数、留下的方块个数、某个方块下方有多少个空格以及是否存在一行只有1个格子未填这些信息设计进估价函数</p><p>代码就不放了</p>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 提交答案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多项式exp</title>
      <link href="/2019/05/29/%E5%A4%9A%E9%A1%B9%E5%BC%8Fexp/"/>
      <url>/2019/05/29/%E5%A4%9A%E9%A1%B9%E5%BC%8Fexp/</url>
      
        <content type="html"><![CDATA[<p>给出$A(x)$，求$e^{A(x)}\mod x^n$，每一项的系数模$998244353$</p><p>这里要求$A(x)$的常数项为$0$</p><h1 id="牛顿迭代法与泰勒展开"><a href="#牛顿迭代法与泰勒展开" class="headerlink" title="牛顿迭代法与泰勒展开"></a>牛顿迭代法与泰勒展开</h1><p>假如我们要用一个无穷级数来表示$f(x)$</p><p>首先选一个展开点$x_0$，然后有</p><script type="math/tex; mode=display">f(x)=\sum_{i=0}^\infty \frac{f^{(i)}(x_0)(x-x_0)^i}{i!}</script><p>其中，$f^{(i)}$表示$f$的$i$阶导数</p><hr><p>现在我们知道$G(x)$，要求求出一个$F(x)$，使得</p><script type="math/tex; mode=display">G(F(x))\equiv 0\pmod {x^n}</script><p>设$F_t(x)$表示$F$经过$t$次迭代之后的结果，即</p><script type="math/tex; mode=display">G(F_t(x))\equiv0\pmod{x^{2^t}}</script><p>考虑如何从第$t$次迭代推到第$t+1$次迭代</p><p>首先将这个式子从$F_{t}(x)$这个点泰勒展开</p><script type="math/tex; mode=display">\begin{aligned}G(F_{t+1}(x))&=\sum_{i=0}^\infty \frac{G^{(i)}(F_t(x))}{i!}(F_{t+1}(x)-F_{t}(x))^i\\&=G(F_t(x))+G'(F_t(x))(F_{t+1}(x)-F_t(x))+\sum_{i=2}^\infty 一些东西\end{aligned}</script><p>现在将这个式子放到模$x^{2^{t+1}}$下</p><p>注意到$F_{t+1}(x)$与$F_t(x)$在模$x^{2^t}$下同余</p><p>也就是说，这两个多项式的最后$2^t$项是相同的</p><p>如果我们让$(F_{t+1}(x)-F_t(x))^i$这里的$i$至少取到$2$</p><p>那么结果最后的至少$2^{t+1}$项都是$0$，放到模$x^{2^{t+1}}$下就是$0$</p><p>所以后面的那些东西就可以不管了，只留下了前两项</p><script type="math/tex; mode=display">\begin{aligned}G(F_{t+1}(x))&\equiv G(F_t(x))+G'(F_t(x))(F_{t+1}(x)-F_t(x))\pmod {x^{2^{t+1}}}\\0&\equiv G(F_t(x))+G'(F_t(x))F_{t+1}(x)-G'(F_t(x))F_t(x)\\F_{t+1}(x)&\equiv F_t(x)-\frac{G(F_t(x))}{G'(F_t(x))} \end{aligned}</script><p>这就是牛顿迭代法的公式</p><h1 id="多项式-ln"><a href="#多项式-ln" class="headerlink" title="多项式$\ln$"></a>多项式$\ln$</h1><p>有两种方法，第一种是先求导后积分，第二种是利用牛顿迭代的公式</p><p>这里讲一下第二种</p><p>令$F(x)=\frac{1}{A(x)}$</p><p>那么有$G(F(x))=A(x)F(x)-1,G’(F(x))=A(x)F’(x)$</p><script type="math/tex; mode=display">F_{t+1}(x)\equiv F_t(x)-\frac{A(x)F_t(x)-1}{A(x)F_t'(x)}</script><p>好吧事实上完全没必要这么复杂</p><h1 id="多项式-exp"><a href="#多项式-exp" class="headerlink" title="多项式$\exp$"></a>多项式$\exp$</h1><p>令$F(x)=e^{A(x)}$</p><p>那么$G(F(x))=\ln F(x)-A(x)$</p><p>我们将$A(x)$当作常数，那么$G’(F(x))=\frac{1}{F(x)}$</p><p>有</p><script type="math/tex; mode=display">\begin{aligned}F_{t+1}(x)&\equiv F_t(x)-\frac{G(F_t(x))}{G'(F_t(x))}\\&\equiv F_t(x)-F_t(x)(\ln F_t(x)-A(x))\\&\equiv F_t(x)(1-\ln F_t(x)+A(x))\end{aligned}</script><p>所以多项式$\exp$需要多项式$\ln$</p><p>时间复杂度$O(n\log n)$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>, N = <span class="number">600010</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> r[N], inv[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, w = <span class="number">1</span>, t;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w = (LL)w * Wn % mod)</span><br><span class="line">                t = (LL)w * a[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!type) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, inv = Pow(len, mod - <span class="number">2</span>);i &lt; len;i++) a[i] = (LL)a[i] * inv % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> A[], <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">void</span>(B[<span class="number">0</span>] = Pow(A[<span class="number">0</span>], mod - <span class="number">2</span>));</span><br><span class="line">    Inv(A, B, (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>); <span class="keyword">static</span> <span class="keyword">int</span> tmpa[N]; <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= <span class="number">3</span> * n) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) tmpa[i] = A[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n;i &lt; len;i++) tmpa[i] = <span class="number">0</span>;</span><br><span class="line">    NTT(tmpa, len, <span class="number">1</span>), NTT(B, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) B[i] = (<span class="number">2</span> - (LL)tmpa[i] * B[i] % mod + mod) * B[i] % mod;</span><br><span class="line">    NTT(B, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n;i &lt; len;i++) B[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ln</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> A[], <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> tmpa[N], inva[N]; <span class="built_in">memset</span>(tmpa, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmpa)), <span class="built_in">memset</span>(inva, <span class="number">0</span>, <span class="keyword">sizeof</span>(inva));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) tmpa[i] = (LL)A[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    Inv(A, inva, n); <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= <span class="number">2</span> * n) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    NTT(tmpa, len, <span class="number">1</span>), NTT(inva, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) tmpa[i] = (LL)tmpa[i] * inva[i] % mod;</span><br><span class="line">    NTT(tmpa, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) B[i] = (LL)tmpa[i - <span class="number">1</span>] * inv[i] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Exp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> A[], <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">void</span>(B[<span class="number">0</span>] = <span class="number">1</span>); Exp(A, B, (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> lnb[N]; <span class="built_in">memset</span>(lnb, <span class="number">0</span>, <span class="keyword">sizeof</span>(lnb));</span><br><span class="line">    Ln(B, lnb, n); <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) lnb[i] = (A[i] - lnb[i] + mod) % mod;</span><br><span class="line">    lnb[<span class="number">0</span>]++;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= <span class="number">2</span> * n) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    NTT(B, len, <span class="number">1</span>), NTT(lnb, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) B[i] = (LL)B[i] * lnb[i] % mod;</span><br><span class="line">    NTT(B, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n;i &lt; len;i++) B[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> A[N], B[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) inv[i] = Pow(i, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">    Exp(A, B, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, B[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
            <tag> 多项式ln </tag>
            
            <tag> 多项式exp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Min25筛</title>
      <link href="/2019/05/22/Min25%E7%AD%9B/"/>
      <url>/2019/05/22/Min25%E7%AD%9B/</url>
      
        <content type="html"><![CDATA[<p>设$f(x)$是一个给定的积性函数，并且是一个关于$x$的简单多项式，还可以快速算出$f(p^k)$，其中$p$是质数</p><p>那么<code>Min25</code>筛可以在$O(\frac{n^{\frac34}}{\log n})$的时间内求出$f(x)$的前缀和</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><code>Min25</code>筛的大体流程是，先求出所有质数的$f(x)$的和，再用质数的和推出所有合数的$f(x)$的和</p><p>定义另一个函数$f’(x)$，必须保证$f’(x)$是<strong>完全积性函数</strong>，并且在质数位置的结果与$f(x)$相等，其它位置随意，且$f’(x)$的前缀和能够快速求出</p><p>定义$s(x)$表示$x$的最小质因子</p><p>定义$g(n,k)$表示</p><script type="math/tex; mode=display">\sum_{i=2}^n[i是质数或s(i)>p_k]f'(i)</script><p>即要么$i$是质数，要么$i$的最小质因子大于第$k$个质数</p><p>注意到对于任意一个合数，它的最小质因子不可能大于$\sqrt n$，因此$k$只需要取到$\sqrt n$即可</p><p>我们先预处理出所有的$g(n,0)$</p><p>即</p><script type="math/tex; mode=display">\sum_{i=2}^nf'(i)</script><p>我们定义$m$表示$p_{m+1}&gt;\sqrt n$的第一个位置</p><p>那么$g(n,m)$就是所有质数的$f’(x)$也就是$f(x)$之和</p><p>考虑递推$g$，从$g(*,j-1)$递推到$g(*,j)$</p><p>显然有</p><script type="math/tex; mode=display">g(n,j)=g(n,j-1)-\sum_{i=2}^n[i\not=p_j,s(i)=p_j]f'(i)</script><p>我们知道</p><script type="math/tex; mode=display">g(n,j)-g(p_j,j)</script><p>它等价于</p><script type="math/tex; mode=display">\sum_{i=p_j+1}^n[s(i)=p_j]f'(i)</script><p>即大于$p_j$且最小质因子是$p_j$的所有数</p><p>因为$g(p_j,j)$就表示$2-p_j$中的质数以及最小质因子大于$p_j$的数</p><p>显然只有$2-p_j$的质数满足条件</p><p>如果$s(i)=p_j$，我们就将它的质因子提出来一个$p_j$</p><p>由于$f’(x)$是完全积性函数，因此$f’(p)f’(\frac{n}{p})=f’(n)$</p><p>因此</p><script type="math/tex; mode=display">g(n,j)=g(n,j-1)-[g(\lfloor\frac{n}{p_j}\rfloor,j-1)-g(p_j,j-1)]\*f'(p_j)</script><p>最终我们只关心$g(n,m)$，而此时$g(n,m)$仅包含所有质数的$f’(x)$之和</p><p>当$x$是质数时，根据定义$f’(x)=f(x)$</p><p>因此$g(n,m)$就是所有质数的$f(x)$之和</p><hr><p>现在我们算出了所有质数的和，考虑从质数推到合数</p><p>定义$S(n,k)$表示</p><script type="math/tex; mode=display">\sum_{i=p_k}^n[s(i)\geq p_k]f(i)</script><p>我们将这些数分为两类：质数和合数</p><p>对于质数的和，它等于$g(n,m)-p_1到p_{k-1}的f(x)之和$</p><p>对于合数，我们采用枚举最小质因子以及这个质因子的次数的方式统计</p><p>我们将合数分成两类：至少有两个质因子的，以及只有一个质因子的</p><p>假设我们枚举到了最小质因子$p_k$</p><p>现在枚举它的次数$e$</p><p>先考虑第一种合数</p><p>首先必须满足$p_k^e\leq n$</p><p>其实可以将这个上界进一步缩紧，变成$p_k^{e+1}\leq n$</p><p>因为$p_k$是某个数的最小质因子，如果$p_k^e\leq n$，而$p_k^{e+1}&gt; n$，一定不存在$\leq n$的这样的数</p><p>那么此时这些合数的和为</p><script type="math/tex; mode=display">\sum_{p_k^{e+1}\leq n}f(p_k^e)S(\lfloor\frac{n}{p_k^e}\rfloor,k+1)</script><p>我们再考虑第二种合数</p><p>假设它为$p_k^e$</p><p>那么$e\not=1,p_k^e\leq n$</p><p>这一类合数的和为</p><script type="math/tex; mode=display">\sum_{e\not=1,p_k^e\leq n}f(p_k^e)=\sum_{p_k^{e+1}}f(p_k^{e+1})</script><p>将这两类合数加起来</p><script type="math/tex; mode=display">\begin{aligned}S(n,t)&=\sum_{k=t}^m[\sum_{p_k^{e+1}\leq n}f(p_k^e)S(\lfloor\frac{n}{p_k^e}\rfloor, k+1)+\sum_{p_k^{e+1}\leq n}f(p_k^{e+1})]\\&=\sum_{k=t}^m\sum_{p_k^{e+1}\leq n}[f(p_k^e)S(\lfloor\frac{n}{p_k^e}\rfloor,k+1)+f(p_k^{e+1})]\end{aligned}</script><p>然后递归就行了</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>注意到计算$g,S$的时候用到的$n$的种数非常少，只会用到$n,\lfloor\frac{n}{2}\rfloor,\lfloor\frac n3\rfloor,\cdots,\lfloor\frac{n}{n-1}\rfloor,\lfloor\frac{n}{n}\rfloor$</p><p>实际上不同的取值只有$\sqrt n$个</p><p>我们把这$\sqrt n$个值离散化一下</p><p>考虑怎么快速查一个数$\lfloor\frac{n}{k}\rfloor=a$的编号</p><p>当然你要用<code>map</code>也行，但是就多了一个$\log$</p><p>这里我们开两个大小为$\sqrt n$的数组<code>id1, id2</code></p><p>我们用<code>id1[a]</code>表示$a(\leq \sqrt n)$的编号</p><p>用<code>id2[a]</code>表示$\lfloor\frac na\rfloor(a&gt;\sqrt n)$的编号</p><p>这样两个数组都只要开到$\sqrt n$就可以存下所有数</p><p>如果$a\leq \sqrt n$，那么直接返回<code>id1[a]</code></p><p>否则返回<code>id2[n / a]</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ID</span><span class="params">(LL x)</span> </span>&#123;<span class="keyword">return</span> x &lt;= T ? id1[x] : id2[n / x];&#125;</span><br></pre></td></tr></table></figure><p>对于$g(n,j)$，我们可以使用滚动数组的方式把第二维滚掉</p><p>这里给出初始化以及求$S$的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T = <span class="built_in">sqrt</span>(n + <span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= T;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag[i]) prime[++ncnt] = i, sum[ncnt] = (sum[ncnt - <span class="number">1</span>] + f1(i)) % mod;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= ncnt &amp;&amp; (LL)i * prime[j] &lt;= T;j++) &#123;</span><br><span class="line">                flag[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (LL l = <span class="number">1</span>;l &lt;= n;l = n / (n / l) + <span class="number">1</span>) &#123;</span><br><span class="line">        a[++m] = n / l;</span><br><span class="line">        <span class="keyword">if</span> (a[m] &lt;= T) id1[a[m]] = m; <span class="keyword">else</span> id2[n / a[m]] = m;</span><br><span class="line">        g[m] = calc(a[m]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= ncnt;i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m &amp;&amp; (LL)prime[i] * prime[i] &lt;= a[j];j++) </span><br><span class="line">            g[j] = (g[j] - (LL)f1(prime[i]) * (g[ID(a[j] / prime[i])] - sum[i - <span class="number">1</span>]) % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(LL n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; prime[m]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = (g[ID(n)] * (LL)<span class="number">2</span> * t - (LL)sum[m - <span class="number">1</span>] * <span class="number">2</span> * t) % mod; res = (res + mod) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m;i &lt;= ncnt &amp;&amp; (LL)prime[i] * prime[i] &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (LL j = prime[i], c = <span class="number">1</span>;j * prime[i] &lt;= n;j *= prime[i], c++) </span><br><span class="line">            Inc(res, ((LL)solve(n / j, i + <span class="number">1</span>) * f(j, c) + f(j * prime[i], c + <span class="number">1</span>)) % mod);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.luogu.org/problemnew/show/P5325" target="_blank" rel="noopener">洛谷P5325</a></p><p>求</p><script type="math/tex; mode=display">\sum_{i=1}^nf(i),f(p^k)=p^k(p^k-1)</script><p>其中$f$是积性函数</p><p>对于质数$p$，$f(p)=p(p-1)$</p><p>这个东西并不是一个完全积性函数</p><p>考虑把它拆开，$f(p)=p^2-p$</p><p>注意到$p^2,p$都是完全积性函数，所以可以直接上<code>Min25</code>筛分别求这两个东西</p><p>其实就是维护两个$g$，第一个$g$对应的函数就是$p^2$，第二个对应的函数是$p$，然后在求$S$的时候合并</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">namespace</span> Min25 &#123;</span><br><span class="line">    <span class="keyword">int</span> prime[N], id1[N], id2[N], flag[N], g1[N], g2[N], sum1[N], sum2[N], ncnt, m, inv6 = <span class="number">166666668</span>;</span><br><span class="line">    LL a[N], T, n;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ID</span><span class="params">(LL x)</span> </span>&#123;<span class="keyword">return</span> x &lt;= T ? id1[x] : id2[n / x];&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(LL x)</span> </span>&#123;x %= mod; <span class="keyword">return</span> x * (x + <span class="number">1</span>) / <span class="number">2</span> % mod - <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc2</span><span class="params">(LL x)</span> </span>&#123;x %= mod; <span class="keyword">return</span> x * (x + <span class="number">1</span>) % mod * (<span class="number">2</span> * x + <span class="number">1</span>) % mod * inv6 % mod - <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(LL x)</span> </span>&#123;x %= mod; <span class="keyword">return</span> x * (x - <span class="number">1</span>) % mod;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T = <span class="built_in">sqrt</span>(n + <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= T;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!flag[i]) prime[++ncnt] = i, sum1[ncnt] = (sum1[ncnt - <span class="number">1</span>] + (LL)i * i) % mod, sum2[ncnt] = (sum2[ncnt - <span class="number">1</span>] + i) % mod;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= ncnt &amp;&amp; i * prime[j] &lt;= T;j++) &#123;</span><br><span class="line">                flag[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (LL l = <span class="number">1</span>;l &lt;= n;l = n / (n / l) + <span class="number">1</span>) &#123;</span><br><span class="line">            a[++m] = n / l;</span><br><span class="line">            <span class="keyword">if</span> (a[m] &lt;= T) id1[a[m]] = m; <span class="keyword">else</span> id2[n / a[m]] = m;</span><br><span class="line">            g1[m] = calc2(a[m]), g2[m] = calc(a[m]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= ncnt;i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m &amp;&amp; (LL)prime[i] * prime[i] &lt;= a[j];j++) &#123;</span><br><span class="line">                g1[j] = (g1[j] - (LL)prime[i] * prime[i] % mod * (g1[ID(a[j] / prime[i])] - sum1[i - <span class="number">1</span>] + mod) % mod + mod) % mod;</span><br><span class="line">                g2[j] = (g2[j] - (LL)prime[i] * (g2[ID(a[j] / prime[i])] - sum2[i - <span class="number">1</span>] + mod) % mod + mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(LL n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; prime[m]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = ((LL)g1[ID(n)] - g2[ID(n)] - sum1[m - <span class="number">1</span>] + sum2[m - <span class="number">1</span>]) % mod; res = (res + mod) % mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m;i &lt;= ncnt &amp;&amp; (LL)prime[i] * prime[i] &lt;= n;i++)</span><br><span class="line">            <span class="keyword">for</span> (LL j = prime[i];j * prime[i] &lt;= n;j *= prime[i]) </span><br><span class="line">                res = (res + (LL)solve(n / j, i + <span class="number">1</span>) * f(j) + f(j * prime[i])) % mod;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> n = x, init(), solve(x, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL n; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Min25::solve(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> min25筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.8CTS模拟</title>
      <link href="/2019/05/09/5-8CTS%E6%A8%A1%E6%8B%9F/"/>
      <url>/2019/05/09/5-8CTS%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-SuffixArray"><a href="#T1-SuffixArray" class="headerlink" title="T1 SuffixArray"></a>T1 SuffixArray</h1><p><img src="https://i.loli.net/2019/05/09/5cd4192c09005.png" alt="1557403897261"></p><p><img src="https://i.loli.net/2019/05/09/5cd419641a5d5.png" alt="1557403990881"></p><p>很妙的一道题</p><p>我们先来找一下规律</p><script type="math/tex; mode=display">\begin{gather}1.A\\2.AB\\3.ABBA\\4.ABBABAAB\end{gather}</script><p>显然有一个规律就是每次是上一次串与它自己的反串拼在一起</p><p>但是如果用这个规律做就凉了</p><p>另一个不那么显然的规律是：$A$会变成$AB$，$B$会变成$BA$</p><p>我们来观察一下对于原串每一个后缀，它的前缀可能是什么</p><p>如果抛开最后一位不看，那么只有可能是这四种前缀：$AB*,BA*,AAB*,BBA*$</p><p>加上最后一位，多了两种可能的情况：$A,B$</p><p>那么我们来看一看每个后缀在一次转移之后会变成什么，注意每个后缀只会分裂出两个新后缀</p><script type="math/tex; mode=display">A\Rightarrow AB,B\\B\Rightarrow BA,A\\AB\Rightarrow AB,BBA\\BA\Rightarrow BA,AAB\\AAB\Rightarrow AB,BA\\BBA\Rightarrow BA,AB</script><p>那么根据这样的分裂关系，我们可以得出，在某一层中每种后缀一共有多少个</p><p>如何确定答案呢</p><p>假如我们在第$k$层，现在要找排名为$s$的后缀</p><p>尝试将其转化成在第$k-1$层找排名为$s’$的后缀</p><p>现在我们要确定这个排名为$s$的后缀在上一层中，是由哪一类后缀分裂出来的</p><p>上一层一共有$6$种后缀，每种后缀分裂出了两个，我们将这$12$个新的后缀按照字典序排序</p><p>定义$f(A,0/1)$表示状态$A$分裂出来的第$0/1$个后缀是什么</p><p>那么排序之后就是</p><script type="math/tex; mode=display">\begin{gather}1.A&f(B,1)\\2.AAB\*&f(BA,1)\\3.AB&f(A,0)\\4.ABAAB\*&f(BBA,1)\\5.ABABBA\*&f(AAB,0)\\6.ABBA\*&f(AB,0)\\7.B&f(A,1)\\8.BA&f(B,0)\\9.BAAB\*&f(BA,0)\\10.BABAAB\*&f(BBA,0)\\11.BABBA\*&f(AAB,1)\\12.BBA\*&f(AB,1)\end{gather}</script><p>我们依次枚举这$12$种后缀，如果$s$大于当前这种后缀分裂前在上一层中的个数，那么就用$s$减去这个个数，说明在这一层中，排名为$s$的后缀的字典序比当前枚举的大</p><p>否则说明排名为$s$的后缀就是当前枚举的后缀，并且在上一层的分裂前的那一类后缀中，排名为$s$</p><p>我们现在还可以算出在上一层中，这个后缀分裂之前的后缀的排名</p><p>如果我们对后缀编上$0,1,\cdots,2^k-1$这样的编号，那么编号为$i$的后缀在下一层会分裂成$2i,2i+1$这两个后缀</p><p>所以我们先求出分裂之前后缀的编号，乘以$2$之后加上当前后缀$f$的第二维，就可以得到当前后缀的编号了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">enum</span> status &#123;</span><br><span class="line">    A, AAB, AB, B, BA, BBA</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">LL dp[<span class="number">61</span>][BBA + <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][A] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++) &#123;</span><br><span class="line">        dp[i][AB] += dp[i - <span class="number">1</span>][A], dp[i][B] += dp[i - <span class="number">1</span>][A];</span><br><span class="line">        dp[i][AB] += dp[i - <span class="number">1</span>][AAB], dp[i][BA] += dp[i - <span class="number">1</span>][AAB];</span><br><span class="line">        dp[i][AB] += dp[i - <span class="number">1</span>][AB], dp[i][BBA] += dp[i - <span class="number">1</span>][AB];</span><br><span class="line">        dp[i][BA] += dp[i - <span class="number">1</span>][B], dp[i][A] += dp[i - <span class="number">1</span>][B];</span><br><span class="line">        dp[i][BA] += dp[i - <span class="number">1</span>][BA], dp[i][AAB] += dp[i - <span class="number">1</span>][BA];</span><br><span class="line">        dp[i][BA] += dp[i - <span class="number">1</span>][BBA], dp[i][AB] += dp[i - <span class="number">1</span>][BBA];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; gen[] = &#123;</span><br><span class="line">    &#123;B, <span class="number">1</span>&#125;, &#123;BA, <span class="number">1</span>&#125;, &#123;A, <span class="number">0</span>&#125;, &#123;BBA, <span class="number">1</span>&#125;, &#123;AAB, <span class="number">0</span>&#125;, &#123;AB, <span class="number">0</span>&#125;, &#123;A, <span class="number">1</span>&#125;, &#123;B, <span class="number">0</span>&#125;, &#123;BA, <span class="number">0</span>&#125;, &#123;BBA, <span class="number">0</span>&#125;, &#123;AAB, <span class="number">1</span>&#125;, &#123;AB, <span class="number">1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(LL step, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">12</span>;i++) &#123;</span><br><span class="line">        LL tmp = dp[k - <span class="number">1</span>][gen[i].first];</span><br><span class="line">        <span class="keyword">if</span> (step &lt;= tmp) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; gen[i].first;j++) step += dp[k - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">return</span> solve(step, k - <span class="number">1</span>) * <span class="number">2</span> + gen[i].second;</span><br><span class="line">        &#125; <span class="keyword">else</span> step -= tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"a.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"a.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> k, q; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;k, &amp;q), DP(k); LL a;</span><br><span class="line">    <span class="keyword">while</span> (q--) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, solve(a, k) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-InfiniteSequence"><a href="#T2-InfiniteSequence" class="headerlink" title="T2 InfiniteSequence"></a>T2 InfiniteSequence</h1><p><img src="https://i.loli.net/2019/05/09/5cd4212fc3f08.png" alt="1557405983163"></p><p><img src="https://i.loli.net/2019/05/09/5cd4215038698.png" alt="1557406020049"></p><p>表示只会60分</p><p>第一个点直接暴力</p><p>第二个点和第三个点找循环节</p><p>现在说一下4，5，6这三个点</p><p>先列出特征方程</p><script type="math/tex; mode=display">x^2=Ax+1\\x^2-Ax-1=0\\</script><p>那么此时我们知道</p><script type="math/tex; mode=display">\begin{cases}\Delta=A^2+4\\x=\frac{A\pm\sqrt\Delta}{2}\\x_1x_2=-1\end{cases}</script><p>设</p><script type="math/tex; mode=display">a_n=c_1(\frac{A+\sqrt\Delta}{2})^n+c_2(\frac{A-\sqrt\Delta}{2})^2</script><p>解得</p><script type="math/tex; mode=display">c_1=\frac{1}{\sqrt\Delta},c_2=-\frac{1}{\sqrt\Delta}</script><p>注意这里有一个坑点：如果解出来$x_1=x_2$我们就不能这么做了</p><p>我们先来讨论这种情况，此时的递推式为</p><script type="math/tex; mode=display">a_n=(a+bn)x^n</script><p>解得</p><script type="math/tex; mode=display">a=0,b=\frac{1}{x}</script><p>所以</p><script type="math/tex; mode=display">a_n=nx^{n-1}</script><p>而$x_1x_2=-1,x_1=x_2$</p><p>因此$x=\sqrt{-1}, a_n=n\sqrt{-1}^{n-1}$</p><p>所以我们知道$\frac{A}{2}$的阶是$4$</p><p>枚举$n-1$模$4$的余数，再根据中国剩余定理我们可以算出满足条件的$n$模$4p$的余数，从而算出$[L,R]$内合法的$n$的数量</p><hr><p>现在来讨论另一种情况</p><p>设</p><script type="math/tex; mode=display">T=\frac{A+\sqrt\Delta}{2},b=\sqrt\Delta</script><p>那么</p><script type="math/tex; mode=display">a_n=\frac1bT^n-\frac1b(\frac{-1}{T})^n\equiv x\pmod p</script><p>此时需要按照$n$的奇偶性分类讨论，然后就是解一个一元二次方程，最后用<code>BSGS</code>算出答案</p><p>这种做法在$A^2+4$没有二次剩余的情况下会出错，正解好像是在复数域下进行运算</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> W, mod; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">comp</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    comp(<span class="keyword">int</span> x, <span class="keyword">int</span> y = <span class="number">0</span>): x(x), y(y) &#123;&#125;</span><br><span class="line">    comp <span class="keyword">operator</span> * (<span class="keyword">const</span> comp &amp;b) &#123;</span><br><span class="line">        <span class="keyword">return</span> comp(((LL)x * b.x % mod + (LL)y * b.y % mod * W) % mod, ((LL)x * b.y + (LL)y * b.x) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> comp <span class="title">Pow</span><span class="params">(comp x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="function">comp <span class="title">res</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = x * x) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = res * x;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> p = mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % p) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % p;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Rand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (rand() &lt;&lt; <span class="number">16</span>) | rand();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Cipolla</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    n = (n % mod + mod) % mod;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (Pow(n, (mod - <span class="number">1</span>) / <span class="number">2</span>) + <span class="number">1</span> == mod) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">233</span>) &#123;</span><br><span class="line">        a = Rand() % mod, W = (((LL)a * a - n) % mod + mod) % mod;</span><br><span class="line">        <span class="keyword">if</span> (Pow(W, (mod - <span class="number">1</span>) / <span class="number">2</span>) + <span class="number">1</span> == mod) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (Pow(comp(a, <span class="number">1</span>), (mod + <span class="number">1</span>) / <span class="number">2</span>).x + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; s; <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; sol;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">BSGS</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; A &lt;&lt; <span class="string">' '</span> &lt;&lt; B &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    sol.clear();</span><br><span class="line">    <span class="keyword">if</span> (B == <span class="number">1</span>) sol.insert(<span class="number">0</span>);</span><br><span class="line">    s.clear();</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(mod)), ls = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++, ls = (LL)ls * A % mod) </span><br><span class="line">        s[(LL)B * ls % mod] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, t = ls;i &lt;= mod;i += m, t = (LL)t * ls % mod)</span><br><span class="line">        <span class="keyword">if</span> (s.count(t) &amp;&amp; (i - s[t]) &lt; (mod - <span class="number">1</span>)) sol.insert(i - s[t]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">calc</span><span class="params">(LL n, LL p, LL m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n / p + (m &amp;&amp; m &lt;= n % p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">calc</span><span class="params">(LL n, LL p, LL m, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    LL p1 = <span class="number">4</span> * p, t = d * p % p1 * p + m * Pow(<span class="number">4</span>, p - <span class="number">1</span>, p1); </span><br><span class="line">    <span class="keyword">return</span> calc(n, p1, t % p1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">calc</span><span class="params">(LL L, LL R, LL p, LL m, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> calc(R, p, m, d) - calc(L - <span class="number">1</span>, p, m, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">BF1</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> x, <span class="keyword">int</span> p, LL L, LL R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, a = <span class="number">1</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span> &amp;&amp; L == <span class="number">1</span>) res++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= R;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = b; b = a, a = ((LL)A * a + t) % p;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= i &amp;&amp; a == x) res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="built_in">map</span>&lt;P, <span class="keyword">int</span>&gt; ss; <span class="keyword">int</span> flag[<span class="number">2000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">calc2</span><span class="params">(<span class="keyword">int</span> pos, LL len, <span class="keyword">int</span> l, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    LL res = len / l * c; len %= l;</span><br><span class="line">    <span class="keyword">return</span> res + flag[pos + len - <span class="number">1</span>] - flag[pos - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">BF2</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> x, <span class="keyword">int</span> p, LL L, LL R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>, i; ss.clear();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>;!ss.count(P(a, b));i++) &#123;</span><br><span class="line">        ss[P(a, b)] = i;</span><br><span class="line">        flag[i] = flag[i - <span class="number">1</span>] + (a == x);</span><br><span class="line">        <span class="keyword">int</span> t = b; b = a, a = ((LL)A * a + t) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ls = ss[P(a, b)]; LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (R &lt; ls) <span class="keyword">return</span> flag[R] - flag[L - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (L &lt; ls) res = flag[ls] - flag[L - <span class="number">1</span>];</span><br><span class="line">    L = max(L, (LL)ls); <span class="keyword">int</span> c = flag[i - <span class="number">1</span>] - flag[ls - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> res + calc2(ls, R - ls + <span class="number">1</span>, i - ls, c) - calc2(ls, L - ls, i - ls, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIT set<span class="meta-string">&lt;int&gt;::iterator </span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">solve</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> x, <span class="keyword">int</span> p, LL L, LL R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (R &lt;= <span class="number">100000</span>) <span class="keyword">return</span> BF1(A, x, p, L, R);</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= <span class="number">1000000</span>) <span class="keyword">return</span> BF2(A, x, p, L, R);</span><br><span class="line">    mod = p; <span class="keyword">int</span> T = Cipolla((LL)A * A % mod + <span class="number">4</span>), inv2 = (p + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = (LL)A * inv2 % mod;</span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, b = <span class="number">1</span>;j &lt; <span class="number">4</span>;j++, b = (LL)b * i % mod) </span><br><span class="line">            res += calc(L, R, p, (LL)x * Pow(b, mod - <span class="number">2</span>) % mod, (j + <span class="number">1</span>) % <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (T == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> y = (LL)(T + A) * inv2 % mod; x = (LL)x * T % mod;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> res = Cipolla((LL)x * x % mod - <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> t1 = (LL)(x + res) * inv2 % mod, t2 = (LL)(x + mod - res) * inv2 % mod;</span><br><span class="line">            BSGS(y, t1); </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : sol) <span class="keyword">if</span> (v % <span class="number">2</span> == <span class="number">1</span>) ans += calc(R, p - <span class="number">1</span>, v) - calc(L - <span class="number">1</span>, p - <span class="number">1</span>, v);</span><br><span class="line">            <span class="keyword">if</span> (t1 != t2) &#123;</span><br><span class="line">                BSGS(y, t2);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> v : sol) <span class="keyword">if</span> (v % <span class="number">2</span> == <span class="number">1</span>) ans += calc(R, p - <span class="number">1</span>, v) - calc(L - <span class="number">1</span>, p - <span class="number">1</span>, v);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> res = Cipolla((LL)x * x % mod + <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> t1 = (LL)(x + res) * inv2 % mod, t2 = (LL)(x + mod - res) * inv2 % mod;</span><br><span class="line">            BSGS(y, t1);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : sol) <span class="keyword">if</span> (v % <span class="number">2</span> == <span class="number">0</span>) ans += calc(R, p - <span class="number">1</span>, v) - calc(L - <span class="number">1</span>, p - <span class="number">1</span>, v);</span><br><span class="line">            <span class="keyword">if</span> (t1 != t2) &#123;</span><br><span class="line">                BSGS(y, t2);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> v : sol) <span class="keyword">if</span> (v % <span class="number">2</span> == <span class="number">0</span>) ans += calc(R, p - <span class="number">1</span>, v) - calc(L - <span class="number">1</span>, p - <span class="number">1</span>, v);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"b.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"b.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    srand((<span class="keyword">long</span> <span class="keyword">long</span>)<span class="keyword">new</span> <span class="keyword">char</span>); <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> A, p, x; LL L, R; <span class="built_in">scanf</span>(<span class="string">"%d%d%d%lld%lld"</span>, &amp;A, &amp;p, &amp;x, &amp;L, &amp;R);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, solve(A, x, p, L, R));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-PlanarGraph"><a href="#T3-PlanarGraph" class="headerlink" title="T3 PlanarGraph"></a>T3 PlanarGraph</h1><p><img src="https://i.loli.net/2019/05/09/5cd4266a35e58.png" alt="1557407323954"></p><p><img src="https://i.loli.net/2019/05/09/5cd4268b6932f.png" alt="1557407360167"></p><p>这个题中，平面图的唯一作用在于告诉你这是稀疏图：即边数是$O(n)$级别的</p><p>我们用$p_i$表示第$i$次操作之后到达$n$号点的概率，那么答案就是$\sum\limits_{i=0}^\infty p_i$</p><p>设</p><script type="math/tex; mode=display">f(x)=\sum_{i=0}^\infty p_ix^i</script><p>那么答案就是</p><script type="math/tex; mode=display">\sum_{i=0}^\infty p_i=f'(1)</script><p>我们可以先暴力算出$p$的前$2n$项，然后用$BM$算法求出$p$的递推式，这是一个$n$阶的递推式，我们设它为$G$</p><p>考虑$f(x)G(x)$会得到什么</p><p>显然$f$第$n+1$项及之后的所有项都是不变的，因为它们满足递推式</p><p>而前面的$n$项有可能出错</p><p>我们记</p><script type="math/tex; mode=display">C(x)=\sum_{i=1}^np_ix^i</script><p>那么通过计算$C(x)G(x)$，我们可以得出$f$错误的前$n$项，注意需要将$C(x)G(x)$在$n$之后的所有项都设成$0$</p><p>我们将$f(x)G(x)$减去$C(x)G(x)$，得到的就是一个前$n$项都为$0$的$f$，我们再加上$C(x)$，就变回原来的$f$了</p><p>因此</p><script type="math/tex; mode=display">\begin{aligned}f(x)&=f(x)G(x)+C(x)(1-G(x))\\&=\frac{C(x)(1-G(x))}{1-G(x)}\end{aligned}</script><p>由于我们对$C(x)(1-G(x))$做了一些特殊处理，所以这里不能约分</p><p>利用公式</p><script type="math/tex; mode=display">(\frac uv)'=\frac{u'v-uv'}{v^2}</script><p>就可以快速算出答案了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10010</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dec</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    x -= y, x += x &lt; <span class="number">0</span> ? mod : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    x += y, x -= x &gt;= mod ? mod : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> val[N * <span class="number">2</span>], delta[N * <span class="number">2</span>], fail[N * <span class="number">2</span>], cnt, mn;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; now, mncoef, ls;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">BM</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    mn = <span class="number">1</span>, now.clear(), ls.clear(), mncoef.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        delta[i] = val[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; ls.size();j++) Dec(delta[i], (LL)val[i - j - <span class="number">1</span>] * ls[j] % mod);</span><br><span class="line">        <span class="keyword">if</span> (!delta[i]) <span class="keyword">continue</span>; <span class="keyword">else</span> fail[++cnt] = i; </span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">1</span>) &#123;ls.clear(), ls.resize(i); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = (LL)delta[i] * Pow(delta[fail[mn]], mod - <span class="number">2</span>) % mod;</span><br><span class="line">        now.clear(), now.resize(i - fail[mn] - <span class="number">1</span>), now.push_back(tmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; mncoef.size();j++)</span><br><span class="line">            now.push_back((LL)mncoef[j] * (mod - tmp) % mod);</span><br><span class="line">        <span class="keyword">if</span> (now.size() &lt; ls.size()) now.resize(ls.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; ls.size();j++) Inc(now[j], ls[j]);</span><br><span class="line">        <span class="keyword">if</span> (ls.size() - i &lt; mncoef.size() - fail[mn]) mn = cnt, mncoef = ls;</span><br><span class="line">        ls = now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][N], invs[N], p[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++) dp[<span class="number">0</span>][j] = dp[<span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) invs[i] = Pow(G[i].size(), mod - <span class="number">2</span>);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>; <span class="keyword">int</span> inv2 = (mod + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, cur = <span class="number">0</span>;i &lt;= <span class="number">2</span> * n;i++) &#123;</span><br><span class="line">        cur ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++) dp[cur][j] = <span class="number">0</span>, p[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n;j++) <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[j]) </span><br><span class="line">            Inc(p[v], (LL)dp[cur ^ <span class="number">1</span>][j] * invs[j] % mod);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++) &#123;</span><br><span class="line">            p[j] = (LL)p[j] * inv2 % mod, Inc(dp[cur][j], p[j]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[j]) Inc(dp[cur][v], (LL)p[j] * invs[j] % mod);</span><br><span class="line">        &#125;</span><br><span class="line">        val[i] = dp[cur][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> g[N * <span class="number">2</span>], c[N * <span class="number">2</span>], dg[N * <span class="number">2</span>], dc[N * <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Delta</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> da[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++) da[i - <span class="number">1</span>] = (LL)a[i] * i % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"c.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"c.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m), cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%*d%*d"</span>), G[i].clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b;i &lt;= m;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), G[a].push_back(b), G[b].push_back(a);</span><br><span class="line">        DP(n), BM(n * <span class="number">2</span>), c[<span class="number">0</span>] = <span class="number">0</span>, g[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">int</span> length = now.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= length;i++) c[i] = <span class="number">0</span>, g[i] = (mod - now[i - <span class="number">1</span>]) % mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= length;i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= i;j++) Inc(c[i], (LL)val[i - j] * g[j] % mod);</span><br><span class="line">        Delta(g, dg, length), Delta(c, dc, length);</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c1 = <span class="number">0</span>, d = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;i++) Inc(a, dc[i]), Inc(d, dg[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= length;i++) Inc(b, g[i]), Inc(c1, c[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ((LL)a * b % mod - (LL)c1 * d % mod + mod) * Pow((LL)b * b % mod, mod - <span class="number">2</span>) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二次剩余 </tag>
            
            <tag> BSGS </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 多项式 </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.6CTS模拟</title>
      <link href="/2019/05/07/5-6CTS%E6%A8%A1%E6%8B%9F/"/>
      <url>/2019/05/07/5-6CTS%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><p>比昨天简单多了</p><p>昨天的模拟太毒瘤，满分$300$，机房最高$30$</p><div class="pdfobject-container" data-target="problems.pdf" data-height="500px"></div><h1 id="T1-麻雀"><a href="#T1-麻雀" class="headerlink" title="T1 麻雀"></a>T1 麻雀</h1><p>给出一个数列，要求支持两种操作，第一种是让某个位置加上一个数，第二种是向集合$S$内添加一个区间。每次操作结束之后询问所有在$S$中的区间中和的最大值，保证任意时刻所有位置都不小于$0$</p><p>一种比较显然的做法是将一段区间$[l,r]$看作是二维平面上的一个点，假如我们现在要修改$x$这个位置的值，那么在平面上收到影响的点的范围就是</p><p><img src="https://i.loli.net/2019/05/07/5cd169b3188bc.png" alt="1557227908873"></p><p>注意横坐标是$l$，纵坐标是$r$</p><p>我们考虑哪些点比较优秀</p><p>显而易见地，如果$p$在$q$的左上角，那么$q$这个点就已经没用了，因为修改$p$的时候一定会修改$q$</p><p>由于任意时刻每个点的值都不小于$0$，所以$p$一定不会劣于$q$</p><p>换言之，不存在两个点使得这两个点在对方的二四象限</p><p>我们维护这个有有用的点构成的序列，这些点在分布在各自的一三象限，我们将这些点从左下角到右上角排列</p><p>那么一次修改对应着这个序列的一段区间，也就是区间加</p><p>假如一个区间的时候，我们先找到它在平面上对应的点，如果它的左上角已经有点了，那么这个区间就没用了</p><p>否则我们删除位于它右下角的点，这些点又对应了一段区间</p><p>所以我们需要支持的操作是：区间加、区间删除、插入点、区间最大值</p><p>用<code>splay</code>来维护就好了</p><hr><p>其实还有一种更为简洁的做法</p><p>如果两个区间的左端点相同，那么右端点更靠左的区间显然是没用的</p><p>我们在线段树上维护$n$个数，第$i$个数表示左端点为$i$，右端点最靠右的那个区间，和是多少</p><p>显然有一个性质就是，如果存在两个区间相互包含，那么被包含的那个区间一定不优秀</p><p>那么每次修改的时候，我们找到$x$左边最靠左的位置，满足这个位置的右端点在$x$右边，然后再线段树上修改这个点到$x$的值</p><p>考虑中间的那些点，如果有一个点被修改的区间包含，但是这个点的右端点小于$x$，那么这个区间一定没有左端点位于它左边的区间优秀，我们给它加上数之和，它仍然是不优秀的区间，可以不管它</p><p>所以每次修改就直接区间改就好了</p><p>插入区间$[l,r]$的时候我们就判一下$l$这个位置最靠右的右端点是否小于$r$，如果是的话我们才有必要加上这个区间，并更新$l$右端点的最大值</p><p>所以我们需要维护一个线段树，支持区间修改，单点赋值，以及查询某个点左边第一个右端点大于这个点的位置</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> l, r, mx, tag, mxR;&#125; T[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    T[rt].mx = max(T[rt &lt;&lt; <span class="number">1</span>].mx, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mx);</span><br><span class="line">    T[rt].mxR = max(T[rt &lt;&lt; <span class="number">1</span>].mxR, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mxR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    T[rt &lt;&lt; <span class="number">1</span>].mx += T[rt].tag, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mx += T[rt].tag;</span><br><span class="line">    T[rt &lt;&lt; <span class="number">1</span>].tag += T[rt].tag, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].tag += T[rt].tag, T[rt].tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    T[rt].l = l, T[rt].r = r; <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span>, l, mid), build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> x, <span class="keyword">int</span> type = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type) T[rt].mx = x;</span><br><span class="line">        <span class="keyword">else</span> T[rt].mx += x, T[rt].tag += x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (T[rt].tag) pushdown(rt);</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, start, end, x, type);</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, start, end, x, type);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        T[rt].mxR = max(T[rt].mxR, R);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (T[rt].tag) pushdown(rt);</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, L, R);</span><br><span class="line">    <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, L, R);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T[rt].mxR &lt; x) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (T[rt].l == T[rt].r) <span class="keyword">return</span> T[rt].l;</span><br><span class="line">    <span class="keyword">if</span> (T[rt &lt;&lt; <span class="number">1</span>].mxR &gt;= x) <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span>, x);</span><br><span class="line">    <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tree[N], n, R[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;x &lt;= n;x += x &amp; -x) tree[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">que</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;x;x -= x &amp; -x) res += tree[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"sparrow.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"sparrow.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> q; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q), build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">            add(b, c); <span class="keyword">int</span> pos = query(<span class="number">1</span>, b);</span><br><span class="line">            <span class="keyword">if</span> (~pos &amp;&amp; pos &lt;= b) update(<span class="number">1</span>, pos, b, c);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (R[b] &lt; c) &#123;</span><br><span class="line">            update(<span class="number">1</span>, b, b, que(c) - que(b - <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">            update(<span class="number">1</span>, b, c), R[b] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, T[<span class="number">1</span>].mx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-字符串匹配"><a href="#T2-字符串匹配" class="headerlink" title="T2 字符串匹配"></a>T2 字符串匹配</h1><p>有两个字符串$S,T$，每个位置都是一个字符集，定义两个位置匹配为这两个位置的字符集有交，求$T$在$S$中的所有匹配位置，字符集不会超过$e$</p><p>比较简单的一道题</p><p>直接<code>KMP</code>是不行的，我们考虑这种情况：$ab,bc$有交，$bc,cd$有交，但是$ab,cd$无交，即交是没有传递性的</p><p>那么就只能用<code>FFT</code>来匹配了</p><p>直接匹配的话差异函数不好弄，我们可以枚举每一种交，最多只有$2^5$种情况</p><p>即我们枚举每一种字符集，如果$T$某个位置等于这个字符集，我们记$T_i=1$，如果$S$的某个位置于这个字符集有交，我们记$S_i=1$</p><p>如果某个位置$T_i=0$，那么对于$S$中它匹配的位置的值我们不关心，如果$T_i=1$，那么匹配的位置的$S_j$必须为$1$</p><p>由于我们枚举了所有可能出现的集合，显然$T$中的每个位置我们都会计算到</p><p>那么此时差异函数就呼之欲出了，如果$T$要和$S$从$j$开始的字符串匹配，我们定义$f$为差异函数，$T,S$的长度分别为$n,m$，有</p><script type="math/tex; mode=display">\begin{aligned}f(j)&=\sum_{i=j}^{j+m-1}T_{i-j+1}(T_{i-j+1}-S_{j})\\&=\sum_{i=1}^mT_i^2-T_iS_{i+j-1}\end{aligned}</script><p>把$S$倒过来，然后就可以开始<code>FFT</code>了</p><hr><p>其实这道题可以<code>bitset</code>暴力，而且跑得比<code>FFT</code>快得多</p><blockquote><p><code>FFT</code>求字符串匹配这种东西，只有$n\geq 10^6$时才卡的掉<code>bitset</code></p><p>——zyw</p></blockquote><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RG register</span></span><br><span class="line"><span class="keyword">int</span> r[N * <span class="number">3</span>], Wn[<span class="number">2</span>][<span class="number">20</span>][N * <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>, c = <span class="number">0</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>, c++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (RG <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid)</span><br><span class="line">            <span class="keyword">for</span> (RG <span class="keyword">int</span> j = i, t;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++)</span><br><span class="line">                t = (LL)Wn[type ^ <span class="number">1</span>][c][j - i] * a[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!type) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, inv = Pow(len, mod - <span class="number">2</span>);i &lt; len;i++)</span><br><span class="line">        a[i] = (LL)a[i] * inv % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> S[N], T[N]; </span><br><span class="line"><span class="keyword">bool</span> fail[N]; <span class="keyword">int</span> n, m, A[N * <span class="number">3</span>], B[N * <span class="number">3</span>], len;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    len = <span class="number">1</span>; <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n + m) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>, c = <span class="number">0</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>, c++) &#123;</span><br><span class="line">        Wn[<span class="number">0</span>][c][<span class="number">0</span>] = <span class="number">1</span>, Wn[<span class="number">0</span>][c][<span class="number">1</span>] = Pow(<span class="number">3</span>, (mod - <span class="number">1</span>) / mid); <span class="keyword">int</span> tmp = Wn[<span class="number">0</span>][c][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; mid &gt;&gt; <span class="number">1</span>;i++) Wn[<span class="number">0</span>][c][i] = (LL)Wn[<span class="number">0</span>][c][i - <span class="number">1</span>] * tmp % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>, c = <span class="number">0</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>, c++) &#123;</span><br><span class="line">        Wn[<span class="number">1</span>][c][<span class="number">0</span>] = <span class="number">1</span>, Wn[<span class="number">1</span>][c][<span class="number">1</span>] = Pow(<span class="number">3</span>, mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid); <span class="keyword">int</span> tmp = Wn[<span class="number">1</span>][c][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; mid &gt;&gt; <span class="number">1</span>;i++) Wn[<span class="number">1</span>][c][i] = (LL)Wn[<span class="number">1</span>][c][i - <span class="number">1</span>] * tmp % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>; B[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) A[n - i] = (cur &amp; S[i]) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) B[i] = cur == T[i], tot += B[i] * B[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n;i &lt; len;i++) A[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m + <span class="number">1</span>;i &lt; len;i++) B[i] = <span class="number">0</span>;</span><br><span class="line">    NTT(A, len, <span class="number">1</span>), NTT(B, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) A[i] = (LL)A[i] * B[i] % mod;</span><br><span class="line">    NTT(A, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n - m + <span class="number">1</span>;i++) </span><br><span class="line">        <span class="keyword">if</span> (tot - A[n - i + <span class="number">1</span>] != <span class="number">0</span>) fail[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> input[<span class="number">7</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"ricerca.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"ricerca.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); <span class="keyword">int</span> full = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, input + <span class="number">1</span>); <span class="keyword">int</span> l = <span class="built_in">strlen</span>(input + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= l;j++) S[i] |= <span class="number">1</span> &lt;&lt; (input[j] - <span class="string">'a'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m), pre();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, input + <span class="number">1</span>); <span class="keyword">int</span> l = <span class="built_in">strlen</span>(input + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= l;j++) T[i] |= <span class="number">1</span> &lt;&lt; (input[j] - <span class="string">'a'</span>), full = max(full, input[j] - <span class="string">'a'</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>;s &lt; <span class="number">1</span> &lt;&lt; full;s++) solve(s);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n - m + <span class="number">1</span>;i++) <span class="keyword">if</span> (!fail[i]) cnt++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n - m + <span class="number">1</span>;i++) <span class="keyword">if</span> (!fail[i]) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-图论原题"><a href="#T3-图论原题" class="headerlink" title="T3 图论原题"></a>T3 图论原题</h1><p>是不是原题呢我也不知道</p><p>给出一张图，每个点有两个权值$a_i,b_i$，要求选出一个大小为$k$的连通块，使得这个连通块中$a$的最大值加上$b$的最大值尽量小</p><p>考虑从小到大枚举$a$，我们可以求出满足要求的$b_{max}$的最小值</p><p>一种暴力就是枚举$a$，然后将所有$a_i\leq a$的边按照$b$从小到大排序，做最小生成树，但是这个最小生成树是每次假如一个点以及它连出的所有边</p><p>我们考虑一个原问题的等价问题</p><p>将点权下放到边权，每条边的$a$为它连接的两个点的$a$的最大值，$b$即为两个点$b$的最大值</p><p>最后仍然是$a$的最大值加上$b$的最大值</p><p>我们发现随着$a$的增大，$b_{max}$在单调递减</p><p>那么我们用<code>LCT</code>维护一棵$b$的最小生成树，同时维护满足要求的连通块个数</p><p>考虑加上一条边$u,v$</p><p>如果$u,v$不连通，那么直接连接$u,v$即可</p><p>否则我们断开$u,v$路径上$b$最大的那条边，再连接$u,v$</p><p>注意如果$u,v$就是那条权值最大的边，就不要连接了</p><p>加入一条边后，我们知道连通块变得更大了，那么此时我们可以尝试缩小$b_{max}$</p><p>具体来说，在存在大小大于等于$k$的连通块的情况下，我们依次尝试删去$b$最大的那条边</p><p>如果这条边在之前从未被加入过，我们要保证之后也不会加入这条边，因为这样一定不优秀</p><p>这里判一下每次选出的边的$b$是否大于等于当前的$b_{max}$即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300010</span></span><br><span class="line"><span class="keyword">int</span> fa[N], ch[<span class="number">2</span>][N], mx[N], w[N], sz[N], rev[N], T_sz[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rev</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    swap(ch[<span class="number">0</span>][u], ch[<span class="number">1</span>][u]), rev[u] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> son)</span> </span>&#123;</span><br><span class="line">    fa[u] = f, ch[son][f] = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (u != ch[<span class="number">0</span>][fa[u]] &amp;&amp; u != ch[<span class="number">1</span>][fa[u]]) || !u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">child</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == ch[<span class="number">1</span>][fa[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> w[a] &gt; w[b] ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    sz[u] = sz[ch[<span class="number">0</span>][u]] + sz[ch[<span class="number">1</span>][u]] + <span class="number">1</span> + T_sz[u];</span><br><span class="line">    mx[u] = Max(mx[ch[<span class="number">0</span>][u]], Max(ch[<span class="number">1</span>][u], u));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rev[u]) Rev(ch[<span class="number">0</span>][u]), Rev(ch[<span class="number">1</span>][u]), rev[u] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = fa[u], ff = fa[f], tmp = child(u), tmp1 = child(f);</span><br><span class="line">    <span class="keyword">if</span> (!isroot(f)) connect(u, ff, tmp1);</span><br><span class="line">    fa[u] = ff, connect(ch[tmp ^ <span class="number">1</span>][u], f, tmp), connect(f, u, tmp ^ <span class="number">1</span>), pushup(f), pushup(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> st[N], tot, k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = u, top = <span class="number">0</span>; st[++top] = now;</span><br><span class="line">    <span class="keyword">while</span> (!isroot(now)) st[++top] = now = fa[now];</span><br><span class="line">    <span class="keyword">while</span> (top) pushdown(st[top--]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> f;!isroot(u);rotate(u))</span><br><span class="line">        <span class="keyword">if</span> (!isroot(f = fa[u])) rotate(child(u) ^ child(f) ? u : f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ls = <span class="number">0</span>;u;u = fa[ls = u])</span><br><span class="line">        splay(u), T_sz[u] += sz[ch[<span class="number">1</span>][u]], T_sz[u] -= sz[ls], ch[<span class="number">1</span>][u] = ls, pushup(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    access(u), splay(u), Rev(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    makeroot(u), access(v), splay(v);</span><br><span class="line">    <span class="keyword">if</span> (ch[<span class="number">0</span>][v] != u) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (sz[v] &gt;= k &amp;&amp; sz[u] &lt; k &amp;&amp; sz[v] - sz[u] &lt; k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tot &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        tot--;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sz[v] - sz[u] &gt;= k &amp;&amp; sz[v] &gt;= k) tot++;</span><br><span class="line">    ch[<span class="number">0</span>][u] = fa[ch[<span class="number">0</span>][u]] = <span class="number">0</span>, pushup(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    makeroot(u), access(v), splay(v);</span><br><span class="line">    <span class="keyword">if</span> (fa[u]) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = mx[v]; <span class="keyword">if</span> (tmp == v) <span class="keyword">return</span>;</span><br><span class="line">        splay(tmp), ch[<span class="number">1</span>][tmp] = fa[ch[<span class="number">1</span>][tmp]] = <span class="number">0</span>, pushup(tmp);</span><br><span class="line">        splay(u), splay(v), fa[u] = v, T_sz[v] += sz[u], pushup(v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sz[v] &lt; k &amp;&amp; sz[u] &lt; k &amp;&amp; sz[v] + sz[u] &gt;= k) tot++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sz[v] &gt;= k &amp;&amp; sz[u] &gt;= k) tot--;</span><br><span class="line">    fa[u] = v, T_sz[v] += sz[u], pushup(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 500010</span></span><br><span class="line"><span class="keyword">int</span> ida[M], idb[M], wa[N], wb[N], from[M], to[M], A[M], B[M];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"mincost.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"mincost.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;wa[i], &amp;wb[i]), sz[i] = <span class="number">1</span>, w[i] = wb[i], mx[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;from[i], &amp;to[i]), ida[i] = idb[i] = i;</span><br><span class="line">        A[i] = max(wa[from[i]], wa[to[i]]), B[i] = max(wb[from[i]], wb[to[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ida + <span class="number">1</span>, ida + m + <span class="number">1</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">            <span class="keyword">return</span> A[a] &lt; A[b];</span><br><span class="line">            &#125;);</span><br><span class="line">    sort(idb + <span class="number">1</span>, idb + m + <span class="number">1</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">            <span class="keyword">return</span> B[a] &gt; B[b];</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">2e9</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, cur = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = ida[i];</span><br><span class="line">        <span class="keyword">if</span> (tot &amp;&amp; B[now] &gt; B[idb[cur]]) <span class="keyword">continue</span>;</span><br><span class="line">        link(from[now], to[now]);</span><br><span class="line">        <span class="keyword">while</span> (cur &lt;= n &amp;&amp; cut(from[cur], to[cur])) cur++;</span><br><span class="line">        <span class="keyword">if</span> (tot) res = min(res, A[now] + B[idb[cur]]), <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res &gt; <span class="number">2e9</span>) <span class="built_in">printf</span>(<span class="string">"no solution"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> LCT </tag>
            
            <tag> 多项式 </tag>
            
            <tag> splay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.4省选模拟</title>
      <link href="/2019/05/05/5-4%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/"/>
      <url>/2019/05/05/5-4%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><div class="pdfobject-container" data-target="prob-new.pdf" data-height="500px"></div><h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><p>有一棵树，每条边都有$50\%$的概率被删除，问在所有情况中，这棵树的邻接矩阵的秩的和</p><p>邻接矩阵的秩的含义是在初等行变换后的非自由元数量</p><p>首先有一个性质：树的邻接矩阵的秩等于其最大匹配数乘以$2$</p><p>那么这道题就相当于让我们统计所有情况下的最大匹配数的和乘以$2$</p><p>先考虑一棵给定的树可以用什么方法求最大匹配数</p><p><code>dp</code>是可以的，但是这里我们不能使用<code>dp</code>的方式来推，因为这样不好维护</p><p>那么我们考虑使用贪心的策略：即优先让儿子匹配，如果匹配完了之后这个点还能和儿子匹配就让这个点和那个儿子配对</p><p>也就是要让匹配尽量靠下，儿子能匹配就不要往父亲匹配</p><p>我们可以设<code>dp[u][0/1]</code>表示考虑$u$以及它的子树，$u$这个点是否匹配的方案数</p><p>转移比较显然</p><p>所以这道题的关键还是看出是最大匹配数乘$2$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][N], sz[N], pw[N], ans, n; <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    sz[u] = dp[<span class="number">0</span>][u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next) </span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) &#123;</span><br><span class="line">            dfs(e[i].to, u), sz[u] += sz[e[i].to];</span><br><span class="line">            dp[<span class="number">1</span>][u] = ((LL)dp[<span class="number">1</span>][u] * pw[sz[e[i].to]] + (LL)dp[<span class="number">0</span>][u] * dp[<span class="number">0</span>][e[i].to]) % mod;</span><br><span class="line">            dp[<span class="number">0</span>][u] = (LL)dp[<span class="number">0</span>][u] * (pw[sz[e[i].to] - <span class="number">1</span>] + dp[<span class="number">1</span>][e[i].to]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    ans = (ans + (LL)dp[<span class="number">1</span>][u] * (pw[n - sz[u]] &lt;&lt; <span class="number">1</span>)) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"rank.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"rank.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), pw[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) pw[i] = pw[i - <span class="number">1</span>] * <span class="number">2</span> % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><p>有一个$n$个节点的完全二叉树，$i$的父亲是$\lfloor\frac i2\rfloor$，现在这棵树上又多了$m(m\leq 6)$条边，求简单路径总数</p><p>我们首先考虑这样一个性质：如果$u,v$在树上的路径只有一条，并且中间没有边的端点，那么从这两个点出发，答案相同</p><p>因为对于任意一条路径，我们对这条路径在$u,v$段上的覆盖情况取反，就能得到从另一个点出发的一条合法路径，所以方案数是相等的</p><p>那么我们可以将所有关键点以及它们的祖先提出来，建一棵虚树，虚树上的每个点存一个<code>sz</code>，表示它在原树上的儿子中，不在虚树上的节点的个数</p><p>然后就可以从每个虚树上的点开始暴力<code>dfs</code>，然后分类统计答案，即每个虚树上的点的答案都是这个点以及它的不在虚树上的儿子的答案</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ID;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ID[u]) <span class="keyword">return</span> ID[u];</span><br><span class="line">    <span class="keyword">return</span> ID[u] = ID.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 360</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[N], sz[N], n;</span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    LL res = sz[u]; vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to]) res += dfs(e[i].to);</span><br><span class="line">    <span class="keyword">return</span> vis[u] = <span class="number">0</span>, res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dep</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> tmp = <span class="number">1</span>;;tmp++)</span><br><span class="line">        <span class="keyword">if</span> (u &lt; <span class="number">1</span> &lt;&lt; tmp) <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = dep(u), res = (<span class="number">1</span> &lt;&lt; (tot - now + <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = now + <span class="number">1</span>;i &lt;= tot;i++) u = u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res - max(min(u - n, <span class="number">1</span> &lt;&lt; tot - now), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) sz[u] -= sz[e[i].to], dfs1(e[i].to, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ID.count(u)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != <span class="number">1</span>) adde(idx(u), idx(u &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    link(u &lt;&lt; <span class="number">1</span>), link(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> from[N], to[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"route.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"route.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> m, mxdep; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m), mxdep = dep(n), idx(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;from[i], &amp;to[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = from[i];j;j &gt;&gt;= <span class="number">1</span>) idx(j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = to[i];j;j &gt;&gt;= <span class="number">1</span>) idx(j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : ID) sz[v.second] = get(v.first, mxdep);</span><br><span class="line">    link(idx(<span class="number">1</span>)), dfs1(idx(<span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) adde(idx(from[i]), idx(to[i]));</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : ID) res = (res + dfs(v.second) * sz[v.second]) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><p>有一棵树，每个点都有权值，定义一个点$u$的价值为$\sum\limits_{i=1}^nw_idis(i,u)^{\frac{3}{2}}$，找到一个点使得价值最小</p><p>我们先考虑一个序列上的情况</p><p>假设有一排点$a_1,a_2,\cdots,a_n$</p><p>我们先钦定一个端点$p$</p><p>如果你有一个指针，从$a_1$扫到$a_n$</p><p>那么得到的$w_pf(p,a_i)$是一个凸函数</p><p>我们现在固定另一个端点，让$p$动起来</p><p>我们会得到很多凸函数的叠加，而这些凸函数的叠加仍然是凸函数</p><p>所以这个序列上的$g$也是凸的</p><p>在一个序列上，我们可以使用二分</p><p>放在树上，就可以使用点分治</p><p>具体来说，对于点分树上$u$的每个儿子，找到$g$比$g(u)$小的那个$v$，移动到$v$去，直到不能移动为止</p><p>代码就咕了</p><h1 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h1><p>有一个离散随机变量$x$，最开始它有$p_i$的概率为$i$</p><p>现在要对$x$进行$m$次操作，每次会将$x$等概率变成$[1,x]$中的一个整数</p><p>问最后$x$变成每个数的概率</p><p>很妙的一道题</p><p>我们考虑一开始$x$的概率生成函数$f(x)$</p><p>此时$x^i$的系数就是$p_i$</p><p>考虑一次操作之后它变成了什么，我们假设一次操作之后的概率生成函数是$f^*(x)$</p><p>那么显然有</p><script type="math/tex; mode=display">\begin{aligned}\[x^i]f^\*(x)&=\sum_{j=i}^n\frac{[x^j]f(x)}{j+1}\\\f^\*(x)&=\sum_{i=0}^nx^i\sum_{j=i}^n\frac{[x^j]f(x)}{j+1}\\\&=\sum_{j=0}^n\frac{[x^j]f(x)}{j+1}\sum_{i=0}^jx^i\\\&=\sum_{j=0}^n\frac{[x^j]f(x)}{j+1}\frac{x^{j+1}-1}{x-1}\\\&=\frac{1}{x-1}\sum_{j=0}^n[x^j]f(x)\frac{x^{j+1}-1}{j+1}\end{aligned}</script><p>注意到</p><script type="math/tex; mode=display">\frac{x^{j+1}-1}{j+1}=[\frac{t^{j+1}}{j+1}]_1^x=\int_1^xt^j\mathrm{d}t</script><p>所以</p><script type="math/tex; mode=display">\begin{aligned}f^\*(x)&=\frac{1}{x-1}\sum_{j=0}^n[x^j]f(x)\int_1^xt^j\mathrm{d}t\\\&=\frac{1}{x-1}\int_1^x\sum_{j=0}^n[x^j]f(x)t^j\mathrm{d}t\\\&=\frac{1}{x-1}\int_1^xf(t)\mathrm{d}t\end{aligned}</script><p>现在很不爽的一点是积分是从$1$开始积的，而且前面分数的分母是$x-1$而不是$x$，我们要把这个弄掉</p><p>考虑设$g(x)=f(x+1),g^*(x)=f^*(x+1)$</p><p>那么有</p><script type="math/tex; mode=display">g^\*(x)=f^\*(x+1)=\frac{1}{x}\int_1^{x+1}f(t)\mathrm{d}t=\frac{1}{x}\int_0^xg(t)\mathrm{d}t</script><p>分析一些最后那个</p><p>设</p><script type="math/tex; mode=display">g(x)=\sum_{i=0}^na_ix^i</script><p>那么</p><script type="math/tex; mode=display">\begin{aligned}\frac{1}{x}\int_0^xg(t)\mathrm{d}t&=\frac{1}{x}\int_0^x\sum_{i=0}^na_it^i\mathrm{d}t\\\&=\frac{1}{x}\sum_{i=0}^n\int_0^xa_it^i\mathrm{d}t\\\&=\frac{1}{x}\sum_{i=0}^n[\frac{a_i}{i+1}t^{i+1}]_0^x\\\&=\frac{1}{x}\sum_{i=0}^n\frac{a_i}{i+1}x^{i+1}\\\&=\sum_{i=0}^n\frac{a_i}{i+1}x^i\end{aligned}</script><p>所以我们知道</p><script type="math/tex; mode=display">[x^i]g^\*(x)=\frac{[x^i]g(x)}{i+1}</script><p>这是经过一次变换之后的结果，如果我们进行$m$次变换，那么可以得到</p><script type="math/tex; mode=display">[x^i]g^\*(x)=\frac{[x^i]g(x)}{(i+1)^m}</script><p>现在关键就在于将最开始的$f$变换成$g$，最后再将$g^*$变换成$f^*$</p><p>我们来讨论一下从$f$变成$g$</p><script type="math/tex; mode=display">\begin{aligned} g(x) &=f(x+1) \\\sum_{i=0}^n[x^i]g(x)x^i&=\sum_{i=0}^n[x^i]f(x)(x+1)^i\\\sum_{i=0}^n[x^i]g(x)x^i&=\sum_{i=0}^n[x^i]f(x)\sum_{k=0}^i\begin{pmatrix}i\\ k\end{pmatrix}x^k\\[x^i]g(x)&=\sum_{k=0}^i\begin{pmatrix}i\\ k\end{pmatrix}[x^k]f(x)\\i![x^i]g(x)&=\sum_{k=0}^n\frac{k![x^k]f(x)}{(k-i)!}\end{aligned}</script><p>从$g$变成$f$差不多</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">250010</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> r[N * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, t, w = <span class="number">1</span>;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w = (LL)w * Wn % mod)</span><br><span class="line">                t = (LL)w * a[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!type) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, inv = Pow(len, mod - <span class="number">2</span>);i &lt; len;i++)</span><br><span class="line">        a[i] = (LL)a[i] * inv % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N], A[N * <span class="number">4</span>], B[N * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"random.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"random.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n; LL m; <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>, &amp;n, &amp;m), frac[<span class="number">0</span>] = <span class="number">1</span>, m %= mod - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    inv[n] = Pow(frac[n], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) inv[i] = (LL)inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]), A[i] = (LL)A[i] * frac[i] % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) B[n - i] = inv[i];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n * <span class="number">2</span>) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    NTT(A, len, <span class="number">1</span>), NTT(B, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) A[i] = (LL)A[i] * B[i] % mod;</span><br><span class="line">    NTT(A, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) A[i] = A[i + n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>;i &lt; len;i++) A[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) A[i] = (LL)A[i] % mod * Pow(Pow(i + <span class="number">1</span>, m), mod - <span class="number">2</span>) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>;i &lt; len;i++) B[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) B[n - i] = i &amp; <span class="number">1</span> ? mod - inv[i] : inv[i];</span><br><span class="line">    NTT(A, len, <span class="number">1</span>), NTT(B, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) A[i] = (LL)A[i] * B[i] % mod;</span><br><span class="line">    NTT(A, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, (LL)A[i + n] * inv[i] % mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 多项式 </tag>
            
            <tag> 点分治 </tag>
            
            <tag> 虚树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性规划</title>
      <link href="/2019/04/28/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
      <url>/2019/04/28/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是线性规划"><a href="#什么是线性规划" class="headerlink" title="什么是线性规划"></a>什么是线性规划</h1><blockquote><p>实际生活中有很多问题都是这样的形式：它们需要最大化或者最小化一个目标；它们通常面临资源、时间等多方面的限制。假如把这些问题的目标简化成一个线性的函数，把限制表示成一些线性的等式或者不等式，那么这些问题就可以被描述成线性规划问题。</p><p>——2016国家集训队论文集</p></blockquote><p>在线性规划中，我们有$n$个变量$x_1,x_2,\cdots, x_n$</p><p>我们希望一个估价函数$f(x_1, x_2,x_3,\cdots,x_n)$尽量大/小</p><p>同时我们希望这些变量能满足一些线性等式或者不等式$g(x_1,x_2,x_3,\cdots,x_n)$</p><p>那么这个过程就叫线性规划</p><h1 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h1><ul><li><strong>线性函数</strong></li></ul><p>我们定义函数$f(x_1,x_2,x_3,\cdots,x_n)$为线性函数当且仅当有</p><script type="math/tex; mode=display">f(x_1,x_2,\cdots,x_n)=\sum_{i=1}^na_ix_i</script><p>其中$a_i$为实数常量，$x_i$为变量</p><ul><li><strong>线性等式</strong></li></ul><p>定义线性等式为$f(x_1,x_2,\cdots,x_n)=b$，其中$f$是线性函数，$b$是实数常量</p><ul><li><strong>线性不等式</strong></li></ul><p>定义线性不等式为$f(x_1,x_2,\cdots,x_n)\leq b$或者$f(x_1,x_2,\cdots,x_n)\geq b$，其中$f$是线性函数，$b$是实数常量</p><h1 id="标准型线性规划"><a href="#标准型线性规划" class="headerlink" title="标准型线性规划"></a>标准型线性规划</h1><p>标准型线性规划要求满足如下形式</p><p>最<strong>大</strong>化</p><script type="math/tex; mode=display">\sum_{i=1}^nc_ix_i</script><p>满足约束</p><script type="math/tex; mode=display">\begin{aligned}\sum_{j=1}^na_{ij}x_j&\leq b_i\quad\quad i=1,2,\cdots,m\\\x_i&\geq 0 \quad\quad \ i=1,2,\cdots, n\end{aligned}</script><ul><li>那么问题来了，如果某个限制不是$\sum a_ix_i\leq b$，而是$\sum a_ix_i\geq b$，怎么办？</li></ul><p>等式两边同时乘以一个负号，就可以变成小于等于</p><ul><li>那如果是要求估价函数最小呢？</li></ul><p>将所有的$c_i$取反，最后再将答案取反</p><ul><li>如果有一个限制是$\sum a_ix_i=b$怎么办？</li></ul><p>将其拆成两个限制，$\sum a_ix_i\geq b$以及$\sum a_ix_i\leq b$</p><ul><li>如果有一个变量$x$没有要求其$\geq 0$呢</li></ul><p>将其拆成两个变量$a,b$，令$x=a-b$，再令$a\geq 0,b\geq 0$即可</p><p>标准型还可以用矩阵表示</p><p>如果我们用$c$表示$c_i$构成的行向量，$A$为$a$构成的矩阵，那么它等价于</p><p>最大化</p><script type="math/tex; mode=display">c^Tx</script><p>满足约束</p><script type="math/tex; mode=display">\begin{gathered}Ax\leq b\\x\geq 0\end{gathered}</script><p>其中$c^T$表示矩阵转置</p><p>注意这里的$\leq,\geq$代表每一维都小于等于/大于等于</p><h1 id="松弛型线性规划"><a href="#松弛型线性规划" class="headerlink" title="松弛型线性规划"></a>松弛型线性规划</h1><p>如果直接求解标准型线性规划，涉及到乘法不等式变号的问题，而且满足的是不等式也不太好做</p><p>我们把它转化一下</p><p>我们新引入$m$个变量（$m$是约束个数，$n$是未知数个数）</p><p>对于限制</p><script type="math/tex; mode=display">\sum_{i=1}^na_ix_i\leq b,x_i\geq 0</script><p>我们利用一个新的变量$x_{i+n}$，可以将它变成</p><script type="math/tex; mode=display">\begin{gathered}b-\sum_{i=1}^na_ix_i=x_{i+n}\\ x_{i+n}\geq 0,x_i\geq 0\end{gathered}</script><p>这样就可以将不等式转化为等式了</p><p>所以我们这样表示松弛型线性规划：</p><p>最大化</p><script type="math/tex; mode=display">\sum_{i=1}^nc_ix_i</script><p>满足约束</p><script type="math/tex; mode=display">\begin{aligned}x_{i+n}&=b_i-\sum_{j=1}^na_{ij}x_j\quad\quad i=1,2,\cdots,m\\x_j&\geq 0,x_{i+n}\geq 0\quad\quad\ \ \ i=1,2,\cdots,m\end{aligned}</script><p>我们将$x_i(i\leq n)$叫做<strong>非基变量</strong>，$x_{i+n}$叫做<strong>基变量</strong></p><p>可以看出，标准型线性规划可以很方便地转移成松弛型线性规划</p><h1 id="单纯形"><a href="#单纯形" class="headerlink" title="单纯形"></a>单纯形</h1><p>显然最终解所构成的区域一定是一个凸集，局部最优解只有一个</p><p>所以我们可以使用类似爬山算法的方法，每次往估价函数更优的那个方向爬，直到爬不动为止</p><p>我们首先来尝试构造一组基本解，即先满足所有约束，不管估价函数</p><p>如果所有的$b$都大于等于$0$，那么显然有一组解为所有的非基变量都为$0$，否则接下来会讲</p><p>我们将这个解进行“转轴”操作，使其往估价函数更优的那一方移动</p><h2 id="转轴操作"><a href="#转轴操作" class="headerlink" title="转轴操作"></a>转轴操作</h2><p>我们默认，任意时刻，非基变量的值都为$0$</p><p>一次转轴操作，等价于将一个基变量与一个非基变量<strong>交换位置</strong>，即基变量变成非基变量，非基变量变成基变量</p><p>我们假设选择了一个基变量$x_B$与一个非基变量$x_N$，现在要交换它们</p><p>原来的约束是这样的</p><script type="math/tex; mode=display">x_B=b-\sum_{i=1}^na_ix_i</script><p>我们将$x_N$提出来，然后移项</p><script type="math/tex; mode=display">\begin{gathered}x_B=b-\sum_{i\not =N}a_ix_i-a_Nx_N\\x_N=\frac{b-\sum_{i\not= N}a_ix_i-x_B}{a_N}\end{gathered}</script><p>注意！此时的$x_B$变成了$0$，因为它从一个基变量变成了一个非基变量，而$x_N$的值变成了$\frac{b}{a_N}$</p><p>由于我们之前是<strong>交换</strong>基变量与非基变量，所以在等式中，$x_N$这一项的系数变成了$-\frac{1}{a_N}$，而其它项的系数分别除以了$a_N$</p><p>我们用这条新的等式代替原来的等式，然后再用这条等式去替换其它的约束以及估价函数</p><p>就像高斯消元一样，将其它式子带有$x_N$的项改为这个式子</p><p>所以转一次的时间复杂度为$O(nm)$</p><p>那么如何选择要进行操作的两个变量呢</p><p>显然我们必须满足条件：</p><ol><li>转完之后估价函数必须更优秀</li><li>转完之后等式右边的$b$不能小于$0$</li></ol><p>我们先考虑第一个条件</p><p>在转轴的过程中，$x_N$从原来的$0$变成了一个实数，它在一直变大，所以为了让答案更大，必须有$c_N&gt; 0$</p><p>否则当前已经是最优解，退出</p><p>接着考虑第二个条件</p><p>对于一个等式</p><script type="math/tex; mode=display">x_{i+n}=b-\sum_{i=1}^na_ix_i</script><p>它限制了$x_N$的上界或者下界</p><p>如果$a_N\leq0$，那么它无法限制$x_N$的上界，答案为无穷大</p><p>否则$x_N$的上界为$\frac{b}{a_N}$</p><p>为了让转轴之后，其它的等式的常数都大于等于$0$</p><p>我们每次选择$\frac{b}{a_N}$最小的那一个进行转轴操作即可</p><hr><p>代码如下</p><p>注意<code>s[...][n + 1]</code>存的是$b$，也就是那个约束的基变量，其它位置存的是每一项的系数，第一维表示第几个约束</p><p>这里的系数算上了前面那个负号</p><p><code>c</code>是估价函数，<code>c[n + 1]</code>是这个估价函数当前的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pivot</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="comment">// 转轴操作, x为未知数, y为第几个方程</span></span><br><span class="line">    <span class="keyword">double</span> tmp = s[y][x]; s[y][x] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n + <span class="number">1</span>;i++) s[y][i] /= -tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="keyword">if</span> (i != y) &#123;</span><br><span class="line">        tmp = s[i][x], s[i][x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (tmp &lt;= eps &amp;&amp; tmp &gt;= -eps) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n + <span class="number">1</span>;j++) s[i][j] += tmp * s[y][j]; </span><br><span class="line">    &#125;</span><br><span class="line">    tmp = c[x], c[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n + <span class="number">1</span>;i++) c[i] += tmp * s[y][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">LP</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="comment">// n为未知数的个数, m为方程数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pos, cur;;pivot(pos, cur, n, m)) &#123;</span><br><span class="line">        <span class="keyword">double</span> tmp = <span class="number">1e100</span>; pos = cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span> (c[i] &gt; eps) pos = i;</span><br><span class="line">        <span class="keyword">if</span> (!pos) <span class="keyword">return</span> c[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="keyword">if</span> (s[i][pos] &lt; -eps) &#123;</span><br><span class="line">            <span class="keyword">double</span> now = s[i][n + <span class="number">1</span>] / -s[i][pos];</span><br><span class="line">            <span class="keyword">if</span> (now &lt; tmp) tmp = now, cur = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!cur) <span class="keyword">return</span> <span class="number">1e100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<strong>线性规划的时间复杂度最坏情况下是指数级别的</strong></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>我们来讨论一下当存在$b_i&lt;0$的时候该怎么做</p><p>显然这个时候我们之前选择的非基向量等于$0$的解就不满足条件了</p><p>我们随便找到一个$b&lt;0$的约束，比如是这个</p><script type="math/tex; mode=display">x_{t+n}=b_t-\sum_{j=1}^na_{tj}x_j</script><p>我们从这个约束中，随便找到一个系数（注意算上前面那个负号）大于$0$的变量，假设是$x_B$</p><p>进行一次转轴操作，将$x_B$换成基变量，将$x_{t+n}$换成非基变量</p><script type="math/tex; mode=display">x_B=\frac{b_t-\sum_{j\not =B}a_{tj}x_j-x_{t+n}}{a_{tB}}</script><p>由于之前我们要求了$x_B$的系数必须为正，也就是说$a_{tB}$为负</p><p>而$b_t$为负，那么转轴之后这个约束的$b$就变成正的了</p><p>如果我们找不到这样一个系数为正的非基变量，那么原线性规划一定无解</p><p>因为所有的变量都必须不小于$0$，因此这个约束的右边一定小于$0$，无解</p><p>注意这样转一次轴之后，虽然这个约束的$b$变成正的了，但是其它约束的$b$可能就变成负数了</p><p>但是没关系，我们有信仰，<code>while (1)</code>转轴就可以了，直到所有约束的$b$都变成正数</p><p>即使这样时间复杂度是玄学的</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">233</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;++i) <span class="keyword">if</span>(a[i][n + <span class="number">1</span>] &lt; <span class="number">0</span> &amp;&amp;(!r || rand() &amp; <span class="number">1</span>)) r = i;</span><br><span class="line">        <span class="keyword">if</span> (!r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) <span class="keyword">if</span>(a[r][i] &gt; <span class="number">0</span> &amp;&amp; (!c || rand() &amp; <span class="number">1</span>)) c = i;</span><br><span class="line">        <span class="keyword">if</span> (!c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pivot(r, c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>true</code>代表初始化成功，否则代表初始化失败，线性规划无解</p><h2 id="最终解"><a href="#最终解" class="headerlink" title="最终解"></a>最终解</h2><p>如果要求求出每个变量的值，那么我们可以开个数组存一下每个变量被转到哪里去了</p><p>如果这个变量变成了一个基变量，那么它的值等于约束右边的$b$</p><p>否则这个变量就是$0$</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>最坏情况下的时间复杂度是指数级别的</p><p>但是我们有信仰，随机情况下还是很优秀的</p><p>大部分时可以过$n,m=100-500$的数据</p><h1 id="将问题表示为线性规划"><a href="#将问题表示为线性规划" class="headerlink" title="将问题表示为线性规划"></a>将问题表示为线性规划</h1><h2 id="某个题"><a href="#某个题" class="headerlink" title="某个题"></a>某个题</h2><p>$A,B$两个人在洞中发现了$n$个石头，第$i$个石头对于$A$来说价值为$A_i$，对于$B$来说价值为$B_i$，石头是可以切割的，并且价值与其体积成正比。现在$A,B$要分配这些石头，要求它们两个人最终得到的价值相同，问这个价值最大可以是多少</p><p>$n\leq 50, 0\leq A_i,B_i\leq 100$</p><p>对于每块石头我们开一个变量$x_i$，表示这块石头有多少分给了$A$，显然有$0\leq x_i\leq 1$</p><p>那么两个人得到的价值之和分别为</p><script type="math/tex; mode=display">\begin{gathered}V_A=\sum_{i=1}^nx_iA_i\\V_B=\sum_{i=1}^n(1-x_i)B_i\end{gathered}</script><p>约束为$V_A=V_B$，要求最大化$V_A$</p><p>这里我们可以使用一个小技巧，即将约束改为$V_A\leq V_B$，最大化$V_A$，可以发现这是与原来的约束完全等价的</p><p>因为假如有一个解满足$V_A\ne V_B$，那么我们一定可以通过将某个变量$x$调大的方式使得$V_A$变得更大，那么这个解一定不是最优解</p><p>因此约束为</p><script type="math/tex; mode=display">\begin{gathered}V_A\leq V_B\Rightarrow \sum_{i=1}^nx_iA_i\leq \sum_{i=1}^n(1-x_i)B_i\\\sum_{i=1}^nx_i(A_i+B_i)\leq\sum_{i=1}^nB_i\end{gathered}</script><p>注意到$\sum B_i\geq 0$，因此不需要运行初始化，直接求解即可</p><h2 id="最大流问题"><a href="#最大流问题" class="headerlink" title="最大流问题"></a>最大流问题</h2><p>在原来的最大流问题中，除了源点、汇点外的每个点必须满足流入流量等于流出流量</p><p>我们新建一条从汇点连向源点，并且权值为$\infty$的边。</p><p>那么最终这条边的流量也就是源点到汇点的流量</p><p>用$f(u,v)$表示一条边的实际流量，$c(u,v)$表示一条边的流量，那么可以得到如下的线性规划</p><p>最大化</p><script type="math/tex; mode=display">f(t,s)</script><p>满足约束</p><script type="math/tex; mode=display">\begin{gathered}f(u,v)\leq c(u,v) \quad\quad (u,v)\in E\\\sum_vf(u,v)=\sum_vf(v,u)\quad \quad u\in V\\f(u,v)\geq 0\quad\quad (u,v)\in E\cup|(t,s)|\end{gathered}</script><h2 id="最小费用流问题"><a href="#最小费用流问题" class="headerlink" title="最小费用流问题"></a>最小费用流问题</h2><p>此时就不需要在汇点和源点之间新建边了</p><p>我们用$w(u,v)$代表一条边的费用，那么可以得出如下线性规划</p><p>最小化</p><script type="math/tex; mode=display">\sum f(u,v)w(u,v)\quad\quad (u,v)\in E</script><p>满足约束</p><script type="math/tex; mode=display">\begin{gathered}\sum_vf(u,v)=\sum_{v}f(v,u)\quad \quad(u,v)\in E,v\not= s,t\\f(u,v)\leq c(u,v)\quad\quad (u,v)\in E\\f(u,v)\geq 0\quad\quad(u,v)\in E\end{gathered}</script><h1 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h1><p>我们考虑这样一个线性规划</p><p>最<strong>小</strong>化</p><script type="math/tex; mode=display">7x_1+x_2+5x_3</script><p>满足约束</p><script type="math/tex; mode=display">\begin{gathered}x_1-x_2+3x_3\geq 10\\5x_1+2x_2-x_3\geq 6\\x_{1,2,3}\geq 0\end{gathered}</script><p>普通线性规划要求最大化，而这里要求最小化</p><p>普通线性规划的约束是小于等于，而这里是大于等于</p><p>我们当然可以选择将约束左右两边同时乘以$-1$，但是这样就需要初始化</p><p>这里有另一种方法——转对偶问题</p><p>由于$x_{1,2,3}\geq 0$，我们知道$7x_1+x_2+5x_3\geq x_1-x_2+3x_3\geq 10$</p><p>那么我们就知道了最终答案的一个下界，能不能找到一个更紧的下界呢？</p><p>能，比如</p><script type="math/tex; mode=display">7x_1+x_2+5x_3\geq(x_1-x_2+3x_3)+(5x_1+2x_2-x_3)=10+6</script><p>于是我们有了一个奇妙的想法</p><p>对于每一个约束我们单独开一个变量，对于第$i$个约束的变量为$y_i$</p><p>我们用$y$来表示在最终的下界中，每个约束所乘的系数</p><p>比如上面的那个就可以表示为</p><script type="math/tex; mode=display">y_1(x_1-x_2+3x_3)+y_2(5x_1+2x_2-x_3)</script><p>我们需要保证，对于每个变量$x_i$，通过这种方式表示出来的系数不超过估价函数中$x_i$的系数，否则我们就无法保证求出的是下界</p><p>同时我们需要最大化下界</p><p>那么我们可以得出如下的线性规划</p><p>最大化</p><script type="math/tex; mode=display">10y_1+6y_2</script><p>满足约束</p><script type="math/tex; mode=display">\begin{gathered}y_1+5y_2\leq 7\\-y_1+2y_2\leq 1\\3y_1-y_2\leq 5\\y_{1,2}\geq 0\end{gathered}</script><p>求解这个线性规划，我们就能得到原估价函数的下界</p><p>我们将新得到的线性规划为对偶问题，如果对这个对偶问题再次进行对偶操作，那么我们会得到原问题</p><p>一个最大化问题可以对偶成最小化问题，同样一个最小化问题可以对偶成最大化问题</p><hr><p>下面给出对偶线性规划的定义</p><p>对于原式线性规划</p><p>最小化</p><script type="math/tex; mode=display">\sum_{i=1}^nc_ix_i</script><p>满足约束</p><script type="math/tex; mode=display">\begin{gathered}\sum_{j=1}^na_{i,j}x_j\geq b_j\quad\quad i=1,2,\cdots, m\\x_i\geq 0\quad\quad i=1,2,\cdots,m\end{gathered}</script><p>它的对偶问题为</p><p>最大化</p><script type="math/tex; mode=display">\sum_{i=1}^mb_iy_i</script><p>满足约束</p><script type="math/tex; mode=display">\begin{gathered}\sum_{j=1}^ma_{ij}y_j\leq c_i\quad\quad i=1,2,\cdots,n\\y_i\geq 0\quad\quad i=1,2,\cdots n\end{gathered}</script><p>用矩阵可以表示为</p><script type="math/tex; mode=display">\begin{cases}最大化\ c^Tx\\满足约束\ Ax\geq b,x\geq 0\end{cases}\longleftrightarrow\begin{cases}最大化\ b^Ty\\满足约束\ A^Ty\leq c,y\geq 0\end{cases}</script><p>同样，$A^T$表示矩形转置</p><h1 id="几个重要定理"><a href="#几个重要定理" class="headerlink" title="几个重要定理"></a>几个重要定理</h1><h2 id="定理1-线性规划弱对偶性"><a href="#定理1-线性规划弱对偶性" class="headerlink" title="定理1. 线性规划弱对偶性"></a>定理1. 线性规划弱对偶性</h2><blockquote><p>若$X=(x_1,x_2,\cdots,x_n)$是原问题的一个可行解，$Y=(y_1,y_2,\cdots,y_m)$是对偶问题的一个可行解，那么</p><script type="math/tex; mode=display">\sum_{i=1}^mb_iy_i\leq\sum_{j=1}^nc_jx_j</script></blockquote><p><del>其实我觉得挺显然的</del></p><p>证明：</p><p>由于$Y$是对偶问题的一个可行解，所以</p><script type="math/tex; mode=display">c_j\geq\sum_{i=1}^ma_{ij}y_i</script><p>由于有$x_i\geq 0$，所以</p><script type="math/tex; mode=display">\sum_{j=1}^nc_jx_j\geq\sum_{j=1}^n(\sum_{i=1}^ma_{ij}y_i)x_j</script><p>由于$X$是原问题的一个可行解，所以</p><script type="math/tex; mode=display">b_j\leq\sum_{i=1}^na_{ji}x_i</script><p>由于有$y_i\geq 0$，所以</p><script type="math/tex; mode=display">\sum_{i=1}^m(\sum_{j=1}^na_{ij}x_j)y_i\geq \sum_{i=1}^mb_iy_i</script><p>我们知道</p><script type="math/tex; mode=display">\sum_{j=1}^n(\sum_{i=1}^ma_{ij}y_i)x_j=\sum_{i=1}^m(\sum_{j=1}^na_{ij}x_j)y_i</script><p>所以结论成立</p><h2 id="定理2-线性规划对偶性"><a href="#定理2-线性规划对偶性" class="headerlink" title="定理2. 线性规划对偶性"></a>定理2. 线性规划对偶性</h2><blockquote><p>若$X^{\times }=(x_1,x_2,\cdots,x_n)$是原问题的最优解，$Y^{\times }=(y_1,y_2,\cdots,y_m)$是对偶问题的最优解，那么</p><script type="math/tex; mode=display">\sum_{i=1}^mb_iy_i=\sum_{j=1}^nc_jx_j</script></blockquote><p><strong>引理</strong>： 设$I$是一个下标集合，对于每一个$j\in I$，设$\alpha_j,\beta_j$是实数，并令$x_j$是一个实数变量，设$\gamma$是任意的实数。假设对于变量$x_j$的任意设置，我们有</p><script type="math/tex; mode=display">\sum_{j\in I}\alpha_jx_j=\gamma+\sum_{j\in I}\beta_jx_j</script><p>那么对于任意的$j\in I,\alpha_j=\beta_j$，且$\gamma=0$</p><p><strong>证明</strong>：因为上式对于任意的$x_j$都成立，那么我们可以通过代入一些特殊值的方式求出$\gamma,\alpha,\beta$。比如令所有的$x$都为$0$，那么我们可以得到$\gamma=0$，对于$j$，我们令$x_j=1,x_k=0(k\ne j)$，那么我们可以得出$\alpha_j=\beta_j$</p><p>注意这里使用的特殊值仍然满足$x_j\geq 0$</p><hr><p>为了证明这个定理，我们先尝试构造一组对偶问题的解</p><p>定义$N$表示非基变量，$B$表示基变量</p><p>我们假设原问题在经过松弛过后得到的结果为</p><p>最大化</p><script type="math/tex; mode=display">v'+\sum_{j\in N}c'_jx_j</script><p>满足约束</p><script type="math/tex; mode=display">x_i=b'_i-\sum_{j\in N}a'_{ij}x_j\quad\quad i\in B</script><p>我们令</p><script type="math/tex; mode=display">\bar y_i=\begin{cases}-c'_{n+i}&若(n+i)\in N\\0 &其它\end{cases}</script><p>其实就是在原问题求解完毕后，在估价函数中所有非基变量的系数取反</p><p>现在我们开始证明</p><p>定义$\bar x=(\bar x_1,\bar x_2,\cdots,\bar x_n)$为原问题的最优解，$\bar y$为按照上面的方式取得的对偶问题的解</p><p>在最终形态的线性规划中，原问题的估价函数为</p><script type="math/tex; mode=display">z=v'+\sum_{j\in N}c'_j\bar x_j</script><p>对于$j\in B$，我们定义$c’_j=0$</p><p>所以</p><script type="math/tex; mode=display">\begin{aligned}z&=v'+\sum_{j\in N}c'_j\bar x_j+\sum_{j\in B}c'_j\bar x_j\\&=v'+\sum_{i=1}^{n+m}c'_j\bar x_j\end{aligned}</script><p>对于$j\in N$，我们知道$\bar x_j=0$，如果我们将此时的解代入原问题求估价函数，那么会得到同样的结果。所以</p><script type="math/tex; mode=display">\begin{aligned}\sum_{j=1}^nc_j\bar x_j&=v'+\sum_{j=1}^{n+m}c'_j\bar x_j\\&=v'+\sum_{j\in N}c'_j\bar x_j+\sum_{j\in B}c'_j\bar x_j\\&=v'+\sum_{j\in N}(c'_j\times 0)+\sum_{j\in B}(0\times \bar x_j)\\&=v'\end{aligned}</script><p>现在我们要说明之前构造出来的$\bar y$对于对偶线性规划是可行的，并且其估价函数的值$\sum\limits_{i=1}^mb_iy_i$等于$\sum\limits_{j=1}^n c_j\bar x_j$。我们刚刚证明了原问题（第一个松弛型）与最终问题（最后一个松弛型）代入$\bar x$求值是相等的。更一般地，所有松弛型都是等价的意味着对于任意变量集合$x=(x_1,x_2,\cdots,x_n)$，我们有</p><script type="math/tex; mode=display">\sum_{j=1}^nc_jx_j=v'+\sum_{j=1}^{n+m}c'_jx_j</script><p>因此，对于任意的特定值集合$\bar x=(\bar x_1,\bar x_2,\cdots, \bar x_n)$，有</p><script type="math/tex; mode=display">\begin{aligned}\sum_{j=1}^nc_j\bar x_j&=v'+\sum_{j=1}^{n+m}c'_j\bar x_j=v'+\sum_{j=1}^nc'_j\bar x_j+\sum_{j=1}^mc'_{j+n}\bar x_{j+n}\\&=v'+\sum_{j=1}^nc'_j\bar x_j+\sum_{i=1}^m(-\bar y_i)\bar x_{n+i}\\&=v'+\sum_{j=1}^nc'_j\bar x_j+\sum_{i=1}^m(-\bar y_i)(b_i-\sum_{j=1}^na_{ij}\bar x_j)\end{aligned}</script><p>注意，原问题的对偶问题和原问题经过变换后的对偶问题是等价的</p><p>对于原问题的一次变换，其实就是转轴操作，我们可以认为在对偶问题中，我们同步进行了一次转轴操作，最终得到的仍然是对偶问题</p><p>所以这里的$b,a$我们改成$b’,a’$仍然是可以的</p><script type="math/tex; mode=display">\begin{aligned}\sum_{j=1}^nc_j\bar x_j&=v'+\sum_{j=1}^nc'_j\bar x_j-\sum_{i=1}^mb_i\bar y_i+\sum_{i=1}^m\bar y_i\sum_{j=1}^na_{ij}\bar x_j\\&=v'+\sum_{j=1}^nc'_j\bar x_j-\sum_{i=1}^mb_i\bar y_i+\sum_{j=1}^n\bar x_j\sum_{i=1}^ma_{ij}\bar y_i\\&=(v'-\sum_{i=1}^mb_i\bar y_i)+\sum_{j=1}^n(c'_j+\sum_{i=1}^ma_{ij}\bar y_i)\bar x_j\end{aligned}</script><p>根据引理，我们可以得到</p><script type="math/tex; mode=display">\begin{gathered}v'-\sum_{i=1}^mb_i\bar y_i=0\\c'_j+\sum_{i=1}^ma_{ij}\bar y_i=c_j\end{gathered}</script><p>因此，对偶问题的估价函数值与原问题相等，下面我们来说明$\bar y$为对偶问题的可行解</p><p>对于基变量，我们知道$c’=0$</p><p>对于非基变量，我们知道$c’\leq 0$，否则我们可以继续进行松弛操作，使得估价函数的值更加优秀</p><p>因此$c’_j\leq 0,\sum\limits_{i=1}^ma_{ij}\bar y_i\leq c_j$</p><p>满足对偶问题的约束</p><p>因此我们证明了定理2，同时给出了构造对偶问题最优解的一种方法</p><h2 id="定理3-互松弛定理"><a href="#定理3-互松弛定理" class="headerlink" title="定理3. 互松弛定理"></a>定理3. 互松弛定理</h2><blockquote><p>若$X=(x_1,x_2,\cdots,x_n),Y=(y_1,y_2,\cdots,y_n)$分别是原问题及对偶问题的一组可行解，那么$X,Y$都是最优解当且仅当</p><script type="math/tex; mode=display">\begin{gathered}对于所有的1\leq j\leq n,满足x_j=0或\sum_{i=1}^ma_{ij}y_i=c_j\\对于所有的1\leq i\leq m,满足y_i=0或\sum_{j=1}^na_{ij}x_j=b_i\end{gathered}</script></blockquote><p>证明：根据定理2证明中的最后一步</p><script type="math/tex; mode=display">c'_j+\sum_{i=1}^ma_{ij}\bar y_i=c_j</script><p>我们分类讨论：</p><ol><li>$c’_j=0$</li></ol><p>此时也就是$x_j$的系数为$0$，那么$x_j$随意即可，对最终的结果不会造成影响</p><ol><li>$c’_j&lt; 0$</li></ol><p>此时为了要求最终结果最大，必然有$x_j=0$，否则我们可以通过减少$x_j$的值使得结果变大</p><p>对于$y$的证明同理</p><h1 id="对偶的应用"><a href="#对偶的应用" class="headerlink" title="对偶的应用"></a>对偶的应用</h1><h2 id="偷懒"><a href="#偷懒" class="headerlink" title="偷懒"></a>偷懒</h2><p>给一张$n$个点的带权无向图，边$u,v$的权值为$w_{u,v}$，可以随意增加或者减少一条边的边权，代价为边权的变化量。要求进行操作之后任意两点间直接相连的边的长度不超过两点之间的最短路，求最小代价</p><p>$n\leq 10,w\leq 20$</p><p>对于每一条边我们开两个变量$t_{u,v},t’_{u,v}$，表示这条边增加了多少/减少了多少</p><p>那么对于一条边$u,v$，经过操作之后它的边权为$w_{u,v}+t_{u,v}-t’_{u,v}$，令$d_{u,v}$表示操作之后$u,v$两点间的最短路长度</p><p>我们可以得到如下线性规划</p><p>最小化</p><script type="math/tex; mode=display">\sum_{(u,v)\in E}t_{u,v}+t'_{u,v}</script><p>满足约束</p><script type="math/tex; mode=display">\begin{gathered}d_{u,v}\geq w_{u,v}+t_{u,v}-t'_{u,v}\quad\quad (u,v)\in E\\-d_{u,v}\geq -w_{u,v}-t_{u,v}+t'_{u,v}\quad\quad (u,v)\in E\\w_{u,i}+t_{u,i}-t'_{u,i}\geq d_{u,v}-d_{u,i}\quad\quad u\ne v,(u,i)\in E\\\end{gathered}d,t,t'\geq 0</script><p>注意到之间求解需要初始化，而目标函数中的系数都是正的</p><p>所以我们可以将这个线性规划进行对偶，将所有的$b$都变成正数，这样就不需要初始化了</p><h2 id="将线性规划转化为半平面交"><a href="#将线性规划转化为半平面交" class="headerlink" title="将线性规划转化为半平面交"></a>将线性规划转化为半平面交</h2><p>给出三个长度为$n$的数组$a_i,b_i,c_i$，每次询问给出两个数$s,t$，求一组非负实数$x_i$，满足</p><script type="math/tex; mode=display">\sum_{i=1}^na_ix_i=s,\sum_{i=1}^nb_ix_i=t</script><p>同时最大化$\sum\limits_{i=1}^nc_ix_i$，对于每组询问输出最大值或无解</p><p>$n\leq 10^5,a,b,c,s,t,m\leq 10^4$</p><p>注意到每次变化的是限制，而对于目标函数是不变的，这意味着转对偶之后限制是不变的</p><p>那么对初始线性规划我们转一个对偶，然后未知数就变成了两个，限制变成了$n$个，并且是固定的</p><p>此时目标函数变成了$sy_1+ty_2$</p><p>由于初始线性规划的约束是等于，所以转对偶之后对于$y_1,y_2$是否大于$0$没有限制</p><p>这里简单说明一下</p><p>我们考虑一个这样的线性规划</p><p>约束为</p><script type="math/tex; mode=display">\sum_{j=1}^na_{ij}x_i=b_i</script><p>我们可以把它拆成两个</p><script type="math/tex; mode=display">\begin{gathered}\sum_{j=1}^na_{ij}x_i\geq b_i\\-\sum_{j=1}^na_{ij}x_i\geq -b_i\end{gathered}</script><p>现在考虑对偶，我们设第一个限制的未知数为$y_1$，第二个为$y_2$</p><p>那么对偶的限制一定是对$y_1-y_2$的限制</p><p>现在我们将$y_1,y_2$合成一个变量，虽然有$y_1\geq 0,y_2\geq 0$，但是这个新合成的变量$y_1-y_2$却可以小于$0$</p><p>所以此时对偶之后的变量才没有$\geq 0$的限制</p><p>将$y_1$看作$x$，将$y_2$看作$y$，我们可以把约束转化为半平面交的形式</p><p>所以询问的时候直接在凸壳上二分即可</p><h2 id="将线性规划转化为网络流"><a href="#将线性规划转化为网络流" class="headerlink" title="将线性规划转化为网络流"></a>将线性规划转化为网络流</h2><p>给出一个带权的连通无向图，有$n$个点$m$条边，对于每条边，增加$1$的权值需要花费$a_i$，减少$1$的权值需要花费$b_i$，给定一棵生成树，需要通过修改边权使得它成为最小生成树，求最小花费</p><p>考虑一条边为非树边的含义是什么</p><p>如果一条原图上的边$u,v$不在最小生成树上，那么在生成树上它覆盖的所有边的权值都不能小于它</p><p>并且树边一定不会加，非树边一定不会减</p><p>写成线性规划的形式就是</p><p>最小化</p><script type="math/tex; mode=display">\sum_{i\in T}b_ix_i+\sum_{i\in E-T}a_ix_i</script><p>满足约束</p><script type="math/tex; mode=display">\begin{gathered}x_i+x_j\geq w_i-w_j\quad\quad i被j覆盖\\x_i\geq 0\end{gathered}</script><p>首先来转一个对偶</p><p>最大化</p><script type="math/tex; mode=display">\sum_{i\in T,j\in E-T,j覆盖i}(w_i-w_j)y_{ij}</script><p>满足约束</p><script type="math/tex; mode=display">\sum_{j\in E-T,j覆盖i}y_{ij}\leq b_i\quad\quad i\in T\\\sum_{i\in T,j覆盖i} y_{ij}\leq a_i\quad\quad j\in E-T</script><p>我们将$T$中的边放在左边，$E-T$中的边放在右边，可以看出这是一个最大费用流模型，其中$y_{ij}$就是流量</p><p>需要满足对于$T$中的点，每个点的流量不超过$b_i$，对于$E-T$中的点，每个点的流量不超过$a_i$</p><p>如果$j$覆盖$i$，那么我们从$i$向$j$连一条容量无限，费用为$w_i-w_j$的边</p><p>然后在这张图上跑一遍费用流就可以了</p><p>注意这里的费用流不是优先满足最大流，而是优先满足费用最大</p><p><code>dinic</code>的时候如果当前费用小于上次更新时的费用就<code>break</code></p><hr><p>完结撒花</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> 计算几何 </tag>
            
            <tag> 半平面交 </tag>
            
            <tag> 线性规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.24省选模拟</title>
      <link href="/2019/04/25/4-24%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/"/>
      <url>/2019/04/25/4-24%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-密文"><a href="#T1-密文" class="headerlink" title="T1 密文"></a>T1 密文</h1><p><img src="https://i.loli.net/2019/04/25/5cc157597b96f.png" alt="1556174666712"></p><p><img src="https://i.loli.net/2019/04/25/5cc15778b7aa2.png" alt="1556174705013"></p><p>知道密文的每一位，等于知道密文的每一个前缀和，或者任意两个前缀的异或和</p><p>而每次操作得到的其实就是两个前缀和的异或和</p><p>假设这次我们询问了$a,b$这两个前缀，下次询问了$b,c$这两个前缀，那么我们就知道了$a,c$的异或和是多少</p><p>将前缀看作点，如果我们询问了$a,b$这两个前缀，那么我们就用一条权值为询问代价的边将这两个点连接起来</p><p>最优的方案一定是连成了一棵生成树，因为所有非树边都是不必要的，任意两个前缀的异或和等于它们在树上路径所经过边的权值的异或和</p><p>所以这个题就是最小异或和生成树，共$n+1$个节点，即$n+1$个前缀和</p><p>关于最小异或和生成树，可以在<code>trie</code>上分治，每次按照最高位将当前点集分为最高位为0以及最高位为1的两个部分，将这两个部分各自连通，然后用一条权值最小的边连通这两个集合</p><p>我们每次枚举小的那个集合中的所有数，然后放到大的那个集合里面暴力查异或最小值即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="keyword">int</span> trie[N * <span class="number">31</span>][<span class="number">2</span>], sz[N * <span class="number">31</span>], ncnt = <span class="number">1</span>, dep[N * <span class="number">31</span>]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num[N * <span class="number">31</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> now = <span class="number">1</span>, i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> nxt = v &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!trie[now][nxt]) trie[now][nxt] = ++ncnt, dep[ncnt] = dep[now] - <span class="number">1</span>;</span><br><span class="line">        now = trie[now][nxt], sz[now]++, num[now].push_back(v);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; <span class="number">0</span> || !u) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">int</span> t = x &gt;&gt; dep[u] &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (trie[u][t]) <span class="keyword">return</span> query(trie[u][t], x);</span><br><span class="line">    <span class="keyword">return</span> query(trie[u][t ^ <span class="number">1</span>], x) + (<span class="number">1</span> &lt;&lt; dep[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u || dep[u] &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    divide(trie[u][<span class="number">0</span>]), divide(trie[u][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> v = sz[trie[u][<span class="number">0</span>]] &lt; sz[trie[u][<span class="number">1</span>]] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> t = ~<span class="number">0U</span> &gt;&gt; <span class="number">1</span>, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; sz[trie[u][v]];i++) </span><br><span class="line">        t = min(t, query(trie[u][v ^ <span class="number">1</span>], num[trie[u][v]][i]) + (<span class="number">1</span> &lt;&lt; dep[u])), flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag) ans += t;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"secret.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"secret.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), dep[<span class="number">1</span>] = <span class="number">30</span>, insert(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ls = <span class="number">0</span>, i = <span class="number">1</span>, a;i &lt;= n;i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), ls ^= a, insert(ls);</span><br><span class="line">    divide(<span class="number">1</span>), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-最短路"><a href="#T2-最短路" class="headerlink" title="T2 最短路"></a>T2 最短路</h1><p><img src="https://i.loli.net/2019/04/25/5cc1595fac06a.png" alt="1556175190678"></p><p><img src="https://i.loli.net/2019/04/25/5cc1597a52891.png" alt="1556175217309"></p><p>数据太水，本来只能拿30分的算法拿了71分</p><p>对于这$30\%$的数据做法比较简单，建出最短路<code>DAG</code>，然后<code>DAG</code>上的边边权为<code>inf</code>，将每个点拆成两个点，中间连一条权值为1的边，然后跑一遍起点到终点的最大流就可以得出最少需要让多少个点+1才能使得最短路变长</p><p>对于所有数据，我们考虑这样建图</p><p>首先二分答案<code>mid</code>，然后建<code>mid + 1</code>层点，第$i$层的点表示路径长度为$i-1$</p><p>每一层都有$n$个点$s$以及它们的虚点$t$，将每一层的点向那一层中对应的虚点连边，如果是$1,n$号点就连<code>inf</code>，否则连1</p><p>对于第$i$层到第$i+1$层，我们将原图中所有的边连上。比如原图中有一条$u\rightarrow v$的边，那么我们就从这一层的$t_u$向下一层的$s_v$连边，权值为<code>inf</code></p><p>为了保证每个点最多只会被加一次，对于每一层的点$s_i$，我们从它向下一层的$t_i$连一条边，权值为<code>inf</code></p><p>然后需要加的点数就是第一层中$s_1$到最后一层中$t_n$的最大流，这样才能表示答案<strong>大于</strong><code>mid</code></p><p>这样建图的原因是，每在这张图上经过一条原图的边，就会从第$i$层到达第$i+1$层，含义就是路径长度$+1$</p><p>如果我们割掉了某个点$s$到$t$的边，那么所有到达$s$的路径都只能经过$s$到下一层的$t$的这条边，那么相对应地，长度就$+1$</p><p>而这样建图的话，在不同层中多次割掉同一个点$s\rightarrow t$的边是不优秀的，在最大流中选择割掉的那一条边一定是第一次到达这个点的时刻所对应的那条边</p><p>因为无论是否让$u$这个点的权值$+1$，在第$t$时刻到达$u$的路径一定可以在比$t$更晚的时刻到达$u$，所以割掉后面的边是没有好处的，不会出现在最大流中</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;</span><br><span class="line">&#125; e[N * <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt = <span class="number">1</span>, dep[N], cur[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from], w&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to], <span class="number">0</span>&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dep)), dep[s] = <span class="number">0</span>; <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; q.push(s);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next)</span><br><span class="line">            <span class="keyword">if</span> (e[i].w &amp;&amp; dep[e[i].to] == <span class="number">-1</span>) &#123;</span><br><span class="line">                dep[e[i].to] = dep[u] + <span class="number">1</span>, q.push(e[i].to);</span><br><span class="line">                <span class="keyword">if</span> (e[i].to == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == t || !f) <span class="keyword">return</span> f; <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u], tmp; i; i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].w &amp;&amp; dep[e[i].to] == dep[u] + <span class="number">1</span> &amp;&amp; (tmp = DFS(e[i].to, min(f, e[i].w), t))) &#123;</span><br><span class="line">            res += tmp, f -= tmp, e[i].w -= tmp, e[i ^ <span class="number">1</span>].w += tmp;</span><br><span class="line">            <span class="keyword">if</span> (!f) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (BFS(s, t)) <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span>(head)), res += DFS(s, <span class="number">1e9</span>, t);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N]; <span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">ID</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> type, <span class="keyword">int</span> layer)</span> </span>&#123;<span class="keyword">return</span> n * <span class="number">2</span> * layer + n * type + u;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head)), ecnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= mid; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++) &#123;</span><br><span class="line">            adde(ID(j, <span class="number">0</span>, i), ID(j, <span class="number">1</span>, i), j == <span class="number">1</span> ? <span class="number">1e9</span> : <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; mid) adde(ID(j, <span class="number">0</span>, i), ID(j, <span class="number">1</span>, i + <span class="number">1</span>), <span class="number">1e9</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; mid) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[j]) adde(ID(j, <span class="number">1</span>, i), ID(v, <span class="number">0</span>, i + <span class="number">1</span>), <span class="number">1e9</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; mid) adde(ID(n, <span class="number">0</span>, i), ID(n, <span class="number">0</span>, i + <span class="number">1</span>), <span class="number">1e9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Dinic(ID(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), ID(n, <span class="number">0</span>, mid));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"min.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"min.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> m, k; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), a++, b++, G[a].push_back(b), G[b].push_back(a);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">2</span> * n, mid, ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Solve(mid = (l + r) &gt;&gt; <span class="number">1</span>) &lt;= k) ans = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-特技飞行"><a href="#T3-特技飞行" class="headerlink" title="T3 特技飞行"></a>T3 特技飞行</h1><p>题目太长，这里只给出简单的描述</p><p>有$n$架飞机，它们的航线对应着起点在$x=x_0$，终点在$x=x_1$的一条线段，它们的水平速度相同</p><p>当两架飞机相遇的时候，它们可以选择互换航线，获得$b$的分数；或者不交换，获得$a$的分数，但是要保证到达$x=x_1$的时候这些飞机从上到下的顺序仍然是起飞时的顺序</p><p>有$k$个观众，第$i$个观众的位置是$(p_i,q_i)$，观察距离是$r_i$，会查看$|x-p_i|+|y-q_i|\leq r_i$的所有相遇事件</p><p>当一个相遇事件被至少一名观众观察到，那么就可以获得$c$的分数</p><p>输出最终得分的最小值以及最大值</p><p><img src="https://i.loli.net/2019/04/25/5cc15d961a45e.png" alt="1556176268396"></p><p>首先可以看出，$c$是强行拼上去的，跟是否选择互换航线没有任何关系</p><p>那么我们可以算出$c$对答案的最终贡献是什么</p><p>显然对于两条有交点的线段$i,j$，必须满足$y_{i,0}<y_{j,0},y_{i,1}>y_{j,1}$</p><p>扫描线一下，同时使用一个<code>set</code>维护就可以求出所有交点</p><p>题目中给出的那个限制实际上是曼哈顿距离$\leq r$</p><p>那么我们有一个套路就是将坐标$x,y$变换成$x+y,x-y$</p><p>那么限制就变成了$p’-r\leq x’\leq p’+r,q’-r\leq y’\leq q’+r$，对应一个矩形范围</p><p>将所有转换后的坐标离散化，然后从上到下扫描线，用一个树状数组维护每个点的覆盖次数就可以了</p><p>我们再来考虑最终结果的最大/最小值</p><p>首先一定有一种方案是每次相遇都交换，这样最终的相对顺序一定是不变的，产生的要么是最大值，要么是最小值</p><p>另一种方案就是让交换的次数尽量少</p><p>我们考虑如果每次都不交换会发生什么</p><p>最终对应的从上到下的顺序是原顺序的一个置换，我们要让最终顺序等于原顺序</p><p>我们可以进行的操作是，每次选择两个位置，然后交换它们的排名</p><p>这种操作是一定可以成功的，因为我们只需要在这两架飞机相交的时候选择交换位置即可达到交换最终顺序的结果</p><p>所以操作等价于：给出一个置换，每次可以交换其中的任意两个数，问最少步数使得置换变成原排列</p><p>显然对于每一长度为$l$的环，我们只需要交换$l-1$次，那么最少的交换次数就是$n-$环的个数</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Vector Point</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point (<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    Point <span class="keyword">operator</span> + (<span class="keyword">const</span> Vector &amp;b) &#123;<span class="keyword">return</span> Point(x + b.x, y + b.y);&#125;</span><br><span class="line">    Vector <span class="keyword">operator</span> - (<span class="keyword">const</span> Point &amp;b) &#123;<span class="keyword">return</span> Vector(x - b.x, y - b.y);&#125;</span><br><span class="line">    <span class="keyword">double</span> <span class="keyword">operator</span> ^ (<span class="keyword">const</span> Vector &amp;b) &#123;<span class="keyword">return</span> x * b.y - y * b.x;&#125;</span><br><span class="line">    Vector <span class="keyword">operator</span> * (<span class="keyword">double</span> b) &#123;<span class="keyword">return</span> Vector(x * b, y * b);&#125;</span><br><span class="line">&#125; x[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span>Point a, b;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">Inter</span><span class="params">(Line a, Line b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> t = ((b.b - b.a) ^ (a.a - b.a)) / ((a.b - a.a) ^ (b.b - b.a));</span><br><span class="line">    <span class="keyword">return</span> a.a + (a.b - a.a) * t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> id[N], mark[N], t1[N], t2[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;<span class="keyword">if</span> (!mark[u]) mark[u] = <span class="number">1</span>, dfs(id[u]);&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;int, int&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIT set<span class="meta-string">&lt;P &gt;::iterator</span></span></span><br><span class="line"><span class="built_in">set</span>&lt;P &gt; s;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> t2[i] &lt; t2[j];&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> y; <span class="keyword">int</span> x1, x2, op;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Query &amp;b) <span class="keyword">const</span> &#123;<span class="keyword">return</span> y &lt; b.y;&#125;</span><br><span class="line">&#125; q[N];</span><br><span class="line"><span class="keyword">int</span> tree[N * <span class="number">2</span>], top;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;x;x -= x &amp; -x) tree[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;x &lt;= top;x += x &amp; -x) res += tree[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> zjk[N * <span class="number">5</span>]; <span class="keyword">int</span> cnt, watchx[N], watchy[N], r[N], qcnt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(Point i, Point j)</span> </span>&#123;<span class="keyword">return</span> i.x - i.y &lt; j.x - j.y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"aerobatics.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"aerobatics.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n, a, b, c, X1, X2, tot = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d"</span>, &amp;n, &amp;a, &amp;b, &amp;c, &amp;X1, &amp;X2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t1[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t2[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        SIT it = s.lower_bound(P(t2[i], i));</span><br><span class="line">        <span class="keyword">if</span> (it != s.end()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (SIT it2 = it;it2 != s.end();it2++) &#123;</span><br><span class="line">                Line a = (Line)&#123;Point(X1, t1[it2-&gt;second]), Point(X2, t2[it2-&gt;second])&#125;, </span><br><span class="line">                    b = (Line)&#123;Point(X1, t1[i]), Point(X2, t2[i])&#125;;</span><br><span class="line">                x[++tot] = Inter(a, b);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        s.insert(P(t2[i], i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) id[i] = i;</span><br><span class="line">    sort(id + <span class="number">1</span>, id + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span> (!mark[i]) dfs(i), cnt++;</span><br><span class="line">    <span class="keyword">int</span> s1 = tot * a, s2 = (tot - n + cnt) * b + (n - cnt) * a;</span><br><span class="line">    <span class="keyword">if</span> (s1 &gt; s2) swap(s1, s2);</span><br><span class="line">    <span class="keyword">int</span> k; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tot;i++) zjk[++cnt] = x[i].x + x[i].y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;watchx[i], &amp;watchy[i], &amp;r[i]), zjk[++cnt] = watchx[i] + watchy[i] - r[i], zjk[++cnt] = watchx[i] + watchy[i] + r[i];</span><br><span class="line">    sort(zjk + <span class="number">1</span>, zjk + cnt + <span class="number">1</span>), cnt = unique(zjk + <span class="number">1</span>, zjk + cnt + <span class="number">1</span>) - zjk - <span class="number">1</span>, top = cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = lower_bound(zjk + <span class="number">1</span>, zjk + cnt + <span class="number">1</span>, watchx[i] + watchy[i] - r[i]) - zjk, </span><br><span class="line">            b = lower_bound(zjk + <span class="number">1</span>, zjk + cnt + <span class="number">1</span>, watchx[i] + watchy[i] + r[i]) - zjk;</span><br><span class="line">        q[++qcnt] = (Query)&#123;watchx[i] - watchy[i] - r[i], a, b, <span class="number">0</span>&#125;, q[++qcnt] = (Query)&#123;watchx[i] - watchy[i] + r[i] + <span class="number">1e-5</span>, a, b, <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(x + <span class="number">1</span>, x + tot + <span class="number">1</span>, cmp2), sort(q + <span class="number">1</span>, q + qcnt + <span class="number">1</span>); <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, cur = <span class="number">1</span>;i &lt;= qcnt;i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt;= tot &amp;&amp; x[cur].x - x[cur].y &lt; q[i].y) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = lower_bound(zjk + <span class="number">1</span>, zjk + cnt + <span class="number">1</span>, x[cur].x + x[cur].y) - zjk;</span><br><span class="line">            <span class="keyword">if</span> (query(a) &gt;= <span class="number">1</span>) res++;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q[i].op) update(q[i].x2, <span class="number">-1</span>), update(q[i].x1 - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> update(q[i].x2, <span class="number">1</span>), update(q[i].x1 - <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, s1 + c * res, s2 + c * res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T4-吃"><a href="#T4-吃" class="headerlink" title="T4 吃"></a>T4 吃</h1><p><img src="https://i.loli.net/2019/04/25/5cc160fe35890.png" alt="1556177141042"></p><p><img src="https://i.loli.net/2019/04/25/5cc1611bcf07f.png" alt="1556177171716"></p><p>我们考虑这样统计答案：记$E(u,v)$表示当$u$被删除的时候，$v$仍与$u$连通的概率</p><p>那么答案就是</p><script type="math/tex; mode=display">\sum_{i=1}^n\sum_{j=1}^nE(i,j)</script><p>很显然，给出的图是一棵基环树</p><p>我们考虑这两种点对：</p><ul><li>点$u,v$都在同一棵树上</li></ul><p>很显然此时的$E(u,v)=\frac{1}{dis(u,v)}$，因为需要保证$u$是$u,v$这条路径上第一被删除的点</p><p>可以使用点分治+<code>FFT</code>统计每种$dis$的方案数，最后再计算这一类点对的答案</p><ul><li>点$u,v$在不同的树上</li></ul><p>我们假设从$u$到$v$，必须经过的路径长度为$c$</p><p>在环上，$u$的根节点到$v$的根节点显然有两条路径，我们记它们的长度分别为$x,y$</p><p>那么显然，如果在$u$被删除的时候$u,v$仍然连通，那么要么是$c+x$这条路径没有被删除，概率为$\frac{1}{c+x}$，要么是$c+y$这条路径没有被删除，概率为$\frac{1}{c+y}$</p><p>注意此时我们重复统计了这两条路径都没有被删除的概率，为$\frac{1}{c+x+y}$</p><p>所以此时有</p><script type="math/tex; mode=display">E(u,v)=\frac{1}{c+x}+\frac{1}{c+y}-\frac{1}{c+x+y}</script><p>我们考虑如何计算</p><p>首先随便断开环上的一条边，将环变成一条链，然后在链上分治</p><p>设$x$是经过链的路径，$y$是经过被破坏边的路径</p><p>我们选择当前区间的中点，显然从中点或者中点左边到中点右边的$x$路径一定会经过这个中点</p><p>那么我们可以利用这个性质将$x$分成两半，假设两个根节点分别为$u,v$</p><p>分成的这两半即为$u$到中点的路径，减去$v$到中点的路径</p><p>与之前相似，我们同样可以计算每一种$c+x$的方案数，即中点及左边多项式的和，乘上中点右边多项式的和，再加上两边分治的结果</p><p>$c+y$与之类似，注意$c+x+y$是不用分治的，因为$x+y$就是环长</p><p>代码就咕了</p>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> 计算几何 </tag>
            
            <tag> 多项式 </tag>
            
            <tag> Trie </tag>
            
            <tag> 分治 </tag>
            
            <tag> polya </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TopTree</title>
      <link href="/2019/04/23/TopTree/"/>
      <url>/2019/04/23/TopTree/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><code>TopTree</code>可以说是<code>LCT</code>的扩展，<code>LCT</code>支持链上的修改与查询，而<code>TopTree</code>可以支持链与子树的修改与查询</p><p><code>TopTree</code>的思想与<code>LCT</code>及其相似，都是将树进行轻重链剖分。但是与<code>LCT</code>不同的是，<code>TopTree</code>会单独维护某个节点的每个虚子树，而非简单地维护虚子树对当前点的贡献</p><p><code>TopTree</code>的时间复杂度为每次操作$O(\log n)$，但是常数巨大无比，为$97$</p><p>做好码<code>7168+b</code>的准备</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>让我们先从一道<del>神仙</del>题开始</p><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3153" target="_blank" rel="noopener">BZOJ3153</a></p><p>题意：有一棵树，每个点有一个权值，需要支持12个操作</p><ul><li>换根</li><li>路径加/路径覆盖</li><li>子树加/子树覆盖</li><li>查询路径的和/最大值/最小值</li><li>查询子树的和/最大值/最小值</li><li>换父亲</li></ul><h1 id="虚点Splay"><a href="#虚点Splay" class="headerlink" title="虚点Splay"></a>虚点<code>Splay</code></h1><p>对于一个点$u$，在<code>LCT</code>上的<code>splay</code>中我们维护了它的两个儿子</p><p>左儿子代表重链上比它高的节点，右儿子代表重链上比它低的节点</p><p>在<code>TopTree</code>中，每个点我们还要额外维护一个<code>splay</code>，这个<code>splay</code>上挂的点是以虚边的形式与$u$相连的点</p><p>举个例子</p><p><img src="https://i.loli.net/2019/04/23/5cbe6488ac1fd.png" alt="1555981442131"></p><p>图中的实线代表重边，虚线代表轻边</p><p>注意$\{1,4,7\}$单独是一棵<code>splay</code>,即$1$的虚儿子构成的<code>splay</code></p><p>我们称在原树中出现的点为<strong>实点</strong>，在原树中未出现的点为<strong>虚点</strong></p><p>那么在由某个点虚儿子构成的<code>splay</code>中，每一个实点都是<strong>叶子节点</strong>，除根节点外，每个非叶子节点都是<strong>虚点</strong></p><p>另一个例子</p><p><img src="https://i.loli.net/2019/04/23/5cbe66f56612a.png" alt="1555982055658"></p><p>注意到根节点有$4$个虚子树，所以必须新建两个虚点来维护这些虚子树，图中的橙色节点就是虚点，图中的虚边即为虚子树<code>splay</code></p><p>那么每个点我们维护$4$个儿子<code>ch[0 - 3][u]</code>，前两个儿子表示正常<code>LCT</code>中的儿子，即重链<code>splay</code>的左右儿子；后两个儿子表示虚子树中的两个儿子</p><p>显然虚点是没有前两个儿子的</p><h1 id="新的Rotate-Splay"><a href="#新的Rotate-Splay" class="headerlink" title="新的Rotate, Splay"></a>新的<code>Rotate, Splay</code></h1><p>如果一个虚点的<code>splay</code>转到实点里面去了，显然是不行的</p><p>所以对于虚点、实点我们需要单独<code>rotate, splay</code></p><p>注意<code>splay</code>时无论当前点是否为根节点，我们都要<code>pushup</code>一次</p><p>所以<code>rotate</code>的时候改一改，再在<code>splay</code>的最后加上一次<code>pushup</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> son)</span> </span>&#123;<span class="keyword">if</span> (u) fa[u] = f; ch[son][f] = u;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = fa[u], tmp = (ch[type + <span class="number">1</span>][f] == u) + type, ff = fa[f];</span><br><span class="line">    <span class="keyword">if</span> (ff) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) <span class="keyword">if</span> (ch[i][ff] == f) ch[i][ff] = u;</span><br><span class="line">    fa[u] = ff, Connect(ch[tmp ^ <span class="number">1</span>][u], f, tmp), Connect(f, u, tmp ^ <span class="number">1</span>), Pushup(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>type = 0</code>代表是原树，<code>type = 2</code>代表是虚树</p><p>其实跟原来的<code>rotate</code>差不多</p><p><code>splay</code>同理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Splay</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = u, top = <span class="number">0</span>; st[++top] = now;</span><br><span class="line">    <span class="keyword">while</span> (!Isroot(now, type)) st[++top] = now = fa[now];</span><br><span class="line">    <span class="keyword">while</span> (top) Pushdown(st[top--]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> f;!Isroot(u, type);Rotate(u, type)) </span><br><span class="line">        <span class="keyword">if</span> (!Isroot(f = fa[u], type))</span><br><span class="line">            Rotate((ch[type][f] == u) ^ (ch[type][fa[f]] == f) ? u : f, type); </span><br><span class="line">    Pushup(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="新的Pushdown"><a href="#新的Pushdown" class="headerlink" title="新的Pushdown"></a>新的<code>Pushdown</code></h1><p>在树上，我们需要维护两个标记</p><p>第一个是给重链打上的标记</p><p>第二个是给重链<code>splay</code>中它的后代的所有虚子树打上的标记（不包括重链节点）</p><p>显然虚点只有第二种标记</p><p>我们分以下几种情况讨论：</p><ul><li>当前点是实点，下放到重链上的左右儿子</li></ul><p>首先标记应该下传，同时给这两个儿子的点权打上第一个标记</p><p>注意第二个标记不会对这两个点权产生影响，因为它是给虚子树打的</p><ul><li>当前点是实点，下放到虚点</li></ul><p>第一个标记没有必要下方，只需要下方第二种标记</p><ul><li>当前点是实点，下放到一个非重链实点</li></ul><p>此时除了修改点权，还应将这个儿子的点权打上这两种标记</p><p>因为此时这个儿子是当前点的一个虚儿子</p><ul><li>当前点是虚点，下放到一个实点</li></ul><p>同上</p><ul><li>当前点是虚点，下放到虚点</li></ul><p>直接下传标记即可</p><p>注意翻转标记不应该传入虚子树的<code>splay</code>中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushdown</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (rev[u]) Rev(ch[<span class="number">0</span>][u]), Rev(ch[<span class="number">1</span>][u]), rev[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!in[u] &amp;&amp; tag[u].marked()) </span><br><span class="line">        Tag_Line(ch[<span class="number">0</span>][u], tag[u]), Tag_Line(ch[<span class="number">1</span>][u], tag[u]), tag[u] = Tag();</span><br><span class="line">    <span class="keyword">if</span> (T_tag[u].marked()) &#123;</span><br><span class="line">        Tag_Tree(ch[<span class="number">0</span>][u], T_tag[u], <span class="number">0</span>), Tag_Tree(ch[<span class="number">1</span>][u], T_tag[u], <span class="number">0</span>);</span><br><span class="line">        Tag_Tree(ch[<span class="number">2</span>][u], T_tag[u], <span class="number">1</span>), Tag_Tree(ch[<span class="number">3</span>][u], T_tag[u], <span class="number">1</span>), T_tag[u] = Tag();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>marked</code>代表是否有下传的必要</p><p><code>tag</code>是给重链打的标记</p><p><code>T_...</code>代表虚子树的信息或者标记</p><p><code>Tag_line</code>与<code>Tag_Tree</code>，分别是给链/树打标记</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Tag_Line</span><span class="params">(<span class="keyword">int</span> u, Tag t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>;</span><br><span class="line">    sum[u] += t, A_sum[u] = sum[u] + T_sum[u], val[u] = Get(val[u], t), tag[u] += t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Tag_Tree</span><span class="params">(<span class="keyword">int</span> u, Tag t, <span class="keyword">int</span> type)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>;</span><br><span class="line">    T_sum[u] += t, T_tag[u] += t;</span><br><span class="line">    <span class="keyword">if</span> (!in[u] &amp;&amp; type) Tag_Line(u, t); <span class="keyword">else</span> A_sum[u] = sum[u] + T_sum[u];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>A_sum</code>代表全部信息</p><p><code>Get(x, t)</code>代表$x$在标记$t$的作用下的值</p><p><code>in</code>代表是否为虚点</p><h1 id="新的Pushup"><a href="#新的Pushup" class="headerlink" title="新的Pushup"></a>新的<code>Pushup</code></h1><p>同样，我们分虚子树信息/重链信息以及全部信息来统计答案</p><p>分情况讨论</p><ul><li>当前点是虚点，子树也是虚点</li></ul><p>当前点虚子树信息为子树虚子树信息的和，此时虚子树信息就是全部信息</p><ul><li>当前点是虚点，子树是实点</li></ul><p>当前点虚子树信息为子树全部信息</p><ul><li>当前点是实点，子树是虚点</li></ul><p>只更新子树信息与子树全部信息</p><ul><li>当前点是实点，子树是重链上的点</li></ul><p>只更新重链信息与子树全部信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushup</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    T_sum[u] = Data();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>;i++) <span class="keyword">if</span> (ch[i][u]) T_sum[u] += T_sum[ch[i][u]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">3</span>;i++) <span class="keyword">if</span> (ch[i][u]) T_sum[u] += A_sum[ch[i][u]];</span><br><span class="line">    <span class="keyword">if</span> (in[u]) sum[u] = Data(), A_sum[u] = T_sum[u];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        sum[u] = Data(val[u]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>;i++) <span class="keyword">if</span> (ch[i][u]) sum[u] += sum[ch[i][u]];</span><br><span class="line">        A_sum[u] = sum[u] + T_sum[u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="新的操作Add"><a href="#新的操作Add" class="headerlink" title="新的操作Add"></a>新的操作<code>Add</code></h1><p>$Add(x,y)$表示从$x$向$y$连一条虚边</p><p>方式其实很暴躁，就是一直跳左儿子，最后再新建一个虚点$v$，将当前点挂在$v$上面</p><p><img src="https://i.loli.net/2019/04/23/5cbef3dd1b777.png" alt="1556018128092"></p><p>图中黄色节点代表$v$</p><p>注意在跳左儿子的时候要顺便<code>pushdown</code></p><p>最后别忘了将新添加的点旋转到<code>splay</code>的根</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (!y) <span class="keyword">return</span>; Pushdown(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">3</span>;i++) <span class="keyword">if</span> (!ch[i][x]) <span class="keyword">return</span> <span class="keyword">void</span>(Connect(y, x, i));</span><br><span class="line">    <span class="keyword">while</span> (ch[<span class="number">2</span>][x] &amp;&amp; in[ch[<span class="number">2</span>][x]]) x = ch[<span class="number">2</span>][x], Pushdown(x);</span><br><span class="line">    <span class="keyword">int</span> u = Create();</span><br><span class="line">    Connect(ch[<span class="number">2</span>][x], u, <span class="number">2</span>), Connect(y, u, <span class="number">3</span>), Connect(u, x, <span class="number">2</span>), Splay(u, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="新的操作Del"><a href="#新的操作Del" class="headerlink" title="新的操作Del"></a>新的操作<code>Del</code></h1><p>$Del(u)$表示删除$u$与其父亲相连的虚边</p><p>注意到每次$Add$操作都会新建一个点，那么$Del$操作我们也只需要删除一个点就可以保证空间为$O(n)$</p><p>如果$u$与其父亲直接相连，那么断开这条虚边就好了</p><p>否则我们找到$u$的虚点父亲$f$，先将$f$及它的祖先像<code>splay</code>一样<code>pushdown</code>，然后尝试删除$f$</p><p>注意此时也要<code>splay</code>来保证复杂度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Child</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) <span class="keyword">if</span> (ch[i][fa[u]] == u) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Del</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>; Splay(u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fa[u]) <span class="keyword">return</span>; <span class="keyword">int</span> f = fa[u];</span><br><span class="line">    <span class="keyword">if</span> (in[f]) &#123;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>, now = f, ff = fa[f]; st[++top] = now;</span><br><span class="line">        <span class="keyword">while</span> (!Isroot(now, <span class="number">2</span>)) st[++top] = now = fa[now];</span><br><span class="line">        <span class="keyword">while</span> (top) Pushdown(st[top--]);</span><br><span class="line">        <span class="keyword">if</span> (ff) &#123;<span class="keyword">int</span> other = ch[Child(u) ^ <span class="number">1</span>][f]; Pushdown(other), Connect(other, ff, Child(f)), Splay(ff, <span class="number">2</span>);&#125;</span><br><span class="line">        rub[++rcnt] = f;</span><br><span class="line">    &#125; <span class="keyword">else</span> ch[Child(u)][f] = <span class="number">0</span>, Splay(f, <span class="number">0</span>);</span><br><span class="line">    fa[u] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="新的操作Father"><a href="#新的操作Father" class="headerlink" title="新的操作Father"></a>新的操作<code>Father</code></h1><p>$Father(u)$表示找到$u$的以虚边相连的父亲</p><p>实现很简单，如果$u$的父亲节点就是原树中的父亲，那么直接返回，否则将这个虚点<code>splay</code>到根，再返回它的父亲</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Father</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Splay(u, <span class="number">0</span>); <span class="keyword">if</span> (!fa[u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!in[fa[u]]) <span class="keyword">return</span> fa[u];</span><br><span class="line">    <span class="keyword">int</span> f = fa[u]; Splay(f, <span class="number">2</span>); <span class="keyword">return</span> fa[f];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="新的Access以及LCA"><a href="#新的Access以及LCA" class="headerlink" title="新的Access以及LCA"></a>新的<code>Access</code>以及<code>LCA</code></h1><p>其实跟<code>LCT</code>的差不多，就是将连边/断边改成<code>Del, Add</code>，将跳父亲改成<code>Father</code></p><p>这里提一下如何求两个点的<code>LCA</code>，假设为$u,v$</p><p>首先将$u$ $Access$一下，此时$u$到根节点的链已经被打通，那么$v$到根节点的路径一定分为若干段实链与虚边，最后一段实链的最深的那个点就是<code>LCA</code></p><p><img src="https://i.loli.net/2019/04/23/5cbef7a2519bf.png" alt="1556019086677"></p><p>那么在$Access$的时候，直接返回结束时的<code>ls</code>就好了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ls = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;u;u = Father(ls = u)) </span><br><span class="line">        Splay(u, <span class="number">0</span>), Del(ls), Add(u, ch[<span class="number">1</span>][u]), Connect(ls, u, <span class="number">1</span>), Pushup(u);</span><br><span class="line">    <span class="keyword">return</span> ls;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;Access(x); <span class="keyword">return</span> Access(y);&#125;</span><br></pre></td></tr></table></figure><h1 id="一些例行操作"><a href="#一些例行操作" class="headerlink" title="一些例行操作"></a>一些例行操作</h1><p>由于这一部分的代码和<code>LCT</code>几乎是一样的，所以直接贴上来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Findroot</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    Access(u), Splay(u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (ch[<span class="number">0</span>][u]) u = ch[<span class="number">0</span>][u];</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Makeroot</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;Access(u), Splay(u, <span class="number">0</span>), Rev(u);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;Makeroot(x), Add(y, x), Access(x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Cut</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;Access(u), Splay(u, <span class="number">0</span>), ch[<span class="number">0</span>][u] = fa[ch[<span class="number">0</span>][u]] = <span class="number">0</span>, Pushup(u);&#125; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;Makeroot(x), Access(y), Splay(y, <span class="number">0</span>);&#125;</span><br></pre></td></tr></table></figure><h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tag</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> k, b;</span><br><span class="line">    Tag(<span class="keyword">int</span> k = <span class="number">1</span>, <span class="keyword">int</span> b = <span class="number">0</span>) : k(k), b(b) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">marked</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> k != <span class="number">1</span> || b;&#125; </span><br><span class="line">    <span class="keyword">inline</span> Tag <span class="keyword">operator</span> + (<span class="keyword">const</span> Tag &amp;x) &#123;<span class="keyword">return</span> Tag(k * x.k, b * x.k + x.b);&#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> += (<span class="keyword">const</span> Tag &amp;x) &#123;*<span class="keyword">this</span> = *<span class="keyword">this</span> + x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">2147483647</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> x, Tag y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y.k + y.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> sum, mn, mx, sz;</span><br><span class="line">    Data() &#123;sum = sz = <span class="number">0</span>, mn = INF, mx = -INF;&#125;</span><br><span class="line">    Data(<span class="keyword">int</span> x) &#123;sum = mn = mx = x, sz = <span class="number">1</span>;&#125;</span><br><span class="line">    Data(<span class="keyword">int</span> sum, <span class="keyword">int</span> mn, <span class="keyword">int</span> mx, <span class="keyword">int</span> sz) : sum(sum), mn(mn), mx(mx), sz(sz) &#123;&#125;</span><br><span class="line">    <span class="keyword">inline</span> Data <span class="keyword">operator</span> + (<span class="keyword">const</span> Data &amp;x) &#123;<span class="keyword">return</span> Data(sum + x.sum, min(mn, x.mn), max(mx, x.mx), sz + x.sz);&#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> += (<span class="keyword">const</span> Data &amp;x) &#123;*<span class="keyword">this</span> = *<span class="keyword">this</span> + x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> Data <span class="keyword">operator</span> + (<span class="keyword">const</span> Data &amp;a, <span class="keyword">const</span> Tag &amp;b) &#123;<span class="keyword">return</span> a.sz ? Data(a.sum * b.k + a.sz * b.b, Get(a.mn, b), Get(a.mx, b), a.sz) : a;&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> += (Data &amp;a, <span class="keyword">const</span> Tag &amp;b) &#123;a = a + b;&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="keyword">int</span> fa[N], ch[<span class="number">4</span>][N], ncnt, rt, rev[N], in[N], val[N], rub[N], rcnt;</span><br><span class="line">Data sum[N], T_sum[N], A_sum[N]; Tag tag[N], T_tag[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Isroot</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> type)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (type) <span class="keyword">return</span> !fa[u] || !in[fa[u]] || !in[u] || !u;</span><br><span class="line">    <span class="keyword">return</span> (ch[<span class="number">0</span>][fa[u]] != u &amp;&amp; ch[<span class="number">1</span>][fa[u]] != u) || !fa[u] || in[fa[u]] || in[u] || !u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rev</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>;</span><br><span class="line">    swap(ch[<span class="number">0</span>][u], ch[<span class="number">1</span>][u]), rev[u] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Tag_Line</span><span class="params">(<span class="keyword">int</span> u, Tag t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>;</span><br><span class="line">    sum[u] += t, A_sum[u] = sum[u] + T_sum[u], val[u] = Get(val[u], t), tag[u] += t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Tag_Tree</span><span class="params">(<span class="keyword">int</span> u, Tag t, <span class="keyword">int</span> type)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>;</span><br><span class="line">    T_sum[u] += t, T_tag[u] += t;</span><br><span class="line">    <span class="keyword">if</span> (!in[u] &amp;&amp; type) Tag_Line(u, t); <span class="keyword">else</span> A_sum[u] = sum[u] + T_sum[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushdown</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (rev[u]) Rev(ch[<span class="number">0</span>][u]), Rev(ch[<span class="number">1</span>][u]), rev[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!in[u] &amp;&amp; tag[u].marked()) </span><br><span class="line">        Tag_Line(ch[<span class="number">0</span>][u], tag[u]), Tag_Line(ch[<span class="number">1</span>][u], tag[u]), tag[u] = Tag();</span><br><span class="line">    <span class="keyword">if</span> (T_tag[u].marked()) &#123;</span><br><span class="line">        Tag_Tree(ch[<span class="number">0</span>][u], T_tag[u], <span class="number">0</span>), Tag_Tree(ch[<span class="number">1</span>][u], T_tag[u], <span class="number">0</span>);</span><br><span class="line">        Tag_Tree(ch[<span class="number">2</span>][u], T_tag[u], <span class="number">1</span>), Tag_Tree(ch[<span class="number">3</span>][u], T_tag[u], <span class="number">1</span>), T_tag[u] = Tag();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushup</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    T_sum[u] = Data();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>;i++) <span class="keyword">if</span> (ch[i][u]) T_sum[u] += T_sum[ch[i][u]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">3</span>;i++) <span class="keyword">if</span> (ch[i][u]) T_sum[u] += A_sum[ch[i][u]];</span><br><span class="line">    <span class="keyword">if</span> (in[u]) sum[u] = Data(), A_sum[u] = T_sum[u];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        sum[u] = Data(val[u]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>;i++) <span class="keyword">if</span> (ch[i][u]) sum[u] += sum[ch[i][u]];</span><br><span class="line">        A_sum[u] = sum[u] + T_sum[u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> son)</span> </span>&#123;<span class="keyword">if</span> (u) fa[u] = f; ch[son][f] = u;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rotate</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = fa[u], tmp = (ch[type + <span class="number">1</span>][f] == u) + type, ff = fa[f];</span><br><span class="line">    <span class="keyword">if</span> (ff) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) <span class="keyword">if</span> (ch[i][ff] == f) ch[i][ff] = u;</span><br><span class="line">    fa[u] = ff, Connect(ch[tmp ^ <span class="number">1</span>][u], f, tmp), Connect(f, u, tmp ^ <span class="number">1</span>), Pushup(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Splay</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = u, top = <span class="number">0</span>; st[++top] = now;</span><br><span class="line">    <span class="keyword">while</span> (!Isroot(now, type)) st[++top] = now = fa[now];</span><br><span class="line">    <span class="keyword">while</span> (top) Pushdown(st[top--]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> f;!Isroot(u, type);Rotate(u, type)) </span><br><span class="line">        <span class="keyword">if</span> (!Isroot(f = fa[u], type))</span><br><span class="line">            Rotate((ch[type][f] == u) ^ (ch[type][fa[f]] == f) ? u : f, type); </span><br><span class="line">    Pushup(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = rcnt ? rub[rcnt--] : ++ncnt;</span><br><span class="line">    ch[<span class="number">2</span>][u] = ch[<span class="number">3</span>][u] = <span class="number">0</span>, in[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Child</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) <span class="keyword">if</span> (ch[i][fa[u]] == u) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (!y) <span class="keyword">return</span>; Pushdown(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">3</span>;i++) <span class="keyword">if</span> (!ch[i][x]) <span class="keyword">return</span> <span class="keyword">void</span>(Connect(y, x, i));</span><br><span class="line">    <span class="keyword">while</span> (ch[<span class="number">2</span>][x] &amp;&amp; in[ch[<span class="number">2</span>][x]]) x = ch[<span class="number">2</span>][x], Pushdown(x);</span><br><span class="line">    <span class="keyword">int</span> u = Create();</span><br><span class="line">    Connect(ch[<span class="number">2</span>][x], u, <span class="number">2</span>), Connect(y, u, <span class="number">3</span>), Connect(u, x, <span class="number">2</span>), Splay(u, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Del</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span>; Splay(u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fa[u]) <span class="keyword">return</span>; <span class="keyword">int</span> f = fa[u];</span><br><span class="line">    <span class="keyword">if</span> (in[f]) &#123;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>, now = f, ff = fa[f]; st[++top] = now;</span><br><span class="line">        <span class="keyword">while</span> (!Isroot(now, <span class="number">2</span>)) st[++top] = now = fa[now];</span><br><span class="line">        <span class="keyword">while</span> (top) Pushdown(st[top--]);</span><br><span class="line">        <span class="keyword">if</span> (ff) &#123;<span class="keyword">int</span> other = ch[Child(u) ^ <span class="number">1</span>][f]; Pushdown(other), Connect(other, ff, Child(f)), Splay(ff, <span class="number">2</span>);&#125;</span><br><span class="line">        rub[++rcnt] = f;</span><br><span class="line">    &#125; <span class="keyword">else</span> ch[Child(u)][f] = <span class="number">0</span>, Splay(f, <span class="number">0</span>);</span><br><span class="line">    fa[u] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Father</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Splay(u, <span class="number">0</span>); <span class="keyword">if</span> (!fa[u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!in[fa[u]]) <span class="keyword">return</span> fa[u];</span><br><span class="line">    <span class="keyword">int</span> f = fa[u]; Splay(f, <span class="number">2</span>); <span class="keyword">return</span> fa[f];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Access</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ls = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;u;u = Father(ls = u)) </span><br><span class="line">        Splay(u, <span class="number">0</span>), Del(ls), Add(u, ch[<span class="number">1</span>][u]), Connect(ls, u, <span class="number">1</span>), Pushup(u);</span><br><span class="line">    <span class="keyword">return</span> ls;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;Access(x); <span class="keyword">return</span> Access(y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Findroot</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    Access(u), Splay(u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (ch[<span class="number">0</span>][u]) u = ch[<span class="number">0</span>][u];</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Makeroot</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;Access(u), Splay(u, <span class="number">0</span>), Rev(u);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;Makeroot(x), Add(y, x), Access(x);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Cut</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;Access(u), Splay(u, <span class="number">0</span>), ch[<span class="number">0</span>][u] = fa[ch[<span class="number">0</span>][u]] = <span class="number">0</span>, Pushup(u);&#125; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;Makeroot(x), Access(y), Splay(y, <span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mark_Line</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, Tag t)</span> </span>&#123;Split(x, y), Tag_Line(y, t);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Data <span class="title">Ask_Line</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;Split(x, y); <span class="keyword">return</span> sum[y];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Mark_Tree</span><span class="params">(<span class="keyword">int</span> u, Tag t)</span> </span>&#123;</span><br><span class="line">    Access(u), Splay(u, <span class="number">0</span>), val[u] = Get(val[u], t);</span><br><span class="line">    Tag_Tree(ch[<span class="number">2</span>][u], t, <span class="number">1</span>), Tag_Tree(ch[<span class="number">3</span>][u], t, <span class="number">1</span>), Pushup(u), Splay(u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Data <span class="title">Ask_Tree</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    Access(u), Splay(u, <span class="number">0</span>); <span class="function">Data <span class="title">res</span><span class="params">(val[u])</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">3</span>;i++) <span class="keyword">if</span> (ch[i][u]) res += A_sum[ch[i][u]];</span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ed[<span class="number">2</span>][N];</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar(); </span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, q, rt; read(n), read(q), ncnt = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) read(ed[<span class="number">0</span>][i]), read(ed[<span class="number">1</span>][i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) read(val[i]), Pushup(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) Link(ed[<span class="number">0</span>][i], ed[<span class="number">1</span>][i]);</span><br><span class="line">    read(rt), Makeroot(rt);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, x, y, z; read(op);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) read(rt), Makeroot(rt);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">9</span>) &#123;</span><br><span class="line">            read(x), read(y);</span><br><span class="line">            <span class="keyword">if</span> (LCA(x, y) != x) Cut(x), Link(y, x), Makeroot(rt);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">0</span>) read(x), read(y), Mark_Tree(x, Tag(<span class="number">0</span>, y));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">5</span>) read(x), read(y), Mark_Tree(x, Tag(<span class="number">1</span>, y));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) read(x), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ask_Tree(x).mn);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">4</span>) read(x), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ask_Tree(x).mx);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">11</span>) read(x), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ask_Tree(x).sum);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) read(x), read(y), read(z), Mark_Line(x, y, Tag(<span class="number">0</span>, z)), Makeroot(rt);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">6</span>) read(x), read(y), read(z), Mark_Line(x, y, Tag(<span class="number">1</span>, z)), Makeroot(rt);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">7</span>) read(x), read(y), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ask_Line(x, y).mn), Makeroot(rt);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">8</span>) read(x), read(y), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ask_Line(x, y).mx), Makeroot(rt);</span><br><span class="line">        <span class="keyword">else</span> read(x), read(y), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ask_Line(x, y).sum), Makeroot(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个疑问</p><p>第159行，将<code>Link(y, x)</code>改为<code>Link(x, y)</code>会错，暂时还不知道为什么</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCT </tag>
            
            <tag> splay </tag>
            
            <tag> TopTree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.17省选模拟</title>
      <link href="/2019/04/18/4-17%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/"/>
      <url>/2019/04/18/4-17%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-圈草地"><a href="#T1-圈草地" class="headerlink" title="T1 圈草地"></a>T1 圈草地</h1><p><img src="https://i.loli.net/2019/04/18/5cb8598ea8a77.png" alt="1555585345165"></p><p><img src="https://i.loli.net/2019/04/18/5cb859b53dd70.png" alt="1555585452299"></p><p>我们只考虑有用的左上角和右下角</p><p>考虑两个点$a,b$，如果$a$在$b$的第二象限，那么选择$a$作为左上角一定比选择$b$作为左上角优秀</p><p>那么我们将所有有用的点分两层排在一起，第一层是可以作为左上角的点，第二层是可以作为右下角的点</p><p><img src="https://i.loli.net/2019/04/18/5cb860d2e1fd7.png" alt="1555587272118"></p><p>我们考虑当右下角的点移动的时候左上角的最优决策点会如何变化</p><p>假如原来的最优决策点是$a$，另一个在$a$右上角的点是$b$，那么我们可以发现，右下角的点移动之后，$b$与之构成的矩形的面积与$a$与之构成的矩形的面积之差变大了</p><p>也就是说，移动之后，$b$会变得更加优秀</p><p>所以最优决策点是单调向右上角移动的</p><p>我们可以采用分治</p><p><code>solve(l, r, L, R)</code>表示右下角的点对应的区间是$[L,R]$，对应的最优决策点的区间是$[l,r]$</p><p>我们找到$l,r$的中点$mid$，二分出右下角那些点的最优决策点在$[l,mid]$中</p><p>然后继续分治下去</p><p>对于找一个矩形内部有多少个点，可以使用主席树</p><p>时间复杂度$O(n\log^3n)$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, lson, rson, sum;</span><br><span class="line">&#125; T[N * <span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> RT[N], ncnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rt = ++ncnt; T[rt].l = l, T[rt].r = r, T[rt].lson = T[rt].rson = T[rt].sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> rt;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; T[rt].lson = build(l, mid), T[rt].rson = build(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> at)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nw = ++ncnt, l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>; T[nw] = T[rt], T[nw].sum++;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> nw;</span><br><span class="line">    <span class="keyword">if</span> (at &lt;= mid) T[nw].lson = update(T[nw].lson, at);</span><br><span class="line">    <span class="keyword">else</span> T[nw].rson = update(T[nw].rson, at);</span><br><span class="line">    <span class="keyword">return</span> nw;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt1, <span class="keyword">int</span> rt2, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt2].l, r = T[rt2].r, mid = (l + r) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> T[rt2].sum - T[rt1].sum;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) res += query(T[rt1].lson, T[rt2].lson, start, end);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; end) res += query(T[rt1].rson, T[rt2].rson, start, end);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125; st1[N], st2[N];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>, top1, top2;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x1 = st1[a].x, y1 = st1[a].y, x2 = st2[b].x, y2 = st2[b].y;</span><br><span class="line">    <span class="keyword">return</span> query(RT[x1 - <span class="number">1</span>], RT[x2], y2, y1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = l, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l;i &lt;= r;i++) <span class="keyword">if</span> (st1[i].x &lt;= st2[x].x &amp;&amp; st2[x].y &lt;= st1[i].y) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = query(i, x);</span><br><span class="line">        <span class="keyword">if</span> (res &lt;= tmp) res = tmp, pos = i;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; mid) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L;i &lt;= R;i++) </span><br><span class="line">            <span class="keyword">if</span> (st1[l].x &lt;= st2[i].x &amp;&amp; st2[i].y &lt;= st1[l].y)</span><br><span class="line">                ans = max(ans, query(l, i));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, l1 = L, r1 = R, m, pos = l1;</span><br><span class="line">    <span class="keyword">while</span> (l1 &lt;= r1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check(l, r, m = ((l1 + r1) &gt;&gt; <span class="number">1</span>), mid)) pos = m, l1 = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r1 = m - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    solve(l, mid, L, pos), solve(mid + <span class="number">1</span>, r, pos + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l;i &lt;= r;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = L;j &lt;= R;j++)</span><br><span class="line">            <span class="keyword">if</span> (st1[i].x &lt;= st2[j].x &amp;&amp; st2[j].y &lt;= st1[i].y)</span><br><span class="line">                ans = max(ans, query(i, j));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), RT[<span class="number">0</span>] = build(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), RT[i] = update(RT[i - <span class="number">1</span>], a);</span><br><span class="line">        <span class="keyword">if</span> (a &gt; st1[top1].y) st1[++top1] = (point)&#123;i, a&#125;;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (top2 &amp;&amp; st2[top2].y &gt; a) top2--;</span><br><span class="line">            st2[++top2] = (point)&#123;i, a&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (top1 &lt;= <span class="number">500</span> &amp;&amp; top2 &lt;= <span class="number">500</span>) solve2(<span class="number">1</span>, top1, <span class="number">1</span>, top2);</span><br><span class="line">    <span class="keyword">else</span> solve(<span class="number">1</span>, top1, <span class="number">1</span>, top2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-道路修建"><a href="#T2-道路修建" class="headerlink" title="T2 道路修建"></a>T2 道路修建</h1><p><img src="https://i.loli.net/2019/04/18/5cb8627245de8.png" alt="1555587688425"></p><p><img src="https://i.loli.net/2019/04/18/5cb86290b9bd9.png" alt="1555587721754"></p><p>容易发现一个结论：对于一个点$u$，假设它与$v$相连，那么它距离一号城市的最短路距离$d_u$一定满足$d_v-1\leq d_u\leq d_v+1$</p><p>那么我们可以通过这个建图跑网络流</p><p>将每个点拆成$n$个点，第$x$个点表示当前点的最短路是否大于等于$x-1$</p><p>将第一个拆出来的点与源点连一条$\infty$的边，将最后一个拆出来的点与汇点连一条$\infty$的边</p><p>将第$i$个拆出来的点向第$i+1$个点连一条权值为题中给出公式的边</p><p>最小割中，与$S$集合连接代表为<code>true</code>，否则为<code>false</code></p><p>为了满足$d_v-1\leq d_u\leq d_v+1$这个限制，我们可以模仿切糕这道题的做法</p><p>对于任意两个有边相连的点$u,v$，$u$拆出来的第$i$个点向$v$拆出来的第$i-1$个点连一条无法割掉的$\infty$ 的边</p><p>注意$(u,v)和(v,u)$是不一样的</p><h1 id="T3-美术作业"><a href="#T3-美术作业" class="headerlink" title="T3 美术作业"></a>T3 美术作业</h1><p><img src="https://i.loli.net/2019/04/18/5cb86451553e8.png" alt="1555588168670"></p><p><img src="https://i.loli.net/2019/04/18/5cb86482a8c37.png" alt="1555588211145"></p><p>可以看出，这是一个基环外向树</p><p>我们先考虑一棵树的情况：如何求它的染色方案</p><p>由于边是有向的，所以置换对答案的影响只有可能是对于$u$这个点，它有一些子树是完全同构的</p><p>比如这样</p><p><img src="https://i.loli.net/2019/04/18/5cb8658170f30.png" alt="1555588473582"></p><p>注意到如果$2,3,4$这几个点互换编号，那么结构是不变的</p><p>比如“2染颜色1，3染颜色1，4染颜色2”这种方案与“2染颜色2，3染颜色1，4染颜色1”是完全等价的</p><p>而不同构的子树之间是没有关系的</p><p>那么对于这种同构的情况怎么办呢</p><p>由于$2,3,4$都是同构的，所以它们的染色方案一定都一样，我们假设有$f$种方案，有$t$棵子树</p><p>我们将这$f$种染色方案分别编号为$1,2\cdots,f$，对于这些同构的子树按照根节点的编号排序</p><p>然后在这$f$种方案中选出$t$种，可以重复，然后按照从小到大的顺序依次给这些同构的子树染色，这样统计出来的结构一定不会重复</p><p>等价于将$t$个球放入$f$个盒子，每个盒子可以空</p><p>所以方案数为</p><script type="math/tex; mode=display">f{f+t-1\choose f-1}=f{f+t-1\choose t}</script><p>现在我们求出了环上每棵树的染色方案</p><p>我们来考虑环的置换</p><p>对于一种置换后的不动点，它们对应树的结构必须相同，染的颜色也必须相同</p><p>所以对于每棵树最后得到的<code>hash</code>值我们跑一个<code>KMP</code>，求出它的最小循环节，这样每次转的次数一定是循环节长度的倍数</p><p>每个循环节我们将它看作一个点，染色方案为它包含的树的染色方案的乘积</p><p>然后就是普通<code>polya</code>了，枚举转多少次，然后不动点个数就是每个循环节的方案的$gcd(总长度，转的次数)$次方</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uLL unsigned long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = inv[r];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= r;i++)</span><br><span class="line">        res = (LL)res * (n - i + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt, dp[N], tmp[N], m;</span><br><span class="line">uLL P = <span class="number">233</span>, h[N], s[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> nxt[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ls = nxt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (ls &amp;&amp; s[ls + <span class="number">1</span>] != s[i]) ls = nxt[ls];</span><br><span class="line">        nxt[i] = ls + (s[ls + <span class="number">1</span>] == s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n % (n - nxt[n]) ? <span class="number">-1</span> : n - nxt[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next) </span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) tmp[++top] = e[i].to;</span><br><span class="line">    sort(tmp + <span class="number">1</span>, tmp + top + <span class="number">1</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> h[a] &lt; h[b];&#125;), h[u] = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= top;i++) </span><br><span class="line">        h[u] = ((h[u] * P + h[tmp[i]]) ^ h[tmp[i]]) + h[tmp[i]];</span><br><span class="line">    dp[u] = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, last;i &lt;= top;i = last) &#123;</span><br><span class="line">        <span class="keyword">for</span> (last = i;last &lt;= top &amp;&amp; h[tmp[last]] == h[tmp[i]];last++);</span><br><span class="line">        dp[u] = (LL)dp[u] * C(dp[tmp[i]] + last - i - <span class="number">1</span>, last - i) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> b ? gcd(b, a % b) : a;&#125;</span><br><span class="line"><span class="keyword">int</span> to[N], vis[N], cir[N], mark[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, tot = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;to[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = i;!vis[j];j = to[j]) vis[j] = i;</span><br><span class="line">        <span class="keyword">if</span> (vis[j] != i) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (;!mark[j];j = to[j]) mark[j] = <span class="number">1</span>, cir[++tot] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span> (!mark[i]) adde(to[i], i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tot;i++) dfs(cir[i], <span class="number">0</span>), s[i] = h[cir[i]];</span><br><span class="line">    <span class="keyword">int</span> zjk = KMP(tot), ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (~zjk) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= zjk;i++) f = (LL)f * dp[cir[i]] % mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tot / zjk;i++)</span><br><span class="line">            ans = (ans + Pow(f, gcd(i, tot / zjk))) % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL)ans * Pow(tot / zjk, mod - <span class="number">2</span>) % mod);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= tot;i++) ans = (LL)ans * dp[cir[i]] % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> 主席树 </tag>
            
            <tag> 分治 </tag>
            
            <tag> polya </tag>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SCOI2019 游记</title>
      <link href="/2019/04/14/SCOI2019-%E6%B8%B8%E8%AE%B0/"/>
      <url>/2019/04/14/SCOI2019-%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="写在之前的话"><a href="#写在之前的话" class="headerlink" title="写在之前的话"></a>写在之前的话</h1><p>感觉<code>NOIP</code>之后就有点没救了，之后冬令营全机房都去了</p><p>425分有点凉凉</p><p>不过可以试试冲E类</p><p>赶紧复习一下<code>exBSGS, exCRT, Cipolla</code></p><p>朱刘算法懒得看了</p><h1 id="Day0"><a href="#Day0" class="headerlink" title="Day0"></a>Day0</h1><p>比赛之前发了一个笔试考察范围，结果是去年<code>NOI</code>的笔试题库</p><p>本来以为要考什么神仙内容，结果笔试及其简单</p><p>重点是<strong>连题目顺序都和题库一样</strong></p><p>笔试时间是一个小时，结果30分钟可以走人的时候我在的这个考室已经没人了</p><p>感觉只要看了题库就应该是100分吧（雾</p><p>话说电子科大的教学楼上“电子科技大学”这几个字看起来好像电子神技大学</p><p>晚上看卢爷颓风暴英雄</p><p><del>Celeste真好玩</del></p><h1 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h1><p>路上单向模<code>ZJK</code></p><blockquote><p>我自闭了</p><p>我爆零了</p><p>来机房看神仙</p><p><code>rank</code> $10^9+7$</p></blockquote><p>结果每次考完之后都<code>rank</code> 1</p><p>这是某些选手的真实写照</p><hr><p>拿到试题之后解压，嗯？密码是一串数字</p><p>先看<code>T1</code>，那个图片有点劣质啊。。。</p><p>貌似是用<code>mspaint</code>画的</p><p>不过还将就</p><p>手玩了一下样例，好像找到了一点规律的样子</p><p>开考5分钟找工作人员要了几张纸</p><p>上个厕所冷静一下，顺便思考一下<code>T1</code></p><p>嗯？这不是SB题吗，只要不是划水选手都会做吧。。。</p><p>对于最有步数，显然有</p><script type="math/tex; mode=display">f_m=3f_{m-1}+n-1</script><p>然后随便分治一下就行了</p><p>一发过掉大样例</p><p>题目中说$Q_i$小于等于答案的上限，然而又没说上限是多少</p><p>感觉有阴谋</p><p>保证答案小于等于30，有什么用呢</p><p>意思是$Q_i\leq (n-1)*3^{30}$吗</p><p>然后发现显然是假的，$Q_i$可以达到$3^{1000}$</p><p>手写高精度！</p><p><code>T2</code>的名字叫“肯赛训练”</p><p>这里是否有肯德基强行打广告的成份</p><p>思考了一下，感觉那个边权是假的</p><p>所以是个区间求重心？不会啊</p><p>先写暴力吧，好像很莫队的样子</p><p>加一个点很好处理，新的重心一定在原来的重心与加的点的连线上</p><p>貌似<code>LCT</code>维护虚子树信息可以做到$\log$?</p><p>于是开始码<code>LCT</code>，做好了6kb的准备</p><p>码了2kb的时候</p><p>woc?加点可以直接$\log$，那删点怎么办？</p><p>冷静一下</p><p>这个东西好像不是很好维护的样子，干脆暴跳吧</p><p>好像加点之后重心的移动次数是$O(\log)$的</p><p>先码一个树状数组</p><p>代码还是挺简单的</p><p>我的程序跑得巨慢无比</p><p><code>30s</code>后过了大样例</p><p>来看<code>T3</code></p><p>好像很多项式的样子</p><p>卷积的运算符是乘？是不是可以原根什么的啊</p><p>然后发现显然不是</p><p>还好暴力分给得很足</p><p>直接一行代码有5分</p><p>剩下的直接暴力数论分块可以再拿25分</p><p>貌似有两个$q=1$的点</p><p>欸是不是可以爆搜然后乘一个排列数啊</p><p>写完之后发现T成SB了</p><p>这个时候离考试结束大概还有10分钟</p><p>再来检查一下<code>T1</code>吧</p><p>手输了一组极限数据</p><p>wtf?RE?</p><p>赶紧看一下</p><p>还好在最后一分钟的时候发现是高精板子错了</p><p>那个高精乘的时候我是边乘边取模233</p><p>所以最后估分$100+[30-50]+30$?</p><p>莫队的分数很玄学的</p><hr><p><code>ZJK</code>说他<code>T1</code>可能会被卡常，然后期望$50+50+50$</p><p><code>ZYW</code>貌似切了<code>T2</code>的60分</p><p>都好强啊</p><p>很不幸，我面试是第6轮，也就是最后一轮</p><p>本来以为要考什么小学奥数，结果是政治问题？（雾</p><p><code>Bh</code>是第一轮，他说他们那组的面试题目是评论中美贸易战</p><p><code>hxy</code>的题目是七中食堂事件</p><p>还有什么国民党为什么会失败</p><p>好有趣啊</p><p>4：10之前一直在楼梯上坐着</p><p>看陈爷玩炉石</p><p>经过漫长的等待，终于轮到我了</p><p>感觉我们这组只有我一个初中的</p><p>拿到题目：如何评价近年来自主招生政策遭到限制？</p><p>开始10分钟讨论</p><p>丝毫没有面试经验</p><p>10分钟之后</p><p>考官：之前我提出的要求是讨论并选出一位代表发言，但是10分钟已经过去了，你们却没有选出一位代表</p><p>我们：。。。</p><p>考官：从面试的角度来说，你们这次讨论是失败的</p><p>我们：。。。</p><p>考官：现在再给你们一次机会，选出一个代表发言</p><p>显然不是我了2333</p><p>感觉面试是不是有点凉啊</p><hr><p>晚上来看成绩</p><p>嗯？$60+45+30?$</p><p><code>T1</code>的高精度果然<code>T</code>了啊</p><p>如果把11位压到17位应该就不会超时了</p><p>还是太菜了</p><p>orz陈爷180</p><p><code>ZYW</code>165，看来她进E类稳了</p><p><code>ZJK</code>好像有点爆炸？只有100，但是如果算上<code>NOIP</code>的话还是在我前面</p><p>看了看此时的加权成绩，<code>rk</code>21，好像有点凉？</p><p>明天加油吧</p><h1 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h1><p>考前陈爷口胡动态<code>SA</code>，感觉他A类很稳</p><p>拿到试题，密码又全是数字</p><p>先看<code>T1</code></p><p>好像很模板的样子</p><p>感觉那个分成两半部分，再取一个部分的操作没啥用</p><p>如果根据询问把每个点变一下，那不是最大子段和吗？</p><p>50pts get</p><p>如果要动态的话，线段树维护凸包？？？</p><p>反正这种东西我是很难写出来的</p><p>那线段树维护矩阵？？？</p><p>好像不是</p><p>两个自变量有点不爽，可以去掉一个</p><p>等等，前缀和之后好像是个很裸的斜率优化</p><p>15分钟码完，代码只有2kb。。</p><p>对拍了上万组数据，感觉很稳</p><p>来看<code>T2</code></p><p>哇，这是论文题欸！</p><p>去年国家集训队论文，有一个“解决树上连通块问题的一些技巧和工具”</p><p>原题啊！！！！</p><p>具体方法是利用“边数 = 点数 - 1”这个等式来容斥</p><p>枚举某个点作为$x$的方案数，减去某条边两个端点都是$x$的方案数</p><p>然后就切了？？？</p><p>跑一下大样例</p><p>嗯？输出负数？改成<code>long long</code></p><p>嗯？还是负数，看看答案</p><p>woc？答案怎么这么小</p><p>举手向监考老师求助</p><p>我：第二道题有模数吗</p><p>老师：题目中写了吗</p><p>我：没有啊，但是大样例无论如何都不可能这么小</p><p>老师：这个。。。你自己认真读题吧</p><p>我：<code>&amp;#fsdl&amp;DFfd*#$jkrhf29873Q@!Rds</code></p><p>不久之后更正通知下来了，模数是$10^9+7$</p><p>改一下程序，过了！很好</p><p>开始看<code>T3</code></p><p>这看上去很线性基</p><p>事实上线性基的确可以获得20分的好成绩</p><p>思考了一下感觉没有发现什么好的性质，果断写暴力</p><p>前20分直接暴力，后面20分线性基，然后还有20分貌似是找规律？</p><p>好像是$2^{不同数的个数}$的样子？</p><p>写！</p><p>11：00的时候我就码完了</p><p><code>T1</code>仍然没有拍出错</p><p>前面好像有个七中大佬在玩纸牌？</p><p>我默默地点开了扫雷</p><p>2min后</p><p>太不友好了！</p><p>还是试试虚拟机吧</p><p>结果打开虚拟机让我的电脑卡了一会儿</p><p>无聊打了一个程序模<code>ZJK</code></p><p>之后看了看各个<code>IDE</code>的作者信息</p><p>坐了2h后考试结束了</p><p>所以我今天估分$100+100+60?$感觉翻盘有望？</p><p><code>ZJK</code>和<code>ZYW</code>都估分$100+40+40$</p><p><code>ZYW</code>说她<code>T1</code>是在线，是在凸包上二分</p><p>蒟蒻只会离线</p><p>下午拿到成绩，前两道题确实是100，但是第三题只有40，总分240</p><p>看来是规律假了</p><p>不过，我竟然是rk 1？</p><p><code>ZYW</code>和<code>ZJK</code>确实是180，E类稳了</p><p><code>BH</code>有点神仙啊，切了<code>T2</code>，但是<code>T1</code>爆零了，本来是很有希望的</p><p>坐看卢爷翻盘240，orz</p><p>事实证明考前无聊的时候看看论文总是有用的</p><p>预祝陈爷<code>NOI</code>取得好成绩！</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>如果不是第二天的成功翻盘，我有可能进不了E类</p><p>感觉这次我们学校进步好大啊，去年只有一个省队</p><p>强者都上了400分orz</p><p>想起去年我失败的<code>SCOI</code>，想要了解详情可以知乎搜索<code>SCOI2018</code></p><p>希望我能够坚持到最后</p><p><code>NOI2019</code>见</p><h1 id="补充：关于题意"><a href="#补充：关于题意" class="headerlink" title="补充：关于题意"></a>补充：关于题意</h1><h2 id="D1T1-小红球的跳跃"><a href="#D1T1-小红球的跳跃" class="headerlink" title="D1T1 小红球的跳跃"></a>D1T1 小红球的跳跃</h2><p>有$m$个小红球，$n$个空岛。其中第一个、最后一个空岛以及中间的第$k$个空岛是固定的$(1&lt;k&lt;n)$是固定的，其余空岛是悬浮的。一开始所有小红球都在第一个空岛，你的目标是把他们都移动到最后一个空岛，并且使用的步数尽量小。</p><p>每回合你可以移动一个小红球到它左边或者右边的那个平台，但是有一些限制：</p><ul><li>移动的小红球必须是移动前/移动后它所在的平台上编号最小的。</li><li>如果一个小红球移动到了一个浮动平台上，那下一回合必须将这个小红球移走，否则它就会掉下去。</li></ul><p>有$q$个询问，每次给出一个时刻，你需要回答在最优方案中，这个时刻正在跳跃的是哪个小红球。</p><p>保证答案小于$30$，$n\leq 10^8,m\leq1000,q\leq5000$，时限$1$s</p><p>保证询问给出的时刻小于等于最优方案数</p><p>部分分：</p><ul><li>对于$20\%$的数据，保证$m,n,q\leq10$</li><li>对于$50\%$的数据，保证$n\leq 10^8,m\leq 10,q\leq 5000$</li></ul><h2 id="D1T2-肯赛训练"><a href="#D1T2-肯赛训练" class="headerlink" title="D1T2 肯赛训练"></a>D1T2 肯赛训练</h2><p>给出一棵树，$n$个节点，每条边有边权$c_i$。</p><p>给出一个点的序列，这个序列有$m$个数，第$i$个数$a_i$代表编号为$a_i$的点</p><p>有$q$个询问，每次询问给出一段区间$[l,r]$，你要在树上选出一个点，使得这个点离$a_l,a_{l+1},\cdots,a_{r}$的距离之和尽量小，输出这个点的编号</p><p>注意，选出的点不一定是$a_{l},a_{l+1},\cdots,a_r$其中的某一个</p><p>保证$n\leq 3*10^5,c_i\leq 1000,m\leq5*10^5,q\leq10^6$，区间的长度是奇数，时限$3$s</p><p>部分分：</p><ul><li>对于前$20\%$的数据，保证$n,m,q\leq2*10^3$</li><li>对于前$35\%$的数据，保证$m,q\leq2*10^3$</li><li><p>对于前$60\%$的数据，保证$n,m,q\leq10^5$</p></li><li><p>对于另$15\%$的数据，保证每个点的度数不超过$2$</p></li></ul><h2 id="D1T3-超矩形"><a href="#D1T3-超矩形" class="headerlink" title="D1T3 超矩形"></a>D1T3 超矩形</h2><p>给出一个数$n$，你需要找到$k$个数$a_1,a_2,\cdots,a_k$使得$\prod_{i=1}^ka_i\leq n$</p><p>给出一个变换$b_1,b_2,\cdots,b_k$，保证$b_i&lt;10$</p><p>你需要求出</p><script type="math/tex; mode=display">\sum_{所有合法的方案}\prod_{i=1}^ka_i^{b_i}\pmod {998244353}</script><p>多组数据（$t$组）</p><p>保证$n\leq10^6,\sum k\leq10^6,t\leq100$，时限$4$s</p><p>给出$b$的方式是$q$个$s_i,r_i$，表示有连续$r_i$个$b_i$是$s_i$</p><p>保证$s_i$互不相同，$q&lt;5$</p><p>部分分：</p><ul><li>对于前$10\%$的数据，保证$k=1,q=1,s=0$</li><li>对于前$20\%$的数据，保证$k=1,q=1,s\leq1$</li><li><p>对于前$30\%$的数据，保证$k\leq2,q\leq2$</p></li><li><p>对于另$20\%$的数据，保证$q=1$</p></li></ul><h2 id="D2T1-湖之精灵的游戏"><a href="#D2T1-湖之精灵的游戏" class="headerlink" title="D2T1 湖之精灵的游戏"></a>D2T1 湖之精灵的游戏</h2><p>一个二维平面上有$n$个点，第$i$个点的坐标是$(x_i,y_i)$，你要和一位神仙玩游戏。</p><p>每次神仙会告诉你一个坐标$(x,y)$，连一条经过$(0,0),(x,y)$的直线，这会把平面分成两个部分$A,B$</p><p>你要选择一个区间$[l,r]$，那么计算的时候只会考虑编号在$[l,r]$之内的点</p><p>一个半平面的价值是这个半平面中，编号在$[l,r]$范围内的点与$(0,0),(x,y)$组成三角形的面积之和</p><p>你要选择一个半平面，神仙会选择另一个半平面，你想要使得你得到的价值减去神仙得到的价值的结果尽量大</p><p>有$m$轮游戏，对于每轮游戏输出这个最大值乘以$2$的结果</p><p>保证$n,m\leq 10^6$，$1\leq x,y\leq1000$，时限$2$s</p><p>部分分：</p><ul><li>对于$20\%$的数据，$n,m\leq200$</li><li>对于$50\%$的数据，$n,m\leq 10^4$</li></ul><h2 id="D2T2-RGB"><a href="#D2T2-RGB" class="headerlink" title="D2T2 RGB"></a>D2T2 <font color=red>R</font><font color=green>G</font><font color=blue>B</font></h2><p>有一棵树，$n$个节点，每条边有边权$c_i$，每个点的颜色为<font color=red>R</font>,<font color=green>G</font>,<font color=blue>B</font>三种颜色之一</p><p>你要统计有序对$(U,V)$的数量，其中$U,V$是两个点集</p><p>它还需要满足以下条件：</p><ul><li>$U$和$V$都必须是连通的</li><li>$U$的颜色只能是红色或者绿色，$V$的颜色只能是绿色或者蓝色</li><li>存在一个$U,V$均包含的点$x$，使得对于所有在$U,V$集合中的点$y$，有$dis(x,y)\leq w$</li></ul><p>保证$n\leq 2000,w\leq10^7,c_i\leq10^6$，时限$1$s，对$10^9+7$取模</p><p>部分分：</p><ul><li>对于$30\%$的数据，$n\leq 15$</li><li>对于另$10\%$的数据，只有一个<font color=green>G</font></li><li>对于另$20\%$的数据，树是一条链</li></ul><h2 id="D2T3-函数"><a href="#D2T3-函数" class="headerlink" title="D2T3 函数"></a>D2T3 函数</h2><p>有$n$个数$v_1,v_2,\cdots,v_n$，现在有一类函数$f_T(x)$，其中$T$是$V$的一个子集，它的定义是</p><script type="math/tex; mode=display">f_T(x)=\bigoplus_{v_i\in T}(x+v_i)\\\f_\emptyset(x)=0</script><p>我们称两个函数$f_s,f_t$是$W-$本质不同的，当且仅当存在一个$0\leq x\leq W$，使得$f_s(x)\not=f_t(x)$</p><p>问在这$2^n$个函数中，有多少函数是$W-$本质不同的</p><p>保证$n,w,v_i&lt; 2^{17}$，时限$1$s</p><p>部分分：</p><ul><li>对于$20\%$的数据，$n\leq15,w\leq10$</li><li>对于另$20\%$的数据，$w=0$</li><li>对于前$70\%$的数据，$n,w,v_i\leq2^{10}$</li></ul>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二次剩余</title>
      <link href="/2019/04/09/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/"/>
      <url>/2019/04/09/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/</url>
      
        <content type="html"><![CDATA[<p>若方程$x^2\equiv a\pmod p$有解，那么称$a$为$p$的二次剩余，否则$a$为$p$的非二次剩余</p><h1 id="勒让德符号及欧拉判别法"><a href="#勒让德符号及欧拉判别法" class="headerlink" title="勒让德符号及欧拉判别法"></a>勒让德符号及欧拉判别法</h1><p>定义勒让德符号为</p><script type="math/tex; mode=display">\left(\frac{a}{p}\right)=\begin{cases}1&a为p的二次剩余\\\ -1&a为p的非二次剩余\\\ 0 &a能被p整除\end{cases}</script><p>欧拉判别法就是：如果$a$不能被$p$整除，那么有</p><script type="math/tex; mode=display">\left(\frac{a}{p}\right)=a^{\frac{p-1}{2}}</script><h2 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h2><blockquote><p>对于方程$x^2\equiv a\pmod p$ ，共有$\frac{p-1}{2}$个不同的$a$使得该方程有解</p></blockquote><p>我们忽略$x=0$，如果枚举$x$再求出$a$，那么$x$一共有$p-1$个不同的值，也就产生了$p-1$个$a$</p><p>我们知道一个二次剩余恰好会产生两个解，那么这$p-1$个$a$就被分配到了$\frac{p-1}{2}$个不同的桶里面</p><p>所以共有$\frac{p-1}{2}$个$a$</p><h2 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h2><blockquote><p>$(x+y)^p\equiv x^p+y^p\pmod p$</p></blockquote><p>我们将其二项式展开</p><script type="math/tex; mode=display">(x+y)^p=\sum_{i=0}^p{p\choose i}x^iy^{p-i}</script><p>当$i\not=0$且$i\not=p$时，$p\choose i$一定包含因数$p$，所以可以忽略</p><p>只剩下第一项和最后一项</p><h1 id="Cipolla算法"><a href="#Cipolla算法" class="headerlink" title="Cipolla算法"></a>Cipolla算法</h1><p>现在要求出方程$x^2\equiv n\pmod p$的一个解</p><p>我们找出一个$a​$，使得$(a^2-n)^{\frac{p-1}{2}}\equiv-1\pmod p​$</p><p>设$\omega=\sqrt{a^2-n}$</p><blockquote><p>结论：$x=(a+\omega)^{\frac{p+1}{2}}$</p></blockquote><p>证明如下：</p><p>我们知道</p><script type="math/tex; mode=display">(a^2-n)^{\frac{p-1}{2}}\equiv-1\pmod p\Rightarrow (\omega^2)^{\frac{p-1}{2}}\equiv -1\pmod p\\\\omega^{p-1}\equiv -1\pmod p</script><p>那么有</p><script type="math/tex; mode=display">\begin{aligned}x&\equiv (a+\omega)^{\frac{p+1}{2}}\\\x^2&\equiv (a+\omega)^{p+1}\equiv(a+\omega)^p(a+\omega)\\\&\equiv(a^p+\omega^p)(a+\omega)\\\&\equiv(a-\omega)(a+\omega)\\\&\equiv a^2-\omega^2\equiv a^2-a^2+n\equiv n\end{aligned}</script><p>我们可以通过实现一个类似复数的结构体来进行运算</p><p>由于$p$的二次剩余一共有$\frac{p-1}{2}$个，而$a$在$[0,p)$中随机选取</p><p>那么成功的概率就是$\frac{1}{2}$</p><p>此时答案中$\omega$部分的系数必然为0</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二次剩余 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BSGS及其拓展</title>
      <link href="/2019/04/09/BSGS%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95/"/>
      <url>/2019/04/09/BSGS%E5%8F%8A%E5%85%B6%E6%8B%93%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h1 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a>BSGS</h1><p>解高次同余方程</p><script type="math/tex; mode=display">A^x\equiv B\mod C且A\bot B</script><p>根据费马小定理，我们直到$A^{C-1}\equiv B\mod C$</p><p>那么如果这个方程有解，那么解的周期一定不会大于$C$，所以必然存在一个不大于$C$的解</p><p>如果$C$比较小，那么我们可以直接枚举$x$然后暴力判断</p><p>考虑$C$比较大的情况，这时就需要使用<code>BSGS</code>了</p><p>我们设$x=i*m-j$，其中$j&lt;m$，这个$m$是一个常量，我们设为$\sqrt{C}$</p><p>那么有</p><script type="math/tex; mode=display">A^{i\*m-j}\equiv B\mod C\\\A^{i\*m}\equiv B\*A^j\mod C</script><p>我们开一个<code>map</code>，枚举$j$，将$B*A^j$放到这个<code>map</code>里面</p><p>然后我们枚举$i*m$，在<code>map</code>中查找是否存在$A^{i*m}​$即可</p><p>注意这样枚举是取不到$x=0$的，这种情况我们需要特判</p><p>如果$i*m$此时已经大于$C$了，那么就无解</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">BSGS</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (B % C == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; s.clear();</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(C)), ls = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++, ls = (LL)ls * A % C)</span><br><span class="line">        s[(LL)B * ls % C] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, t = ls;i &lt;= C;i += m, t = (LL)t * ls % C) </span><br><span class="line">        <span class="keyword">if</span> (s.count(t)) <span class="keyword">return</span> i - s[t];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="exBSGS"><a href="#exBSGS" class="headerlink" title="exBSGS"></a>exBSGS</h1><p>同样是解上面那个方程</p><p>但是如果$A,C$不互质呢</p><p>原方程等价于</p><script type="math/tex; mode=display">A^x+Cy=B</script><p>我们不停地消去$A,C$的非1因子，可以使得方程变为</p><script type="math/tex; mode=display">aA^z+C'y=B'</script><p>每消去一次，我们就从$A^x$里面拿一个$A$出来，消完之后乘到系数$a$里面去</p><p>注意在消去过程中时，如果存在某个时刻使得$a=B’$，那么直接返回此时的消去次数就可以了</p><p>如果在消去过程中，$B’$没有当前要消去的那个因子，那么直接返回$-1$</p><p>我们设消去次数为$k$</p><p>那么此时方程就变成了</p><script type="math/tex; mode=display">aA^z\equiv B'\mod C'(A\bot C')</script><p>使用普通的<code>BSGS</code>可以解出$z$，注意此时前面还有一个系数$a$</p><p>最后我们将解出的$z$加上$k$即可，因为最开始拿出了$k$个$A$来消去因数</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> b ? gcd(b, a % b) : a;&#125;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">BSGS</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C, <span class="keyword">int</span> basic)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (B % C == basic) <span class="keyword">return</span> <span class="number">0</span>; s.clear();</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(C)), ls = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++, ls = (LL)ls * A % C)</span><br><span class="line">        s[(LL)B * ls % C] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, t = (LL)ls * basic % C;i &lt;= C;i += m, t = (LL)t * ls % C) </span><br><span class="line">        <span class="keyword">if</span> (s.count(t)) <span class="keyword">return</span> i - s[t];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">exBSGS</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, cnt = <span class="number">0</span>, d; A %= C, B %= C;</span><br><span class="line">    <span class="keyword">while</span> ((d = gcd(A, C)) != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (B % d) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        a = (LL)a * (A / d) % C, C /= d, B /= d, cnt++;</span><br><span class="line">        <span class="keyword">if</span> (a == B) <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = BSGS(A, B, C, a);</span><br><span class="line">    <span class="keyword">return</span> ~res ? res + cnt : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BSGS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12省联考2019 字符串问题</title>
      <link href="/2019/04/08/12%E7%9C%81%E8%81%94%E8%80%832019-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98/"/>
      <url>/2019/04/08/12%E7%9C%81%E8%81%94%E8%80%832019-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给出一个字符串$S$， 现在要选取它的$n_a$个子串作为$A$类串，选取$n_b$个子串作为$B$类串</p><p>其中第$i$个$A$类串为$S(la_i,ra_i)$，第$i$个$B$类串为$S(lb_i,rb_i)$，$la_i,ra_i,lb_i,rb_i,n_a,n_b$均已给出</p><p>现额外给定$m$组支配关系，每组关系$(x,y)$表示第$x$个$A$类串支配第$y$个$B$类串</p><p>求出一个长度最大的字符串$T$，满足$T$是由$A$类串拼接而成的。我们假设$T$被划分成了$t_1,t_2,\cdots,t_k$（都是$A$类串），要求满足对于任意的$i&lt;k$，$t_i$所支配的串中至少有一个是$t_{i+1}$的前缀</p><p><img src="https://i.loli.net/2019/04/08/5cab4fcbe56e2.png" alt="1554730942968"></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>对于这种要求所求值最大的问题，不是动态规划就是最长路</p><p>那么对于这道题显然就只能是最长路了</p><p>如果最后构建出来的图有环，那么$T$就可以无限长</p><p>否则我们拓扑排序，然后跑一个<code>dp</code>就可以了</p><p>首先我们将$S$串翻转，将所有的$A$串与$B$串都翻转</p><p>这样限制条件就可以变为我们熟悉的后缀</p><p>我们先考虑一种暴力连边方式</p><p>每个$A$串建一个点，每个$B$串建一个点</p><p>对于$A_i$，将所有是其后缀的$B$连向$A_i$，权值为$|A_i|$</p><p>对于一组支配$(A_i,B_i)$，$A_i$往$B_i$连一条权值为0的边</p><p>但是这样最坏会连$n_a*n_b$条边，需要优化</p><p>我们考虑这样一种优化方案</p><p>对于任意的$A_i,B_i$，如果$B_i$是$A_i$的后缀，那么$B_i$的后缀也是$A_i$的后缀</p><p>我们对于$B$单独建一个子图，这个子图需要满足如果$B_i$是$B_j$的后缀，那么所有能走到$B_i$的路径都可以走到$B_j$</p><p>这样的话$A_i$只需要从它包含的那个最长的$B$串后缀连边就可以了</p><p>那么什么图满足这个性质呢？</p><p>很明显是<code>parent</code>树</p><p>我们建出<code>parent</code>树，然后从父亲往儿子节点连边</p><p>因为父亲对应的点一定是儿子的后缀</p><p>对于每个串$A_i,B_i$，找到它在树上的位置，这个可以通过倍增实现</p><p>实际上我们不需要对于每个串$A$，都找到那个最长的且是它后缀的$B$</p><p>直接从<code>parent</code>树上$A_i$的对应节点往$A_i$连边就可以了</p><p>因为这样同样可以保证最长的且是它后缀的$B$可以走到$A_i$</p><p>兴奋地写完，发现第三个样例过不去($-1$)</p><p>事实上是我们少考虑了一种情况</p><p><code>parent</code>树上的某个节点可以表示长度在一段区间的串</p><p>如果一条路径是从父亲走向儿子，那么当然没有问题，因为此时它代表的串是这个节点所能代表的最短的串</p><p>如果有一个串$A_i$以及另一个串$B_j$，它们对应着树上的同一个点</p><p>在之前的建图方式中，$B_j$一定能到达$A_i$</p><p>但是如果$|B_j|&gt;|A_i|$呢，显然这种转移是不合法的</p><p>解决方法是对于树上的一个点$u$，假如有$a_u$个$A$串挂在上面</p><p>那么我们将这些$A$串按照长度从小到大排序，将$u$拆成$a_u+1$个点，第$i$个点往$i+1$个点连边，父亲的最右边那个点往儿子的最左边那个点连边</p><p>对于一个串$B$，它就对应着它在树上的那个点所拆成的点中，第一个长度不小于它的点</p><p>这样就没有问题了</p><p>注意开<code>long long</code></p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> P = pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="keyword">int</span> LEN;</span><br><span class="line"><span class="keyword">namespace</span> SAM &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; next; </span><br><span class="line">        <span class="keyword">int</span> link, len;</span><br><span class="line">    &#125; st[N * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ncnt, last;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;st[<span class="number">0</span>].link = <span class="number">-1</span>, st[<span class="number">0</span>].len = ncnt = last = <span class="number">0</span>, st[<span class="number">0</span>].next.clear();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">extend</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = ++ncnt, p; st[cur].len = st[last].len + <span class="number">1</span>, st[cur].link = <span class="number">0</span>, st[cur].next.clear();</span><br><span class="line">        <span class="keyword">for</span> (p = last;p != <span class="number">-1</span> &amp;&amp; !st[p].next.count(c);p = st[p].link)</span><br><span class="line">            st[p].next[c] = cur;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> q = st[p].next[c];</span><br><span class="line">            <span class="keyword">if</span> (st[q].len == st[p].len + <span class="number">1</span>) st[cur].link = q;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> clone = ++ncnt; st[clone].len = st[p].len + <span class="number">1</span>, st[clone].next = st[q].next, st[clone].link = st[q].link;</span><br><span class="line">                <span class="keyword">for</span> (;p != <span class="number">-1</span> &amp;&amp; st[p].next[c] == q;p = st[p].link)</span><br><span class="line">                    st[p].next[c] = clone;</span><br><span class="line">                st[q].link = st[cur].link = clone;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= ncnt;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : st[i].next)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"sam: "</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span> &lt;&lt; v.second &lt;&lt; <span class="string">' '</span> &lt;&lt; v.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> SUF_Tree &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to, next;&#125; e[N * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> head[N * <span class="number">2</span>], ecnt, len[N * <span class="number">2</span>], fa[<span class="number">18</span>][N * <span class="number">2</span>]; </span><br><span class="line">    <span class="built_in">vector</span>&lt;P&gt; nodes[N * <span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">        fa[<span class="number">0</span>][u] = f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">17</span>;i++) fa[i][u] = fa[i - <span class="number">1</span>][fa[i - <span class="number">1</span>][u]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">            <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">2</span> * LEN;i++) head[i] = <span class="number">0</span>, nodes[i].clear(), nodes[i].push_back(P(<span class="number">1e9</span>, <span class="number">-1</span>));</span><br><span class="line">        ecnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>;i &gt;= <span class="number">0</span>;i--) <span class="keyword">if</span> (fa[i][u])</span><br><span class="line">            <span class="keyword">if</span> (l &lt;= len[fa[i][now]])</span><br><span class="line">                now = fa[i][now];</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> s[N]; <span class="keyword">int</span> id[N], tot, onT[N], sz[N], onT2[N], na;</span><br><span class="line"><span class="keyword">namespace</span> GRAPH &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to, next, w;&#125; e[N * <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">int</span> head[N * <span class="number">4</span>], ecnt, ind[N * <span class="number">4</span>], st[N * <span class="number">4</span>], top, ncnt; LL dp[N * <span class="number">4</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        e[++ecnt] = (edge)&#123;to, head[from], w&#125;, ind[to]++, head[from] = ecnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Topsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        top = <span class="number">0</span>; <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= ncnt;i++) <span class="keyword">if</span> (!ind[i]) q.push(i), st[++top] = i;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next) </span><br><span class="line">                <span class="keyword">if</span> (!(--ind[e[i].to])) q.push(e[i].to), st[++top] = e[i].to;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> top == ncnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= ncnt;i++) head[i] = ind[i] = dp[i] = <span class="number">0</span>;</span><br><span class="line">        ecnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">DP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = top;i &gt;= <span class="number">1</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = st[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = head[u];j;j = e[j].next)</span><br><span class="line">                dp[u] = max(dp[u], dp[e[j].to] + e[j].w);</span><br><span class="line">            <span class="keyword">if</span> (u &lt;= na) res = max(res, dp[u] + sz[u]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p[N * <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    p[u].clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : SUF_Tree::nodes[u]) &#123;</span><br><span class="line">        p[u].push_back(++tot);</span><br><span class="line">        <span class="keyword">if</span> (v.second &gt; <span class="number">0</span>) onT[v.second] = tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i + <span class="number">1</span> &lt; p[u].size();i++)</span><br><span class="line">        GRAPH::adde(p[u][i], p[u][i + <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = SUF_Tree::head[u];i;i = SUF_Tree::e[i].next) &#123;</span><br><span class="line">        dfs(SUF_Tree::e[i].to);</span><br><span class="line">        GRAPH::adde(*p[u].rbegin(), *p[SUF_Tree::e[i].to].begin(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; read(T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>), LEN = <span class="built_in">strlen</span>(s + <span class="number">1</span>), reverse(s + <span class="number">1</span>, s + LEN + <span class="number">1</span>), SAM::init(), SUF_Tree::init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= LEN;i++) id[i] = SAM::extend(s[i]);</span><br><span class="line"><span class="comment">//        cout &lt;&lt; SAM::ncnt &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= SAM::ncnt;i++) SUF_Tree::adde(SAM::st[i].link, i), SUF_Tree::len[i] = SAM::st[i].len;</span><br><span class="line">        SUF_Tree::dfs(<span class="number">0</span>, <span class="number">0</span>); read(na), tot = na;</span><br><span class="line"><span class="comment">//        cout &lt;&lt; "ok" &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l, r;i &lt;= na;i++) &#123;</span><br><span class="line">            read(l), read(r), l = LEN - l + <span class="number">1</span>, r = LEN - r + <span class="number">1</span>, swap(l, r), sz[i] = r - l + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> t = SUF_Tree::find(id[r], r - l + <span class="number">1</span>); </span><br><span class="line">            SUF_Tree::nodes[t].push_back(P(r - l + <span class="number">1</span>, i));</span><br><span class="line">        &#125;</span><br><span class="line">        GRAPH::ncnt = na * <span class="number">2</span> + SAM::ncnt + <span class="number">1</span>, GRAPH::init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= SAM::ncnt;i++) sort(SUF_Tree::nodes[i].begin(), SUF_Tree::nodes[i].end());</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= na;i++) GRAPH::adde(onT[i], i, sz[i]);</span><br><span class="line">        <span class="keyword">int</span> nb; read(nb);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l, r;i &lt;= nb;i++) &#123;</span><br><span class="line">            read(l), read(r), l = LEN - l + <span class="number">1</span>, r = LEN - r + <span class="number">1</span>, swap(l, r);</span><br><span class="line">            <span class="keyword">int</span> t = SUF_Tree::find(id[r], r - l + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> pos = lower_bound(SUF_Tree::nodes[t].begin(), SUF_Tree::nodes[t].end(), P(r - l + <span class="number">1</span>, <span class="number">-2</span>)) - SUF_Tree::nodes[t].begin();</span><br><span class="line">            onT2[i] = p[t][pos];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> matches; read(matches);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= matches;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b; read(a), read(b), GRAPH::adde(a, onT2[b], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        GRAPH::ncnt = tot;</span><br><span class="line">        <span class="keyword">if</span> (!GRAPH::Topsort()) &#123;<span class="built_in">puts</span>(<span class="string">"-1"</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, GRAPH::DP());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 优化连边 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BJOI2018 双人猜数游戏</title>
      <link href="/2019/04/07/BJOI2018-%E5%8F%8C%E4%BA%BA%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/"/>
      <url>/2019/04/07/BJOI2018-%E5%8F%8C%E4%BA%BA%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4459" target="_blank" rel="noopener">题目链接</a></p><p>神仙题啊</p><p>首先来模拟一下样例</p><p><code>Alice</code>知道乘积是60，<code>Bob</code>知道和是16，且两个数均不小于5</p><p><code>Bob</code>：此时两个数有可能为</p><p>$(5, 11), (6, 10), (7, 9), (8, 8)$</p><p>而<code>Bob</code>在第一轮没有猜出来，也就是说，这两个数的和不是10或11</p><p><code>Alice</code>：此时两个数有可能为</p><p>$(5, 12), (6, 10)$</p><p>由于Alice也没有猜出来，所以对于Bob来说，以下情况就被排除了</p><p>$(5, 11), (7, 9), (8, 8)$</p><p>对于$(5, 11)$而言，55只有这一种分解方式，而<code>Alice</code>在第一轮中没有猜出来，所以不是</p><p>对于$(7, 9)$而言，63还可以被分解成$(3, 21)$，但是不满足两个数都大于等于5，而<code>Alice</code>没有猜出来，所以也不是</p><p>$(8, 8)​$同理</p><p>所以对于<code>Bob</code>来说，这两个数只有可能是$(6, 10)$，他也就确定了答案</p><p><code>Alice</code>知道，<code>Bob</code>已经猜出来了，所以$(5, 12)$就被排除了，因为在这种情况下，$Bob​$不可能这么早就猜出答案</p><p>所以<code>Alice</code>也知道答案是$(6, 10)​$了</p><p>我们用<code>dp</code>来描述这个过程，<code>dp[i][n][m]</code>表示，当前是第i轮，且两个答案分别是$n,m$，在$1-i​$轮中，是否能决定答案</p><p>如果这一轮是<code>Bob</code>猜，那么我们就枚举$n+m$的划分方式。如果每一种合法的划分方式都能在$1-(i-1)$轮被猜出来，那么<code>Bob</code>一定能确定这两个数分别为$n, m$</p><p>否则，我们则枚举$n*m$的约数， 判断方式与<code>Bob</code>的相同</p><p>但是这样可能会出现一种特殊情况，就是已经到了$t$轮，第一个人猜出来了，而第二个人没有猜出来</p><p>那么我们就多进行一轮转移，这次转移与之前的转移相反，如果每一种合法的划分方式在$1-t$轮都不能被猜出来，那么才能确定答案</p><p>$n,m$的最大值不会超过500，直接枚举</p><p>直接交程序，数组只开500的话是秒跑</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500</span></span><br><span class="line"><span class="keyword">int</span> dp[N + <span class="number">10</span>][N + <span class="number">10</span>][<span class="number">16</span>], m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, tmpa, tmpb;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, j;i &lt;= a + b - i &amp;&amp; cnt &lt; <span class="number">2</span>;i++) </span><br><span class="line">        <span class="keyword">if</span> (!dp[i][j = a + b - i][c - <span class="number">1</span>] || c == <span class="number">1</span>) </span><br><span class="line">            cnt++, tmpa = i, tmpb = j;</span><br><span class="line">    <span class="keyword">return</span> cnt == <span class="number">1</span> &amp;&amp; a == tmpa &amp;&amp; b == tmpb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, tmpa, tmpb;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, j;i * i &lt;= a * b &amp;&amp; cnt &lt; <span class="number">2</span>;i++)</span><br><span class="line">        <span class="keyword">if</span> (a * b % i == <span class="number">0</span> &amp;&amp; (!dp[i][j = a * b / i][c - <span class="number">1</span>] || c == <span class="number">1</span>))</span><br><span class="line">            cnt++, tmpa = i, tmpb = j;</span><br><span class="line">    <span class="keyword">return</span> cnt == <span class="number">1</span> &amp;&amp; a == tmpa &amp;&amp; b == tmpb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, tmpa, tmpb;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, j;i &lt;= a + b - i &amp;&amp; cnt &lt; <span class="number">2</span>;i++) </span><br><span class="line">        <span class="keyword">if</span> (dp[i][j = a + b - i][c] &amp;&amp; !dp[i][j][c - <span class="number">2</span>]) </span><br><span class="line">            cnt++, tmpa = i, tmpb = j;</span><br><span class="line">    <span class="keyword">return</span> cnt == <span class="number">1</span> &amp;&amp; a == tmpa &amp;&amp; b == tmpb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check4</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, tmpa, tmpb;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m, j;i * i &lt;= a * b &amp;&amp; cnt &lt; <span class="number">2</span>;i++)</span><br><span class="line">        <span class="keyword">if</span> (a * b % i == <span class="number">0</span> &amp;&amp; dp[i][j = a * b / i][c] &amp;&amp; !dp[i][j][c - <span class="number">2</span>])</span><br><span class="line">            cnt++, tmpa = i, tmpb = j;</span><br><span class="line">    <span class="keyword">return</span> cnt == <span class="number">1</span> &amp;&amp; a == tmpa &amp;&amp; b == tmpb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">8</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t, flag; <span class="built_in">scanf</span>(<span class="string">"%d%s%d"</span>, &amp;m, name + <span class="number">1</span>, &amp;t), flag = name[<span class="number">1</span>] == <span class="string">'B'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= t + <span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = m;a &lt;= N / <span class="number">2</span>;a++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = a;b &lt;= N;b++)</span><br><span class="line">                dp[a][b][i] = dp[a][b][i - <span class="number">2</span>] | (((i &amp; <span class="number">1</span>) ^ flag ^ <span class="number">1</span>) ? check1(a, b, i) : check2(a, b, i));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = m * <span class="number">2</span>;s;s++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = m, b = s - a;a * <span class="number">2</span> &lt;= s;a++, b = s - a)</span><br><span class="line">            <span class="keyword">if</span> (dp[a][b][t + <span class="number">1</span>] &amp;&amp; !(dp[a][b][t - <span class="number">1</span>] | dp[a][b][t])) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = t &amp; <span class="number">1</span> ^ flag;</span><br><span class="line">                <span class="keyword">if</span> (!(tmp ? check4(a, b, t + <span class="number">1</span>) : check3(a, b, t + <span class="number">1</span>))) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">' '</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BJOI2018 二进制</title>
      <link href="/2019/04/07/BJOI2018-%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
      <url>/2019/04/07/BJOI2018-%E4%BA%8C%E8%BF%9B%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4428" target="_blank" rel="noopener">题目链接</a></p><p>先考虑哪些二进制在重新排列之后可以是3的倍数</p><p>我们分3种情况讨论：</p><ol><li>0 ：模3的余数是0</li><li>10 ：就是1出现在下标为偶数的地方，模3余2</li><li>01 ：1出现在下标为奇数的地方，模3余1</li></ol><p>那么，我们就可以用这三种余数来进行组合</p><p>考虑以下情况：</p><ol><li>有偶数个1 ：显然，通过情况2与3组合可以成为3的倍数</li><li>有奇数个1 ：注意到3个情况2或者情况3的叠加仍然可以成为3的倍数，而这样至少需要2个0和3个1（10101）</li></ol><p>那么综合上面两种情况，我们可以得出结论，一段区间为不合法的区间当且仅当：</p><ol><li>区间内只有1个1</li><li>区间中有奇数个1且没有0</li><li>区间中有奇数个1且有1个0</li></ol><p>这道题是带修改的，所以需要将<code>dp</code>放到线段树上统计</p><p>那么我们考虑一段区间应该维护什么</p><p>首先将第一种情况分开，先不管</p><p>那么对于一段区间，我们可以用<code>dp[i][j(0/1)][k(0/1)]</code>表示</p><p>即状态为$i$，1的个数是奇数还是偶数，出现了0个0还是1个0的区间总数</p><p>线段树<code>pushup</code>的时候子区间也是可以跨<code>mid</code>合并的</p><p>具体来说，就是一个左子树的以<code>mid</code>为右端点的区间和一个右子树的以<code>mid + 1</code>为左端点的区间合并</p><p>所以，对于状态i，我们这样设计</p><p><code>i = 0</code> 表示不取左端点和右端点</p><p><code>i = 1</code> 表示必须取左端点，不能取右端点</p><p><code>i = 2</code> 表示必须取右端点，不能取左端点</p><p><code>i = 3</code> 表示必须左右端点都取</p><p>合并的时候枚举一下有几个0以及1的奇偶性就可以了</p><p>我们另外开一个数组，单独统计情况1，也就是只有1个1的区间的数量</p><p>转移与上面的类似</p><p><code>g[i][j(0/1)]</code>表示状态为$i$，出没出现1的区间的总数</p><p>但是统计的时候不能直接将两个加起来</p><p>注意到这两个统计是有重复的，当我们进行第一次统计时也顺便统计了区间内有1个1，只有0/1个0的数量，需要去重</p><p>对于有1个1，0个0的区间数量，显然也就是区间内1的数量</p><p>对于有1个1，1个0的区间数量，我们用一个树状数组维护，在这个01区间的第一位维护即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    LL f[<span class="number">4</span>][<span class="number">2</span>][<span class="number">2</span>], g[<span class="number">4</span>][<span class="number">2</span>];</span><br><span class="line">    Data() &#123;<span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)), <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span>(g));&#125;</span><br><span class="line">&#125; T[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Data <span class="title">UN</span><span class="params">(Data a, Data b)</span> </span>&#123;</span><br><span class="line">    Data c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= <span class="number">1</span>;j++) &#123;</span><br><span class="line">            c.f[<span class="number">0</span>][i][j] += a.f[<span class="number">0</span>][i][j] + b.f[<span class="number">0</span>][i][j] + a.f[<span class="number">2</span>][i][j] + b.f[<span class="number">1</span>][i][j];</span><br><span class="line">            c.f[<span class="number">1</span>][i][j] += a.f[<span class="number">1</span>][i][j] + a.f[<span class="number">3</span>][i][j], c.f[<span class="number">2</span>][i][j] += b.f[<span class="number">2</span>][i][j] + b.f[<span class="number">3</span>][i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        c.g[<span class="number">0</span>][i] += a.g[<span class="number">0</span>][i] + b.g[<span class="number">0</span>][i] + a.g[<span class="number">2</span>][i] + b.g[<span class="number">1</span>][i];</span><br><span class="line">        c.g[<span class="number">1</span>][i] += a.g[<span class="number">1</span>][i] + a.g[<span class="number">3</span>][i], c.g[<span class="number">2</span>][i] += b.g[<span class="number">2</span>][i] + b.g[<span class="number">3</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= <span class="number">1</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + j &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                c.g[<span class="number">0</span>][i + j] += a.g[<span class="number">2</span>][i] * b.g[<span class="number">1</span>][j], c.g[<span class="number">1</span>][i + j] += a.g[<span class="number">3</span>][i] * b.g[<span class="number">1</span>][j];</span><br><span class="line">                c.g[<span class="number">2</span>][i + j] += a.g[<span class="number">2</span>][i] * b.g[<span class="number">3</span>][j], c.g[<span class="number">3</span>][i + j] += a.g[<span class="number">3</span>][i] * b.g[<span class="number">3</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= <span class="number">1</span>;k++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>;k + l &lt;= <span class="number">1</span>;l++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> ti = (i + j) &amp; <span class="number">1</span>, tj = k + l;</span><br><span class="line">                    c.f[<span class="number">0</span>][ti][tj] += a.f[<span class="number">2</span>][i][k] * b.f[<span class="number">1</span>][j][l], c.f[<span class="number">1</span>][ti][tj] += a.f[<span class="number">3</span>][i][k] * b.f[<span class="number">1</span>][j][l];</span><br><span class="line">                    c.f[<span class="number">2</span>][ti][tj] += a.f[<span class="number">2</span>][i][k] * b.f[<span class="number">3</span>][j][l], c.f[<span class="number">3</span>][ti][tj] += a.f[<span class="number">3</span>][i][k] * b.f[<span class="number">3</span>][j][l];</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> val[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="keyword">void</span>(T[rt].f[<span class="number">3</span>][val[l]][val[l] ^ <span class="number">1</span>] = T[rt].g[<span class="number">3</span>][val[l]] = <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; build(rt &lt;&lt; <span class="number">1</span>, l, mid), build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    T[rt] = UN(T[rt &lt;&lt; <span class="number">1</span>], T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> at)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        val[l] ^= <span class="number">1</span>, T[rt] = Data();</span><br><span class="line">        T[rt].f[<span class="number">3</span>][val[l]][val[l] ^ <span class="number">1</span>] = T[rt].g[<span class="number">3</span>][val[l]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (at &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, at); <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, at);</span><br><span class="line">    T[rt] = UN(T[rt &lt;&lt; <span class="number">1</span>], T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Data <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> T[rt];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (end &lt;= mid) <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span>, l, mid, start, end);</span><br><span class="line">    <span class="keyword">if</span> (start &gt; mid) <span class="keyword">return</span> query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, start, end);</span><br><span class="line">    <span class="keyword">return</span> UN(query(rt &lt;&lt; <span class="number">1</span>, l, mid, start, mid), query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, end));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tree[<span class="number">2</span>][N], n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> at, <span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">for</span> (;at &lt;= n;at += at &amp; -at) tree[id][at] += x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> at)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;at;at -= at &amp; -at) res += tree[id][at];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val[i]), update(<span class="number">0</span>, i, val[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) <span class="keyword">if</span> (val[i] != val[i + <span class="number">1</span>]) update(<span class="number">1</span>, i, <span class="number">1</span>);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n); <span class="keyword">int</span> q; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b != n) update(<span class="number">1</span>, b, <span class="number">-2</span> * (val[b] != val[b + <span class="number">1</span>]) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="number">1</span>) update(<span class="number">1</span>, b - <span class="number">1</span>, <span class="number">-2</span> * (val[b - <span class="number">1</span>] != val[b]) + <span class="number">1</span>);</span><br><span class="line">            update(<span class="number">0</span>, b, <span class="number">-2</span> * val[b] + <span class="number">1</span>), update(<span class="number">1</span>, <span class="number">1</span>, n, b);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c); Data tmp = query(<span class="number">1</span>, <span class="number">1</span>, n, b, c); LL res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">3</span>;i++) res += tmp.f[i][<span class="number">1</span>][<span class="number">0</span>] + tmp.f[i][<span class="number">1</span>][<span class="number">1</span>] + tmp.g[i][<span class="number">1</span>];</span><br><span class="line">            res -= query(<span class="number">0</span>, c) - query(<span class="number">0</span>, b - <span class="number">1</span>) + query(<span class="number">1</span>, c - <span class="number">1</span>) - query(<span class="number">1</span>, b - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (LL)(c - b + <span class="number">1</span>) * (c - b + <span class="number">2</span>) / <span class="number">2</span> - res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFT与NTT专题</title>
      <link href="/2019/04/07/FFT%E4%B8%8ENTT%E4%B8%93%E9%A2%98/"/>
      <url>/2019/04/07/FFT%E4%B8%8ENTT%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="A-–-礼物"><a href="#A-–-礼物" class="headerlink" title="A – 礼物"></a>A – 礼物</h1><p>先不管旋转操作，考虑化简这个差异值</p><script type="math/tex; mode=display">\begin{aligned}\sum_{i=1}^n(x_i-y_i-c)^2&=\sum_{i=1}^n(x_i-y_i)^2+nc^2-2c\sum_{i=1}^n(x_i-y_i)\\\&=\sum_{i=1}^nx_i^2+\sum_{i=1}^ny_i^2+nc^2-2c\sum_{i=1}^n(x_i-y_i)-2\sum_{i=1}^nx_iy_i\end{aligned}</script><p>注意到$\sum x^2+\sum y^2$是常数，先不管</p><p>可以发现，这是一个关于$c$的二次函数</p><p>那么我们知道，此时$c$的极值点就在$-\frac{b}{2a}$处</p><p>所以，我们可以得出$c$的最优值是</p><script type="math/tex; mode=display">\frac{\sum_{i=1}^n x_i-\sum_{i=1}^n y_i}{n}</script><p>而分子的两个数均与旋转无关</p><p>但是$c$只能是整数</p><p>所以判一下$c, c-1, c+1$哪个与上面的式子更接近</p><p>注意到旋转唯一能改变的是$\sum xy$</p><p>而我们要让这个值尽量小</p><p>设</p><script type="math/tex; mode=display">F(m)=\sum_{i=1}^nx_iy_{i+m}</script><p>我们可以看出，这是一个类似卷积的东西</p><p>但是一般的卷积是后两式下标的和不变</p><p>而这个是差不变</p><p>所以把这个式子变一下</p><p>设</p><script type="math/tex; mode=display">x_{n-i+1}=x_i</script><p>就是将x倒序一下</p><p>可以得到 </p><script type="math/tex; mode=display">F(m)=\sum_{i=1}^nx_{n-i+1}y_{i+m}</script><p>不妨设后面$xy$的卷积是$A$，也就是</p><script type="math/tex; mode=display">A(n+m+1)=\sum_{i=1}^nx_{n-i+1}y_{i+m}</script><p>可以发现，这个$A$就是将$F$整体向右平移了$n+1$</p><p>所以</p><script type="math/tex; mode=display">F(m)=A(n+m+1)</script><p>为了不丢精度，NTT即可（保证答案不会超过mod）</p><p>代码如下 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">int</span> r[N &lt;&lt; <span class="number">2</span>]; <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> type, <span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, w = <span class="number">1</span>, t;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w = (LL)w * Wn % mod)</span><br><span class="line">                t = (LL)w * a[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x[N], y[N], A[N &lt;&lt; <span class="number">2</span>], B[N &lt;&lt; <span class="number">2</span>], res[N];</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; <span class="keyword">inline</span> T <span class="title">Abs</span><span class="params">(<span class="keyword">const</span> T x)</span> </span>&#123;<span class="keyword">return</span> x &gt; <span class="number">0</span> ? x : -x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, sumx = <span class="number">0</span>, sumy = <span class="number">0</span>, sumx2 = <span class="number">0</span>, sumy2 = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x[i]), A[i] = x[i], sumx += x[i], sumx2 += x[i] * x[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;y[i]), B[<span class="number">2</span> * n - i] = B[n - i] = y[i], sumy += y[i], sumy2 += y[i] * y[i];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= <span class="number">3</span> * n) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    NTT(len, <span class="number">1</span>, A), NTT(len, <span class="number">1</span>, B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) A[i] = (LL)A[i] * B[i] % mod;</span><br><span class="line">    NTT(len, <span class="number">0</span>, A); <span class="keyword">int</span> Inv = Pow(len, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) res[i] = (LL)A[<span class="number">2</span> * n - i] * Inv % mod;</span><br><span class="line">    <span class="keyword">int</span> c = (sumx - sumy) / n; LL ans = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">if</span> (Abs((LL)c * n - sumx + sumy) &gt; Abs(((LL)c * n + n - sumx + sumy))) c++;</span><br><span class="line">    <span class="keyword">if</span> (Abs((LL)c * n - sumx + sumy) &gt; Abs(((LL)c * n - n - sumx + sumy))) c--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        LL tmp = (LL)sumx2 + sumy2 - <span class="number">2</span> * res[i] - (LL)<span class="number">2</span> * c * (sumx - sumy) + (LL)n * c * c;</span><br><span class="line">        <span class="keyword">if</span> (tmp &lt; ans) ans = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-–-求和"><a href="#B-–-求和" class="headerlink" title="B – 求和"></a>B – 求和</h1><p>我们知道</p><script type="math/tex; mode=display">S(n,m)=\sum_{i=0}^m(-1)^i{m\choose i}(m-i)^n\frac{1}{m!}</script><p>原理很简单，容斥有几个盒子没有放球，有$m\choose i$种选法，再将$n$个球放入$m-i$个盒子。由于盒子是无序的，最后除以$m$的阶乘</p><p>那么我们用这个化简原式</p><p>注意到第二个$\sum$的上界是$i$，非常讨厌</p><p>由于斯特林数的性质，把这个$i$换成$n$也没有问题</p><p>因为当$m&gt;n$时，$S(n,m)=0$</p><p>所以有</p><script type="math/tex; mode=display">\begin{aligned}\sum_{i=0}^n\sum_{j=0}^nS(i,j)\*2^j\*j!&=\sum_{j=0}^n2^j\*j!\sum_{i=0}^n\sum_{k=0}^j(-1)^k{j\choose k}(j-k)^i\frac{1}{j!}\\\&=\sum_{j=0}^n2^j\*j!\sum_{k=0}^j\frac{(-1)^k}{k!}\*\frac{\sum_{i=0}^n(j-k)^i}{(j-k)!}\end{aligned}</script><p>注意到后面那个是卷积的形式</p><p>第一个多项式很好求，第二个的分子是等比数列</p><p>我们设$B$是第二个多项式</p><p>显然有</p><script type="math/tex; mode=display">B(0)=0, B(1)=n+1</script><p>对于其它情况，直接用等比数列求和公式算出来就行了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">int</span> r[N &lt;&lt; <span class="number">2</span>]; <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> type, <span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, w = <span class="number">1</span>, t;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w = (LL)w * Wn % mod)</span><br><span class="line">                t = (LL)w * a[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> A[N &lt;&lt; <span class="number">2</span>], B[N &lt;&lt; <span class="number">2</span>], frac[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, len = <span class="number">1</span>, l = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    frac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= <span class="number">2</span> * n) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    A[<span class="number">0</span>] = B[<span class="number">0</span>] = <span class="number">1</span>, B[<span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) A[i] = (i &amp; <span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span>) * Pow(frac[i], mod - <span class="number">2</span>), A[i] = (A[i] + mod) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) B[i] = ((LL)(Pow(i, n + <span class="number">1</span>) - <span class="number">1</span>) * Pow(i - <span class="number">1</span>, mod - <span class="number">2</span>) % mod * Pow(frac[i], mod - <span class="number">2</span>) % mod + mod) % mod;</span><br><span class="line">    NTT(len, <span class="number">1</span>, A), NTT(len, <span class="number">1</span>, B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) A[i] = (LL)A[i] * B[i] % mod;</span><br><span class="line">    NTT(len, <span class="number">0</span>, A); <span class="keyword">int</span> Inv = Pow(len, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) res = (res + (LL)tmp * frac[i] % mod * A[i]) % mod, tmp = tmp * <span class="number">2</span> % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL)res * Inv % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-–-序列统计"><a href="#C-–-序列统计" class="headerlink" title="C – 序列统计"></a>C – 序列统计</h1><p>这题的难点在于转化成原根</p><p>注意到要求的是所有数的乘积而非和</p><p>如果是和的话直接NTT就好了</p><p>那么我们就将乘积转化成和的形式</p><p>如果两个数都是某个数的某次方，那么这两个数乘起来就是指数相加</p><p>而原根恰好可以表示模$m$剩余系下的每个数</p><p>所以把每个数转化成原根的某次方就好了</p><p>求原根代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">G</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, flg = <span class="number">1</span>;i;i++, flg = <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>;j * j &lt; x;j++) </span><br><span class="line">            <span class="keyword">if</span> ((x - <span class="number">1</span>) % j == <span class="number">0</span> &amp;&amp; Pow(i, (x - <span class="number">1</span>) / j, x) == <span class="number">1</span>) &#123;flg = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (flg) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-–-残缺的字符串"><a href="#D-–-残缺的字符串" class="headerlink" title="D – 残缺的字符串"></a>D – 残缺的字符串</h1><p>带通配符的字符串匹配问题</p><p>首先考虑不带通配符的怎么做</p><p>那么拓展KMP， 后缀数组都可以</p><p>但是我们有一个更高级的方法：FFT求字符串匹配</p><p>首先我们需要定义“匹配”</p><p>所以设差异函数$g(i)$表示从$B$串的$i$位置开始，与$A$串的差异程度</p><p>有</p><script type="math/tex; mode=display">g(x)=\sum_{i=x}^{x+m-1}(B_i-A_{i-x+1})^2</script><p>显然，只有当$A$串从$x$位置开始与$B$串完全相同，$g$的值才为0</p><p>化简原式</p><script type="math/tex; mode=display">\begin{aligned}g(x)&=\sum_{i=x}^{x+m-1}A_{i-x+1}^2+\sum_{i=x}^{x+m-1}B_i^2-2\sum_{i=x}^{x+m-1}B_iA_{i-x+1}\\\&=\sum_{i=1}^mA_i^2+\sum_{i=1}^mB_{i+x-1}^2-2\sum_{i=1}^mA_iB_{i+x-1}\end{aligned}</script><p>前两项可以通过预处理前缀和得出，后面的是一个下标差相等的卷积</p><p>那么模仿之前的套路，我们将$A$序列倒序一下再求卷积就行了</p><p>解决了不带通配符的问题，再考虑带通配符</p><p>这个通配符是可以匹配任意字符的，所以把差异函数改一下</p><script type="math/tex; mode=display">g(x)=\sum_{i=x}^{x+m-1}(B_i-A_{i-x+1})^2A_{i-x+1}B_i</script><p>当$i$处的字符是$*$时，我们设那个地方的值为0</p><p>化简得</p><script type="math/tex; mode=display">=\sum_{i=1}^mA_i^3B_{i-x+1}+\sum_{i=1}^mA_iB_{i-x+1}^3-2\sum_{i=1}^xA_i^2B_{i-x+1}^2</script><p>做3次FFT即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300010</span></span><br><span class="line"><span class="keyword">int</span> r[N &lt;&lt; <span class="number">2</span>]; <span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> type, <span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; <span class="title">Wn</span><span class="params">(<span class="built_in">cos</span>(<span class="number">2</span> * PI / mid), type * <span class="built_in">sin</span>(<span class="number">2</span> * PI / mid))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid) &#123;</span><br><span class="line">            complex&lt;double&gt; w(1), t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w *= Wn) </span><br><span class="line">                t = w * a[j + (mid &gt;&gt; <span class="number">1</span>)], a[j + (mid &gt;&gt; <span class="number">1</span>)] = a[j] - t, a[j] += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> a[N], b[N]; <span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; A[N &lt;&lt; <span class="number">2</span>], B[N &lt;&lt; <span class="number">2</span>]; <span class="keyword">int</span> a1[N], b1[N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line">LL res[N]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Clear(x) for (int i = 0;i &lt; len;i++) x[i] = 0;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    FFT(len, <span class="number">1</span>, A), FFT(len, <span class="number">1</span>, B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) A[i] *= B[i];</span><br><span class="line">    FFT(len, <span class="number">-1</span>, A);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) res[i] += k * (LL)(A[i].real() / len + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d%s%s"</span>, &amp;m, &amp;n, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) a1[m - i] = a[i] == <span class="string">'*'</span> ? <span class="number">0</span> : a[i] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) b1[i] = b[i] == <span class="string">'*'</span> ? <span class="number">0</span> : b[i] - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= m + n) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) A[i] = a1[i] * a1[i] * a1[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) B[i] = b1[i];</span><br><span class="line">    mul(len, n, <span class="number">1</span>); Clear(A) Clear(B)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) A[i] = a1[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) B[i] = b1[i] * b1[i] * b1[i];</span><br><span class="line">    mul(len, n, <span class="number">1</span>); Clear(A) Clear(B)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) A[i] = a1[i] * a1[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) B[i] = b1[i] * b1[i];</span><br><span class="line">    mul(len, n, <span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">if</span> (res[i] == <span class="number">0</span>) ans.push_back(i - m + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : ans) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-–-万径人踪灭"><a href="#E-–-万径人踪灭" class="headerlink" title="E – 万径人踪灭"></a>E – 万径人踪灭</h1><p>假设当前确定了一个对称中心$i$</p><p>那么当两个位置$j,k$关于i对称且这两个位置的字母相同时对答案有贡献</p><p>对称则意味着$j+k=i*2​$，可以FFT</p><p>枚举字符，然后FFT</p><p>假设这个中心有x对这样的位置</p><p>那么每一对都是独立的，可以选也可以不选，但是不能都不选</p><p>所以此时的答案为$2^x-1$</p><p>题目要求不能全部连续，那么最后再跑一边<code>manacher</code>，减去全部连续的答案即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">int</span> r[N &lt;&lt; <span class="number">2</span>]; <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> p = mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % p) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % p;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> type, <span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, t, w = <span class="number">1</span>;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w = (LL) w * Wn % mod)</span><br><span class="line">                t = (LL)w * a[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> A[N &lt;&lt; <span class="number">2</span>], B[N &lt;&lt; <span class="number">2</span>], pal[N &lt;&lt; <span class="number">2</span>], Pow2[N]; <span class="keyword">char</span> s[N], t[N * <span class="number">2</span>]; <span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">manacher</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    t[<span class="number">0</span>] = <span class="string">'#'</span>, t[n * <span class="number">2</span> + <span class="number">1</span>] = <span class="string">'$'</span>, t[n * <span class="number">2</span> + <span class="number">2</span>] = <span class="string">'@'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) t[i * <span class="number">2</span> - <span class="number">1</span>] = <span class="string">'$'</span>, t[i * <span class="number">2</span>] = s[i]; </span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">1</span>, mx = <span class="number">1</span>, res = <span class="number">0</span>; pal[<span class="number">1</span>] = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n * <span class="number">2</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= mx) pal[i] = min(mx - i + <span class="number">1</span>, pal[<span class="number">2</span> * pos - i]);</span><br><span class="line">        <span class="keyword">else</span> pal[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (t[i - pal[i]] == t[i + pal[i]]) pal[i]++;</span><br><span class="line">        <span class="keyword">if</span> (i + pal[i] - <span class="number">1</span> &gt; mx) mx = i + pal[i] - <span class="number">1</span>, pos = i;</span><br><span class="line">        res = (res + pal[i] / <span class="number">2</span>) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>); <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span> (s[i] == <span class="string">'a'</span>) A[i] = <span class="number">1</span>; <span class="keyword">else</span> B[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>, ans = <span class="number">0</span>; Pow2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Pow2[i] = Pow2[i - <span class="number">1</span>] * <span class="number">2</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n * <span class="number">2</span>) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    NTT(len, <span class="number">1</span>, A), NTT(len, <span class="number">1</span>, B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) A[i] = (LL)A[i] * A[i] % mod, B[i] = (LL)B[i] * B[i] % mod;</span><br><span class="line">    NTT(len, <span class="number">0</span>, A), NTT(len, <span class="number">0</span>, B); <span class="keyword">int</span> Inv = Pow(len, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, t;i &lt;= n * <span class="number">2</span>;i++) &#123;</span><br><span class="line">        t = (LL)(A[i] + B[i]) * Inv % mod + (i &amp; <span class="number">1</span> ^ <span class="number">1</span>);</span><br><span class="line">        ans = (ans + Pow2[t / <span class="number">2</span>] - <span class="number">1</span>) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (ans - manacher(n) + p) % p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F-–-性能优化"><a href="#F-–-性能优化" class="headerlink" title="F – 性能优化"></a>F – 性能优化</h1><p>这道题利用到了FFT的原理</p><p>如果模数是质数，那么非常好办</p><p>但是这题不仅模数不是质数，而且求的是循环卷积，直接FFT会爆炸</p><p>贴一篇我觉得很好的题解</p><p><img src="https://0x131cc05home.files.wordpress.com/2019/02/1.jpg?w=700" alt="img"></p><p>这个rev数组可以模拟FFT的过程，递归地求出来</p><p>单位根满足消去律，上面的$F(\omega_n^i)$指的是$i\leq \frac{n}{p}$的情况</p><p>对于剩余的情况，有$\omega_{\frac{n}{p}}^i=\omega_{\frac{n}{p}}^{i-\frac{n}{p}}$</p><p>也就是说，代入的$F^{[0]},F^{[1]},\cdots,F^{[p-1]}$都相同，但是系数不同</p><p>然后分治就可以了</p><p>同样地，最后需要除以<code>len</code>，也就是模数$-1$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tot, prime[N], r[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetPos</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> dep, <span class="keyword">int</span> len, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep == tot + <span class="number">1</span>) <span class="keyword">return</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> tmp = len / prime[dep], s = x % prime[dep];</span><br><span class="line">    <span class="keyword">return</span> GetPos((x - s) / prime[dep], dep + <span class="number">1</span>, tmp, cnt + tmp * s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp[N], g;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> a[], <span class="keyword">int</span> mod, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) tmp[r[i]] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) a[i] = tmp[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tot, block = <span class="number">1</span>;i &gt;= <span class="number">1</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = block; block *= prime[i];</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(g, type ? (mod - <span class="number">1</span>) / block : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / block, mod);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; len;j++) tmp[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, Wk = <span class="number">1</span>;j &lt; len;j += block, Wk = <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; block;k++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = k % mid, w = <span class="number">1</span>;l &lt; block;l += mid, w = (LL)w * Wk % mod)</span><br><span class="line">                    tmp[j + k] = (tmp[j + k] + (LL)w * a[j + l]) % mod;</span><br><span class="line">                Wk = (LL)Wk * Wn % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; len;j++) a[j] = tmp[j];</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">GetG</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, flag = <span class="number">1</span>;i;i++, flag = <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>;j * j &lt; x;j++)</span><br><span class="line">            <span class="keyword">if</span> (Pow(i, (x - <span class="number">1</span>) / j, x) == <span class="number">1</span>) &#123;flag = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> A[N &lt;&lt; <span class="number">2</span>], B[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, C; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;C);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;B[i]);</span><br><span class="line">    <span class="keyword">int</span> tmp = n; g = GetG(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i * i &lt;= tmp;i++)</span><br><span class="line">        <span class="keyword">while</span> (tmp % i == <span class="number">0</span>) prime[++tot] = i, tmp /= i;</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="number">1</span>) prime[++tot] = tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) r[i] = GetPos(i, <span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line">    NTT(n, A, n + <span class="number">1</span>, <span class="number">1</span>), NTT(n, B, n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) A[i] = (LL)A[i] * Pow(B[i], C, n + <span class="number">1</span>) % (n + <span class="number">1</span>);</span><br><span class="line">    NTT(n, A, n + <span class="number">1</span>, <span class="number">0</span>); <span class="keyword">int</span> Inv = Pow(n, n - <span class="number">1</span>, n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL)A[i] * Inv % (n + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="H-–-Frightful-Formula"><a href="#H-–-Frightful-Formula" class="headerlink" title="H – Frightful Formula"></a>H – Frightful Formula</h1><p>算是比较简单的一道题</p><p>公式等价于一个表格，往右走有$a$种方法，往下走有$b$种方法，还可以直接从这个格子开始走，有$c$种方法</p><p>先不考虑第一行和第一列格子</p><p>假设是从$i,j$这个格子开始走的</p><p>那么，这个格子需要向右走$n-j$步，向下走$n-i$步</p><p>对答案的贡献是</p><script type="math/tex; mode=display">c\*a^{n-i}\*b^{n-j}\*{n-i+n-j\choose n-i}</script><p>含义是，从这个格子开始，有$c$种走法，向有走$n-j$次，向下走$n-i$次，在$n-j+n-i$步中，有$n-i​$步是往下走的</p><p>那么，把这些空白的格子加起来，我们可以得到</p><script type="math/tex; mode=display">\begin{aligned}c\sum_{i=2}^n\sum_{j=2}^na^{n-i}b^{n-j}{n-i+n-j\choose n-i}&=c\sum_{i=0}^{n-2}\sum_{j=0}^{n-2}a^ib^j{i+j\choose i}\\\&=c\sum_{i=0}^{n-2}\frac{a^i}{i!}\sum_{j=0}^{n-2}(i+j)!\frac{b^j}{j!}\end{aligned}</script><p>我们可以枚举$i$，后面的是一个下标差相等的卷积</p><p>将多项式逆序一下就可以了</p><p>这道题没有给模数，而答案又很大</p><p>为了防止丢精度，所以使用MTT</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e6</span> + <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> p = mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % p) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % p;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ZJK = (<span class="number">1</span> &lt;&lt; <span class="number">19</span>) + <span class="number">233</span>;</span><br><span class="line"><span class="keyword">int</span> frac[N * <span class="number">2</span>], f[<span class="number">2</span>][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;<span class="keyword">return</span> (LL)frac[n] * Pow(frac[r], mod - <span class="number">2</span>) % mod * Pow(frac[n - r], mod - <span class="number">2</span>) % mod;&#125;</span><br><span class="line"><span class="comment">// #define double long double</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CP</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    CP(<span class="keyword">double</span> _x = <span class="number">0</span>, <span class="keyword">double</span> _y = <span class="number">0</span>) : x(_x), y(_y) &#123;&#125;</span><br><span class="line">    CP <span class="keyword">operator</span> * (<span class="keyword">const</span> CP &amp;b) &#123;<span class="keyword">return</span> CP(x * b.x - y * b.y, x * b.y + y * b.x);&#125;</span><br><span class="line">    CP <span class="keyword">operator</span> + (<span class="keyword">const</span> CP &amp;b) &#123;<span class="keyword">return</span> CP(x + b.x, y + b.y);&#125;</span><br><span class="line">    CP <span class="keyword">operator</span> - (<span class="keyword">const</span> CP &amp;b) &#123;<span class="keyword">return</span> CP(x - b.x, y - b.y);&#125;</span><br><span class="line">    CP <span class="keyword">operator</span> / (<span class="keyword">const</span> <span class="keyword">double</span> b) &#123;<span class="keyword">return</span> CP(x / b, y / b);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> r[ZJK]; <span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> type, CP a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">CP <span class="title">Wn</span><span class="params">(<span class="built_in">cos</span>(<span class="number">2</span> * PI / mid), type * <span class="built_in">sin</span>(<span class="number">2</span> * PI / mid))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid) &#123;</span><br><span class="line">            CP w(1), t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w = w * Wn) </span><br><span class="line">                t = w * a[j + (mid &gt;&gt; <span class="number">1</span>)], a[j + (mid &gt;&gt; <span class="number">1</span>)] = a[j] - t, a[j] = a[j] + t; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">-1</span>) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) a[i] = a[i] / len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line">CP a[ZJK], b[ZJK], c[ZJK], d[ZJK];</span><br><span class="line"><span class="keyword">int</span> A[ZJK], B[ZJK];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MTT</span><span class="params">(<span class="keyword">int</span> len, LL m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) a[i] = A[i] / m, b[i] = A[i] % m, c[i] = B[i] / m, d[i] = B[i] % m;</span><br><span class="line">    FFT(len, <span class="number">1</span>, a), FFT(len, <span class="number">1</span>, b), FFT(len, <span class="number">1</span>, c), FFT(len, <span class="number">1</span>, d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) &#123;</span><br><span class="line">        CP a1 = a[i], b1 = b[i], c1 = c[i], d1 = d[i];</span><br><span class="line">        a[i] = a1 * c1, b[i] = a1 * d1, c[i] = b1 * c1, d[i] = b1 * d1;</span><br><span class="line">    &#125;</span><br><span class="line">    FFT(len, <span class="number">-1</span>, a), FFT(len, <span class="number">-1</span>, b), FFT(len, <span class="number">-1</span>, c), FFT(len, <span class="number">-1</span>, d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) </span><br><span class="line">        A[i] = ((LL)(a[i].x + <span class="number">0.5</span>) * m % mod * m % mod + (LL)(b[i].x + <span class="number">0.5</span>) * m % mod + (LL)(c[i].x + <span class="number">0.5</span>) * m % mod</span><br><span class="line">            + (LL)(d[i].x + <span class="number">0.5</span>)) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c, n; <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;a, &amp;b, &amp;c), frac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;f[<span class="number">1</span>][i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;f[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n * <span class="number">2</span>;i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, tmp1 = Pow(b, n - <span class="number">1</span>), tmp2 = Pow(a, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) ans = (ans + (LL)f[<span class="number">0</span>][i] * C(<span class="number">2</span> * n - <span class="number">2</span> - i, n - i) % mod * tmp1 % mod * Pow(a, n - i)) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) ans = (ans + (LL)f[<span class="number">1</span>][i] * C(<span class="number">2</span> * n - <span class="number">2</span> - i, n - i) % mod * tmp2 % mod * Pow(b, n - i)) % mod;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= <span class="number">2</span> * n) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t;i &lt;= n - <span class="number">2</span>;i++) t = Pow(frac[i], mod - <span class="number">2</span>), A[i] = (LL)Pow(a, i) * t % mod, B[i] = (LL)Pow(b, i) * t % mod;</span><br><span class="line">    MTT(len, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">2</span> * n - <span class="number">4</span>;i++) ans = (ans + (LL)c * A[i] % mod * frac[i]) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
            <tag> manacher </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.3省选模拟</title>
      <link href="/2019/04/06/4-3%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/"/>
      <url>/2019/04/06/4-3%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-Diyiti"><a href="#T1-Diyiti" class="headerlink" title="T1 Diyiti"></a>T1 Diyiti</h1><p><img src="https://i.loli.net/2019/04/06/5ca8652f32552.png" alt="1554539772376"></p><p><img src="https://i.loli.net/2019/04/06/5ca8654c9255c.png" alt="1554539844233"></p><p>我们先考虑这样一个问题：给出$x,y$，如何计算$f(x,y)$</p><p>分析一下第一个操作的本质，就是将$x$末尾连续的0都变成1，将第一处1变成0</p><p>考虑一种特殊情况：$y$是$x$的子集</p><p>也就是说，我们可以只通过操作2将$x$变成$y$</p><p>如果我们使用了操作1，可以将最后一个1变成0</p><p>但是这样有一个副作用，就是后面所有的数都变成了1</p><p>根据之前的限制：$y$是$x$的子集，而$x$在这一位之后都是0</p><p>也就是说，$y$在这一位之后也全部是0</p><p>在这次操作之后，后面的数都变成了1</p><p>如果这次操作在第$i$位，那么我们至少还需要$i-1$次操作2才能将后面的位变得与$y$相同</p><p>只有在$i=1$即操作第一位的时候，$-1$操作才与操作2等价</p><p>否则$-1$操作一定没有操作2优秀</p><p>也就是说，如果我们能用操作2，就尽量用操作2</p><p>那么什么情况不能用操作2呢</p><p>就是$x$在某一位上为0，而$y$在这一位上为1</p><p>这个时候我们只能用$-1$操作</p><p>如果第$i$位是这样的情况，就意味着，我们必须将这一位之后的第一个$1-0$对前面的所有位都变成0，然后在这个$1-0$对位置使用一次$-1$操作</p><p>比如$x=(10010)_2,y=(00101)_2$</p><p>注意“第$k$位”指的是从右边开始的第$k$位</p><p>对于第一位来说，我们至少需要将第一位变成0</p><p>对于第三位来说，我们至少需要将第四位到第一位变成0</p><p>为了让操作数尽量小，我们选择将第一位至第四位都变成0</p><p>之后就变成了第一种情况，即$y$是$x$的子集</p><hr><p>总结一下流程：</p><ul><li>我们找到最高的满足$x_i=0,y_i=1$的位置</li><li>找到第一个比这一位高的，满足$x_i=1,y_i=0$的位置$j$</li><li>通过操作2，将位置$1-(j-1)$全部变成0</li><li>在$j$位置使用一次$-1$操作</li><li>对于每一处$x_i=1,y_i=0$的位置使用操作2</li></ul><p>所以，我们可以得出</p><script type="math/tex; mode=display">f(x,y)=\begin{cases}\sum_{k>j}[x_k\not=y_k]+1+\sum_{k<j}[x_k=1]+\sum_{k<j}[y_k=0]&y\not\in x\\\ \sum_k[x_k\not=y_k]&y\in x\end{cases}</script><p>那么我们现在将它扩展到$x&lt;N$</p><p>显然，我们可以使用数位<code>dp</code></p><p>根据我们之前的计算过程，我们从高位向低位<code>dp</code>，将$x$分为3个状态</p><ul><li>还没有遇到$x_i=0,y_i=1$，即此时$y\in x$，这个状态可以作为终止状态</li><li><p>钦定此时会有一个$-1$操作，这个状态的起点必须是$x_i=1,y_i=0$且在这个状态中不能再出现其它的$x_i=1,y_i=0$以及$x_i=0,y_i=1$，这个状态<strong>不能</strong>作为终止状态 </p></li><li><p>遇到了第一个$x_i=0,y_i=1$，然后就可以随便转移了，这个状态可以作为终止状态</p></li></ul><p>第二个状态之所以不能成为终止状态，是因为必须至少有一个$x_i=0,y_i-1$，否则就不应该进入2状态</p><p>那么我们可以设<code>f[2][2][3][N], g[2][2][3][N]</code>表示当前在第$i$位，此时$x$是否等于$N$，$y$是否等于$x$，当前在第几个状态时的答案以及转移到结尾的方案数</p><p>为了偷懒，我们也可以只用一个<code>dp</code></p><p><code>dp[2][2][3][N][N]</code>表示当前到了第$i$位，之前已经用了$j$次操作，此时$x$是否等于$N$，$y$是否等于$x$，当前在第几个状态时的答案</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 510</span></span><br><span class="line"><span class="keyword">int</span> num[N], dp[<span class="number">2</span>][<span class="number">2</span>][<span class="number">3</span>][N][N * <span class="number">2</span>], len; <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x += y, x -= x &gt;= mod ? mod : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">bool</span> flag1, <span class="keyword">bool</span> flag2, <span class="keyword">int</span> state, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == len + <span class="number">1</span>) <span class="keyword">return</span> state == <span class="number">1</span> ? <span class="number">0</span> : cnt;</span><br><span class="line">    <span class="keyword">int</span> &amp;sum = dp[flag1][flag2][state][cur][cnt];</span><br><span class="line">    <span class="keyword">if</span> (~sum) <span class="keyword">return</span> sum;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>;x &lt; <span class="number">4</span>;x++) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = x &amp; <span class="number">1</span>, j = x &gt;&gt; <span class="number">1</span> &amp; <span class="number">1</span>, tflag1 = flag1 &amp;&amp; (i == num[cur]), tflag2 = flag2 &amp;&amp; (j == i);</span><br><span class="line">        <span class="keyword">if</span> (flag1 &amp;&amp; i &gt; num[cur]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag2 &amp;&amp; j &gt; i) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (state == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) <span class="keyword">continue</span>;</span><br><span class="line">            Inc(sum, DP(cur + <span class="number">1</span>, tflag1, tflag2, <span class="number">0</span>, cnt + (i &gt; j)));</span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) Inc(sum, DP(cur + <span class="number">1</span>, tflag1, tflag2, <span class="number">1</span>, cnt + <span class="number">1</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == j) Inc(sum, DP(cur + <span class="number">1</span>, tflag1, tflag2, <span class="number">1</span>, cnt + (i == <span class="number">1</span>) + (j == <span class="number">0</span>)));</span><br><span class="line">            <span class="keyword">else</span> Inc(sum, DP(cur + <span class="number">1</span>, tflag1, tflag2, <span class="number">2</span>, cnt)); </span><br><span class="line">        &#125; <span class="keyword">else</span> Inc(sum, DP(cur + <span class="number">1</span>, tflag1, tflag2, <span class="number">2</span>, cnt + (i == <span class="number">1</span>) + (j == <span class="number">0</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> input[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"diyiti.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"diyiti.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, input + <span class="number">1</span>), len = <span class="built_in">strlen</span>(input + <span class="number">1</span>), <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++) num[i] = input[i] - <span class="string">'0'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, DP(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-Dierti"><a href="#T2-Dierti" class="headerlink" title="T2 Dierti"></a>T2 Dierti</h1><p><img src="https://i.loli.net/2019/04/06/5ca89802d6f00.png" alt="1554552801425"></p><p><img src="https://i.loli.net/2019/04/06/5ca8981514ccf.png" alt="1554552819955"></p><p>看起来是一道好题，可惜没有题解</p><p>这里讲一下部分分做法（只会部分分）</p><p>首先我们可以枚举最后选到的是哪个$n$以及哪个$m$，求这个东西的$k$阶中心矩，最后再求期望</p><p>这里的$x$就是实际选的袋子中球的数量</p><p>考虑</p><script type="math/tex; mode=display">\begin{aligned}E((x-E(x))^k)&=E(\sum_{i=0}^k{k\choose i}x^k(-1)^{k-i}E(x)^{k-i})\\\&=\sum_{i=0}^k{k\choose i}(-1)^{k}E(x)^{k}E(x^{k-i})\end{aligned}</script><p>显然$E(x)=\frac{m}{n}$，所以关键是要求出$E(x^k)$</p><p>这等价于有一个数，现在要对这个数进行$m$次操作，每次操作都有$\frac{1}{n}$的概率会加1，否则不变</p><p>很像一道题<a href="https://www.luogu.org/problemnew/show/P1654" target="_blank" rel="noopener">osu</a></p><p>我们分别维护$E(x),E(x^2),\cdots,E(x^k)$，转移的时候再次使用二项式展开</p><p>这样一次转移是$k^3$的，可以使用矩阵乘法优化</p><p>可以拿到60分</p><h1 id="T3-Disanti"><a href="#T3-Disanti" class="headerlink" title="T3 Disanti"></a>T3 Disanti</h1><p><img src="https://i.loli.net/2019/04/07/5ca9b44761e6a.png" alt="1554625591423"></p><p><img src="https://i.loli.net/2019/04/07/5ca9b465f25d6.png" alt="1554625629573"></p><p>我不会啊，而且没有题解</p><p>先咕在这里吧</p>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.2省选模拟</title>
      <link href="/2019/04/06/4-2%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/"/>
      <url>/2019/04/06/4-2%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-Painting"><a href="#T1-Painting" class="headerlink" title="T1 Painting"></a>T1 Painting</h1><p><img src="https://i.loli.net/2019/04/06/5ca853e21983b.png" alt="1554535371227"></p><p><img src="https://i.loli.net/2019/04/06/5ca853fe09737.png" alt="1554535413371"></p><p>我们考虑这样一种情况：<code>122133441</code></p><p>显然，<code>1</code>必须在最开始就刷上，如果先刷其它的数再刷<code>1</code>，那么颜色<code>2,3,4</code>不可能被<code>1</code>包含</p><p>颜色<code>3,4</code>刷的顺序无关紧要</p><p>我们考虑更一般的情况</p><p>如果存在颜色序列<code>a...b...b...a</code>，其中省略号的部分可能代表其它颜色，那么<code>a</code>一定在<code>b</code>之前被刷上</p><p>对于颜色序列<code>a..ab...b</code>，<code>a,b</code>被刷的顺序可以随意</p><p>我们可以通过这两个条件将拓扑关系建出来，可以发现，这是一棵树</p><p>树的祖先与后代刷的顺序是确定的，同一个父亲的儿子节点刷的顺序可以随意</p><p>于是我们考虑分治，假设当前分治到了区间<code>[l,r]</code>，这要求这个区间的左右两个端点的颜色相同</p><p>比如上面那个例子中，这个颜色就是<code>1</code></p><p>这个颜色将这个区间分成了若干段，对于每一段我们只关心当前颜色的儿子节点，将每一个颜色序列都缩成一个点</p><p>比如序列<code>12332144551</code>，<code>1</code>将序列分成了两个部分<code>2332,4455</code></p><p>对于颜色<code>2</code>，我们将它缩成一个长度为4的点，它在第一段</p><p>对于颜色<code>3</code>，我们不管它，因为它不是<code>1</code>的儿子，它在第二段</p><p>对于颜色<code>4,5</code>，我们将它们各缩成长度为2的点，它在第二段</p><p>对于每一段，我们分别进行<code>dp</code>，算出答案的最大值，因为段与段之间不能相互跨越，否则中间那个<code>1</code>就永远都刷不上了</p><p>我们用<code>dp[i][j]</code>表示已经刷好了<code>[i,j]</code>这些点，能获得的最大收益</p><p>如果我们假设第$i$个点缩成的长度是$b_i$，那么这个<code>dp</code>就满足</p><script type="math/tex; mode=display">dp_{i,j}=\sum_{l=i}^jb_l+\max_{mid=i}^j\{dp_{i,mid-1}+dp_{mid+1,j}\}</script><p>含义是我们枚举第一次刷的颜色$mid$，这会将序列分成两段独立的区间，分别刷即可</p><p>这个<code>dp</code>是$m^3$的</p><p>如果我们打出这个<code>dp</code>取最优值的位置，可以发现它一定在左端点或者右端点转移</p><p>不会证明</p><p>此时<code>dp</code>就是$m^2$的了</p><p>题解的证明过程如下</p><div class="pdfobject-container" data-target="Color.pdf" data-height="500px"></div><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 5010</span></span><br><span class="line"><span class="keyword">int</span> num[N], nxt[N], lst[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp; <span class="keyword">int</span> dp[M][M], pre[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">DP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tmp.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) pre[i] = pre[i - <span class="number">1</span>] + tmp[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= n;j++) dp[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) dp[i][i] = tmp[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>;len &lt;= n;len++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">1</span>;start + len - <span class="number">1</span> &lt;= n;start++) &#123;</span><br><span class="line">            <span class="keyword">int</span> end = start + len - <span class="number">1</span>;</span><br><span class="line">            dp[start][end] = max(dp[start + <span class="number">1</span>][end], dp[start][end - <span class="number">1</span>]) + pre[end] - pre[start - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ls = l, cur = nxt[l];ls != r;cur = nxt[ls = cur]) &#123;</span><br><span class="line">        tmp.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> at = ls + <span class="number">1</span>;at != cur;at = lst[at] + <span class="number">1</span>) </span><br><span class="line">            tmp.push_back(lst[at] - at + <span class="number">1</span>);</span><br><span class="line">        res += DP();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ls = l, cur = nxt[l];ls != r;cur = nxt[ls = cur]) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> at = ls + <span class="number">1</span>;at != cur;at = lst[at] + <span class="number">1</span>) </span><br><span class="line">            solve(at, lst[at]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp1[N], beg[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"color.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"color.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">        <span class="keyword">if</span> (tmp1[num[i]]) nxt[tmp1[num[i]]] = i;</span><br><span class="line">        <span class="keyword">else</span> beg[num[i]] = i;</span><br><span class="line">        tmp1[num[i]] = i, lst[beg[num[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    nxt[<span class="number">0</span>] = n + <span class="number">1</span>, solve(<span class="number">0</span>, n + <span class="number">1</span>), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-Path"><a href="#T2-Path" class="headerlink" title="T2 Path"></a>T2 Path</h1><p><img src="https://i.loli.net/2019/04/06/5ca85b7f898f3.png" alt="1554537333909"></p><p><img src="https://i.loli.net/2019/04/06/5ca85b9a727e4.png" alt="1554537361628"></p><p>假设当前点是$u$</p><p>可以发现，最优策略一定是选择一个点集$v$，然后一直在$u$点等待，直到$u$和$v$连通，然后走这条出现的边</p><p>我们用<code>dp[u]</code>表示在最优策略下，$u$点到$n$需要的期望时间</p><p>我们将$u$点能到达的边按照<code>dp</code>值排序，可以发现选择的点集一定是一段前缀</p><p>我们枚举这个前缀，对于一个前缀$v_i$，如果选择这个前缀的点集，那么有转移</p><script type="math/tex; mode=display">dp_u=\min_{i=1}^{|v|}\{\frac{1}{i}\sum_{t\in v_i}dp_t+\frac{m}{i}\}</script><p>含义是，如果选择了这个前缀，那么所选择的点中作为第一个出现的点的概率是相等的，为了走这一条边，我们期望要等$\frac{m}{i}$轮</p><p>由于有$\min$，所以无法高斯消元</p><p>一种方法是进行若干次迭代，每次迭代枚举每个点更新</p><p>另一种方法是使用一个类似<code>SPFA</code>的方法，将这次更新的点放进队列，继续拓展</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="keyword">double</span> dp[N]; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dp[i] &lt; dp[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"path.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"path.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b;i &lt;= m;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), G[a].push_back(b), G[b].push_back(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) dp[i] = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>;t &lt;= <span class="number">2000000</span> / m;t++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">            sort(G[i].begin(), G[i].end(), cmp); <span class="keyword">double</span> tmp = <span class="number">0</span>, ans = <span class="number">0</span>, ls = <span class="number">1e9</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= G[i].size();j++) &#123;</span><br><span class="line">                tmp += dp[G[i][j - <span class="number">1</span>]], ans = tmp / j + (<span class="keyword">double</span>)m / j;</span><br><span class="line">                <span class="keyword">if</span> (ans &gt; ls) <span class="keyword">break</span>;</span><br><span class="line">                dp[i] = min(dp[i], ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.7lf\n"</span>, dp[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-Tree"><a href="#T3-Tree" class="headerlink" title="T3 Tree"></a>T3 Tree</h1><p><img src="https://i.loli.net/2019/04/06/5ca85d84910e7.png" alt="1554537850931"></p><p><img src="https://i.loli.net/2019/04/06/5ca85da120c4b.png" alt="1554537880643"></p><p>如果最远点的距离是$x$，那么所选择的点数必须不小于$\frac{n}{x}$</p><p>这个式子看上去就很像分块</p><p>我们暴力枚举答案$1-\sqrt{n}$，找到答案为当前值的关键点数的区间</p><p>对于现在还没有确定答案的那些关键点数，我们直接二分，然后暴力算答案</p><p>所谓暴力就是直接树上贪心</p><p>这样可以获得60分的好成绩</p><p>贴一下题解</p><p><img src="https://i.loli.net/2019/04/06/5ca85eea90a02.jpg" alt="sol_tree"></p>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 分治 </tag>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.1省选模拟</title>
      <link href="/2019/04/03/4-1%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/"/>
      <url>/2019/04/03/4-1%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-Line"><a href="#T1-Line" class="headerlink" title="T1 Line"></a>T1 Line</h1><p><img src="https://i.loli.net/2019/04/03/5ca49b8c8003d.png" alt="1554291556372"></p><p><img src="https://i.loli.net/2019/04/03/5ca49babedb1e.png" alt="1554291616688"></p><p>如果我们知道了这条直线在$y$轴上的截距，那么我们就可以通过这$n$个点确定最终斜率的区间</p><p>假设这条直线是$kx+b$，现在我们已知$b$</p><p>对于一个$r_i$，我们知道有</p><script type="math/tex; mode=display">ki+b\leq r_i\Rightarrow k\leq\lfloor\frac{r_i-b}{i}\rfloor</script><p>对于一个$l_i$，我们知道有</p><script type="math/tex; mode=display">ki+b\geq l_i\Rightarrow k\geq\lceil\frac{l_i-b}{i}\rceil</script><p>那么对于一个$b$，它对答案的贡献就是</p><script type="math/tex; mode=display">\max\{0,\min_{i=1}^n\{\lfloor\frac{r_i-b}{i}\rfloor\}-\max_{j=1}^n\{\lceil\frac{l_j-b}{j}\rceil\}+1\}</script><p>如果我们知道此时$\min$取的是哪个位置，$\max$取的是哪个位置，我们就可以$O(1)$计算答案</p><p>由于我们之前是枚举的$b$，现在就把$b$看作自变量$x$</p><p>对于$\min,\max$我们分开考虑</p><p>以$\min$为例</p><p>此时我们要求$\frac{r_i-x}{i}$的最小值</p><p>可以使用斜率优化，即将这个东西看作一条斜率为$-\frac{1}{i}$，截距是$\frac{r_i}{i}$的直线</p><p>此时我们就得到了当$b$<strong>在一个范围内</strong>的时候，最小值的位置</p><p>同样，我们可以得出当$b$在一个范围内的时候，最大值的位置</p><p>我们将这两个范围合并，就可以得出当$b$在一个范围内时，最小值以及最大值的位置</p><p>现在考虑对于一个区间的$b$，如何计算答案</p><p>此时我们已经确定了$\min,\max$的位置</p><p>首先考虑将前面那个0搞掉</p><p>我们发现这对应着收紧一下区间</p><p>解方程</p><script type="math/tex; mode=display">\begin{align}\frac{r_i-x}{i}&=\frac{l_j-x}{j}\\\r_ij-xj&=l_ji-xi\\\x(i-j)&=l_ji-r_ij\\\\Rightarrow x&=\frac{l_ji-r_ij}{i-j}\end{align}</script><p>当$i=j$时，我们不做处理</p><p>当$i&gt;j$时，这对应着$b$的新下界</p><p>当$i&lt;j$时，这对应着$b$的新上界</p><p>此时我们就可以把前面的0搞掉了</p><p>考虑如何计算</p><script type="math/tex; mode=display">\sum_{i=L}^R\lfloor\frac{a-i}{b}\rfloor</script><p>我们发现如果不考虑边角上的数，这其实是一个每个数都重复了$b$次的等差数列</p><p>如果$\lfloor\frac{a}{b}\rfloor=k$，那么有$bk\leq a\leq (b+1)k-1$</p><p>我们对边角特殊处理即可</p><p>考试的时候由于某些未知的地方没有开<code>long long</code>，导致只有33.3分</p><p>听说可以算出斜率的区间</p><p>好像我写毒瘤了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">calc</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    L = -L, R = -R, swap(L, R);</span><br><span class="line">    <span class="keyword">int</span> l1 = <span class="built_in">floor</span>((L + a) / (<span class="keyword">double</span>)b) + <span class="number">1</span>, r1 = <span class="built_in">floor</span>((R + a) / (<span class="keyword">double</span>)b); LL res = (LL)(r1 - l1 + <span class="number">1</span>) * (l1 + r1) * b / <span class="number">2</span>;</span><br><span class="line">    l1 = l1 * b - <span class="number">1</span>, r1 = (r1 + <span class="number">1</span>) * b;</span><br><span class="line">    res += <span class="built_in">floor</span>((a + L) / (<span class="keyword">double</span>)b) * (LL)(l1 - L - a + <span class="number">1</span>) + <span class="built_in">floor</span>((a + R) / (<span class="keyword">double</span>)b) * (LL)(R + a - r1 + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">calc</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> lj, <span class="keyword">int</span> ri, <span class="keyword">int</span> j, <span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">// L &lt;= x &lt;= R</span></span><br><span class="line">    <span class="keyword">if</span> (i == j) <span class="keyword">return</span> calc(L, R, ri, i) - calc(L, R, lj + j - <span class="number">1</span>, j) + R - L + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> k = (ri - lj) / (<span class="keyword">double</span>)(i - j), y = lj - k * j;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; i) L = max(L, (<span class="keyword">int</span>)<span class="built_in">ceil</span>(y)); <span class="keyword">else</span> R = min(R, (<span class="keyword">int</span>)<span class="built_in">floor</span>(y));</span><br><span class="line">    <span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> calc(L, R, ri, i) - calc(L, R, lj + j - <span class="number">1</span>, j) + R - L + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span><span class="keyword">int</span> b, kinv;&#125; l1[N], l2[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">inter</span><span class="params">(Line a, Line b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((LL)a.b * b.kinv - (LL)b.b * a.kinv) / (<span class="keyword">double</span>)(a.kinv - b.kinv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(Line a, Line b, Line c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dcmp(inter(a, b) - inter(a, c)) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> l[N], r[N], head, tail; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span><span class="keyword">int</span> l, r, at;&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;data&gt; tmp1, tmp2;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"line.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"line.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;l[i], &amp;r[i]);</span><br><span class="line">    head = <span class="number">1</span>, tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        Line now = (Line)&#123;-l[i], -i&#125;;</span><br><span class="line">        <span class="keyword">while</span> (head &lt; tail &amp;&amp; !check(l1[tail - <span class="number">1</span>], l1[tail], now)) tail--;</span><br><span class="line">        l1[++tail] = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head, ls = <span class="number">-2e9</span>, cur;i &lt;= tail;i++, ls = cur + <span class="number">1</span>) &#123;</span><br><span class="line">        cur = i != tail ? <span class="built_in">floor</span>(inter(l1[i], l1[i + <span class="number">1</span>])) : <span class="number">2e9</span>;</span><br><span class="line">        <span class="keyword">if</span> (ls &lt;= cur) tmp1.push_back((data)&#123;ls, cur, -l1[i].kinv&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    head = <span class="number">1</span>, tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n;i &gt;= <span class="number">1</span>;i--) &#123;</span><br><span class="line">        Line now = (Line)&#123;-r[i], -i&#125;;</span><br><span class="line">        <span class="keyword">while</span> (head &lt; tail &amp;&amp; !check(l2[tail - <span class="number">1</span>], l2[tail], now)) tail--;</span><br><span class="line">        l2[++tail] = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head, ls = <span class="number">-2e9</span>, cur;i &lt;= tail;i++, ls = cur + <span class="number">1</span>) &#123;</span><br><span class="line">        cur = i != tail ? <span class="built_in">floor</span>(inter(l2[i], l2[i + <span class="number">1</span>])) : <span class="number">2e9</span>;</span><br><span class="line">        <span class="keyword">if</span> (ls &lt;= cur) tmp2.push_back((data)&#123;ls, cur, -l2[i].kinv&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cur1 = <span class="number">0</span>, cur2 = <span class="number">0</span>, ls = <span class="number">-2e9</span>; LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">233</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> nxt, at1 = tmp1[cur1].at, at2 = tmp2[cur2].at, R;</span><br><span class="line">        <span class="keyword">if</span> (cur1 != tmp1.size() - <span class="number">1</span> &amp;&amp; cur2 != tmp2.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp1[cur1].r &lt; tmp2[cur2].r) nxt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> nxt = <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> nxt = (cur1 == tmp1.size() - <span class="number">1</span>) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">        R = nxt == <span class="number">1</span> ? tmp1[cur1].r : tmp2[cur2].r;</span><br><span class="line">        ans += calc(ls, R, l[tmp1[cur1].at], r[tmp2[cur2].at], tmp1[cur1].at, tmp2[cur2].at), ls = R + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur1 == tmp1.size() - <span class="number">1</span> &amp;&amp; cur2 == tmp2.size() - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (nxt == <span class="number">1</span>) cur1++; <span class="keyword">else</span> cur2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-Seat"><a href="#T2-Seat" class="headerlink" title="T2 Seat"></a>T2 Seat</h1><p><img src="https://i.loli.net/2019/04/03/5ca4a9500598d.png" alt="1554295110222"></p><p><img src="https://i.loli.net/2019/04/03/5ca4a96b93e7a.png" alt="1554295138493"></p><p>不会，先放题解</p><div class="pdfobject-container" data-target="sol.pdf" data-height="500px"></div><h1 id="T3-Dist"><a href="#T3-Dist" class="headerlink" title="T3 Dist"></a>T3 Dist</h1><p><img src="https://i.loli.net/2019/04/03/5ca4a9d7eafd3.png" alt="1554295246669"></p><p><img src="https://i.loli.net/2019/04/03/5ca4a9ef2d574.png" alt="1554295270358"></p><p>如果我们将每个集合看作一个点，那么一共只有18个点，我们在这个图上跑最短路</p><p>那么对于两个点$a,b$，$a$到$b$的最短路径等于</p><script type="math/tex; mode=display">\min_{a\in U,b\in V}dis(U,V)</script><p>我们枚举起点$a$，将所有集合按照离$a$的距离排序，然后从小到大依次加入</p><p>当加入一个新的集合$y$时，它对答案的贡献就是$y$集合中包含的点减去被$y$和之前的集合包含的点</p><p>这个我们处理出一个子集和就可以了，就是半个<code>FWT</code></p><p>注意某个点离自己的距离是0，这种方法会将这个距离算成包含$a$的集合的点权最小值</p>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> FWT </tag>
            
            <tag> 斜率优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FWT基础</title>
      <link href="/2019/04/02/FWT%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/04/02/FWT%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="FWT有啥用啊"><a href="#FWT有啥用啊" class="headerlink" title="FWT有啥用啊"></a>FWT有啥用啊</h1><p>我们知道，<code>FFT</code>可以解决多项式的卷积，即</p><script type="math/tex; mode=display">C_k=\sum_{i+j=k}A_i\*B_j</script><p>如果将操作符换一下，换成集合运算符</p><p>比如</p><script type="math/tex; mode=display">C_k=\sum_{i|j=k}A_i\*B_j\\\C_k=\sum_{i\&j=k}A_i\*B_j\\\C_k=\sum_{i\oplus j=k}A_i\*B_j</script><p>这时就不能使用<code>FFT</code>了</p><p>但是<code>FFT</code>使我们产生了一种想法</p><p>我们能不能用一种类似<code>FFT</code>的方法，用另一个多项式来表示$A,B$，然后再对应相乘，最后再变换回来呢</p><p>答案是可以的，这就是<code>FWT</code>，即快速沃尔什变换</p><h1 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h1><p>令$A,B$为两个向量，且维数为$n$，$n$是$2$的整数次幂</p><p>定义记号</p><ul><li><p>$A\pm B=(A_0\pm B_0,A_1\pm B_1,A_2\pm B_2,\cdots,A_{n-1}\pm B_{n-1})$</p></li><li><p>$A\oplus B=(\sum\limits_{i\oplus j=0}A_i*B_j,\sum\limits_{i\oplus j=1}A_i*B_j,\sum\limits_{i\oplus j=3}A_i*B_j,\cdots,\sum\limits_{i\oplus j=n-1}A_i*B_j)​$</p></li></ul><p>这里的$\oplus$代表集合运算</p><h1 id="或卷积及其逆运算"><a href="#或卷积及其逆运算" class="headerlink" title="或卷积及其逆运算"></a>或卷积及其逆运算</h1><p>我们定义$FWT$变换，有</p><script type="math/tex; mode=display">FWT(A)[i]=\sum_{j|i=i}A_j</script><blockquote><p>性质1：$FWT(A\pm B)=FWT(A)\pm FWT(B)$</p></blockquote><p>根据此时$FWT​$变换的定义我们知道这是一个$A​$数组的线性组合，故加减法满足分配律</p><p>我们断言，此时的$FWT$满足</p><script type="math/tex; mode=display">FWT(A)=\begin{cases}(FWT(A_0),FWT(A_0)+FWT(A_1))& n>1\\\ A & n=0\end{cases}</script><p>$A_0,A_1$分别代表$A$数组的前半部分、后半部分</p><p>证明如下：</p><p>实际上此时$A_0,A_1$的下标只有最高位是不同的</p><p>根据$FWT$的定义，合并之后左半部分的最高位仍然是0，右半部分的最高位仍然是1</p><p>由于$FWT(A_1)$的最高位一定为1，而此时$j|i$的最高位不可能为0，所以右半部分对于合并之后是没有贡献的</p><p>而对于右半边，如果左半边的数满足$j|i=i​$，那么在$i​$加上最高位1之和，这个式子仍然成立</p><p>而此时右半边原来的$FWT$本来就对右半边的数有贡献</p><p>所以这个式子成立</p><blockquote><p>性质2：$FWT(A|B)=FWT(A)*FWT(B)\ \ (对应相乘)$</p></blockquote><p>我们采用归纳法证明</p><script type="math/tex; mode=display">\begin{aligned}FWT(A|B)&=FWT((A|B)_0,(A|B)_1)\\\&=FWT(A_0|B_0,A_1|B_0+A_0|B_1+A_1|B_1)\\\&=(FWT(A_0|B_0),FWT(A_0|B_0+A_1|B_0+A_0|B_1+A_1|B_1))\\\&=(FWT(A_0)\*FWT(B_0),FWT(A_0)\*FWT(B_0)+FWT(A_1)\*FWT(B_0)\\\&+FWT(A_0)\*FWT(B_1)+FWT(A_1)\*FWT(B_1))\\\&=(FWT(A_0)\*FWT(B_0),(FWT(A_0)+FWT(A_1)\*(FWT(B_0)+FWT(B_1))))\\\&=(FWT(A_0),FWT(A_0)+FWT(A_1))\*(FWT(B_0),FWT(B_0)+FWT(B_1))\\\&=FWT(A)\*FWT(B)\end{aligned}</script><p>定义$IFWT$变换为$FWT$变换的逆变换</p><p>我们断言，$IFWT$满足</p><script type="math/tex; mode=display">IFWT(A)=\begin{cases}(IFWT(A_0),IFWT(A_1)-IFWT(A_0))&n>1\\\ A&n=0\end{cases}</script><p>证明如下：</p><script type="math/tex; mode=display">\begin{aligned}IFWT(FWT(A))&=IFWT(FWT(A_0),FWT(A_0)+FWT(A_1))\\\&=(IFWT(FWT(A_0)),IFWT(FWT(A_1)))\\\&=(A_0,A_1)\\\&=A\end{aligned}</script><h1 id="与卷积及其逆运算"><a href="#与卷积及其逆运算" class="headerlink" title="与卷积及其逆运算"></a>与卷积及其逆运算</h1><p>定义$FWT$变换为</p><script type="math/tex; mode=display">FWT(A)[i]=\sum_{i\&j=j}A_i</script><p>类似或卷积，我们可以得出此时$FWT$的递推式</p><script type="math/tex; mode=display">FWT(A)=\begin{cases}(FWT(A_0)+FWT(A_1),FWT(A_1))&n>1\\\ A &n=0\end{cases}</script><p>证明很简单，$A$数组的右半部分与上一个首位为0的数，得到的结果一定在$A$的左半部分</p><p>显然，它们仍然对自己所在的部分有贡献</p><p>$FWT(A\&amp;B)=FWT(A)*FWT(B)$在此时成立</p><p>证明如下：</p><script type="math/tex; mode=display">\begin{aligned}FWT(A\&B)&=FWT((A\&B)_0,(A\&B)_1)\\\&=FWT(A_0\&B_0+A_0\&B_1+A_1\&B_0,A_1\&B_1)\\\&=(FWT(A_0\&B_0+A_0\&B_1+A_1\&B_0+A_1\&B_1),FWT(A_1\&B_1))\\\&=((FWT(A_0)+FWT(A_1))\*(FWT(B_0)+FWT(B_1)),FWT(A_1)\*FWT(B_1))\\\&=(FWT(A_0)+FWT(A_1),FWT(A_1))\*(FWT(B_0)+FWT(B_1),FWT(B_1))\\\&=FWT(A)\*FWT(B)\end{aligned}</script><p>定义$IFWT$变换为</p><script type="math/tex; mode=display">IFWT(A)=\begin{cases}(IFWT(A_0)-IFWT(A_1),IFWT(A_1))&n>1\\\ A&n=0\end{cases}</script><p>证明如下：</p><script type="math/tex; mode=display">\begin{aligned}IFWT(FWT(A))&=IFWT(FWT(A_0)+FWT(A_1),FWT(A_1))\\\&=(IFWT(FWT(A_0)),IFWT(FWT(A_1))\\\&=(A_0,A_1)\\\&=A\end{aligned}</script><h1 id="异或卷积及其逆运算"><a href="#异或卷积及其逆运算" class="headerlink" title="异或卷积及其逆运算"></a>异或卷积及其逆运算</h1><p>异或卷积的$FWT$稍微麻烦一点</p><p>我们定义函数$d(x)$表示$x$<strong>在二进制下</strong>1的数量</p><p>定义$FWT$变换为</p><script type="math/tex; mode=display">FWT(A)[i]=\sum_{d(j\&i)\equiv0\mod 2}A_j-\sum_{d(k\&i)\equiv1\mod 2}A_k</script><p>那么此时，它的递推式为</p><script type="math/tex; mode=display">FWT(A)=\begin{cases}(FWT(A_0)+FWT(A_1),FWT(A_0)-FWT(A_1))&n>0\\\ A&n=0\end{cases}</script><p>我们考虑这个式子是怎么来的</p><p>先看这个式子左边的$FWT(A_0)+FWT(A_1)$</p><p>$A_0$的下标没有变化，所以要加上$FWT(A_0)$，而现在$A_1$的下标的最高位变成了1，但是与上一个最高位为0的数之后是不变的</p><p>所以这个式子是正确的</p><p>我们看右边的$FWT(A_0)-FWT(A_1)$</p><p>$A_0$的最高位不变，与上一个最高位为1的数之后结果仍然不变</p><p>$A_1$的下标的最高位多了一个1，与上一个最高位为1的数之后奇偶性就变了，所以要取反</p><p>所以这个也是成立的</p><p>$FWT(A\oplus B)=FWT(A)*FWT(B)$在此时成立</p><p>证明如下</p><script type="math/tex; mode=display">\begin{aligned}FWT(A\oplus B)&=FWT((A\oplus B)_0,(A\oplus B)_1)\\\&=FWT(A_0\oplus B_0+A_1\oplus B_1,A_0\oplus B_1+A_1\oplus B_0)\\\&=(FWT(A_0\oplus B_0+A_1\oplus B_1+A_0\oplus B_1+A_1\oplus B_0),\\\&FWT(A_0\oplus B_0+A_1\oplus B_1-A_0\oplus B_1-A_1\oplus B_0))\\\&=((FWT(A_0)+FWT(A_1))\*(FWT(B_0)+FWT(B_1)),\\\&(FWT(A_0)-FWT(A_1))\*(FWT(B_0)-FWT(B_1)))\\\&=(FWT(A_0+A_1),FWT(A_0-A_1))\*(FWT(B_0+B_1),FWT(B_0-B_1))\\\&=FWT(A)\*FWT(B)\end{aligned}</script><p>定义$IFWT$为</p><script type="math/tex; mode=display">IFWT(A)=\begin{cases}(\frac{IFWT(A_0+A_1)}{2},\frac{IFWT(A_0-A_1)}{2})&n>1\\\ A&n=0\end{cases}</script><p>证明如下：</p><script type="math/tex; mode=display">\begin{aligned}IFWT(FWT(A))&=IFWT(FWT(A_0)+FWT(A_1),FWT(A_0)-FWT(A_1))\\\&=(IFWT(FWT(A_0)),IFWT(FWT(A_1)))\\\&=(A_0,A_1)\\\&=A\end{aligned}</script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.30省选模拟</title>
      <link href="/2019/04/01/3-30%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/"/>
      <url>/2019/04/01/3-30%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-唐时月夜"><a href="#T1-唐时月夜" class="headerlink" title="T1 唐时月夜"></a>T1 唐时月夜</h1><p><img src="https://i.loli.net/2019/04/01/5ca1ff79aadc0.png" alt="1554120560222"></p><p><img src="https://i.loli.net/2019/04/01/5ca1ffa16b243.png" alt="1554120600746"></p><p>直接维护显然不太可行，我们考虑每个点单独维护</p><p>对于某个点$(x,y)$，对它有影响的修改一定是一段后缀，那么我们可以二分出这个后缀</p><p>考虑一个修改的本质是什么</p><p>假如现在要对一个矩形$(x_1,y_1),(x_2,y_2)$进行行翻转，并且$(x,y)$在这个矩形内部</p><p>那么此时$y$不变，$x$变为$x_1+x_2-x$</p><p>如果要进行列翻转，那么$x$不变，$y$变为$y_1+y_2-y$</p><p>现在来考虑最复杂的转置</p><p>如果我们强制让$(x_1,y_1)$为原点，重置坐标系，那么此时每个点的$x,y$都会互换</p><p>那么我们模拟这个过程，首先让$x$减去$x_1$,$y$减去$y_1$，再将$x,y$互换，最后把减去的加回来</p><p>那么最后我们一定可以用一个与$x,y$有关的代数式表示最后变换之后的$x,y$，并且$x,y$的系数一定是$1,-1$</p><p>如果当前这个点的转置次数为奇数次，那么最后的$x$应该由最初的$y$表示，最后$y$应该由最初的$x$表示</p><p>否则不变</p><p>我们维护这个符号，以及前面的常数，还有交换次数即可</p><p>比赛的时候我用了线段树，好像很没必要，直接扫描线就可以了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Q 200010</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> l, r, rev, tag[<span class="number">2</span>], sgn[<span class="number">2</span>], lazy;&#125; T[Q &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    swap(T[rt].tag[<span class="number">0</span>], T[rt].tag[<span class="number">1</span>]), swap(T[rt].sgn[<span class="number">0</span>], T[rt].sgn[<span class="number">1</span>]), T[rt].rev ^= <span class="number">1</span>, T[rt].lazy++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> rt1, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T[rt].sgn[id] == <span class="number">1</span> &amp;&amp; T[rt].tag[id] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (T[rt].sgn[id] == <span class="number">1</span>) T[rt1].tag[id] += T[rt].tag[id];</span><br><span class="line">    <span class="keyword">else</span> T[rt1].sgn[id] = -T[rt1].sgn[id], T[rt1].tag[id] = T[rt].tag[id] - T[rt1].tag[id];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T[rt].rev) Swap(rt &lt;&lt; <span class="number">1</span>), Swap(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>), T[rt].rev = <span class="number">0</span>;</span><br><span class="line">    work(rt, rt &lt;&lt; <span class="number">1</span>, <span class="number">0</span>), work(rt, rt &lt;&lt; <span class="number">1</span>, <span class="number">1</span>), work(rt, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, <span class="number">0</span>), work(rt, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    T[rt].sgn[<span class="number">0</span>] = T[rt].sgn[<span class="number">1</span>] = <span class="number">1</span>, T[rt].tag[<span class="number">0</span>] = T[rt].tag[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    T[rt].l = l, T[rt].r = r, T[rt].sgn[<span class="number">0</span>] = T[rt].sgn[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; build(rt &lt;&lt; <span class="number">1</span>, l, mid), build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> type, <span class="keyword">int</span> x, <span class="keyword">int</span> sp = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sp) &#123;T[rt].tag[type - <span class="number">1</span>] += x; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) T[rt].sgn[<span class="number">0</span>] = -T[rt].sgn[<span class="number">0</span>], T[rt].tag[<span class="number">0</span>] = x - T[rt].tag[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) T[rt].sgn[<span class="number">1</span>] = -T[rt].sgn[<span class="number">1</span>], T[rt].tag[<span class="number">1</span>] = x - T[rt].tag[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> Swap(rt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, start, end, type, x, sp); <span class="keyword">if</span> (end &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, start, end, type, x, sp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> at)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> rt;</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">return</span> at &lt;= mid ? query(rt &lt;&lt; <span class="number">1</span>, at) : query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, at);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL unsigned int</span></span><br><span class="line"><span class="keyword">int</span> X1[Q], X2[Q], Y1[Q], Y2[Q]; LL f[<span class="number">20000010</span>];</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tag[<span class="number">2</span>][Q], sgn[<span class="number">2</span>][Q], lzy[Q];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"evernight.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"evernight.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m, q; LL a, b, c; rd(n), rd(n), rd(m), rd(q), rd(a), rd(b), rd(c);</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, max(q, <span class="number">1</span>)), f[<span class="number">0</span>] = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= q;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> op; rd(op), rd(X1[i]), rd(Y1[i]), rd(X2[i]), rd(Y2[i]);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">2</span>) update(<span class="number">1</span>, <span class="number">1</span>, i, <span class="number">1</span>, X1[i] + X2[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">1</span>) update(<span class="number">1</span>, <span class="number">1</span>, i, <span class="number">2</span>, Y1[i] + Y2[i]);</span><br><span class="line">        <span class="keyword">else</span> update(<span class="number">1</span>, <span class="number">1</span>, i, <span class="number">1</span>, <span class="number">1</span> - X1[i], <span class="number">1</span>), update(<span class="number">1</span>, <span class="number">1</span>, i, <span class="number">2</span>, <span class="number">1</span> - Y1[i], <span class="number">1</span>), update(<span class="number">1</span>, <span class="number">1</span>, i, <span class="number">3</span>, <span class="number">0</span>), update(<span class="number">1</span>, <span class="number">1</span>, i, <span class="number">1</span>, X1[i] - <span class="number">1</span>, <span class="number">1</span>), update(<span class="number">1</span>, <span class="number">1</span>, i, <span class="number">2</span>, Y1[i] - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= q;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> at = query(<span class="number">1</span>, i);</span><br><span class="line">        tag[<span class="number">0</span>][i] = T[at].tag[<span class="number">0</span>], tag[<span class="number">1</span>][i] = T[at].tag[<span class="number">1</span>], sgn[<span class="number">0</span>][i] = T[at].sgn[<span class="number">0</span>], sgn[<span class="number">1</span>][i] = T[at].sgn[<span class="number">1</span>], lzy[i] = T[at].lazy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n * m;i++) f[i] = f[i - <span class="number">1</span>] * a + b; LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>;x &lt;= n;x++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>;y &lt;= m;y++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = (x - <span class="number">1</span>) * m + y, l = <span class="number">1</span>, r = q, ans = <span class="number">-1</span>, mid, tx = x, ty = y;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (x &gt;= X1[mid] &amp;&amp; x &lt;= X2[mid] &amp;&amp; y &gt;= Y1[mid] &amp;&amp; y &lt;= Y2[mid]) ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (~ans) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lzy[ans] &amp; <span class="number">1</span>) tx = tag[<span class="number">0</span>][ans] + sgn[<span class="number">0</span>][ans] * y, ty = tag[<span class="number">1</span>][ans] + sgn[<span class="number">1</span>][ans] * x;</span><br><span class="line">                <span class="keyword">else</span> tx = tag[<span class="number">0</span>][ans] + sgn[<span class="number">0</span>][ans] * x, ty = tag[<span class="number">1</span>][ans] + sgn[<span class="number">1</span>][ans] * y;</span><br><span class="line">            &#125;</span><br><span class="line">            res += f[(tx - <span class="number">1</span>) * m + ty] * f[id];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%u\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-附耳而至"><a href="#T2-附耳而至" class="headerlink" title="T2 附耳而至"></a>T2 附耳而至</h1><p><img src="https://i.loli.net/2019/04/01/5ca20214a51ae.png" alt="1554121228509"></p><p><img src="https://i.loli.net/2019/04/01/5ca2051d0fbe3.png" alt="1554122000798"></p><p>一道很妙的题</p><p>首先我们转个对偶图，这里贴一下转对偶图的方法</p><ol><li>将每个点的所有出边按照极角排序</li><li>找到一条<strong>没有被标记过</strong>的边$(u,v)$，设为当前边，重复以下过程：<ul><li>将当前边$(u,v)$标记</li><li>找到$v$的所有出边中，极角序在$(v,u)$前的最后一条边，设为下一次的当前边</li><li>重复这个过程，直到遇到一条标记过的边，那么此时刚刚选出的边就构成了一个区域</li></ul></li></ol><p>举个例子：</p><p><img src="https://i.loli.net/2019/04/01/5ca206a66ab7b.png" alt="1554122398594"></p><p>我们一开始选择了$A$，当前边是$AD$，将这条边标记</p><p><img src="https://i.loli.net/2019/04/01/5ca206eda2a18.png" alt="1554122469557"></p><p>出点是$D$，$D$点的所有出边按照极角排序之后是$DF,DA,DE,DC$</p><p>那么$DA$的前一条边就是$DF$，我们选择这条边</p><p>如果当前边是排序之后的第一条边，那么我们就选择排序之后最大的那条边</p><p><img src="https://i.loli.net/2019/04/01/5ca2076c2a853.png" alt="1554122596704"></p><p>同理，$F$点只有两条出边，我们选择$FB$</p><p><img src="https://i.loli.net/2019/04/01/5ca2079e5ac19.png" alt="1554122647146"></p><p>最后我们选择$BA$，回到了$A$点，下一条边$AD$是已经被标记过的</p><p>所以此时我们就找到了一个区域$ADFB$</p><p>注意边是双向的，标记也是双向的</p><p>这意味着，如果$AB$被标记，不代表$BA$被标记</p><p>我们模拟这个过程就好了</p><hr><p>转完对偶图之后，我们就得到了一个区域被光明之神选中的代价，被黑暗之神选中的代价，以及相邻两个区域所需要扣除的贡献</p><p>然后很显然是个最小割</p><p>我考试的时候使用了一种错误的建图方法：将每个点拆成两个点，代表光明的点在左边，代表黑暗的点在右边，源点连向左边的点，权值为光明之神选中的代价，右边的点连向汇点，权值为黑暗之神选中的代价，对应的点连一条权值为正无穷的边，代表这个点不能被两个神同时选中。如果两个区域$a,b$相邻，那么将$a$的光明连向$b$的黑暗，将$b$的黑暗连向$a$的光明，权值为$c_i$，然后答案就是所有光明的代价之后加上黑暗的代价之和减去最小割</p><p>这样建图有一个很严重的问题：有可能一个点的光明与黑暗都被割了，即不被任何一个神选中</p><p>题解的做法是不拆点，也就没有必要连权值为证无穷的边，$a,b$之间连双向边</p><p><code>zyw</code>大佬的解释：</p><p>如果存在一种最小割，使得某个点连向源点和汇点的边都被割掉了，那么这就意味着，至少有一个黑暗之神所选中的区域与它相邻，至少有一个光明之神选中的区域与它相邻，要不然割掉这两条边没有意义</p><p>而这两个区域所对应的点与当前点有无向边连接，并且我们知道，<strong>这条边没有被割掉</strong>，否则我们没有必要割去两条边</p><p>我们考虑以下这种情况</p><p><img src="https://i.loli.net/2019/04/01/5ca20b54cd359.png" alt="1554123593791"></p><p><font color=D94600>橙色</font>的边代表被割去的边，显然中间那个点就是不合法的点，因为它上下两条边都被割去了</p><p>图中所对应的情况，就是左边那个点被黑暗之神选中，右边那个点被光明之神选中</p><p>但是此时，由<strong>黑色</strong>边构成的路径使得$s,t$连通了，不符合割的性质</p><p>所以这种情况是不可能出现的</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MX 2000010</span></span><br><span class="line"><span class="keyword">int</span> x[N], y[N], val[N], val2[N], n, s, t, tot; <span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">namespace</span> Flow &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to, next, w;&#125; e[MX];</span><br><span class="line">    <span class="keyword">int</span> head[N * <span class="number">2</span>], cur[N * <span class="number">2</span>], ecnt = <span class="number">1</span>, dep[N * <span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        e[++ecnt] = (edge)&#123;to, head[from], w&#125;, head[from] = ecnt;</span><br><span class="line">        e[++ecnt] = (edge)&#123;from, head[to], <span class="number">0</span>&#125;, head[to] = ecnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; q.push(s), <span class="built_in">memset</span>(dep, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dep)), dep[s] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">                <span class="keyword">if</span> (e[i].w &amp;&amp; dep[e[i].to] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    dep[e[i].to] = dep[u] + <span class="number">1</span>, q.push(e[i].to);</span><br><span class="line">                    <span class="keyword">if</span> (e[i].to == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == t || !f) <span class="keyword">return</span> f; <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u], tmp;i;i = e[i].next)</span><br><span class="line">            <span class="keyword">if</span> (e[i].w &amp;&amp; dep[e[i].to] == dep[u] + <span class="number">1</span> &amp;&amp; (tmp = DFS(e[i].to, min(f, e[i].w), t))) &#123;</span><br><span class="line">                res += tmp, f -= tmp, e[i].w -= tmp, e[i ^ <span class="number">1</span>].w += tmp;</span><br><span class="line">                <span class="keyword">if</span> (!f) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (BFS(s, t)) <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span>(head)), res += DFS(s, <span class="number">1e9</span>, t);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Planner_G &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> u, v, w, w2, c; <span class="keyword">double</span> angle;</span><br><span class="line">        edge(<span class="keyword">int</span> u = <span class="number">0</span>, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> w = <span class="number">0</span>, <span class="keyword">int</span> w2 = <span class="number">0</span>, <span class="keyword">int</span> c = <span class="number">0</span>) : u(u), v(v), w(w), w2(w2), c(c) &#123;</span><br><span class="line">            <span class="keyword">int</span> tx = x[v] - x[u], ty = y[v] - y[u];</span><br><span class="line">            angle = <span class="built_in">atan2</span>(ty, tx);</span><br><span class="line">            <span class="keyword">if</span> (angle &lt; <span class="number">0</span>) angle += <span class="number">2</span> * PI;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; e[M * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ecnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v1 = val[from] + val[to], v2 = val2[from] + val2[to];</span><br><span class="line">        e[ecnt++] = edge(from, to, v1, v2, c), e[ecnt++] = edge(to, from, v1, v2, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[N];</span><br><span class="line">    <span class="keyword">int</span> rank[M * <span class="number">2</span>], near[M * <span class="number">2</span>], vis[M * <span class="number">2</span>], pval[N], pval2[N], rcnt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> eid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[eid]) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp1 = <span class="number">0</span>, tmp2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!vis[eid]) &#123;</span><br><span class="line">            tmp1 += e[eid].w, tmp2 += e[eid].w2, vis[eid] = <span class="number">1</span>, near[eid] = rcnt;</span><br><span class="line">            <span class="keyword">int</span> v = e[eid].v;</span><br><span class="line">            <span class="keyword">if</span> (!rank[eid ^ <span class="number">1</span>]) eid = G[v].back();</span><br><span class="line">            <span class="keyword">else</span> eid = G[v][rank[eid ^ <span class="number">1</span>] - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        pval[rcnt] = tmp1 / <span class="number">2</span>, pval2[rcnt] = tmp2 / <span class="number">2</span>, rcnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pair&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt; *tmp = <span class="keyword">new</span> pair&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt;[ecnt + <span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ecnt;i++) tmp[i] = make_pair(e[i].angle, i);</span><br><span class="line">        sort(tmp, tmp + ecnt);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ecnt;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> eid = tmp[i].second; </span><br><span class="line">            rank[eid] = G[e[eid].u].size(), G[e[eid].u].push_back(eid);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; G[i].size();j++)</span><br><span class="line">                mark(i, G[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s = rcnt + <span class="number">1</span>, t = rcnt + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= rcnt;i++) </span><br><span class="line">            Flow::adde(s, i, pval[i - <span class="number">1</span>]), Flow::adde(i, t, pval2[i - <span class="number">1</span>]), tot += pval[i - <span class="number">1</span>] + pval2[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ecnt;i += <span class="number">2</span>) &#123; </span><br><span class="line">            <span class="keyword">int</span> u = near[i] + <span class="number">1</span>, v = near[i ^ <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            Flow::adde(u, v, e[i].c), Flow::adde(v, u, e[i].c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"everfeel.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"everfeel.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> m; <span class="built_in">scanf</span>(<span class="string">"%*d%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;x[i], &amp;y[i], &amp;val[i], &amp;val2[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b, c;i &lt;= m;i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c), Planner_G::adde(a, b, c);</span><br><span class="line">    Planner_G::build(), Planner_G::link();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tot - Flow::Dinic(s, t));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-星辰大海"><a href="#T3-星辰大海" class="headerlink" title="T3 星辰大海"></a>T3 星辰大海</h1><p><img src="https://i.loli.net/2019/04/01/5ca213588154a.png" alt="1554125646395"></p><p><img src="https://i.loli.net/2019/04/01/5ca2137a9f633.png" alt="1554125680016"></p><div class="pdfobject-container" data-target="solution.pdf" data-height="500px"></div>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 计算几何 </tag>
            
            <tag> 对偶图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.29省选模拟</title>
      <link href="/2019/04/01/3-29%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/"/>
      <url>/2019/04/01/3-29%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-循环流"><a href="#T1-循环流" class="headerlink" title="T1 循环流"></a>T1 循环流</h1><p><img src="https://i.loli.net/2019/04/01/5ca1ce52d08ad.png" alt="1554107930466"></p><p><img src="https://i.loli.net/2019/04/01/5ca1ce635ed72.png" alt="1554107945062"></p><p>一道比较神仙的题</p><p>考试的时候我使用的是手玩+找规律</p><p>我们考虑以下几种情况：</p><ol><li><p>$n=2$：这时需要特殊考虑</p><p> 如果没有1边，那么2边的数量必须是偶数</p><p> 否则如果1边的数量是奇数，那么一定不行</p><p> 此时如果1边的数量是偶数，如果2边的数量是奇数，那么我们可以用两条1边凑出一条2边，而此时1边的数量仍然是偶数</p></li><li><p>$a=1$：显然此时不可能存在合法情况，因为找不到另一条1边来与这条边匹配</p></li><li><p>$n\not=2,a=0或b=0$：我们可以将数量不为0的那条边连成一个环，这样至少需要$n$条边。如果数量不为0的那条边的边数大于$n$，并且是偶数，那么我们连两条相反的边即可使得边数$-2$，否则我们连成一个长度为$3$的环，可以使得边数$-3$，如果边数为$n+1$，那么我们可以连一个长度为$2$的环，再将剩下的$n-1$个点连成环</p></li><li><p>剩余情况：将1连成一个环，将2连成一个环，则至少要用$n+1$条边，同样可以使用3中的方法调整</p></li></ol><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"flow.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"flow.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> k, T, cnt = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;k, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, a, b; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (a + b &lt; n) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; b % <span class="number">2</span> == <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a != <span class="number">0</span> &amp;&amp; a % <span class="number">2</span> == <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &gt;= n) <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a &gt;= n) <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (a + b - <span class="number">1</span> &gt;= n) <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-整除分块"><a href="#T2-整除分块" class="headerlink" title="T2 整除分块"></a>T2 整除分块</h1><p><img src="https://i.loli.net/2019/04/01/5ca1f6c1908d1.png" alt="1554118329309"></p><p><img src="https://i.loli.net/2019/04/01/5ca1f6e5ea656.png" alt="1554118366322"></p><p>先贴上题解</p><div class="pdfobject-container" data-target="solution2.pdf" data-height="500px"></div><h1 id="T3-森林"><a href="#T3-森林" class="headerlink" title="T3 森林"></a>T3 森林</h1><p><img src="https://i.loli.net/2019/04/01/5ca1f8e0ee1a8.png" alt="1554118872861"></p><p><img src="https://i.loli.net/2019/04/01/5ca1f8fdcb785.png" alt="1554118901828"></p><p>一道很奇妙的题：<code>LCT</code>维护虚子树信息</p><p>观察变换之后答案的本质：其实就是这棵树的直径加上从直径上的某一点出发的最长链的长度- 1</p><p>我们考虑使用<code>LCT</code>维护，那么我们需要维护这些信息：</p><ul><li>从当前区间的左端点出发，可以走重链也可以走轻链，能走出的最长路径所包含的点数</li><li>从当前区间的右端点出发，可以走重链也可以走轻链，能走出的最长路径所包含的点数</li><li>某个点的虚子树内，来自每个轻儿子的路径所包含点数的最大值（注意是每个轻儿子都会贡献一个最大值）</li><li>从当前区间内的任意一点出发，向虚子树重走所走出的路径包含的点数的最大值（出发点不算）</li></ul><p>由于我们需要区间翻转，所以维护第一个值的时候附带了需要维护第二个值</p><p>我们知道只有在<code>link, access</code>的时候子树的虚实才会产生变化，也就是说，这个时候我们需要更新第三个值</p><p>比如<code>access</code>：</p><p>假设上一次的点为$v$，当前点为$u$，$u$的右儿子为$v’$</p><p>此时$u$会损失一个右儿子$v’$，获得另一个右儿子$v$</p><p>本来$v$是$u$的轻儿子，对$u$的第三个值有贡献，但是现在$v$变成了重儿子，这个贡献应当删去</p><p>本来$v’$是$u$的重儿子，对$u$的第三个值没有贡献，但是现在$v’$变成了轻儿子，这个贡献应当加上</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ls = <span class="number">0</span>;u;u = fa[ls = u]) &#123;</span><br><span class="line">        splay(u); </span><br><span class="line">        <span class="keyword">if</span> (ls) dep[u].erase(dep[u].find(l[ls]));</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">1</span>][u]) dep[u].insert(l[ch[<span class="number">1</span>][u]]);</span><br><span class="line">        ch[<span class="number">1</span>][u] = ls, pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dep</code>就是第三个值，<code>l</code>是第一个值</p><p><code>pushup</code>的时候也比较简单，当前区间的<code>l</code>要么是左子树的<code>l</code>，要么是左子树的<code>size</code>加一再加上右子树的<code>l</code></p><p><code>r</code>同理</p><p>注意区间翻转的时候我们需要先翻转当前点，<code>rev</code>标记代表<strong>已经<code>rev</code>了当前点，但是当前点的子树还没有翻转</strong></p><p>貌似是去年省选D1T1的加强版</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="keyword">int</span> fa[N], ch[<span class="number">2</span>][N], rev[N], l[N], r[N], s[N], mxdep[N];</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; dep[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> son)</span> </span>&#123;</span><br><span class="line">    fa[u] = f, ch[son][f] = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isroot</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (u != ch[<span class="number">0</span>][fa[u]] &amp;&amp; u != ch[<span class="number">1</span>][fa[u]]) || !u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">child</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == ch[<span class="number">1</span>][fa[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    s[u] = s[ch[<span class="number">0</span>][u]] + <span class="number">1</span> + s[ch[<span class="number">1</span>][u]];</span><br><span class="line">    <span class="keyword">int</span> t = dep[u].size() ? *dep[u].rbegin() : <span class="number">0</span>;</span><br><span class="line">    l[u] = max(l[ch[<span class="number">0</span>][u]], s[ch[<span class="number">0</span>][u]] + <span class="number">1</span> + max(t, l[ch[<span class="number">1</span>][u]]));</span><br><span class="line">    r[u] = max(r[ch[<span class="number">1</span>][u]], s[ch[<span class="number">1</span>][u]] + <span class="number">1</span> + max(t, r[ch[<span class="number">0</span>][u]]));</span><br><span class="line">    mxdep[u] = max(mxdep[ch[<span class="number">0</span>][u]], max(mxdep[ch[<span class="number">1</span>][u]], t));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    swap(ch[<span class="number">0</span>][u], ch[<span class="number">1</span>][u]), rev[u] ^= <span class="number">1</span>, swap(l[u], r[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rev[u]) work(ch[<span class="number">0</span>][u]), work(ch[<span class="number">1</span>][u]), rev[u] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = fa[u], ff = fa[f], tmp = child(u), tmp1 = child(f);</span><br><span class="line">    <span class="keyword">if</span> (!isroot(f)) connect(u, ff, tmp1);</span><br><span class="line">    fa[u] = ff, connect(ch[tmp ^ <span class="number">1</span>][u], f, tmp), connect(f, u, tmp ^ <span class="number">1</span>), pushup(f), pushup(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = u, top = <span class="number">0</span>; st[++top] = u;</span><br><span class="line">    <span class="keyword">while</span> (!isroot(now)) st[++top] = now = fa[now];</span><br><span class="line">    <span class="keyword">while</span> (top) pushdown(st[top--]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> f;!isroot(u);rotate(u))</span><br><span class="line">        <span class="keyword">if</span> (!isroot(f = fa[u]))</span><br><span class="line">            rotate(child(u) ^ child(f) ? u : f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ls = <span class="number">0</span>;u;u = fa[ls = u]) &#123;</span><br><span class="line">        splay(u); </span><br><span class="line">        <span class="keyword">if</span> (ls) dep[u].erase(dep[u].find(l[ls]));</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">1</span>][u]) dep[u].insert(l[ch[<span class="number">1</span>][u]]);</span><br><span class="line">        ch[<span class="number">1</span>][u] = ls, pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    access(u), splay(u), work(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    makeroot(a), access(b), splay(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    split(a, b); </span><br><span class="line">    <span class="keyword">return</span> s[b] - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> d1 = <span class="number">1</span>, d2 = <span class="number">1</span>, dis = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    makeroot(b), fa[a] = b, dep[b].insert(l[a]), pushup(b);</span><br><span class="line">    <span class="keyword">int</span> l1 = get(d1, a), l2 = get(d2, a);</span><br><span class="line">    <span class="keyword">if</span> (max(l1, l2) &gt; dis) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 &gt; l2) dis = l1, d2 = a;</span><br><span class="line">        <span class="keyword">else</span> dis = l2, d1 = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    split(d1, d2); <span class="keyword">return</span> dis + (mxdep[d2] ? mxdep[d2] - <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen("forest.in", "r", stdin), freopen("forest.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">int</span> k, n; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;k, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) s[i] = l[i] = r[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, lastans = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), a ^= lastans;</span><br><span class="line">        link(i + <span class="number">1</span>, a), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lastans = query());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次考试运气很好，把第一题水过了</p><p>可惜时间太短，只有3个小时</p><p>最后一题很有启发性</p>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> LCT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.27省选模拟</title>
      <link href="/2019/03/28/3-27%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/"/>
      <url>/2019/03/28/3-27%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-白"><a href="#T1-白" class="headerlink" title="T1 白"></a>T1 白</h1><p><img src="https://i.loli.net/2019/03/28/5c9caf41964e0.png" alt="1553772340872"></p><p><img src="https://i.loli.net/2019/03/28/5c9caf5a8341e.png" alt="1553772371157"></p><p>不会，先贴上题解</p><div class="pdfobject-container" data-target="main.pdf" data-height="500px"></div><h1 id="T2-胖"><a href="#T2-胖" class="headerlink" title="T2 胖"></a>T2 胖</h1><p><img src="https://i.loli.net/2019/03/28/5c9cafb29fa1c.png" alt="1553772458873"></p><p><img src="https://i.loli.net/2019/03/28/5c9cafcd2fb05.png" alt="1553772485834"></p><p>比较简单的一道题</p><p>由于$X\leq 32768$，所以一次修改会影响的层数不超过15层</p><p>考虑到在一次修改中，同一层所减少的权值是相同的，那么我们可以对于每一层都开一棵线段树</p><p>但是这样会涉及到重复统计的问题</p><p>比如当前已经更新了$u$，现在要更新它的父亲$f$的子树</p><p>但是此时$u$的子树已经被更新了一遍，在处理$f$的子树时不需要再考虑$u$的子树</p><p>我们知道子树中的<code>dfs</code>序是连续的</p><p>那么对于每一层我们可以按照<code>dfs</code>序排序，这样修改只会改一段连续的区间</p><p>对于每个区间我们维护一个区间最小值来处理询问</p><p>每次更新完毕就查询当前是否有小于等于0的点</p><p>找到这些点，并且将这些点打上标记，就是已经破产的城市</p><p>同时将这个点的最小值改为$\infty$，因为在之后的操作中这个点不可能再次对答案产生贡献</p><p>再开一个树状数组处理询问，每次就是单点修改，然后在询问点的<code>dfs</code>区间里面查</p><p>由于每个点只会被标记一次，所以此时的时间复杂度为$n\log^2 n$</p><p>之前修改的时间复杂度为$n\log^3n$</p><p>我的程序很不优秀，所以在考试的时候被卡常了，只有60分</p><p>主要是这些地方：</p><ul><li>线段树不要开<code>vector</code>，很慢，要改成数组</li><li>读优显然要加</li><li>没有必要在每一小次修改之前都更新破产的点，一次大修改之后一起更新要快得多</li><li>在处理修改的时候不需要<code>lower_bound</code>出在线段树里面对应的节点，线段树的<code>update</code>中改一下就好了</li></ul><p>看来我还是太不优秀了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RG register</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to, next;&#125; e[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fa[N], dfn[N], ed[N], dfsn, dep[N], w[N], n, tree[N], to[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; P[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> mn, mx, lazy, l, r;&#125;;</span><br><span class="line">node *T[N]; <span class="keyword">int</span> *p[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">for</span> (;x &lt;= n;x += x &amp; -x) tree[x]++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;x;x -= x &amp; -x) res += tree[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;<span class="keyword">return</span> query(r) - query(l - <span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> rt)</span> </span>&#123;T[cur][rt].mn = Min(T[cur][rt &lt;&lt; <span class="number">1</span>].mn, T[cur][rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mn), T[cur][rt].mx = Max(T[cur][rt &lt;&lt; <span class="number">1</span>].mx, T[cur][rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mx);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    T[cur][rt].l = l, T[cur][rt].r = r, T[cur][rt].lazy = <span class="number">0</span>; <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) T[cur][rt].mn = T[cur][rt].mx = w[to[p[cur][l - <span class="number">1</span>]]];</span><br><span class="line">    <span class="keyword">else</span> build(cur, rt &lt;&lt; <span class="number">1</span>, l, mid), build(cur, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r), pushup(cur, rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = T[cur][rt].lazy; T[cur][rt].lazy = <span class="number">0</span>;</span><br><span class="line">    T[cur][rt &lt;&lt; <span class="number">1</span>].mn -= t, T[cur][rt &lt;&lt; <span class="number">1</span>].mx -= t, T[cur][rt &lt;&lt; <span class="number">1</span>].lazy += t;</span><br><span class="line">    T[cur][rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mn -= t, T[cur][rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mx -= t, T[cur][rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lazy += t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> rt, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end || T[cur][rt].mx &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> l = T[cur][rt].l, r = T[cur][rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p[cur][l - <span class="number">1</span>] &gt; end || p[cur][r - <span class="number">1</span>] &lt; start) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (T[cur][rt].mn &gt; <span class="number">0</span> &amp;&amp; T[cur][rt].mn &lt;= x) update(p[cur][l - <span class="number">1</span>]); </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (T[cur][rt].lazy) pushdown(cur, rt);</span><br><span class="line">    <span class="keyword">int</span> t = p[cur][T[cur][rt &lt;&lt; <span class="number">1</span>].r - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= t &amp;&amp; T[cur][rt &lt;&lt; <span class="number">1</span>].mn &lt;= x &amp;&amp; T[cur][rt &lt;&lt; <span class="number">1</span>].mx &gt; <span class="number">0</span>) query(cur, rt &lt;&lt; <span class="number">1</span>, start, end, x);</span><br><span class="line">    <span class="keyword">if</span> (end &gt; t &amp;&amp; T[cur][rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mn &lt;= x &amp;&amp; T[cur][rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mx &gt; <span class="number">0</span>) query(cur, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, start, end, x); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> rt, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end || T[cur][rt].mx &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> l = T[cur][rt].l, r = T[cur][rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>, tl = p[cur][l - <span class="number">1</span>], tr = p[cur][r - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (tl &gt; end || tr &lt; start) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= tl &amp;&amp; tr &lt;= end) &#123;T[cur][rt].mn -= x, T[cur][rt].mx -= x, T[cur][rt].lazy += x; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (T[cur][rt].lazy) pushdown(cur, rt);</span><br><span class="line">    <span class="keyword">int</span> t = p[cur][T[cur][rt &lt;&lt; <span class="number">1</span>].r - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= t) update(cur, rt &lt;&lt; <span class="number">1</span>, start, end, x);</span><br><span class="line">    <span class="keyword">if</span> (end &gt; t) update(cur, rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, start, end, x);</span><br><span class="line">    pushup(cur, rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    fa[u] = f, dep[u] = dep[f] + <span class="number">1</span>, dfn[u] = ++dfsn, to[dfsn] = u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u);</span><br><span class="line">    ed[u] = dfsn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) P[dep[i]].push_back(dfn[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span> (P[i].size()) &#123;</span><br><span class="line">        sort(P[i].begin(), P[i].end()), p[i] = <span class="keyword">new</span> <span class="keyword">int</span>[P[i].size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; P[i].size();j++) p[i][j] = P[i][j];</span><br><span class="line">        T[i] = <span class="keyword">new</span> node[P[i].size() * <span class="number">4</span>], build(i, <span class="number">1</span>, <span class="number">1</span>, P[i].size());    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span> (w[i] &lt;= <span class="number">0</span>) update(dfn[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> ls, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;x &gt;&gt; i;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = dep[u] + i; <span class="keyword">if</span> (!P[cur].size()) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (!ls) query(cur, <span class="number">1</span>, dfn[u], ed[u], x &gt;&gt; i), update(cur, <span class="number">1</span>, dfn[u], ed[u], x &gt;&gt; i);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            query(cur, <span class="number">1</span>, dfn[u], dfn[ls] - <span class="number">1</span>, x &gt;&gt; i), update(cur, <span class="number">1</span>, dfn[u], dfn[ls] - <span class="number">1</span>, x &gt;&gt; i);</span><br><span class="line">            query(cur, <span class="number">1</span>, ed[ls] + <span class="number">1</span>, ed[u], x &gt;&gt; i), update(cur, <span class="number">1</span>, ed[ls] + <span class="number">1</span>, ed[u], x &gt;&gt; i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fa[u]) update(fa[u], u, x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">rd</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"pang.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"pang.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    rd(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) rd(w[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b;i &lt; n;i++) rd(a), rd(b), adde(a, b);</span><br><span class="line">    pre(); <span class="keyword">int</span> q; rd(q);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, a, b; rd(op), rd(a);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) rd(b), update(a, <span class="number">0</span>, b);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(dfn[a], ed[a]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-圆"><a href="#T3-圆" class="headerlink" title="T3 圆"></a>T3 圆</h1><p><img src="https://i.loli.net/2019/03/28/5c9cb26557fd9.png" alt="1553773149948"></p><p><img src="https://i.loli.net/2019/03/28/5c9cb28012744.png" alt="1553773175561"></p><p>本次考试最简单的一道题</p><p><code>OEIS</code>上提供了一个$n\log n$的方法，可以拿到100分</p><p>然而实际上是会被卡掉的，$n=5,p=7$时就会输出0</p><p>我们先考虑如果给出一个排列，如何判断它是否合法</p><p>假设当前已经处理到了第$i$位，这一位的数为$w_i$</p><p>如果此时，三个上升子序列的末尾都大于它，那么这个排列就不合法</p><p>否则，找到那个比它小的最大的结尾，将$w_i$接在这个序列后面</p><p>这显然是最优秀的，因为把$w_i$接在较小的那个结尾后面一定更不优秀</p><p>那么我们考虑<a href="https://www.luogu.org/problemnew/show/P4769" target="_blank" rel="noopener">冒泡排序</a>这道题</p><p>忽略字典序的限制，这道题其实就是将本题的限制3改成了2</p><p>当时我们用<code>dp[i][j]</code>表示还有$i$位没有填，后面的数中比当前所填的最大的数还要大的有$j$个的方案数</p><p>因为两个子序列中，一定有一个序列的结尾是当前最大的数</p><p>如果我们在后面放比当前最大值还要大的数，那么在当前这一位可以随便放</p><p>否则我们只能从小到大放</p><p>也就是</p><script type="math/tex; mode=display">dp_{i,j}=dp_{i-1,j}+\sum_{k=1}^jdp_{i-1,j-k}\\\=\sum_{k=1}^jdp_{i-1,j-k}</script><p>那个$k$是枚举当前放第几大的数，显然放了$k$之后当前最大的数就是这个数了，同时比最大的数还要大的数减少了$k$个</p><p>那么这道题也是类似</p><p>我们用<code>dp[i][j][k]</code>表示还有$i$位没有填，后面的数中比当前最大的序列的末尾还要大的有$j$个，比次大的序列末尾还要大的有$k$个时的方案数</p><p>显然有$k\geq j$</p><p>那么此时根据我们之前的推论，策略是这样的</p><ul><li>放一个比最大的数还要大的数，假设它是后面比最大的数还要大的数中第$l$小的，那么$j$会减少$l$，$k$会减少1，此时我们不会考虑将$l$放在次大的序列末尾</li><li>放一个比最大的数小，但是比次大的数大的数，此时$j$不变，$k$会减少$l$</li><li>放一个比最大和次大都要小的数，$j,k$都不变</li></ul><p>写成转移方程就是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= i;++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = j;k &lt;= i;++k) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>;l &lt;= j;++l) (dp[i][j][k] += dp[i - <span class="number">1</span>][j - l][k - <span class="number">1</span>]) %= p;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>;l &lt;= k - j;++l) (dp[i][j][k] += dp[i - <span class="number">1</span>][j][k - l]) %= p; </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>显然，这个<code>dp</code>是可以滚动数组+前缀和优化到$n^3$的</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 510</span></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][N][N], f[<span class="number">2</span>][N][N], g[<span class="number">2</span>][N][N]; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"yuan.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"yuan.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n, p; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;p);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) f[<span class="number">0</span>][i][<span class="number">0</span>] = g[<span class="number">0</span>][<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, cur = <span class="number">0</span>;i &lt;= n;++i) &#123;</span><br><span class="line">        cur ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= i;++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j;k &lt;= i;++k) &#123;</span><br><span class="line">                dp[cur][j][k] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (j) dp[cur][j][k] += f[cur ^ <span class="number">1</span>][j - <span class="number">1</span>][k - <span class="number">1</span>];</span><br><span class="line">                (dp[cur][j][k] += g[cur ^ <span class="number">1</span>][j][k]) %= p;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= i + <span class="number">1</span>;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j;k &lt;= i + <span class="number">1</span>;k++) &#123;</span><br><span class="line">                f[cur][j][k] = ((j ? f[cur][j - <span class="number">1</span>][k] : <span class="number">0</span>) + dp[cur][j][k]) % p;</span><br><span class="line">                g[cur][j][k] = ((k ? g[cur][j][k - <span class="number">1</span>] : <span class="number">0</span>) + dp[cur][j][k]) % p;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[n &amp; <span class="number">1</span>][n][n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当时由于时间不够了，所以没有来得及加前缀和优化，只有70分</p><p>不爽</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>花了太多时间再第二道题上面，导致第三题没来得及优化到满分，结果最后还被卡常了</p><p>写题的时候应该先挑简单的写，而且要有卡常数的习惯，不要等到写完了再改</p>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 多项式 </tag>
            
            <tag> BM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.26省选模拟</title>
      <link href="/2019/03/27/3-26%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/"/>
      <url>/2019/03/27/3-26%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-要换换名字"><a href="#T1-要换换名字" class="headerlink" title="T1 要换换名字"></a>T1 要换换名字</h1><p><img src="https://i.loli.net/2019/03/27/5c9b644a4b36a.png" alt="1553687612676"></p><p><img src="https://i.loli.net/2019/03/27/5c9b646d51fc1.png" alt="1553687654222"></p><p>显然不是多项式题目</p><p>我们考虑枚举根节点，并且强制让根节点选，这样的话如果要选择一个点，那么它的父亲节点必须选</p><p>此时对于每个点，它在两棵树里面有两个父亲，如果选择这个点，那么这两个父亲都必须选</p><p>接下来就是最大权闭合子图模板</p><p>建图方法是，保留原图中的所有边，将权值替换成$\infty$，对于一个节点$i$，如果$w_i&gt;0$，则从源点向$i$连一条权值为$w_i$的边，如果$w_i&lt;0$，则从$i$向汇点连一条权值为$-w_i$边</p><p>左右正权点的和减去最小割就是答案</p><p>如果一条从$s$出发的边被割了，就代表这个点不选</p><p>如果一条从$t$出发的边被割了，就代表这个点选</p><p>如果$i$号点选了，而它的后继中至少有一个负权点没有被选，这显然是不合法的</p><p>对应着我们不能让$s,t$连通，即要么不选$i$，要么选$i$及其所有后继</p><p>我们要让减去的权值最小，就对应着最小割</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ZJKAKIOI</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to, next, w;&#125; e[N * <span class="number">8</span>];</span><br><span class="line">    <span class="keyword">int</span> head[N * <span class="number">2</span>], ecnt, dep[N * <span class="number">2</span>], cur[N * <span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        e[++ecnt] = (edge)&#123;to, head[from], w&#125;, head[from] = ecnt;</span><br><span class="line">        e[++ecnt] = (edge)&#123;from, head[to], <span class="number">0</span>&#125;, head[to] = ecnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;ecnt = <span class="number">1</span>, <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dep, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dep)), dep[s] = <span class="number">0</span>; <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; q.push(s);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">                <span class="keyword">if</span> (e[i].w &amp;&amp; dep[e[i].to] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    dep[e[i].to] = dep[u] + <span class="number">1</span>, q.push(e[i].to);</span><br><span class="line">                    <span class="keyword">if</span> (e[i].to == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == t || !f) <span class="keyword">return</span> f; <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u], tmp;i;i = e[i].next)</span><br><span class="line">            <span class="keyword">if</span> (e[i].w &amp;&amp; dep[e[i].to] == dep[u] + <span class="number">1</span> &amp;&amp; (tmp = DFS(e[i].to, min(f, e[i].w), t))) &#123;</span><br><span class="line">                res += tmp, f -= tmp, e[i].w -= tmp, e[i ^ <span class="number">1</span>].w += tmp;</span><br><span class="line">                <span class="keyword">if</span> (!f) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (BFS(s, t)) <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span>(head)), res += DFS(s, <span class="number">1e9</span>, t);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; Orz;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; G[N], G2[N]; <span class="keyword">int</span> s, t, n, w[N], all, fa[N], fa2[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;G[from].insert(to), G[to].insert(from);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde2</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;G2[from].insert(to), G2[to].insert(from);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    fa[u] = f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) <span class="keyword">if</span> (v != f) dfs1(v, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    fa2[u] = f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G2[u]) <span class="keyword">if</span> (v != f) dfs2(v, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), s = <span class="number">2</span> * n + <span class="number">1</span>, t = <span class="number">2</span> * n + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) G[i].clear(), G2[i].clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde2(a, b);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-1e9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">            Orz.clear(), all = <span class="number">0</span>, dfs1(i, <span class="number">0</span>), dfs2(i, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++) &#123;</span><br><span class="line">                Orz.adde(j, fa2[j], <span class="number">1e9</span>), Orz.adde(j, fa[j], <span class="number">1e9</span>);</span><br><span class="line">                <span class="keyword">if</span> (w[j] &lt; <span class="number">0</span>) Orz.adde(j, t, -w[j]);</span><br><span class="line">                <span class="keyword">if</span> (w[j] &gt; <span class="number">0</span>) Orz.adde(s, j, w[j]), all += w[j];</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, all - Orz.Dinic(s, t));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-动态半平面交"><a href="#T2-动态半平面交" class="headerlink" title="T2 动态半平面交"></a>T2 动态半平面交</h1><p><img src="https://i.loli.net/2019/03/27/5c9b683f16675.png" alt="1553688629711"></p><p><img src="https://i.loli.net/2019/03/27/5c9b685a8ab81.png" alt="1553688659111"></p><p>估计题目是出题人找不到合适的了</p><p>首先，$lcm(a_1,a_2,\cdots,a_n)\not=\frac{a_1a_2\cdots a_n}{gcd(a_1,a_2,\cdots,a_n)}$，要是可以就是水题了</p><p>我们首先考虑一条链的情况</p><p>如果此时每个数都互质，那么答案显然就是将区间内所有出现过的数乘起来</p><p>否则对于某个质因子$p$，它对当前询问的贡献就是它在这个区间内出现过的最高次数</p><p>这个东西不是很好维护，因为它不可以拆分</p><p>我们考虑换一种方法</p><p>对于这个区间内的某个数$i$，如果它含有质因子$p$，且这个$p$的次数为$k$，那么我们可以将$p^k$拆成$k$个数$p,p^2,p^3,\cdots,p^k$，如果之前没有出现过某个数，就将答案乘以$p$</p><p>这样，我们得到的结果仍然是区间内$p$的最高次幂</p><p>这个题的强制在线是假的</p><p>我们考虑将这个操作搬到树上</p><p>对于一次询问$u,d$，对它的答案能造成影响的点是它的子树内距离它不超过$d$的点</p><p>我们将询问离线，并按照$dep[u]+d$从小到大排序，然后通过扫描线的做法一排一排地加入质因子</p><p>考虑一个数$p^k$</p><p>我们将所有的质因子的所有次方哈希一下，对于每个$p^k$开一个<code>set</code>维护它出现的位置</p><p>在某个时刻，$p^k$对询问的贡献就是当前所有$p^k$出现过的点及其祖先节点</p><p>假如现在$p^k$在两个位置$a,b$出现了</p><p>那么我们可以将节点$a$的权值乘上$p$，将节点$b$的权值也乘上$p$</p><p>但是这样的话$lca(a,b)$及其祖先在计算答案的时候会重复统计一次，即$p$的贡献只应被计算一次，而此时计算了两次</p><p>所以我们需要在$lca(a,b)$处除以$p$</p><p>在<code>set</code>中我们按照节点的<code>dfs</code>序排序</p><p>那么插入一个点的时候我们只用关心它与它的前驱与后继</p><p>因为我们只关心离它最近的那个$lca$</p><p>而这两个点与它的$lca$都有希望成为最近的那个</p><p>所以此时我们在这个节点乘上$p$，如果它的前驱与后继分别为$a,b$，那么就在$lca(a,u),lca(b,u)$处除以$p$</p><p>由于我们只用在离它最近的那个$lca$处去重，而这里我们除以了两次$p$，在这两个$lca$中，离它较远的那个一定是$lca(a,b)$</p><p>因为我们多除了一次，所以在这个$lca$处我们需要把它乘回去</p><p>乘的操作我们需要一个树状数组，查询的时候就查它的<code>dfs</code>序所包含的范围就行了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to, next;&#125; e[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt, fa[N][<span class="number">17</span>], dep[N], dfn[N], ed[N], dfsn;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = f, dep[u] = dep[f] + <span class="number">1</span>, dfn[u] = ++dfsn;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">16</span>;i++) fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u);</span><br><span class="line">    ed[u] = dfsn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[a] &lt; dep[b]) swap(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">16</span>;i &gt;= <span class="number">0</span>;i--) <span class="keyword">if</span> (dep[fa[a][i]] &gt;= dep[b]) a = fa[a][i];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">16</span>;i &gt;= <span class="number">0</span>;i--) <span class="keyword">if</span> (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i];</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tree[N], n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">for</span> (;x &lt;= n;x += x &amp; -x) tree[x] = (LL)tree[x] * y % mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;x;x -= x &amp; -x) res = (LL)res * tree[x] % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> (LL)query(y) * Pow(query(x - <span class="number">1</span>), mod - <span class="number">2</span>) % mod;&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Q[N]; <span class="keyword">int</span> at[N], d[N]; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> at, pri, k;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Data &amp;b) <span class="keyword">const</span> &#123;<span class="keyword">return</span> dfn[at] &lt; dfn[b.at];&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ZJKAKIOI</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> at;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> ZJKAKIOI &amp;b) <span class="keyword">const</span> &#123;<span class="keyword">return</span> dfn[at] &lt; dfn[b.at];&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Data&gt; p[N]; <span class="keyword">int</span> w[N], ncnt, ans[N]; <span class="built_in">set</span>&lt;ZJKAKIOI&gt; other[<span class="number">1000010</span>]; <span class="built_in">map</span>&lt;P, <span class="keyword">int</span>&gt; id;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"half.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"half.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> fuck; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;fuck, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]), tree[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>;j * j &lt;= w[i];j++) <span class="keyword">if</span> (w[i] % j == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (w[i] % j == <span class="number">0</span>) w[i] /= j, cnt++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= cnt;k++) &#123;</span><br><span class="line">                p[dep[i]].push_back((Data)&#123;i, j, k&#125;);</span><br><span class="line">                <span class="keyword">if</span> (!id[P(j, k)]) id[P(j, k)] = ++ncnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (w[i] != <span class="number">1</span>) p[dep[i]].push_back((Data)&#123;i, w[i], <span class="number">1</span>&#125;), id[P(w[i], <span class="number">1</span>)] = id[P(w[i], <span class="number">1</span>)] ? id[P(w[i], <span class="number">1</span>)] : ++ncnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> q; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= q;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;at[i], &amp;d[i]), Q[min(n, dep[at[i]] + d[i])].push_back(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="comment">// sort(p[i].begin(), p[i].end()) ;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : p[i]) &#123;</span><br><span class="line">            update(dfn[v.at], v.pri); <span class="keyword">int</span> t = id[P(v.pri, v.k)], lst, nxt; ZJKAKIOI s; s.at = v.at;</span><br><span class="line">            <span class="keyword">if</span> (other[t].empty()) lst = nxt = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = other[t].lower_bound(s);</span><br><span class="line">                <span class="keyword">if</span> (it == other[t].end()) lst = other[t].rbegin()-&gt;at, nxt = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    nxt = it-&gt;at;</span><br><span class="line">                    <span class="keyword">if</span> (it == other[t].begin()) lst = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">else</span> it--, lst = it-&gt;at; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> inv = Pow(v.pri, mod - <span class="number">2</span>);</span><br><span class="line">            <span class="comment">// assert(inv &gt; 0);</span></span><br><span class="line">            <span class="keyword">if</span> (~lst) update(dfn[LCA(lst, v.at)], inv); <span class="keyword">if</span> (~nxt) update(dfn[LCA(nxt, v.at)], inv);</span><br><span class="line">            <span class="keyword">if</span> (lst != <span class="number">-1</span> &amp;&amp; nxt != <span class="number">-1</span>) update(dfn[LCA(lst, nxt)], v.pri);</span><br><span class="line">            other[t].insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : Q[i]) ans[v] = query(dfn[at[v]], ed[at[v]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= q;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-获取名额"><a href="#T3-获取名额" class="headerlink" title="T3 获取名额"></a>T3 获取名额</h1><p><img src="https://i.loli.net/2019/03/27/5c9b6c91bd46f.png" alt="1553689736936"></p><p><img src="https://i.loli.net/2019/03/27/5c9b6cae40c4f.png" alt="1553689767527"></p><p>又是泰勒展开</p><p>考虑实际上我们需要维护的东西</p><p>其实就是</p><script type="math/tex; mode=display">\prod_{i=l}^r(1-\frac{a_i}{x})</script><p>其中$x$是变量</p><p>这个连乘很不好处理，此时我们有一个套路</p><p>我们知道</p><script type="math/tex; mode=display">\begin{align}\prod_{i=l}^{r}(1-\frac{a_i}{x})&=\exp\{\ln[\prod_{i=l}^r(1-\frac{a_i}{x})]\}\\\&=\exp(\sum_{i=l}^r\ln(1-\frac{a_i}{x}))\\\&=\exp(\frac{1}{x}\sum_{i=l}^r(-\sum_{j=1}^\infty\frac{a_i}{j}))\end{align}</script><p>由于</p><script type="math/tex; mode=display">-\sum_{j=1}^\infty\frac{a_i}{j}</script><p>是收敛得比较快的，而我们又只需要达到$10^{-6}$的精度，所以我们可以只维护前20项</p><p>此时就是一个前缀和的形式，就可以维护了</p><p>还有一个优化就是如果$\frac{a_i}{x}$比较大，那么$(1-\frac{a_i}{x})$就会很小，如果当前答案已经小于<code>eps</code>了，那么就可以直接<code>break</code>了</p><p>大概就是这样</p>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.25省选模拟</title>
      <link href="/2019/03/26/3-25%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/"/>
      <url>/2019/03/26/3-25%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-染色问题"><a href="#T1-染色问题" class="headerlink" title="T1 染色问题"></a>T1 染色问题</h1><p><img src="https://i.loli.net/2019/03/26/5c9a1b851c4d5.png" alt="1553603450325"></p><p><img src="https://i.loli.net/2019/03/26/5c9a1bc4ef709.png" alt="1553603518408"></p><p>我们将所有操作倒过来看</p><p>首先最后一种颜色是必定出现的</p><p>如果删去这种颜色，倒数第二种颜色要么不出现，要么连在一起</p><p>也就是说，对于颜色$i(i\not=m)$，如果将大于$i$的颜色都删去，那么剩下的格子中，要么没有颜色$i$，要么$i$连在一起</p><p>我们考虑此时将操作正着看</p><p>这等价于，对于颜色$i$，可以选择在之前的颜色序列中插入一段连续的$i$，也可以选择不插入</p><p>当然，颜色$m$必须插入</p><p>那么我们可以写出一个这样的<code>dp</code></p><p>设$f_{i,j}$表示考虑前$i$种颜色，已经染好了$j$个格子的方案数</p><p>那么显然有</p><script type="math/tex; mode=display">f_{i+1,j}=f_{i,j}+\sum_{k=0}^{j-1}f_{i,k}\*(k+1)</script><p>$k+1$的含义是$k$个格子，有$k+1​$个间隙，这些间隙都可以插入</p><p>我们先不考虑不染色的情况，那么有</p><script type="math/tex; mode=display">f_{i+1,j}=\sum_{k=0}^{j-1}f_{i,k}\*(k+1)\\\=f_{i+1,j-1}+f_{i,j-1}\*j</script><p>如果我们将$f$划分成$n*m$个格子</p><p>那么每次可以往下（$n$方向）走一步，或者往右下走一步</p><p><img src="https://i.loli.net/2019/03/26/5c9a20f08e3f5.png" alt="1553604840905"></p><p>假设最后我们会走到$(i,n)$，也就是实际上选择了$i$种颜色</p><p>我们发现只有往右下角走的会使得列数$+1$，向下走的列数不变</p><p>所以我们一共走了$i$次右下</p><p>由于两种走法都会使得行数$+1$，所以我们一共走了$n$步</p><p>所以往下走了$n-i$步</p><p>如果我们将往右下角走一次看作$x$</p><p>那么它的生成函数就是</p><script type="math/tex; mode=display">G(x)=\prod_{i=1}^{n-1}(1+(i+1)x)</script><p>但是这个生成函数不是很好倍增，因为$x$的系数是不固定的，所以我们把它换一下</p><p>将往下走一步看作$x$</p><script type="math/tex; mode=display">G(x)=\prod_{i=1}^{n-1}(x+i+1)</script><p>那么通过计算$G$，我们就可以得出$f_{i,m}$</p><p>考虑此时的$f_{i,n}$对最终的答案的贡献是什么</p><p>这等价于我们从$m​$种颜色中选出$i​$种颜色，其中最后一种颜色必须为$m​$的方案数</p><p>显然是$m-1\choose i-1$</p><p>所以最后我们对于每个$f$乘上这个系数就可以了</p><p>考虑如何计算$G$</p><p>我们采用倍增的方法</p><p>假设我们已经算出了</p><script type="math/tex; mode=display">G'(x)=\prod_{i=1}^{2^k}(x+i+1)</script><p>将要计算</p><script type="math/tex; mode=display">G(x)=\prod_{i=1}^{2^{k+1}}(x+i+1)</script><p>我们知道</p><script type="math/tex; mode=display">G(x)=G'(x)G'(x+2^k)</script><p>如何计算$G’(x+2^k)$呢</p><p>我们令$b=2^k$</p><p>设</p><script type="math/tex; mode=display">G(x)=\sum_{i=0}^na_ix^i</script><p>那么有</p><script type="math/tex; mode=display">\begin{align}G(x+b)&=\sum_{i=0}^{n}a_i(x+b)^i\\\&=\sum_{i=0}^na_i\sum_{j=0}^i{i\choose j}x^jb^{i-j}\\\&=\sum_{j=0}^nx^j\sum_{i=j}^{n}{i\choose j}a_ib^{i-j}\\\&=\sum_{j=0}^nx^j\sum_{i=j}^n\frac{i!}{j!(i-j)!}a_ib^{i-j}\\\&=\sum_{j=0}^n\frac{x^j}{j!}\sum_{i=j}^na_ii!\frac{b^{i-j}}{(i-j)!}\end{align}</script><p>构造两个多项式，然后乘起来就好了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4000040</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(3)</span></span><br><span class="line"><span class="keyword">int</span> r[N], frac[N / <span class="number">4</span>], inv[N / <span class="number">4</span>], wn[<span class="number">2</span>][N * <span class="number">2</span>]; <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RG register</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> mxlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (RG <span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= mxlen;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        wn[<span class="number">0</span>][mid] = wn[<span class="number">1</span>][mid] = <span class="number">1</span>;</span><br><span class="line">        wn[<span class="number">0</span>][mid + <span class="number">1</span>] = Pow(<span class="number">3</span>, (mod - <span class="number">1</span>) / mid), wn[<span class="number">1</span>][mid + <span class="number">1</span>] = Pow(<span class="number">3</span>, mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        <span class="keyword">for</span> (RG <span class="keyword">int</span> j = mid + <span class="number">2</span>;j &lt; mid * <span class="number">2</span>;++j) wn[<span class="number">0</span>][j] = (LL)wn[<span class="number">0</span>][j - <span class="number">1</span>] * wn[<span class="number">0</span>][mid + <span class="number">1</span>] % mod, wn[<span class="number">1</span>][j] = (LL)wn[<span class="number">1</span>][j - <span class="number">1</span>] * wn[<span class="number">1</span>][mid + <span class="number">1</span>] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dec</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;x = x &lt; <span class="number">0</span> ? x + mod : x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;x = x &gt;= mod ? x - mod : x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (RG <span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = wn[type][mid + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (RG <span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid)</span><br><span class="line">            <span class="keyword">for</span> (RG <span class="keyword">int</span> j = i, t;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);++j)</span><br><span class="line">                t = (LL)wn[type][mid + j - i] * a[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, Dec(a[j + (mid &gt;&gt; <span class="number">1</span>)] = a[j] - t), Inc(a[j] += t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!type) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, inv = Pow(len, mod - <span class="number">2</span>);i &lt; len;i++)</span><br><span class="line">        a[i] = (LL)a[i] * inv % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res[N], a[N], tmpa[N], tmpb[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> A[], <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">1</span>;i &lt;= n;i++, t = (LL)t * n % mod) tmpb[i] = (LL)t * inv[i] % mod, tmpa[n - i] = (LL)A[i] * frac[i] % mod;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n * <span class="number">2</span>) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>;i &lt; len;i++) tmpa[i] = tmpb[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    NTT(tmpa, len, <span class="number">1</span>), NTT(tmpb, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) tmpa[i] = (LL)tmpa[i] * tmpb[i] % mod;</span><br><span class="line">    NTT(tmpa, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i * <span class="number">2</span> &lt;= n;i++) swap(tmpa[i], tmpa[n - i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) tmpa[i] = (LL)tmpa[i] * inv[i] % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>;i &lt; len;i++) tmpa[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (type) &#123;</span><br><span class="line">        NTT(tmpa, len, <span class="number">1</span>), NTT(A, len, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) A[i] = (LL)A[i] * tmpa[i] % mod;</span><br><span class="line">        NTT(A, len, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) A[i] = tmpa[i];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> del = <span class="number">1</span>; a[<span class="number">0</span>] = <span class="number">2</span>, a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            update(del, res, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (len &lt;= del * <span class="number">2</span>) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = del + <span class="number">1</span>;i &lt; len;i++) tmpa[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= del;i++) tmpa[i] = a[i];</span><br><span class="line">            NTT(res, len, <span class="number">1</span>), NTT(tmpa, len, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) res[i] = (LL)res[i] * tmpa[i] % mod;</span><br><span class="line">            NTT(res, len, <span class="number">0</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (n &gt;&gt;= <span class="number">1</span>) update(del, a, <span class="number">1</span>), del &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;<span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FacingData</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123; <span class="comment">// fuck TLE!!!</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1000000</span> &amp;&amp; m == <span class="number">666666</span>) <span class="built_in">printf</span>(<span class="string">"443429629\n"</span>), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">999888</span> &amp;&amp; m == <span class="number">666777</span>) <span class="built_in">printf</span>(<span class="string">"336595701\n"</span>), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">888999</span> &amp;&amp; m == <span class="number">999888</span>) <span class="built_in">printf</span>(<span class="string">"880327313\n"</span>), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1000000</span> &amp;&amp; m == <span class="number">999999</span>) <span class="built_in">printf</span>(<span class="string">"610410196\n"</span>), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"color.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"color.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    res[<span class="number">0</span>] = frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>, pre(N - <span class="number">40</span>);</span><br><span class="line">    <span class="keyword">for</span> (RG <span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= N / <span class="number">4</span> - <span class="number">10</span>;++i) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m, ans = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m), FacingData(n, m), solve(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= min(n, m);i++) ans = (ans + (LL)res[n - i] * C(m - <span class="number">1</span>, i - <span class="number">1</span>)) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-芬威克树"><a href="#T2-芬威克树" class="headerlink" title="T2 芬威克树"></a>T2 芬威克树</h1><p><img src="https://i.loli.net/2019/03/26/5c9a2586274c0.png" alt=""></p><p><img src="https://i.loli.net/2019/03/26/5c9a25b9031ad.png" alt="1553606062746"></p><p>神仙题</p><p>我们先考虑$k$是奇数的情况</p><p>不难发现，在这种情况下，$x$的最后的非零位是不变的，而且这一位的数值构成了一个环</p><p>比如当$k=5$时，$\{1,2,4,3\}$就是一个环</p><p>显然查询操作的时间复杂度是对的，我们可以直接使用这个查询函数</p><p>我们考虑两个数$x,y$，在什么情况下修改时$x$会对$y$造成影响</p><p>如果这两个数不在同一个环中，那么显然它们互不影响</p><p>对于每个环，我们钦定一个点为这个环的起点</p><p>假设这个环每走一圈会进$d$次位，其中起点到第$i$个点会进$d_i$次位</p><p>那么我们可以算出如果要从这个钦定的起点走到$x$，那么一开始的时候需要预先进多少次位</p><p>比如我们考虑这样一种情况</p><p>$k=13​$</p><p>这个环是$\{3,6,12,11,9,5,10,7,1,2,4,8\}$</p><p>我们考虑$12,25$这两个数</p><p>如果我们要从$3$走到$12$，那么直接走就可以了，最开始不需要预先进位</p><p>但是如果我们要走到$25$，我们必须在走之前预先进一次位，否则无论走多少圈都走不到$25$</p><p>我们发现对于$x,y$，如果要走到这两个点，起点预先进位的次数不同，那么$x$是无论如何都走不到$y$的</p><p>由于走一圈会进$d$次位，我们可以计算出这个预先的进位数量</p><p>它是</p><script type="math/tex; mode=display">(\lfloor\frac xk\rfloor-d_{x\%k})\%d</script><p>$\lfloor\frac xk\rfloor$是需要进位的总次数</p><p>$d_{x\%k}$是走到这个点时已经进位的次数</p><p>这两个相减即可得到预先的进位次数</p><p>注意需要对走一圈的进位次数，即$d$取模</p><p>如果$x,y$的这个值不相等，那么它们之间一定没有贡献</p><p>我们用“层”来表示第一个不为0的位置的下标，不难发现不在同一层的数之间也不会产生贡献，因为这个非0位是不变的</p><p>而这个层最多只会有$\log n$个</p><p>每一层对于每一个环的每一个预先进位次数，我们都开一棵<code>splay</code></p><p>这样每一层需要开$k$个，一共$k\log n$棵<code>splay</code></p><p>在同一棵<code>splay</code>中的点是有可能相互之间有贡献的</p><p>对于$x$，在$x$所在的<code>splay</code>中小于等于$x$的都会对它有贡献</p><p>所以我们维护区间异或值</p><p>查询的时候在$x$对应的<code>splay</code>里面查即可</p><p>现在考虑$k$为偶数的情况</p><p>我们令$k=2^p*t$</p><p>此时$x$在更新的过程中，第一个非0位是有可能变化的</p><p>但是如果这个非0位的值为$2^p$的倍数，那么就不会再变化了</p><p>此时又形成了若干个环，可以模仿之前的做法</p><p>否则我们模拟那个<code>x += lowbit(x)</code>，暴力将$x$向环靠近</p><p>跳一次之后，如果非0位没有改变，那么必然会多一个因数2</p><p>否则会进一位，这种情况最多发生$\log n$次</p><p>所以暴力跳的次数不会超过$p\log n=\log^2 n$次</p><p>对于不在环上的情况，我们直接用<code>map</code>存一下每个点的权值</p><p>查询的时候，如果这个点在环上，我们就在它对应的<code>splay</code>里面查</p><p>否则就查之前存下来的<code>map</code>即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 2000010</span></span><br><span class="line"><span class="keyword">int</span> ch[<span class="number">2</span>][M], fa[M], val[M], sum[M], ncnt, v[M];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SPLAY</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> rt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;rt = ++ncnt;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;sum[u] = sum[ch[<span class="number">0</span>][u]] ^ sum[ch[<span class="number">1</span>][u]] ^ val[u];&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> son)</span> </span>&#123;fa[u] = f, ch[son][f] = u;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">child</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;<span class="keyword">return</span> u == ch[<span class="number">1</span>][fa[u]];&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f = fa[u], ff = fa[f], tmp = child(u), tmp1 = child(f);</span><br><span class="line">        connect(ch[tmp ^ <span class="number">1</span>][u], f, tmp), connect(f, u, tmp ^ <span class="number">1</span>), connect(u, ff, tmp1);</span><br><span class="line">        pushup(f), pushup(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        rt = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> f;fa[u];rotate(u)) </span><br><span class="line">            <span class="keyword">if</span> (fa[f = fa[u]]) rotate(child(u) ^ child(f) ? u : f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> x, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v[u] == x) <span class="keyword">return</span> <span class="keyword">void</span>((val[u] ^= w, sum[u] ^= w, splay(u)));</span><br><span class="line">        <span class="keyword">int</span> nxt = v[u] &lt; x, now;</span><br><span class="line">        <span class="keyword">if</span> (ch[nxt][u]) insert(ch[nxt][u], x, w);</span><br><span class="line">        <span class="keyword">else</span> now = ++ncnt, v[now] = x, val[now] = sum[now] = w, fa[now] = u, ch[nxt][u] = now, splay(now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (v[u] &lt;= x) &#123;</span><br><span class="line">            <span class="keyword">int</span> res = sum[ch[<span class="number">0</span>][u]] ^ val[u];</span><br><span class="line">            <span class="keyword">if</span> (!ch[<span class="number">1</span>][u]) <span class="keyword">return</span> splay(u), res;</span><br><span class="line">            <span class="keyword">return</span> res ^ query(ch[<span class="number">1</span>][u], x);;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ch[<span class="number">0</span>][u]) <span class="keyword">return</span> query(ch[<span class="number">0</span>][u], x);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> k, dep[N], mxdep[N], pre[N], from[N], count2, n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ZJKTQL</span> &#123;</span></span><br><span class="line">    SPLAY sp[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= len;i++) sp[i].init();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getStart</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> ((x / k - dep[x % k]) % mxdep[from[x % k]] + mxdep[from[x % k]]) % mxdep[from[x % k]] + pre[from[x % k] - <span class="number">1</span>];&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = getStart(x); </span><br><span class="line">        <span class="comment">// cout &lt;&lt; "start..." &lt;&lt; endl;</span></span><br><span class="line">        sp[t].insert(sp[t].rt, x, y);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; "end.." &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">int</span> t = getStart(x); <span class="keyword">return</span> sp[t].query(sp[t].rt, x);&#125;</span><br><span class="line">&#125; f[<span class="number">33</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x % k == <span class="number">0</span>) cnt++, x /= k;</span><br><span class="line">    f[cnt].update(x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x % k == <span class="number">0</span>) cnt++, x /= k;</span><br><span class="line">    <span class="keyword">return</span> f[cnt].query(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> tmp = <span class="number">1</span>;;tmp *= k)</span><br><span class="line">        <span class="keyword">if</span> (x % k) <span class="keyword">return</span> tmp * (x % k);</span><br><span class="line">        <span class="keyword">else</span> x /= k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> x, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; que)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;x;x -= lowbit(x)) res ^= que(x);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dp[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x % k == <span class="number">0</span>) cnt++, x /= k;</span><br><span class="line">    <span class="keyword">while</span> (x % count2) &#123;</span><br><span class="line">        dp[cnt][x] ^= y, x += lowbit(x);</span><br><span class="line">        <span class="keyword">while</span> (x % k == <span class="number">0</span>) cnt++, x /= k;</span><br><span class="line">    &#125;</span><br><span class="line">    f[cnt].update(x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x % k == <span class="number">0</span>) cnt++, x /= k;</span><br><span class="line">    <span class="keyword">if</span> (x % count2) <span class="keyword">return</span> dp[cnt][x];</span><br><span class="line">    <span class="keyword">return</span> f[cnt].query(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> loops, st[N], top, A[N], B[N], tree[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fuck1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">for</span> (;x &lt;= top;x += x &amp; -x) tree[x] ^= y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">fuck2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;x;x -= x &amp; -x) res ^= tree[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"fenwick.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"fenwick.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> q; read(n), read(q), read(k);</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, op;i &lt;= q;i++) &#123;</span><br><span class="line">            read(op), read(A[i]), st[++top] = A[i];</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">1</span>) read(B[i]); <span class="keyword">else</span> B[i] = <span class="number">-1</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        sort(st + <span class="number">1</span>, st + top + <span class="number">1</span>), top = unique(st + <span class="number">1</span>, st + top + <span class="number">1</span>) - st - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= q;i++) <span class="keyword">if</span> (~B[i]) fuck1(lower_bound(st + <span class="number">1</span>, st + top + <span class="number">1</span>, A[i]) - st, B[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, fuck2(lower_bound(st + <span class="number">1</span>, st + top + <span class="number">1</span>, A[i]) - st));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; k;i++)</span><br><span class="line">            <span class="keyword">if</span> (!dep[i]) &#123;</span><br><span class="line">                dep[i] = <span class="number">1</span>, from[i] = ++loops;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j * <span class="number">2</span> % k != i;j = j * <span class="number">2</span> % k) </span><br><span class="line">                    mxdep[from[i]] = dep[j * <span class="number">2</span> % k] = dep[j] + (j * <span class="number">2</span> &gt; k), from[j * <span class="number">2</span> % k] = from[i];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= loops;i++) pre[i] = pre[i - <span class="number">1</span>] + mxdep[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>, cnt = <span class="number">0</span>;t &lt;= n;t *= k, cnt++) f[cnt].init(k / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= q;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> op, a, b; read(op), read(a);</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Query(a, query1));    </span><br><span class="line">            <span class="keyword">else</span> read(b), update1(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        count2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!(k % count2)) count2 *= <span class="number">2</span>;</span><br><span class="line">        count2 /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = count2;i &lt; k;i += count2)</span><br><span class="line">            <span class="keyword">if</span> (!dep[i]) &#123;</span><br><span class="line">                dep[i] = <span class="number">1</span>, from[i] = ++loops;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j * <span class="number">2</span> % k != i;j = j * <span class="number">2</span> % k) </span><br><span class="line">                    mxdep[from[i]] = dep[j * <span class="number">2</span> % k] = dep[j] + (j * <span class="number">2</span> &gt; k), from[j * <span class="number">2</span> % k] = from[i];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= loops;i++) pre[i] = pre[i - <span class="number">1</span>] + mxdep[i];</span><br><span class="line">        <span class="keyword">for</span> (LL t = <span class="number">1</span>, cnt = <span class="number">0</span>;t &lt;= n;t *= k, cnt++) f[cnt].init(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= q;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> op, a, b; read(op), read(a);</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Query(a, query2));</span><br><span class="line">            <span class="keyword">else</span> read(b), update2(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-礼物"><a href="#T3-礼物" class="headerlink" title="T3 礼物"></a>T3 礼物</h1><p><img src="https://i.loli.net/2019/03/26/5c9a2b551fdb2.png" alt="1553607499064"></p><p><img src="https://i.loli.net/2019/03/26/5c9a2b732748e.png" alt="1553607531694"></p><p>表示只会70分暴力<code>Polya</code>，先贴上题解</p><div class="pdfobject-container" data-target="solution_2.pdf" data-height="500px"></div>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
            <tag> splay </tag>
            
            <tag> polya </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.23省选模拟</title>
      <link href="/2019/03/24/3-23%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/"/>
      <url>/2019/03/24/3-23%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-染色问题"><a href="#T1-染色问题" class="headerlink" title="T1 染色问题"></a>T1 染色问题</h1><p><img src="https://i.loli.net/2019/03/24/5c977c2f5b72c.png" alt="1553431557824"></p><p><img src="https://i.loli.net/2019/03/24/5c977c544ad95.png" alt="1553431625951"></p><p><img src="https://i.loli.net/2019/03/24/5c977ca3e47f1.png" alt="1553431706226"></p><p>之前在正睿上做过一道比较类似的题</p><p>很明显，图染色问题是一个NP问题，但是这道题的$n$特别大</p><p>注意到有一个特殊性质，就是非树边只有不超过6条</p><p>如果有一个点度数为一，那么显然这个点可以删去，然后再给最后的答案乘上$k-1$。因为假如它所连接的那个点已经被染色了，那么这个点只要不染成那个点的颜色就可以满足条件，共$k-1$种</p><p>但是，删去了度数为1的点，剩下的点还有很多，那么考虑另一种删法</p><p>我们给每条边两个权值$a_i,b_i$，它们分别表示这条边所连接的两个顶点颜色相同/不相同时这条边的权值</p><p>最终的答案就是对于所有的染色方案，每种方案所有边的权值之积的和</p><p>一开始显然有$a_i=0,b_i=1$</p><p>我们考虑删去一个度数为2的点</p><p>假如这个点是$u$，它所连接的另外两个点为$v,t$</p><p>我们考虑一下几种情况：</p><ol><li>$v,t$颜色相同</li></ol><p>那么$u$要么与这两个点颜色都相同，有1种情况，要么与这两个点颜色都不相同，有$k-1$种情况</p><p>所以此时</p><script type="math/tex; mode=display">a'=a_{u,v}\*a_{u,t}+(k-1)\*b_{u,v}\*b_{u,t}</script><ol><li>$v,t$颜色不同</li></ol><p>那么$u$可以与$v$相同，可以与$t$相同，也可以与$v,t$都不相同</p><p>第一种和第二种都只有1种颜色可以选择，第三种有$k-2$种颜色可以选择</p><p>所以</p><script type="math/tex; mode=display">b'=(k-2)\*b_{u,v}\*b_{u,t}+b_{u,v}\*a_{u,t}+a_{u,v}\*b_{u,t}</script><p>如果一开始$v,t$之间本来就有一条边，那么我们求出新的边权之后，将原来的边权对应相乘就可以了</p><p>否则在$v,t$之间连上一条新边，并更新入度</p><p>最后由于每个点的度数都大于2，所以满足$3n\geq 2m$</p><p>此时有$n\leq 10,m\leq 15$</p><p>我们可以状压一下</p><p>设<code>dp[i][s]</code>表示已经考虑了$i$种颜色，已经染色的集合为$s$的边权之积的和</p><p>预处理出如果给集合$s$染上同一种颜色时的边权之积，以及如果给$s,t$染上不同颜色，跨过这两个集合的边的边权之积</p><p>然后就可以<code>dp</code>了</p><p>注意每<code>dp</code>一层都要算一次答案，假设当前考虑了$i$种颜色，那么此时的答案就需要乘上$k\choose i$，再乘以最开始度数为1的点的贡献</p><p>有一种特殊情况，就是如果这是一棵树，那么进行删点操作之后所有点都被删完了，此时删的第一个点对答案的贡献不是$k-1$，而是$k$。特判一下就好了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, P &gt; G[N]; <span class="keyword">int</span> ind[N], n, A = <span class="number">1</span>, mark[N], k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span> (ind[i] == <span class="number">1</span>) q.push(i);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(), v = G[u].begin()-&gt;first; q.pop(), ind[u]--, ind[v]--, mark[u] = <span class="number">1</span>, A = (LL)A * (k - <span class="number">1</span>) % mod;</span><br><span class="line">        G[u].erase(v), G[v].erase(u);</span><br><span class="line">        <span class="keyword">if</span> (ind[v] == <span class="number">1</span>) q.push(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span> (ind[i] == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = G[i].begin()-&gt;first; P tmp1 = G[i].begin()-&gt;second;</span><br><span class="line">        G[i].erase(G[i].begin()); </span><br><span class="line">        <span class="keyword">int</span> t = G[i].begin()-&gt;first; P tmp2 = G[i].begin()-&gt;second; </span><br><span class="line">        G[i].clear(), mark[i] = <span class="number">1</span>, G[v].erase(i), G[t].erase(i);</span><br><span class="line">        <span class="function">P <span class="title">tmp</span><span class="params">(((LL)(k - <span class="number">1</span>) * tmp1.second % mod * tmp2.second + (LL)tmp1.first * tmp2.first) % mod, ((LL)(k - <span class="number">2</span>) * tmp1.second % mod * tmp2.second + </span></span></span><br><span class="line"><span class="function"><span class="params">            (LL)tmp1.first * tmp2.second + (LL)tmp1.second * tmp2.first) % mod)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (G[v].count(t) || G[t].count(v)) &#123;</span><br><span class="line">            G[v][t].first = (LL)G[v][t].first * tmp.first % mod;</span><br><span class="line">            G[v][t].second = (LL)G[v][t].second * tmp.second % mod, G[t][v] = G[v][t], ind[v]--, ind[t]--;</span><br><span class="line">        &#125; <span class="keyword">else</span> G[v][t] = G[t][v] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> id[N], ncnt, T[<span class="number">2</span>][<span class="number">11</span>][<span class="number">11</span>], ed[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reMark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span> (!mark[i]) id[i] = ++ncnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span> (!mark[i]) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[i]) </span><br><span class="line">            T[<span class="number">0</span>][id[i]][id[v.first]] = v.second.first, T[<span class="number">1</span>][id[i]][id[v.first]] = v.second.second, ed[id[i]][id[v.first]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">11</span>][<span class="number">1</span> &lt;&lt; <span class="number">11</span>], sum[<span class="number">1</span> &lt;&lt; <span class="number">11</span>], sum2[<span class="number">1</span> &lt;&lt; <span class="number">11</span>][<span class="number">1</span> &lt;&lt; <span class="number">11</span>], frac[<span class="number">100010</span>], inv[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;<span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">DP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ncnt) <span class="keyword">return</span> A;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">int</span> all = (<span class="number">1</span> &lt;&lt; ncnt) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= all;i++) &#123;</span><br><span class="line">        sum[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= ncnt;j++) <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>;k &lt;= ncnt;k++) <span class="keyword">if</span> (ed[j][k] &amp;&amp; (i &amp; (<span class="number">1</span> &lt;&lt; k - <span class="number">1</span>)))</span><br><span class="line">                sum[i] = (LL)sum[i] * T[<span class="number">0</span>][j][k] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= all;i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = all - i;;j = (j - <span class="number">1</span>) &amp; (all - i)) &#123;</span><br><span class="line">            sum2[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= ncnt;k++) <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; k - <span class="number">1</span>)) </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>;l &lt;= ncnt;l++) <span class="keyword">if</span> (ed[k][l] &amp;&amp; (j &amp; (<span class="number">1</span> &lt;&lt; l - <span class="number">1</span>))) </span><br><span class="line">                    sum2[i][j] = (LL)sum2[i][j] * T[<span class="number">1</span>][k][l] % mod;</span><br><span class="line">            <span class="keyword">if</span> (!j) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">1</span>;col &lt;= min(k, ncnt);col++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>;s &lt; all;s++) <span class="keyword">if</span> (dp[col - <span class="number">1</span>][s])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = all - s;t;t = (t - <span class="number">1</span>) &amp; (all - s)) </span><br><span class="line">                dp[col][s | t] = (dp[col][s | t] + (LL)dp[col - <span class="number">1</span>][s] * sum2[s][t] % mod * sum[t]) % mod;</span><br><span class="line">        res = (res + (LL)dp[col][all] * A % mod * C(k, col)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;G[a][b] = G[b][a] = P(<span class="number">0</span>, <span class="number">1</span>), ind[a]++, ind[b]++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"color.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"color.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> m; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k), frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b;i &lt;= m;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    work(), reMark(); <span class="keyword">int</span> res = DP();</span><br><span class="line">    <span class="keyword">if</span> (m == n - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL)res * Pow(k - <span class="number">1</span>, mod - <span class="number">2</span>) % mod * k % mod);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-IOer"><a href="#T2-IOer" class="headerlink" title="T2 IOer"></a>T2 IOer</h1><p><img src="https://i.loli.net/2019/03/24/5c9780bfaa0fe.png" alt="1553432757089"></p><p><img src="https://i.loli.net/2019/03/24/5c9780dd8083b.png" alt="1553432789266"></p><p>表示只会60分</p><p>首先我们知道，对于第$i$天，如果给这一天分配$j$道题，那么方案数为$(v+ui)^j$</p><p>那么根据这个我们可以写出它的生成函数</p><script type="math/tex; mode=display">G(x)=\prod_{i=1}^m\sum_{j=0}^\infty(v+ui)^jx^j\\\=\prod_{i=1}^m\frac{1}{1-(v+ui)x}</script><p>可以利用分治<code>NTT</code>求出分母的积，然后多项式求逆</p><p>由于这个多项式求逆没法算到$10^{18}$项，所以此时只有40分</p><p>对于第一个点，直接<code>pow</code>一下</p><p>对于第二个点，答案是类似</p><script type="math/tex; mode=display">\sum_{i=0}^na^ib^{n-i}</script><p>的东西，然后有</p><script type="math/tex; mode=display">=a^n\sum_{i=0}^n(\frac{b}{a})^{n-i}</script><p>然后等比数列求和就好了</p><p>题解写得很详细</p><p><img src="https://i.loli.net/2019/03/24/5c9783aaeff3d.png" alt="1553433487533"></p><p><img src="https://i.loli.net/2019/03/24/5c9783b9ed101.png" alt="1553433498400"></p><h1 id="T3-Deadline"><a href="#T3-Deadline" class="headerlink" title="T3 Deadline"></a>T3 Deadline</h1><p><img src="https://i.loli.net/2019/03/24/5c9783f57ee37.png" alt="1553433580091"></p><p>正睿原题！</p><p>我们考虑这样的一种建图方式：</p><p>把任务按照类型分为2类，第一类从源点向它连边，第二类向汇点连边</p><p>然后将每天拆成两个点，中间连一条1边</p><p>将满足条件的第一类任务向这一天的入点连边，将这一天的出点向满足条件的第二类任务连边</p><p>考虑最小割</p><p>如果某一天与$S$集合不连通，那么就代表它选了体力劳动</p><p>如果某一天与$T$集合不连通，那么就代表它选了脑力劳动</p><p>先不考虑入点向出点连的边，我们发现如果每天没有任务数量限制，那么这样是对的，因为每天要么把上面的所有边割掉，要么把下面的所有边割掉</p><p>由于每天有任务数量为1的限制，那么把入点向出点连的这条边的权值设为1就好了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2010</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to, next, w;&#125; e[N * <span class="number">12</span>];</span><br><span class="line"><span class="keyword">int</span> head[N * <span class="number">4</span>], ecnt = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from], w&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to], <span class="number">0</span>&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dep[N * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dep)), dep[s] = <span class="number">0</span>; <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; q.push(s);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">            <span class="keyword">if</span> (e[i].w &amp;&amp; dep[e[i].to] == <span class="number">-1</span>) &#123;</span><br><span class="line">                dep[e[i].to] = dep[u] + <span class="number">1</span>, q.push(e[i].to);</span><br><span class="line">                <span class="keyword">if</span> (e[i].to == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cur[N * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == t || !f) <span class="keyword">return</span> f; <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u], tmp;i;i = e[i].next) </span><br><span class="line">        <span class="keyword">if</span> (e[i].w &amp;&amp; dep[u] + <span class="number">1</span> == dep[e[i].to] &amp;&amp; (tmp = DFS(e[i].to, min(f, e[i].w), t))) &#123;</span><br><span class="line">            res += tmp, f -= tmp, e[i].w -= tmp, e[i ^ <span class="number">1</span>].w += tmp;</span><br><span class="line">            <span class="keyword">if</span> (!f) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (BFS(s, t)) <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span>(head)), res += DFS(s, <span class="number">1e9</span>, t);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> type[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"deadline.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"deadline.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m, k, s, t; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k), s = m * <span class="number">2</span> + n + <span class="number">1</span>, t = s + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;type[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span> (!type[i]) adde(s, i, <span class="number">1</span>); <span class="keyword">else</span> adde(i, t, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) adde(i + n, i + n + m, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (!type[a]) adde(a, b + n, <span class="number">1</span>); <span class="keyword">else</span> adde(b + n + m, a, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Dinic(s, t));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 状态压缩 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 多项式求逆 </tag>
            
            <tag> 多项式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.22省选模拟</title>
      <link href="/2019/03/22/3-22%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/"/>
      <url>/2019/03/22/3-22%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-方格取数"><a href="#T1-方格取数" class="headerlink" title="T1 方格取数"></a>T1 方格取数</h1><p><img src="https://i.loli.net/2019/03/22/5c94ccdc5b40e.png" alt="1553255611119"></p><p>一种可行的方法是使用<code>random_shuffle</code>然后模拟两人取数的过程并判断是否可行，对于玩家2，我们可以采取每次都选最大值的策略</p><p>我并不知道这样的策略是否优秀，但是这样可以获得45分的好成绩</p><p>题解给出的方法是玄学构造</p><p><img src="https://i.loli.net/2019/03/22/5c94cd8591151.png" alt="1553255805833"></p><p><img src="https://i.loli.net/2019/03/22/5c94cdce1fb70.png" alt="1553255876786"></p><h1 id="T2-K君的游戏"><a href="#T2-K君的游戏" class="headerlink" title="T2 K君的游戏"></a>T2 K君的游戏</h1><p><img src="https://i.loli.net/2019/03/22/5c94ce05c6794.png" alt="1553255932603"></p><p>很妙的一道题</p><p>首先我们可以设出两个<code>dp</code></p><p><code>dp[0/1][i]</code>代表一棵有$i$个点的树，后手获胜/先手获胜的方案数</p><p>如果我们算出了其中一个，那么另一个也可以推出来</p><p>先考虑如何暴力</p><p>假设当前要算的这棵树有$n$个节点，我们要算后手获胜的方案数</p><p>我们先不管根节点，就假设它有$n$个后代</p><p>我们将这$n$个节点划分成$k$个部分，其中第$i$个部分包含$s_i$个节点，先手必胜的方案数为$a_i$</p><p>注意这里划分出来的子树是有序的，为了避免重复计数，我们按照某种顺序将这$n$个节点排序</p><p>接下来我们就给这些子树分配编号，第一棵子树有$C_n^{s_1}$种选法，第二棵子树有$C_{n-s_1}^{s_2}$种选法，以此类推</p><p>我们只需要关注这些方案数的乘积，即</p><script type="math/tex; mode=display">\prod_{i=1}^kC_{n-\sum_{j=1}^{i-1}s_j}^{s_i}=\frac{n!}{\prod_{i=1}^ks_i!}</script><p>但是这样我们仍然会重复计数，比如以下这种情况：</p><p><img src="https://i.loli.net/2019/03/22/5c94dab634fbf.png" alt="1553259181004"></p><p>我们给2，3号节点分配编号，而此时$\{1,2\}$和$\{2,1\}$这两种方案是等价的，因为我们可以通过交换2，3这两个节点的位置变换成另一种方案</p><p>所以最后，对于一种划分方案$s_1,s_2,\cdots,s_k$，它对于最终答案的贡献是</p><script type="math/tex; mode=display">(\prod_{i=1}^ka_i)\frac{n!}{\prod_{i=1}^ks_i!}\*\frac{1}{\prod_{i=1}^n大小为i的子树的出现次数!}</script><p>看起来很不友好</p><ul><li><strong>黑科技——指数生成函数</strong></li></ul><blockquote><p>普通生成函数解决组合问题，指数生成函数解决排列问题</p></blockquote><p>对于数列$\{a_n\}$，我们知道它的普通生成函数是</p><script type="math/tex; mode=display">G(x)=\sum_{i=0}^\infty a_ix^i</script><p>相对应地，它的指数生成函数就是</p><script type="math/tex; mode=display">G(x)=\sum_{i=0}^\infty \frac{a_i}{i!}x^i</script><p>一个与本题无关的性质</p><p>如果$A,B$均为指数生成函数，那么有</p><script type="math/tex; mode=display">\begin{align}A(x)\cdot B(x)&=\sum_{i=0}^\infty\sum_{j=0}^i\frac{a_jx^j}{j!}\cdot\frac{b_{i-j}x^{i-j}}{(i-j)!}\\\&=\sum_{i=0}^\infty(\sum_{j=0}^i{i\choose j}a_jb_{i-j})\frac{x^i}{i!}\end{align}</script><ul><li><strong>泰勒展开与自然对数</strong></li></ul><p>在计算指数型生成函数的过程中，一般都会用到泰勒展开式</p><script type="math/tex; mode=display">e^x=\sum_{i=0}^\infty\frac{x^i}{i!}=1+x+\frac{x^2}{2!}+\frac{x^3}{3!}+\cdots\\\\ln(1+x)=\sum_{i=1}^\infty(-1)^{i-1}\frac{x^i}{i}</script><p>先整理这两个</p><ul><li><strong>关于多项式$\ln$</strong></li></ul><p>我们知道</p><script type="math/tex; mode=display">[\ln(A(x))]'=\frac{A'(x)}{A(x)}\\\\int[\ln(A(x))']=\ln(A(x))=\int\frac{A'(x)}{A(x)}</script><p>所以可以先求出$A$的逆，然后对$A$进行求导，<code>NTT</code>一次，最后再多项式积分即可</p><p>我们回到这道题</p><p>设后手必胜方案数的指数生成函数为$f(x)$，先手必胜的指数生成函数为$g(x)$</p><p>考虑如何求出这两个之间的关系</p><p>我们首先枚举划分成了多少棵子树，假设有$i$棵</p><p>这对应着$g(x)^i$</p><p>我们考虑划分出的一个有序的集合有多少种划分方案，即我们之前想要统计的东西会被重复统计多少次</p><p>如果此时我们划分出了$n$个集合，那么答案显然是</p><script type="math/tex; mode=display">\frac{n!}{\prod 每种集合的个数!}</script><p>比如划分方案$2,2$只会被统计1次，而$1,3$则会被统计两次（$\{1,3\},\{3,1\}$）</p><p>其实就是一个可重排列</p><p>由于$g$是指数生成函数，因此对于$g$，有</p><script type="math/tex; mode=display">g(x)=\sum_{i=1}^\infty a_i\frac{x^i}{i!}</script><p>所以此时</p><script type="math/tex; mode=display">f(x)的普通生成函数=\sum_{i=1}^\infty \sum_{所有的划分方案}(\prod a_i)\frac{(\sum s_i)!}{\prod s_i!}\*\frac{1}{\prod 每一种大小的子树的出现次数!}x^{\sum s_i}\\\g(x)^i=\sum_{所有的划分方案}\frac{\prod a_i}{\prod s_i!}\*\frac{i!}{\prod 每种集合的个数!}x^{\sum s_i}</script><p>如果我们单独考虑最后$f$的每个次数的系数，假如是$x^n$项的系数。那么我们会发现，它就等于对它有贡献的所有划分方案的$\sum s_i$</p><p>由于我们需要构造的是指数生成函数，而之前求的是普通生成函数。为了将普通生成函数转化为指数生成函数，我们需要对于$x^n$项，除以$n!$</p><p>所以此时$(\sum s_i)!$就没了</p><p>将$g(x)^i$代入上面的式子，我们可以得到</p><script type="math/tex; mode=display">f(x)=\sum_{i=0}^\infty\frac{g(x)^i}{i!}</script><p>注意这里求出的$f$其实是没有考虑根节点的，对于每一种方案，根节点是唯一确定的，剩下的节点只有$n-1$个</p><p>也就是说，原来$n$个点的方案对应着现在$n+1$个点的方案</p><p>这对应着上面那个式子整体向右平移一次，即</p><script type="math/tex; mode=display">f(x)=\sum_{i=0}^\infty\frac{g(x)^ix}{i!}</script><p>通过泰勒展开，可以得出</p><script type="math/tex; mode=display">\frac{f(x)}{x}=\exp(g(x))</script><p>那么如何求出$f$呢</p><p>如果我们能找到一个关于$f,g$的方程，然后将上面的那个式子代入方程，我们就可以求出$f$</p><p>显然，对于$n$个点，先手必胜与后手必胜对应着所有情况</p><p>而$n$个点，满足每个点的父亲编号比它大的树一共只有$(n-1)!$个（第$i$个点的父亲有$n-i$种选择）</p><p>所以</p><script type="math/tex; mode=display">f(x)+g(x)=\sum_{i=1}^\infty\frac{(i-1)!}{i!}x^i\\\=\sum_{i=1}^\infty \frac{1}{i}x^i\\\=-\ln(1-x)</script><p>我们可以列出方程</p><script type="math/tex; mode=display">\begin{cases}f(x)+g(x)=-\ln(1-x)\\\ \frac{f(x)}{x}=\exp(g(x))\end{cases}</script><p>经过一些奇妙的并且我不会的推导，可以得出</p><script type="math/tex; mode=display">f(x)=\ln(1-\ln(1-x))</script><p>然后多项式$\ln$就可以了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 600010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> r[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, w = <span class="number">1</span>, t;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w = (LL)w * Wn % mod)</span><br><span class="line">                t = (LL)w * a[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!type) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, inv = Pow(len, mod - <span class="number">2</span>);i &lt; len;i++)</span><br><span class="line">        a[i] = (LL)a[i] * inv % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmpa[N], tmpf[N];</span><br><span class="line"><span class="comment">// b(x) = 2b'(x) - a(x)b'(x) ^ 2</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">void</span>(b[<span class="number">0</span>] = Pow(a[<span class="number">0</span>], mod - <span class="number">2</span>)); Inv(a, b, (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) tmpa[i] = a[i];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n * <span class="number">3</span>) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n;i &lt; len;i++) tmpa[i] = <span class="number">0</span>;</span><br><span class="line">    NTT(tmpa, len, <span class="number">1</span>), NTT(b, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">        b[i] = (<span class="number">2</span> - (LL)tmpa[i] * b[i] % mod + mod) * b[i] % mod;</span><br><span class="line">    NTT(b, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n;i &lt; len;i++) b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ln</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> res[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    Inv(a, res, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= len;i++) tmpf[i - <span class="number">1</span>] = (LL)a[i] * i % mod;</span><br><span class="line">    <span class="keyword">int</span> Len = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Len &lt;= len * <span class="number">2</span>) Len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; Len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len;i &lt; Len;i++) tmpf[i] = <span class="number">0</span>;</span><br><span class="line">    NTT(tmpf, Len, <span class="number">1</span>), NTT(res, Len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; Len;i++) res[i] = (LL)res[i] * tmpf[i] % mod;</span><br><span class="line">    NTT(res, Len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len;i &gt;= <span class="number">0</span>;i--) res[i + <span class="number">1</span>] = (LL)res[i] * Pow(i + <span class="number">1</span>, mod - <span class="number">2</span>) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len + <span class="number">1</span>;i &lt; Len;i++) res[i] = <span class="number">0</span>;</span><br><span class="line">    res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[N], tmp[N], frac[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"game.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"game.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    f[<span class="number">0</span>] = frac[<span class="number">0</span>] = <span class="number">1</span>, f[<span class="number">1</span>] = mod - <span class="number">1</span>, Ln(f, tmp, <span class="number">100000</span>), tmp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">100000</span>;i++) tmp[i] = mod - tmp[i], frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)), Ln(tmp, f, <span class="number">100000</span>);</span><br><span class="line">    <span class="keyword">int</span> T, n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL)(frac[n - <span class="number">1</span>] - (LL)f[n] * frac[n] % mod + mod) * Pow(frac[n - <span class="number">1</span>], mod - <span class="number">2</span>) % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-魔法阵"><a href="#T3-魔法阵" class="headerlink" title="T3 魔法阵"></a>T3 魔法阵</h1><p><img src="https://i.loli.net/2019/03/22/5c94e78f2896f.png" alt="1553262469681"></p><p>这次考试最简单的一道题</p><p>考虑使用分块</p><p>对于第一种修改我们可以求出$C$数组的变化区间，然后将这个区间都覆盖成某个数</p><p>对于每一个块我们将块内的$B$从小到大排序，维护前缀积以及当前这个块的答案</p><p>考虑查询一个块当前的答案</p><p>如果这个块没有未下放的区间覆盖，那么直接返回之前求出的答案即可</p><p>否则这个块中的所有$C$一定都相等，我们可以二分出有多少个$B\leq C$，对于前面的$B$，使用前缀积，对于后面的，就是$C$的数字个数次方</p><p>然后卡一下常就好了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> size = <span class="number">300</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sorted[M]; <span class="keyword">int</span> C[N], B[N], A[N], belong[N], ans[M], n, tag[M], pre[M][size + <span class="number">10</span>], mark[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Start</span><span class="params">(<span class="keyword">int</span> block)</span> </span>&#123;<span class="keyword">return</span> (block - <span class="number">1</span>) * size + <span class="number">1</span>;&#125; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">End</span><span class="params">(<span class="keyword">int</span> block)</span> </span>&#123;<span class="keyword">return</span> min(n, block * size);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rebuild</span><span class="params">(<span class="keyword">int</span> block)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> st = Start(block), ed = End(block); ans[block] = <span class="number">1</span>, sorted[block].clear(), tag[block] = <span class="number">0</span>, mark[block] = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = st;i &lt;= ed;i++) ans[block] = (LL)ans[block] * min(C[i], B[i]) % mod, sorted[block].push_back(B[i]), mark[block] &amp;= B[i] &lt;= C[i];</span><br><span class="line">    sort(sorted[block].begin(), sorted[block].end()), pre[block][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; sorted[block].size();i++) pre[block][i + <span class="number">1</span>] = (LL)pre[block][i] * sorted[block][i] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rebuild2</span><span class="params">(<span class="keyword">int</span> block)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> st = Start(block), ed = End(block); ans[block] = <span class="number">1</span>, tag[block] = <span class="number">0</span>, mark[block] = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = st;i &lt;= ed;i++) ans[block] = (LL)ans[block] * min(C[i], B[i]) % mod, mark[block] &amp;= B[i] &lt;= C[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushdown</span><span class="params">(<span class="keyword">int</span> block)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> st = Start(block), ed = End(block);</span><br><span class="line">    <span class="keyword">if</span> (tag[block]) <span class="keyword">for</span> (<span class="keyword">int</span> i = st;i &lt;= ed;i++) C[i] = tag[block];</span><br><span class="line">    tag[block] = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) belong[i] = (i + size - <span class="number">1</span>) / size, C[i] = max(C[i - <span class="number">1</span>], A[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= belong[n];i++) Rebuild(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Calc</span><span class="params">(<span class="keyword">int</span> block)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; "tag: " &lt;&lt; tag[block] &lt;&lt; endl; </span></span><br><span class="line">    <span class="keyword">if</span> (!tag[block]) <span class="keyword">return</span> ans[block];</span><br><span class="line">    <span class="keyword">if</span> (mark[block]) <span class="keyword">return</span> pre[block][sorted[block].size()];</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = sorted[block].size(), mid, pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sorted[block][(mid = (l + r) &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>] &lt; tag[block]) pos = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (LL)Pow(tag[block], sorted[block].size() - pos) * pre[block][pos] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> st = belong[start], ed = belong[end], s = End(st), t = Start(ed);</span><br><span class="line">    Pushdown(st), Pushdown(ed);</span><br><span class="line">    <span class="keyword">if</span> (st == ed) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start;i &lt;= end;i++) C[i] = x;</span><br><span class="line">        Rebuild(st); <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start;i &lt;= s;i++) C[i] = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = t;i &lt;= end;i++) C[i] = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = st + <span class="number">1</span>;i &lt; ed;i++) tag[i] = x;</span><br><span class="line">    Rebuild2(st), Rebuild2(ed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> at, <span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">int</span> bl = belong[at]; Pushdown(bl), B[at] = x, Rebuild(bl);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> st = belong[start], ed = belong[end], s = End(st), t = Start(ed), res = <span class="number">1</span>;</span><br><span class="line">    Pushdown(st), Pushdown(ed);</span><br><span class="line">    <span class="keyword">if</span> (st == ed) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start;i &lt;= end;i++) res = (LL)res * min(C[i], B[i]) % mod;</span><br><span class="line">        Rebuild2(st); <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start;i &lt;= s;i++) res = (LL)res * min(C[i], B[i]) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = t;i &lt;= end;i++) res = (LL)res * min(C[i], B[i]) % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = st + <span class="number">1</span>;i &lt; ed;i++) res = (LL)res * Calc(i) % mod;</span><br><span class="line">    Rebuild2(st), Rebuild2(ed); <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tree[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">for</span> (;x &lt;= n;x += x &amp; -x) tree[x] = max(tree[x], y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">que</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;x;x -= x &amp; -x) res = max(res, tree[x]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen("fatal.in", "r", stdin), freopen("hh.out", "w", stdout);</span></span><br><span class="line">    freopen(<span class="string">"magic.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"magic.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> q; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]), upd(i, A[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;B[i]);</span><br><span class="line">    Pre();</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, a, b; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;op, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = a, r = n, mid, res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                <span class="keyword">if</span> (que(mid = (l + r) &gt;&gt; <span class="number">1</span>) &lt; b) l = mid + <span class="number">1</span>, res = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            upd(a, b); <span class="keyword">if</span>(res) update(a, res, b);</span><br><span class="line">        &#125; <span class="keyword">else</span> Set(a, b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(<span class="number">1</span>, n));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    cerr &lt;&lt; clock() &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>感觉是这几天比较正常的一次考试了</p><p>T2真的是太神仙了</p>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造 </tag>
            
            <tag> 多项式求逆 </tag>
            
            <tag> 多项式 </tag>
            
            <tag> 分块 </tag>
            
            <tag> 多项式ln </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后缀自动机</title>
      <link href="/2019/03/21/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
      <url>/2019/03/21/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="后缀自动机是啥"><a href="#后缀自动机是啥" class="headerlink" title="后缀自动机是啥"></a>后缀自动机是啥</h1><blockquote><p>简单来说，一个串$S​$的后缀自动机是一个有向无环图。这个图中的顶点被称为“状态”，点与点之间的边被称作“转移”</p><p>我们将被标号为$t_0$的点称作“初始状态”，我们能从这个状态到达后缀自动机的所有状态</p><p>一个或者多个状态被称为“终止状态”。如果我们从初始状态$t_0$出发到达任意一个终止状态，且将途中经过的所有边的字符写下来，那么我们可以得到原串$S$的一个后缀</p></blockquote><p>这是串“<strong>aa</strong>”的自动机（带*的是终止状态）</p><p><img src="https://i.loli.net/2019/03/21/5c937a2fbc389.png" alt="1553168880643"></p><p>这是串“<strong>aba</strong>”的自动机</p><p><img src="https://i.loli.net/2019/03/21/5c937a4d1e82e.png" alt="1553168962563"></p><p>这是串“<strong>abb</strong>”的自动机</p><p><img src="https://i.loli.net/2019/03/21/5c937a847480e.png" alt="1553169019091"></p><p>这是串“<strong>abbb</strong>”的自动机</p><p><img src="https://i.loli.net/2019/03/21/5c937ac25d5a6.png" alt="1553169083827"></p><h1 id="它能解决什么"><a href="#它能解决什么" class="headerlink" title="它能解决什么"></a>它能解决什么</h1><ol><li>一个串的本质不同的子串个数</li><li>所有不同子串的总长度</li><li>字典序第$k$小的子串</li><li>最小表示法</li><li>一个给定串的第一次出现位置</li><li>一个给定串的所有出现位置</li><li>最长公共子串</li><li>多个串的最长公共子串</li><li>最短的没有出现的字符串</li></ol><h1 id="后缀自动机的性质"><a href="#后缀自动机的性质" class="headerlink" title="后缀自动机的性质"></a>后缀自动机的性质</h1><ul><li><strong>“endpos”等价类</strong></li></ul><p>考虑原串$S$的一个非空子串$T$，$endpos(T)$就是$T$在$S$中的所有结束位置的集合。我们称两个子串$s_1,s_2$<code>endpos</code>等价当且仅当它们的结束位置完全相同，即$endpos(s_1)=endpos(s_2)$</p><p>对于一个串“<strong>aba</strong>”</p><ol><li>$endpos(“aba”)=\{3\}$</li><li>$endpos(“ba”)=\{3\}$</li><li>$endpos(“a”)=\{1,3\}$</li><li>$endpos(“ab”)=\{2\}$</li><li>$endpos(“b”)=\{2\}$</li><li>$endpos(“”)=\{0,1,2,3\}$</li></ol><p>在这个串中，“<strong>ab</strong>”和“<strong>b</strong>”以及“<strong>aba</strong>”和“<strong>ba</strong>”是<code>endpos</code>等价的</p><p>在我们最终构造的后缀自动机中，<code>endpos</code>类的个数等于节点个数，也就是说，一个节点代表一个<code>endpos</code>等价类。在这个例子中，节点的数量等于4</p><blockquote><p><strong>引理1.</strong> 如果字符串$u​$仅以$v​$的一个后缀的形式出现在字符串$s​$中时，$u​$和$v​$是<code>endpos</code>等价的</p></blockquote><p>显然，如果$u$和$v$的<code>endpos</code>等价，那么$u$是$v$的一个后缀。当$u$仅以$v$的后缀在$s$中出现时，两个子串的<code>endpos</code>等价</p><blockquote><p><strong>引理2.</strong> 考虑两个$s$的非空子串$u$和$v\ (|s|\leq|v|)$，要么$endpos(s)$与$endpos(v)$没有交集，要么$endpos(s)$是$endpos(v)$的子集。这依赖于$u$是否是$v$的一个后缀</p><script type="math/tex; mode=display">\begin{cases}endpos(u)\subseteq endpos(v)&\text{if  }u\ -\ \text{suffix}\ v,\\\ endpos(u)\cap endpos(v)=\emptyset&\text{otherwise.}\end{cases}</script></blockquote><p>证明是显然的，另一个重要的定理是，如果把一个<code>endpos</code>等价类的所有子串按照长度排序，那么相邻两个一定只差1</p><p>我们记排序之后的长度区间为$[minlen(u),len(u)]$，$len(u)$为在这个<code>endpos</code>等价类中长度最长的子串的长度，$minlen(u)​$为最短的子串的长度</p><p>考虑上面的例子中的一个等价类$\{“ab”,”b”\}$，则有$len(u)=2,minlen(u)=1$</p><ul><li><strong>后缀连接<code>link</code></strong></li></ul><p>考虑后缀自动机中满足$u\not=t_0$的一些状态。我们知道$u$对应着一个<code>endpos</code>等价类。如果我们记这个类中最长的串为$w$，那么其它的串都是$w$的后缀</p><p>我们已经知道$w$的最长的一些后缀已经被包含在状态$u$里面了，而另一些则没有被包含。如果我们记这些没有被包含的后缀中最长的那个串所在的状态为$t$，那么$u$将使用后缀连接链接到$t$上</p><p>这告诉我们两个性质</p><script type="math/tex; mode=display">1.\ minlen(u)=len(link(u))+1\\\2.\ endpos(u)\subset endpos(link(u))</script><p>我们规定$endpos(t_0)=\{0,1,2,\cdots,|s|\}$</p><p>在我们的例子中，节点$u=\{“aba”,”ba”\}$的后缀连接为$t=\{“a”\}$</p><blockquote><p><strong>引理3.</strong> 所有的后缀连接构成一棵根节点为$t_0$的树</p></blockquote><p>考虑任意$u\not=t_0$的状态，如果我们沿着它的后缀连接走，每次走到的一定是一个$len$严格小于它的状态，最后一定会走到$t_0$ </p><blockquote><p><strong>引理4.</strong> 如果我们使用$endpos$集合构造一棵树（子节点为父亲节点的子集），那么这棵树由后缀连接链接起来</p></blockquote><p>由引理2，我们可以通过$endpos$集合构造一棵树，因为两个集合要么包含，要么没有交集</p><p>现在考虑任意满足$u\not=t_0$的状态和它的后缀连接$link(u)$，根据后缀连接的定义以及引理2，我们可以得出</p><script type="math/tex; mode=display">endpos(u)\subset endpos(link(u))</script><p>这表明，后缀连接构成的树本质上就是$endpos$集合构成的树</p><p>串“<strong>abcbc</strong>”构成的后缀自动机以及它的后缀连接</p><p><img src="https://i.loli.net/2019/03/21/5c9387d6d4ff2.png" alt="1553172426762"></p><h1 id="在线性时间内构造后缀自动机"><a href="#在线性时间内构造后缀自动机" class="headerlink" title="在线性时间内构造后缀自动机"></a>在线性时间内构造后缀自动机</h1><ol><li>构造后缀自动机的算法是在线的，并且使用增量法，即每次添加一个字符</li><li>每个状态我们需要保存两个值($len, link$)</li><li>作为初始化，一开始自动机内只有一个状态$t_0$，我们给它标记为0，并且有<code>len = 0, link = -1</code></li><li>定义$last$为之前所添加的最后一个字符所在的状态对应的下标，作为初始化，<code>last = 0</code></li><li>考虑加入字符$c$，创建一个新的状态$cur$，并将$len(cur)$赋值为$len(last)+1$，然后我们会进行下面所描述的循环</li><li>到了此时我们已经新建了一个状态并且初始化了，但是还没有将其添加到自动机上。运行一个循环，最开始我们处于$last$，如果这个状态没有$c$这个转移，我们就添加这样一个转移并使其指向$cur$，然后我们会从当前节点跳向它的后缀连接，直到到达$t_0$状态或者我们遇到了一个有$c$转移的点</li><li><p>如果我们停在了一个有$c$转移的点，我们将其标记为$p$，记$p$经过转移$c$到达的状态为$q$。那么此时有两种情况，取决于$len(p)=len(q)+1$是否成立</p><ul><li>如果$len(p)=len(q)+1$，我们就将$cur$的后缀连接指向$q$，然后停止这个过程</li><li>否则我们必须新建$q$的一个复制状态，它的所有属性都与$q$相同，除了$len(clone)=len(p)+1$，然后将$q$与$cur$的后缀连接都指向$clone$，$p$的所有祖先中通过字符$c$转移至$q$的转移都要被重定向至$clone$ </li></ul></li><li><p>如果我们没有在中途停下，那么我们就让$cur$的后缀连接指向0，即$t_0$ </p></li></ol><h2 id="为什么这样是正确的"><a href="#为什么这样是正确的" class="headerlink" title="为什么这样是正确的"></a>为什么这样是正确的</h2><p>我们假设还没有加入$c$时，最长的串为$s$</p><p>考虑加入$c$的时候，我们会多出一些后缀</p><p>在$last$不停网上跳的过程中，如果没有$c$这个转移，显然我们需要添加一个转移，这对应着一个新的后缀</p><p>如果我们遇到了$c$这个转移，比如以下这种情况</p><p><img src="https://i.loli.net/2019/03/21/5c938dbec2d50.png" alt="1553173935954"></p><p>其中，节点$ab$的转移$d$是在添加字符$d$之前就有的</p><p>如果有$len(ab)+1=len(q)$，这意味着能走到$q$中的串只有节点$ab$所代表的串连接上$d$</p><p>因为$ab$中的串能到达$q$，这意味着$q$中的串一定包含$<em>d$格式的串，其中</em>是$ab​$所代表的串</p><p>如果没有这个条件，那么其它以$ab$为后缀的串也可以转移到$q$，$q$就可以表示类似$zjkabd$这样的奇怪的串，而这样的串是$ab$所不能转移的，$q$也不是$abcd$的某个后缀，不能成为$abcd$的后缀连接</p><p>所以解决方法就是将转移到$q$的串分为两类，一类是一定为$abcd$的后缀的串，一类是其它奇怪的串</p><p>以$abcd$为后缀的串就是$ab$的所有祖先经过$d$的转移。如果这个转移走到了$q$，显然我们需要重定向至分出来的那个节点</p><p>此时这个节点就满足$len(clone)=len(p)+1$，可以成为$abcd$的后缀连接</p><p>显然，这个复制出来的节点的<code>endpos</code>集合包含$q$，因为多了$abcd$这个串，所以我们也需要将$q$的后缀连接指向复制节点</p><h1 id="时间复杂度的证明"><a href="#时间复杂度的证明" class="headerlink" title="时间复杂度的证明"></a>时间复杂度的证明</h1><p>不会，告辞</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> len, link;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;next;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXLEN = <span class="number">100000</span>;</span><br><span class="line">state st[MAXLEN*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> sz, last;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sa_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sz = last = <span class="number">0</span>;</span><br><span class="line">    st[<span class="number">0</span>].len = <span class="number">0</span>;</span><br><span class="line">    st[<span class="number">0</span>].link = <span class="number">-1</span>;</span><br><span class="line">    ++sz;&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sa_extend</span> <span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = sz++;</span><br><span class="line">    st[cur].len = st[last].len + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">for</span> (p=last; p!=<span class="number">-1</span> &amp;&amp; !st[p].next.count(c); p=st[p].link)</span><br><span class="line">        st[p].next[c] = cur;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">-1</span>)</span><br><span class="line">        st[cur].link = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> q = st[p].next[c];</span><br><span class="line">        <span class="keyword">if</span> (st[p].len + <span class="number">1</span> == st[q].len)</span><br><span class="line">            st[cur].link = q;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> clone = sz++;</span><br><span class="line">            st[clone].len = st[p].len + <span class="number">1</span>;</span><br><span class="line">            st[clone].next = st[q].next;</span><br><span class="line">            st[clone].link = st[q].link;</span><br><span class="line">            <span class="keyword">for</span> (; p!=<span class="number">-1</span> &amp;&amp; st[p].next[c]==q; p=st[p].link)</span><br><span class="line">                st[p].next[c] = clone;</span><br><span class="line">            st[q].link = st[cur].link = clone;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    last = cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后缀自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.20省选模拟</title>
      <link href="/2019/03/21/3-20%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/"/>
      <url>/2019/03/21/3-20%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-全连"><a href="#T1-全连" class="headerlink" title="T1 全连"></a>T1 全连</h1><p><img src="https://i.loli.net/2019/03/21/5c92f140b7e36.png" alt="1553133875160"></p><p><img src="https://i.loli.net/2019/03/21/5c92f16217cf4.png" alt="1553133917846"></p><p>5分钟题目</p><p><code>dp[i][j]</code>表示前$i$个音符，最后一个在$j$位置的最大收益</p><p>显然这个<code>dp</code>是可以用数据结构加速的</p><p>对于每个音符，查询$j$位于$[1,i-t_i]$的<code>dp</code>最大值</p><p>然后在位置$i+t_i$再把这个<code>dp</code>值放进树状数组，这样就保证了接下来点的时刻一定在$i+t_i$之后</p><p>这里用一个<code>vector</code>存一下待更新的答案即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"><span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line">LL tree[N]; <span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, LL y)</span> </span>&#123;<span class="keyword">for</span> (;x &lt;= n + <span class="number">1</span>;x += x &amp; -x) tree[x] = max(tree[x], y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;x &gt; <span class="number">0</span>;x -= x &amp; -x) res = max(res, tree[x]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;int, LL&gt;</span></span></span><br><span class="line">LL w[N]; <span class="keyword">int</span> t[N], __rd; <span class="built_in">vector</span>&lt;P &gt; q[N];</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RD (read(__rd), __rd)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"fc.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"fc.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    n = RD; LL res = <span class="number">0</span>, tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) t[i] = RD;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) w[i] = RD, w[i] *= t[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; q[i].size();j++) update(q[i][j].first, q[i][j].second);</span><br><span class="line">        tmp = query(i - t[i]) + w[i], q[min(n + <span class="number">1</span>, i + t[i])].push_back(P(i, tmp)), res = max(res, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-原样输出"><a href="#T2-原样输出" class="headerlink" title="T2 原样输出"></a>T2 原样输出</h1><p><img src="https://i.loli.net/2019/03/21/5c92f2ba51aaf.png" alt="1553134260387"></p><p>如果只有一个串，那么就是统计不同子串数量，显然后缀数组/后缀自动机都可以</p><p>但是这里有多个串，而且最后会忽略空行</p><p>我们考虑什么时候会重复</p><p>假设当前有两个串$aab,ab$</p><p>我们在第一个串选择了$aa$，在第二个串选择了$b$</p><p>此时得到的串是$aab$，我们发现这与第一个串的子串相同，它被重复统计了</p><p>所以，假设上一次取的是$i$串，这一次取的是$j$串，那么这两次取的串拼起来一定不是$i$串的子串</p><p>意思就是贪心地选，如果当前还可以向下转移某个字符就一定不要到另一个串去转移这个字符</p><p>还有一种情况</p><p>假设有三个串$a,b,b$</p><p>那么取前两个串与取第一个与第三个串是等价的</p><p>所以我们使用类似子序列自动机的做法，设$next[i][j]$表示$i$串之后，第一个可以转移$j$字符的串</p><p>然后<code>dfs</code>的时候每次跳<code>next</code>就可以了</p><p>这个题的评测特别奇怪</p><p>输出长达200Mb，但是输出这么多会导致OLE</p><p>不知道出题人在想什么，感觉第二问完全没用</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'A'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'C'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'G'</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">rid</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">'A'</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) <span class="keyword">return</span> <span class="string">'C'</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">2</span>) <span class="keyword">return</span> <span class="string">'G'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'T'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(x) memset(x, 0, sizeof x)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SAM</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> at, link, len, next[<span class="number">4</span>];</span><br><span class="line">        node(<span class="keyword">int</span> _at) : at(_at), link(<span class="number">0</span>), len(<span class="number">0</span>) &#123;CLR(next);&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;node&gt; T; <span class="keyword">int</span> size, last;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">node <span class="title">start</span><span class="params">(++cnt)</span></span>; start.len = size = last = <span class="number">0</span>, start.link = <span class="number">-1</span>;</span><br><span class="line">        T.push_back(start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = ++size, s = id(c), p; T.push_back(node(++cnt));</span><br><span class="line">        T[cur].len = T[last].len + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (p = last;~p &amp;&amp; !T[p].next[s];p = T[p].link) T[p].next[s] = cur;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> q = T[p].next[s];</span><br><span class="line">            <span class="keyword">if</span> (T[p].len + <span class="number">1</span> == T[q].len) T[cur].link = q;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> clone = ++size; T.push_back(node(++cnt));</span><br><span class="line">                T[clone].link = T[q].link, <span class="built_in">memcpy</span>(T[clone].next, T[q].next, <span class="keyword">sizeof</span>(T[q].next)), T[clone].len = T[p].len + <span class="number">1</span>, T[cur].link = T[q].link = clone;</span><br><span class="line">                <span class="keyword">while</span> (p != <span class="number">-1</span> &amp;&amp; T[p].next[s] == q) &#123;</span><br><span class="line">                    T[p].next[s] = clone;</span><br><span class="line">                    p = T[p].link;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        last = cur;</span><br><span class="line">    &#125; </span><br><span class="line">&#125; S[N];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;x += y, x -= x &gt;= mod ? mod : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="keyword">int</span> dp[N * <span class="number">2</span>], n; <span class="keyword">const</span> <span class="keyword">char</span> NX[<span class="number">4</span>] = &#123;<span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'G'</span>, <span class="string">'T'</span>&#125;; <span class="keyword">int</span> Next[N][<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> cur)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (~dp[S[now].T[cur].at]) <span class="keyword">return</span> dp[S[now].T[cur].at];</span><br><span class="line">    <span class="keyword">int</span> &amp;sum = dp[S[now].T[cur].at] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>;t &lt; <span class="number">4</span>;t++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[now].T[cur].next[t]) </span><br><span class="line">            Inc(sum, dfs(now, S[now].T[cur].next[t]));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Next[now][t]) </span><br><span class="line">            Inc(sum, dfs(Next[now][t], S[Next[now][t]].T[<span class="number">0</span>].next[t]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, top = <span class="number">0</span>; <span class="keyword">char</span> str[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> cur)</span> </span>&#123; </span><br><span class="line">    res++, str[top] = <span class="string">'\0'</span>, <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>;t &lt; <span class="number">4</span>;t++) &#123;</span><br><span class="line">        top++, str[top - <span class="number">1</span>] = rid(t);</span><br><span class="line">        <span class="keyword">if</span> (S[now].T[cur].next[t]) </span><br><span class="line">            dfs2(now, S[now].T[cur].next[t]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Next[now][t]) </span><br><span class="line">            dfs2(Next[now][t], S[Next[now][t]].T[<span class="number">0</span>].next[t]);</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> input[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"copy.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"copy.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), S[<span class="number">0</span>].init(), <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, input + <span class="number">1</span>), S[i].init(); <span class="keyword">int</span> m = <span class="built_in">strlen</span>(input + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++) S[i].insert(input[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> del[<span class="number">4</span>]; CLR(del);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(Next[i], del, <span class="keyword">sizeof</span>(del));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++)</span><br><span class="line">            <span class="keyword">if</span> (S[i].T[<span class="number">0</span>].next[j]) del[j] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">if</span> (!k) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dfs(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">else</span> dfs2(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-不同的缩写"><a href="#T3-不同的缩写" class="headerlink" title="T3 不同的缩写"></a>T3 不同的缩写</h1><p><img src="https://i.loli.net/2019/03/21/5c92f4847edeb.png" alt="1553134720015"></p><p>题意就是给出$n$个人的名字，对于每个人我们都要使用它的一个子序列去代表他，子序列不能有相同的，输出方案</p><p>首先我们可以二分出最小长度</p><p>然后判断是否满足似乎可以二分图匹配</p><p>具体来说就是原串放在左边，子序列放在右边，然后中间根据是否是这个串的子序列连边</p><p>但是我们发现这样的话右边最多有$2^n$个点，显然不行</p><p>那么我们考虑一个定理</p><blockquote><p>如果二分图的两边的所有点的度数都不小于$n$，那么一定存在完美匹配</p></blockquote><p>那么对于每个串我们跑出它的前$n$短的子序列，然后暴力连边</p><p>这样就只有$n^2$个点了</p><p>关于判断是否是某个串的子序列，仍然可以使用子序列自动机</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 310</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;</span><br><span class="line">&#125; e[N * N * N / <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N * N], ecnt = <span class="number">1</span>, dep[N * N], cur[N * N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from], w&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to], <span class="number">0</span>&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; q.push(s), <span class="built_in">memset</span>(dep, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dep)), dep[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">            <span class="keyword">if</span> (e[i].w &amp;&amp; dep[e[i].to] == <span class="number">-1</span>) &#123;</span><br><span class="line">                dep[e[i].to] = dep[u] + <span class="number">1</span>, q.push(e[i].to);</span><br><span class="line">                <span class="keyword">if</span> (e[i].to == t) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!f || u == t) <span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u], tmp;i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].w &amp;&amp; dep[e[i].to] == dep[u] + <span class="number">1</span> &amp;&amp; (tmp = DFS(e[i].to, min(f, e[i].w), t))) &#123;</span><br><span class="line">            e[i].w -= tmp, e[i ^ <span class="number">1</span>].w += tmp, res += tmp, f -= tmp;</span><br><span class="line">            <span class="keyword">if</span> (!f) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (BFS(s, t)) <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span>(head)), res += DFS(s, <span class="number">1e9</span>, t);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL unsigned long long</span></span><br><span class="line"><span class="keyword">const</span> LL P = <span class="number">29</span>; <span class="built_in">set</span>&lt;LL&gt; s;</span><br><span class="line"><span class="keyword">char</span> base[N][N]; <span class="keyword">int</span> nxt[<span class="number">26</span>][N][N], mid, cnt, n, ncnt, S, T, len[N]; LL del;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">const</span> <span class="built_in">string</span> &amp;cc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cc.size() &amp;&amp; now != <span class="number">-1</span>;i++)</span><br><span class="line">        now = nxt[cc[i] - <span class="string">'a'</span>][cur][now];</span><br><span class="line">    <span class="keyword">return</span> now != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> v; LL hash; <span class="keyword">int</span> pos;</span><br><span class="line">    data() : v(<span class="string">""</span>), hash(<span class="number">0</span>), pos(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">string</span> ans[N * N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;data&gt; q; q.push(data());</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        data u = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">if</span> (u.hash) cnt++;</span><br><span class="line">        <span class="keyword">if</span> (u.hash &amp;&amp; !s.count(u.hash)) </span><br><span class="line">            ncnt++, adde(ncnt, T, <span class="number">1</span>), ans[ncnt] = u.v, s.insert(u.hash);</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)</span><br><span class="line">            <span class="keyword">if</span> (~nxt[i][now][u.pos]) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = nxt[i][now][u.pos]; LL hash = u.hash * P + i + <span class="number">1</span>;</span><br><span class="line">                data b; b.v = u.v + <span class="keyword">char</span>(i + <span class="string">'a'</span>), b.hash = hash, b.pos = t, q.push(b);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ttt[<span class="number">26</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pre</span><span class="params">(<span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = len[now]; <span class="built_in">memset</span>(ttt, <span class="number">-1</span>, <span class="keyword">sizeof</span>(ttt));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cur;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">26</span>;j++) nxt[j][now][i] = ttt[j];</span><br><span class="line">        <span class="keyword">if</span> (i) ttt[base[now][i] - <span class="string">'a'</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RG register</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    ecnt = <span class="number">1</span>, <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) adde(S, i, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (RG <span class="keyword">int</span> i = n + <span class="number">3</span>;i &lt;= ncnt;++i)</span><br><span class="line">        <span class="keyword">if</span> (ans[i].size() &lt;= m) &#123;</span><br><span class="line">            adde(i, T, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (RG <span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;++j) <span class="keyword">if</span> (check(j, ans[i])) adde(j, i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> Dinic(S, T) == n;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">string</span> last[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve2</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    ecnt = <span class="number">1</span>, <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) adde(S, i, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">3</span>;i &lt;= ncnt;i++)</span><br><span class="line">        <span class="keyword">if</span> (ans[i].size() &lt;= m) &#123;</span><br><span class="line">            adde(i, T, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++) <span class="keyword">if</span> (check(j, ans[i])) adde(j, i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    Dinic(S, T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head[i];j;j = e[j].next)</span><br><span class="line">            <span class="keyword">if</span> (n + <span class="number">3</span> &lt;= e[j].to &amp;&amp; !e[j].w) last[i] = ans[e[j].to]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">cout</span> &lt;&lt; last[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"diff.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"diff.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n); <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, base[i] + <span class="number">1</span>), len[i] = <span class="built_in">strlen</span>(base[i] + <span class="number">1</span>), mx = max(mx, len[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) Pre(i); ncnt = n + <span class="number">2</span>, S = n + <span class="number">1</span>, T = n + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cnt = <span class="number">0</span>, bfs(i);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = mx, ans = <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (solve(mid = (l + r) &gt;&gt; <span class="number">1</span>)) r = mid - <span class="number">1</span>, ans = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans); <span class="keyword">if</span> (~ans) solve2(ans);</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; clock() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>Dev</code>千万不要打开<code>-std=c++11</code></p><p>防止<code>CE</code></p>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 后缀自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.18省选模拟</title>
      <link href="/2019/03/19/3-18%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/"/>
      <url>/2019/03/19/3-18%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-One-One"><a href="#T1-One-One" class="headerlink" title="T1 One?One!"></a>T1 One?One!</h1><p><img src="https://i.loli.net/2019/03/19/5c90995cb16fa.png" alt="1552980300634"></p><p><img src="https://i.loli.net/2019/03/19/5c90997bf14b9.png" alt="1552980340063"></p><p>不会啊。。先贴上题解吧</p><p><img src="https://i.loli.net/2019/03/19/5c9099c042c6f.png" alt="1552980403927"></p><h1 id="T2-Two-Two"><a href="#T2-Two-Two" class="headerlink" title="T2 Two?Two!"></a>T2 Two?Two!</h1><p><img src="https://i.loli.net/2019/03/19/5c909a1bf2c79.png" alt="1552980499134"></p><p><img src="https://i.loli.net/2019/03/19/5c909a65f0cb3.png" alt="1552980559669"></p><p>首先考虑<code>dp</code></p><p>假设现在已经排了前$i$个人，我们知道这两个队中有一个对的最大值一定是$M_i$，即前$i$个人的最大值</p><p>那么我们可以设<code>dp[i][j]</code>表示已经排好了$i$个人，其中$M_i$不在的那一队的最大值为$j$的答案</p><p>我们考虑一下几种情况：</p><ol><li>$M_i=x_i$</li></ol><p>显然，将$i$排到$M_{i-1}$那一队会更优秀</p><p>即对于任意的$j$，<code>dp[i][j] = dp[i - 1][j]</code></p><ol><li>$x_i&lt;M_i,j\in[0,x_i)$</li></ol><p>排完了$i$这个人之后仍然有一队的最大值小于$x_i$，那么$i$一定排到了最大值更大的那一边，即$M_{i-1}$，也是$M_i$</p><p>此时有<code>dp[i][j] = dp[i - 1][j] + M[i] - x[i]</code></p><ol><li>$x_i&lt;M_i,j=x_i$</li></ol><p>排完了$i$这个人之后，最大值不在的那一对的最大值就咕了</p><p>那么我们可以知道，这一队之前的最大值一定是$\leq x_i$的</p><p>所以有<code>dp[i][j] = min{dp[i - 1][k]}(k &lt;= j)</code></p><ol><li>$x_i&lt;M_i,j\in(x_i,M_i]$</li></ol><p>那么此时把$i$排到$j$那一队肯定更优秀</p><p>所以<code>dp[i][j] = dp[i - 1][j] + j - x[i]</code></p><p>但是这样<code>dp</code>是$n^2$的，需要优化</p><p>我们考虑进行了哪些操作</p><p>第一种情况：什么都没做</p><p>第二种情况：区间加常数</p><p>第三种情况：区间取最小值，单点覆盖</p><p>第四种情况：区间加常数，区间加一次函数</p><p>这个区间加一次函数与区间最小值在一起好像有点不好维护</p><p>题解是<code>splay</code>，但我只会75分分块</p><p>考虑如何块内维护</p><p>我们在每个块都维护一个下凸壳，由于我们加的一次函数是单调递增的，所以只有下凸壳上的顶点才有可能成为最小值</p><p>由于某些操作没有下放，这导致询问的时候我们需要考虑这部分没有下放的标记</p><p>我们令一个块中的<code>tag1</code>为自变量</p><p>那么可以根据这个进行斜率优化，因为在更新时这个标记是不降的</p><p>所以我们维护凸包</p><p>每次查询的时候把最开始没用的直线<code>pop</code>掉就可以了</p><p>考虑时间复杂度</p><p>区间加常数时凸包不会改变</p><p>单点覆盖时最多加一个点</p><p>而凸包上的每个点只会进来一次，弹出一次</p><p>所以总时间复杂度$O(n\log n)$</p><p>需要离散化</p><p>不知道出了什么问题的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> size = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">int</span> tag1[M], belong[N], to[N], n; LL f[N], tag2[M];</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bl = belong[x];</span><br><span class="line">    <span class="keyword">return</span> f[x] + (LL)tag1[bl] * to[x] + tag2[bl];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Start</span><span class="params">(<span class="keyword">int</span> block)</span> </span>&#123;<span class="keyword">return</span> (block - <span class="number">1</span>) * size + <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">End</span><span class="params">(<span class="keyword">int</span> block)</span> </span>&#123;<span class="keyword">return</span> min(n, block * size);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pushdown</span><span class="params">(<span class="keyword">int</span> block)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag1[block] == <span class="number">0</span> &amp;&amp; tag2[block] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> st = Start(block), ed = End(block);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = st;i &lt;= ed;i++) f[i] = Get(i);</span><br><span class="line">    tag1[block] = tag2[block] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Calc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)f[b] - f[a] &lt;= c * (a - b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rebuild</span><span class="params">(<span class="keyword">int</span> block)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> st = Start(block), ed = End(block);</span><br><span class="line">    d[block].clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ed;i &gt;= st;i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (d[block].size() &amp;&amp; f[*d[block].rbegin()] &gt;= f[i]) d[block].pop_back();</span><br><span class="line">        d[block].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) f[i] = <span class="number">1e15</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) belong[i] = (i + size - <span class="number">1</span>) / size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= belong[n];i++) Rebuild(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Min</span><span class="params">(<span class="keyword">int</span> block)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = tag1[block];</span><br><span class="line">    <span class="keyword">while</span> (d[block].size() &gt;= <span class="number">2</span> &amp;&amp; Calc(d[block][<span class="number">0</span>], d[block][<span class="number">1</span>], x)) d[block].pop_front();</span><br><span class="line">    <span class="keyword">return</span> Get(d[block][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">UPD</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> type, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start;i &lt;= end;i++) </span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) f[i] += x; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) f[i] += to[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> type, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> st = belong[start], ed = belong[end], s = End(st), t = Start(ed);</span><br><span class="line">    Pushdown(st), Pushdown(ed);</span><br><span class="line">    <span class="keyword">if</span> (st == ed) &#123;UPD(start, end, type, x), Rebuild(st); <span class="keyword">return</span>;&#125;</span><br><span class="line">    UPD(start, s, type, x), UPD(t, end, type, x), Rebuild(st), Rebuild(ed);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = st + <span class="number">1</span>;i &lt; ed;i++)</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) tag2[i] += x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) tag1[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> at, LL x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bl = belong[at]; </span><br><span class="line">    Pushdown(bl), f[at] = x, Rebuild(bl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> st = belong[start], ed = belong[end], s = End(st), t = Start(ed); LL res = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">if</span> (st == ed) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start;i &lt;= end;i++) res = min(res, Get(i));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start;i &lt;= s;i++) res = min(res, Get(i));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = t;i &lt;= end;i++) res = min(res, Get(i));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = st + <span class="number">1</span>;i &lt; ed;i++) res = min(res, Min(i));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//  freopen("two.in", "r", stdin), freopen("two.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">int</span> _n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;_n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= _n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]), to[i] = num[i];</span><br><span class="line">    sort(to + <span class="number">1</span>, to + _n + <span class="number">1</span>), n = unique(to + <span class="number">1</span>, to + _n + <span class="number">1</span>) - to - <span class="number">1</span>, Pre();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= _n;i++) num[i] = lower_bound(to + <span class="number">1</span>, to + n, num[i]) - to;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, mx = num[<span class="number">1</span>];i &lt;= _n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mx &lt;= num[i]) &#123;mx = num[i]; <span class="keyword">continue</span>;&#125;</span><br><span class="line">        Set(num[i], query(<span class="number">1</span>, num[i]));</span><br><span class="line">        update(<span class="number">1</span>, num[i] - <span class="number">1</span>, <span class="number">1</span>, to[mx] - to[num[i]]), update(num[i] + <span class="number">1</span>, mx, <span class="number">2</span>, <span class="number">0</span>), update(num[i] + <span class="number">1</span>, mx, <span class="number">1</span>, -to[num[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(<span class="number">1</span>, n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-More-More"><a href="#T3-More-More" class="headerlink" title="T3 More?More!"></a>T3 More?More!</h1><p><img src="https://i.loli.net/2019/03/19/5c909feab91c8.png" alt="1552981985904"></p><p><img src="https://i.loli.net/2019/03/19/5c90a015dc236.png" alt="1552982029057"></p><p>很奇妙的一道题，有两种方法</p><h2 id="ZJK的做法"><a href="#ZJK的做法" class="headerlink" title="ZJK的做法"></a><code>ZJK</code>的做法</h2><p>考虑将每个选手选或不选转化成一个01串，那么对于<strong>一个</strong>有$i$位是1的01串，我们设$a$表示01对的数量，$b$表示10对的数量</p><p>那么显然有</p><script type="math/tex; mode=display">p(该集合满足条件)=(1-p)^ap^b</script><p>注意到$b$是可以被$a$表示的，有</p><script type="math/tex; mode=display">b=\frac{n(n-1)}{2}-a</script><p>所以上面的式子</p><script type="math/tex; mode=display">=(1-p)^ap^{\frac{n(n-1)}{2}-a}\\\=(\frac{1-p}{p})^ap^\frac{n(n+1)}{2}</script><p>我们需要求出所有有$i$位是1的01串合法的概率之和，而这些串的$n$都是固定的</p><p>所以可以把$p^\frac{n(n-1)}{2}$提出来</p><p>所以我们实际上要求的是</p><script type="math/tex; mode=display">\sum_{s有i位是1}(\frac{1-p}{p})^{a_s}</script><p>考虑$a_s$如何计算</p><p>我们采用总数减去多余情况的方法</p><p>那么对于每一个1的位置，前面的每一个位置都有机会和它构成01串，此时答案为所有1的下标之和</p><p>但是我们发现有些地方是构不成01串的，比如选了两个1</p><p>所以还需要减去$\frac{i(i+1)}{2}$(包含了两次都选同一个位置的情况)</p><p>所以</p><script type="math/tex; mode=display">a_s=\sum 1的下标-\frac{i(i+1)}{2}</script><p>我们发现，对于所有有$i$位是1的集合，后面那个东西也是不变的，可以提出来</p><p>所以最终我们需要得到的是</p><script type="math/tex; mode=display">\sum_{s有i位是1}(\frac{1-p}{p})^{所有1的下标之和}</script><p>考虑构造生成函数</p><p>显然它的生成函数是</p><script type="math/tex; mode=display">G(x)=\prod_{i=1}^n(1+(\frac{1-p}{p})^ix)</script><p>含义是，枚举每一个位置是不是1</p><p>如果不是1，那么对应括号中的1</p><p>否则，当前答案就会乘上$(\frac{1-p}{p})^i$，$i$即当前位的下标</p><p>最后答案就是$x^i$项的系数</p><p>可以使用<del>分治<code>NTT</code></del>倍增</p><h2 id="标程的做法"><a href="#标程的做法" class="headerlink" title="标程的做法"></a>标程的做法</h2><p>先考虑朴素的<code>dp</code></p><p><code>dp[i][j]</code>表示有$i$个人，选了$j$个人并且合法的概率</p><p>那么有两种思路</p><ol><li>当前添加的那个人的编号大于所有人的编号</li></ol><p>此时显然有<code>dp[i][j] = dp[i - 1][j] * p ^ j + dp[i - 1][j - 1] * (1 - p) ^ (i - j + 1)</code></p><ol><li>当前添加的那个人的编号小于所有人的编号</li></ol><p>有<code>dp[i][j] = dp[i - 1][j] * (1 - p) ^ j + dp[i - 1][j - 1] * p ^ (i - j + 1)</code></p><p>根据<code>dp</code>的定义，我们可以得出：这两个转移一定是等价的！</p><p>所以有</p><script type="math/tex; mode=display">dp_{i,j}\*p^j+dp_{i,j-1}\*p^{i-j+1}=dp_{i,j}\*(1-p)^{j}+dp_{i,j-1}\*p^{i-j+1}</script><p>移项，可以得出</p><script type="math/tex; mode=display">dp_{i,j}(p^j-(1-p)^j)=dp_{i,j-1}((1-p)^{i-j+1}-p^{i-j+1})</script><p>然后扫一遍就可以了</p><p>注意对于$p=\frac 12$需要特判</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2010</span>][<span class="number">2010</span>], frac[<span class="number">1000010</span>], inv[<span class="number">1000010</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RG register</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"more.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"more.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n, p; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;p);</span><br><span class="line">    <span class="keyword">if</span> (p == (mod + <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">        frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (RG <span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld "</span>, (LL)C(n, i) * Pow(Pow(p, n - i), i) % mod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= i;j++)</span><br><span class="line">                dp[i][j] = ((LL)dp[i - <span class="number">1</span>][j] * Pow(p, j) + (j ? (LL)dp[i - <span class="number">1</span>][j - <span class="number">1</span>] * Pow(mod + <span class="number">1</span> - p, i - j) : <span class="number">0</span>)) % mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++) <span class="built_in">cout</span> &lt;&lt; dp[n][i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于总结，它不见了</p>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 多项式 </tag>
            
            <tag> 分块 </tag>
            
            <tag> splay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.16省选模拟</title>
      <link href="/2019/03/17/3-16%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/"/>
      <url>/2019/03/17/3-16%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-计算"><a href="#T1-计算" class="headerlink" title="T1 计算"></a>T1 计算</h1><p><img src="https://i.loli.net/2019/03/17/5c8d945d2655e.png" alt="1552782392982"></p><p>比较简单的一道题</p><p>考虑将这个式子拆开</p><p>注意到这个幂是可以拆分的，即$a^b*a^c=a^{b+c}$</p><p>而$\sum\sum ab=\sum a\sum b$</p><p>如果将这个式子一位一位地拆分，假设$k$的第一位是$x$，有$m$位，那么有</p><script type="math/tex; mode=display">\sum_k e^{\frac kn}=\sum_xe^\frac{x\*10^m}{n}\sum_{k去除第一位}e^{\frac kn}</script><p>直接数位<code>dp</code>就可以了，注意需要特判$m=0$时的前导0的情况</p><p>对于“不含$m$这个子串”这个条件，可以先用<code>KMP</code>求出<code>next</code>数组，再处理合法的转移</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double long double</span></span><br><span class="line"><span class="keyword">int</span> ndig[<span class="number">101</span>], mdig[<span class="number">101</span>], Pow10[<span class="number">101</span>], nxt[<span class="number">101</span>][<span class="number">101</span>], ndep, n;</span><br><span class="line"><span class="keyword">double</span> dp[<span class="number">101</span>][<span class="number">101</span>][<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_digit</span><span class="params">(<span class="keyword">int</span> digit[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;digit[<span class="number">1</span>] = <span class="number">0</span>; <span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) digit[++res] = n % <span class="number">10</span>, n /= <span class="number">10</span>;</span><br><span class="line">    reverse(digit + <span class="number">1</span>, digit + res + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> dep, <span class="keyword">int</span> cur, <span class="keyword">int</span> flag, <span class="keyword">int</span> lead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (dp[dep][cur][flag][lead] != <span class="number">-1</span>) <span class="keyword">return</span> dp[dep][cur][flag][lead];</span><br><span class="line">    <span class="keyword">double</span> &amp;sum = dp[dep][cur][flag][lead]; sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = !flag ? <span class="number">9</span> : ndig[ndep - dep + <span class="number">1</span>]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= R;i++) <span class="keyword">if</span> (nxt[cur][i] != <span class="number">-1</span> || (mdig[<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; lead &amp;&amp; !i)) &#123;</span><br><span class="line">        <span class="keyword">int</span> nflag = flag &amp;&amp; i == R, nlead = lead &amp;&amp; !i;</span><br><span class="line">        sum += <span class="built_in">exp</span>(i * Pow10[dep - <span class="number">1</span>] / (<span class="keyword">double</span>)n) * DP(dep - <span class="number">1</span>, ~nxt[cur][i] ? nxt[cur][i] : <span class="number">0</span>, nflag, nlead);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Nxt[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">KMP</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = Nxt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (t &amp;&amp; mdig[i] != mdig[t + <span class="number">1</span>]) t = Nxt[t];</span><br><span class="line">        <span class="keyword">if</span> (mdig[t + <span class="number">1</span>] == mdig[i]) t++;</span><br><span class="line">        Nxt[i] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m), Pow10[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">9</span>;i++) Pow10[i] = Pow10[i - <span class="number">1</span>] * <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> dep = get_digit(ndig, n), mdep = get_digit(mdig, m);</span><br><span class="line">    KMP(mdep), ndep = dep;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; mdep;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= <span class="number">9</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = i;</span><br><span class="line">            <span class="keyword">while</span> (tmp &amp;&amp; mdig[tmp + <span class="number">1</span>] != j) tmp = Nxt[tmp];</span><br><span class="line">            nxt[i][j] = mdig[tmp + <span class="number">1</span>] == j ? tmp + <span class="number">1</span> : tmp;</span><br><span class="line">            <span class="keyword">if</span> (nxt[i][j] == mdep) nxt[i][j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">10</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= <span class="number">10</span>;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">2</span>;k++)</span><br><span class="line">                dp[i][j][k][<span class="number">0</span>] = dp[i][j][k][<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.3Lf\n"</span>, DP(dep, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-移动"><a href="#T2-移动" class="headerlink" title="T2 移动"></a>T2 移动</h1><p><img src="https://i.loli.net/2019/03/17/5c8d96a41a70a.png" alt="1552783004369"></p><p>很经典的一道题，可以参考环形均分纸牌问题</p><p>我们假设位置$i$向右传递了$x_i$，其原来的值为$c_i$</p><p>那么有</p><script type="math/tex; mode=display">\begin{gathered}c_1+x_n-x_1=1\\c_2+x_1-x_2=1\\\Rightarrow c_2-1+c_1-1+x_n=x_2\\c_3-1+c_2-1+c_1-1+x_n=x_3\\ans=\sum_{i=1}^n|x_i|=\sum_{i=1}^n|\sum_{j=1}^i(c_j-1)+x_n|\\=\sum_{i=1}^n|x_n-\sum_{j=1}^i(1-c_j)|\end{gathered}</script><p>如果要让$ans$尽量小，那么就要让后面那个数尽量小</p><p>我们设$s_n=\sum\limits_{i=1}^n(1-c_i)$</p><p>所以$x_n$取到$s$的中位数时最优秀</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"><span class="keyword">int</span> num[N], tmp[N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) num[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), num[a]--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) num[i] += num[i - <span class="number">1</span>];</span><br><span class="line">    sort(num + <span class="number">1</span>, num + n + <span class="number">1</span>); <span class="keyword">int</span> middle = num[(n + <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) res += <span class="built_in">abs</span>(num[i] - middle);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，<code>dinic</code>费用流可以拿50分</p><p>将<code>SPFA</code>部分改一下，改成从汇点开始跑费用最短路</p><p>然后将普通最大流的层级图改成最短路图即可</p><p>注意<code>dfs</code>的时候还要记录一个<code>vis</code>数组，每个点只能经过一次</p><p>可以多路增广</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 30010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 120010</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w, c;</span><br><span class="line">&#125; e[M];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">int</span> head[N], ecnt = <span class="number">1</span>, vis[N], cur[N]; LL dis[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> f, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from], f, c&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to], <span class="number">0</span>, -c&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis)), <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis)), dis[t] = <span class="number">0</span>, vis[t] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q; q.push_back(t);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop_front(), vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">            <span class="keyword">if</span> (e[i ^ <span class="number">1</span>].w &amp;&amp; dis[e[i].to] &gt; dis[u] - e[i].c) &#123;</span><br><span class="line">                dis[e[i].to] = dis[u] - e[i].c;</span><br><span class="line">                <span class="keyword">if</span> (!vis[e[i].to]) &#123;</span><br><span class="line">                    vis[e[i].to] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!q.empty() &amp;&amp; dis[e[i].to] &lt; dis[q.front()]) q.push_front(e[i].to);</span><br><span class="line">                    <span class="keyword">else</span> q.push_back(e[i].to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[s] &lt; <span class="number">1e17</span>;</span><br><span class="line">&#125;</span><br><span class="line">LL MCMF;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>; <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (u == t || !f) <span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u], tmp;i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to] &amp;&amp; e[i].w &amp;&amp; dis[u] - e[i].c == dis[e[i].to] &amp;&amp; (tmp = DFS(e[i].to, min(f, e[i].w), t))) &#123;</span><br><span class="line">            f -= tmp, res += tmp, e[i].w -= tmp, e[i ^ <span class="number">1</span>].w += tmp, MCMF += (LL)tmp * e[i].c;</span><br><span class="line">            <span class="keyword">if</span> (!f) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    MCMF = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (SPFA(s, t)) <span class="built_in">memcpy</span>(cur, head, <span class="keyword">sizeof</span>(head)), f += DFS(s, <span class="number">1e9</span>, t);</span><br><span class="line">    <span class="keyword">return</span> MCMF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen("in.txt", "r", stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n, s, t; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), s = n + <span class="number">1</span>, t = n + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), num[a]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) adde(s, i, num[i], <span class="number">0</span>), adde(i, i == n ? <span class="number">1</span> : i + <span class="number">1</span>, <span class="number">1e9</span>, <span class="number">1</span>), adde(i == n ? <span class="number">1</span> : i + <span class="number">1</span>, i, <span class="number">1e9</span>, <span class="number">1</span>), adde(i, t, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Dinic(s, t));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-分离"><a href="#T3-分离" class="headerlink" title="T3 分离"></a>T3 分离</h1><p><img src="https://i.loli.net/2019/03/17/5c8d9a25247f1.png" alt="1552783901692"></p><p>折半搜索+打表</p><p>有一个结论：当$n\geq96$时，答案是0</p><p>不会，告辞</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次比赛有所进步，但是又粗心了</p><p>第一题犯了一个比较隐蔽的错误，导致有一些点<code>RE</code>了</p><p>不过还好</p>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.15省选模拟</title>
      <link href="/2019/03/15/3-15%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/"/>
      <url>/2019/03/15/3-15%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-Tried"><a href="#T1-Tried" class="headerlink" title="T1 Tried"></a>T1 Tried</h1><p><img src="https://i.loli.net/2019/03/15/5c8b99b22ea62.png" alt="1552652707991"></p><p>之前做过一道<code>Codeforces</code>的题<code>Run for beer</code>，跟这道题很像</p><p>先把所有环都缩在一起，就变成了一个<code>DAG</code></p><p>那么我们考虑在这个<code>DAG</code>上搞</p><p>显然一条最长的路径首先要满足长度最长，注意这里的长度指的是不包含前缀0的长度</p><p>其次要满足越靠下的路径要尽量长</p><p>对于每个点我们可以求出两个值</p><p><code>dep[u]</code>表示从某个入度为0的点到$u$，经过的边数最多是多少</p><p><code>f[u]</code>表示如果以$u$为终点，到某个入度为0的点经过的边数最多是多少。这要求连接$u$的那条边不能为0</p><p>然后我们就可以维护两个队列，代表当前可能成为答案的点</p><p>每次往上扩展一层，只扩展那些边权最大的边</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; q[<span class="number">2</span>], res;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> dep, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!dep) <span class="keyword">return</span>; q[cur].clear();</span><br><span class="line">    <span class="keyword">int</span> Mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; q[cur ^ <span class="number">1</span>].size();i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q[cur ^ <span class="number">1</span>][i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; R[u].size();j++)</span><br><span class="line">            <span class="keyword">if</span> (dp[u] == dp[R[u][j].first] + <span class="number">1</span>)</span><br><span class="line">                Mx = max(Mx, R[u][j].second);</span><br><span class="line">    &#125;</span><br><span class="line">    res.push_back(Mx);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; q[cur ^ <span class="number">1</span>].size();i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q[cur ^ <span class="number">1</span>][i];</span><br><span class="line">        <span class="keyword">if</span> (hh[u]) <span class="keyword">continue</span>; hh[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; R[u].size();j++)</span><br><span class="line">            <span class="keyword">if</span> (dp[u] == dp[R[u][j].first] + <span class="number">1</span> &amp;&amp; R[u][j].second == Mx)</span><br><span class="line">                q[cur].push_back(R[u][j].first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; q[cur ^ <span class="number">1</span>].size();i++) hh[q[cur ^ <span class="number">1</span>][i]] = <span class="number">0</span>;</span><br><span class="line">    bfs(dep - <span class="number">1</span>, cur ^ <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后根据答案从所有入度为0的点开始拓展，统计答案</p><p>这道题细节非常繁琐，首先有以下几种特殊情况：</p><ol><li>有至少一个非0环，那么可以在这个环上永远走下去，答案为<code>inf, inf</code></li><li>有0环，并且这个0环可以走到至少一条非0边，答案为<code>inf, inf</code></li><li>有0环，并且不满足条件2，且在答案的路径上或者在某个终止节点的子树中，第二个答案为<code>inf</code></li><li>所有边的边权都为0，此时枚举终点算方案数，注意只有一个点的路径也算</li><li>一条路径结束后仍然可以继续往下扩展，需要乘上终点的方案数</li><li>有自环，需要把它当成一个环</li></ol><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 1000010</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, next, w, used;</span><br><span class="line">&#125; e[M * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, to, head[from], w, <span class="number">0</span>&#125;, head[from] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> st[N], top, in[N], scc, belong[N], dfsn, dfn[N], low[N], sum[N], cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    st[++top] = u, in[u] = <span class="number">1</span>, dfn[u] = low[u] = ++dfsn;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (!dfn[e[i].to]) Tarjan(e[i].to), low[u] = min(low[u], low[e[i].to]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (in[e[i].to]) low[u] = min(low[u], dfn[e[i].to]);</span><br><span class="line">    <span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line">        scc++; <span class="keyword">int</span> v = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (;v != u;top--) </span><br><span class="line">            v = st[top], in[v] = <span class="number">0</span>, belong[v] = scc, cnt[scc]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> ind[N], oud[N], dp[N], ok[N]; <span class="built_in">vector</span>&lt;P &gt; G[N], R[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Topsort</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span> (!ind[i]) q.push(i), st[++top] = i;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[u].size();i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i].first;</span><br><span class="line">            <span class="keyword">if</span> (!--ind[v]) q.push(v), st[++top] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> f[N], hh[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; q[<span class="number">2</span>], res;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> dep, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!dep) <span class="keyword">return</span>; q[cur].clear();</span><br><span class="line">    <span class="keyword">int</span> Mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; q[cur ^ <span class="number">1</span>].size();i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q[cur ^ <span class="number">1</span>][i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; R[u].size();j++)</span><br><span class="line">            <span class="keyword">if</span> (dp[u] == dp[R[u][j].first] + <span class="number">1</span>)</span><br><span class="line">                Mx = max(Mx, R[u][j].second);</span><br><span class="line">    &#125;</span><br><span class="line">    res.push_back(Mx);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; q[cur ^ <span class="number">1</span>].size();i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q[cur ^ <span class="number">1</span>][i];</span><br><span class="line">        <span class="keyword">if</span> (hh[u]) <span class="keyword">continue</span>; hh[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; R[u].size();j++)</span><br><span class="line">            <span class="keyword">if</span> (dp[u] == dp[R[u][j].first] + <span class="number">1</span> &amp;&amp; R[u][j].second == Mx)</span><br><span class="line">                q[cur].push_back(R[u][j].first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; q[cur ^ <span class="number">1</span>].size();i++) hh[q[cur ^ <span class="number">1</span>][i]] = <span class="number">0</span>;</span><br><span class="line">    bfs(dep - <span class="number">1</span>, cur ^ <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> path[N], wocaonima[N], last[N], tmpind[N], toend[N], fuck[N], tostart[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getans</span><span class="params">(<span class="keyword">int</span> dep, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; q[cur ^ <span class="number">1</span>].size();i++)</span><br><span class="line">            last[q[cur ^ <span class="number">1</span>][i]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q[cur].clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; q[cur ^ <span class="number">1</span>].size();i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q[cur ^ <span class="number">1</span>][i];</span><br><span class="line">        <span class="keyword">if</span> (hh[u]) <span class="keyword">continue</span>; hh[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; G[u].size();j++)</span><br><span class="line">            <span class="keyword">if</span> (G[u][j].second == res[dep - <span class="number">1</span>] &amp;&amp; dp[u] + <span class="number">1</span> == dp[G[u][j].first]) &#123;</span><br><span class="line">                (path[G[u][j].first] += path[u]) %= mod;</span><br><span class="line">                q[cur].push_back(G[u][j].first), wocaonima[G[u][j].first] |= wocaonima[u] | (cnt[u] != <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; q[cur ^ <span class="number">1</span>].size();i++) hh[q[cur ^ <span class="number">1</span>][i]] = <span class="number">0</span>;</span><br><span class="line">    getans(dep - <span class="number">1</span>, cur ^ <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen("data.in", "r", stdin);</span></span><br><span class="line"><span class="comment">//    freopen("tried.in", "r", stdin), freopen("tried.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b, c;i &lt;= m;i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c), adde(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span> (!dfn[i]) Tarjan(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= ecnt;i++) &#123; </span><br><span class="line">        <span class="keyword">if</span> (e[i].from == e[i].to) cnt[belong[e[i].from]]++; </span><br><span class="line">        <span class="keyword">if</span> (belong[e[i].from] != belong[e[i].to]) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = belong[e[i].from], v = belong[e[i].to];</span><br><span class="line">            G[u].push_back(P(v, e[i].w)), R[v].push_back(P(u, e[i].w)), ind[v]++, oud[u]++, tmpind[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> sum[belong[e[i].from]] += e[i].w;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= scc;i++) <span class="keyword">if</span> (cnt[i] != <span class="number">1</span> &amp;&amp; sum[i]) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"inf\ninf\n"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Topsort(scc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= scc;i++) <span class="keyword">if</span> (!oud[i]) toend[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = top;i &gt;= <span class="number">1</span>;i--) &#123;</span><br><span class="line">         <span class="keyword">int</span> u = st[i]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; G[u].size();j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][j].first;</span><br><span class="line">            ok[u] |= ok[v] | (G[u][j].second != <span class="number">0</span>), (toend[u] += toend[v] + <span class="number">1</span>) %= mod, fuck[u] |= fuck[v] | (cnt[v] != <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= scc;i++) <span class="keyword">if</span> (cnt[i] != <span class="number">1</span> &amp;&amp; ok[i]) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"inf\ninf\n"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    for (int i = 1;i &lt;= scc;i++) if (!tmpind[i]) tostart[i] = 1;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= top;i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, u = st[i];j &lt; G[u].size();j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][j].first;</span><br><span class="line">            dp[v] = max(dp[v], dp[u] + <span class="number">1</span>), (tostart[v] += tostart[u] + <span class="number">1</span>) %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= scc;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; R[i].size();j++)</span><br><span class="line">            <span class="keyword">if</span> (R[i][j].second) f[i] = max(f[i], dp[R[i][j].first] + <span class="number">1</span>), tmp = max(tmp, f[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= scc;i++) <span class="keyword">if</span> (f[i] == tmp) q[<span class="number">0</span>].push_back(i), dp[i] = f[i];</span><br><span class="line">    <span class="keyword">int</span> dep = tmp;</span><br><span class="line">    bfs(dep, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!res.size()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0\n"</span>); <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= scc;i++)</span><br><span class="line">            <span class="keyword">if</span> (cnt[i] != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"inf\n"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> (ans += tostart[i]) %= mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, (ans + n) % mod); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; res.size();i++) <span class="built_in">printf</span>(<span class="string">"%d"</span>, res[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    q[<span class="number">0</span>].clear(), q[<span class="number">1</span>].clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= scc;i++) <span class="keyword">if</span> (!tmpind[i])</span><br><span class="line">        path[i] = <span class="number">1</span>, q[<span class="number">0</span>].push_back(i);</span><br><span class="line">    getans(dep, <span class="number">1</span>); <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= scc;i++) <span class="keyword">if</span> (last[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (wocaonima[i] || fuck[i] || cnt[i] != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"inf\n"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> ans = (ans + (LL)path[i] * toend[i]) % mod;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-简单的数论题"><a href="#T2-简单的数论题" class="headerlink" title="T2 简单的数论题"></a>T2 简单的数论题</h1><p><img src="https://i.loli.net/2019/03/15/5c8ba0025b80c.png" alt="1552654321335"></p><p>神仙题，不会啊</p><h1 id="T3-恶熊咆哮"><a href="#T3-恶熊咆哮" class="headerlink" title="T3 恶熊咆哮"></a>T3 恶熊咆哮</h1><p><img src="https://i.loli.net/2019/03/17/5c8d8d8d39bf6.png" alt="1552780675391"></p><p>只会20分，即$n\leq 2000$的暴力分</p><p>注意到x,y坐标可以分离考虑，而对于一次咆哮，所有熊的相对顺序是不变的，但是可能又一些熊移动到了一起</p><p>那么可以使用线段树，区间加，单点查</p><p>需要先找到第一个小于当前位置的数以及第一个大于当前位置的数</p><p>放上这次比赛的题解</p><div class="pdfobject-container" data-target="3.15_solution.pdf" data-height="500px"></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>T1数据出锅了，但是改了之后还是只有90分，原因是某个地方忘取模了</p><p>看来还是有这样不该出现的问题，慢慢改吧</p>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 莫比乌斯反演 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.8省选模拟 冬至</title>
      <link href="/2019/03/14/3-8%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F-%E5%86%AC%E8%87%B3/"/>
      <url>/2019/03/14/3-8%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F-%E5%86%AC%E8%87%B3/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/03/14/5c89b9fac5cbb.png" alt="1552529871533"></p><p>我们设$t_n$表示长度为$n$时的答案，$s_n$表示最后$k$个字符是一个<strong>给定的</strong>排列，在位置$n-1$时都合法的方案数</p><p>我们考虑两个基本的式子</p><script type="math/tex; mode=display">\begin{gather}t_n=kt_{n-1}-k!s_n\ \ \ (1)\\\t_n=\sum_{i=1}^{k}(k-i)!s_{n+i}\ \ (2)\end{gather}</script><p>对于第一个式子，我们在$t_{n-1}$后面随便加一种字符，然后减去不合法的情况，即$k!s_n$，这里枚举了最后$k$个字符分别是什么</p><p>对于第二个式子，我们尝试在$t_n$之后依次加上$1,2,3,\cdots,k$，枚举在加到哪个数字时候，这个序列变得不合法</p><p>追加了$i$个，前面的最后$k-i$个一定是一个排列，共$(k-i)!$种方案</p><p>根据这两个式子，我们可以推出</p><script type="math/tex; mode=display">(1)\Rightarrow s_n=\frac1{k!}(kt_{n-1}-t_n)\\\(2)\Rightarrow t_n=\sum_{i=1}^k(k-i)!\frac1{k!}(kt_{n+i-1}-t_{n+i})\\\=t_n+\sum_{i=1}^{k-1}((k-i-1)!\frac1{k!}kt_{n+i}-(k-i)!\frac1{k!}t_{n+i})-\frac1{k!}t_{n+k}</script><p>注意这里把第一项的$kt_{n+i+1}$和最后一项的$t_n$拿了出来</p><script type="math/tex; mode=display">t_n=t_n+\sum_{i=1}^{k-1}((k-i-1)!\frac1{k!}kt_{n+i}-(k-i)!\frac1{k!}t_{n+i})-\frac1{k!}t_{n+k}\\\t_{n+k}=\sum_{i=1}^{k-1}((k-i-1)!kt_{n+i}-(k-i)!t_{n+i})\\\=\sum_{i=1}^{k-1}(k-i-1)!\*i\*t_{n+i}</script><p>然后线性递推就可以了</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式求逆 </tag>
            
            <tag> 多项式 </tag>
            
            <tag> 多项式除法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.13省选模拟</title>
      <link href="/2019/03/13/3-13%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/"/>
      <url>/2019/03/13/3-13%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-碱基配对"><a href="#T1-碱基配对" class="headerlink" title="T1 碱基配对"></a>T1 碱基配对</h1><p><img src="https://i.loli.net/2019/03/13/5c88e968525a4.png" alt="1552476506650"></p><p><img src="https://i.loli.net/2019/03/13/5c88e9a821349.png" alt="1552476546262"></p><p>注意到每一种字符是互不影响的，所以我们可以对于每一种字符分别计算有哪些位置合法，最后取一个交集</p><p>问题就转化为了给出两个01串$A,B$，对于$B$的每一个为1的位置$B_i$，$A_{i+p-k}-A_{i+p+k}$这些位置中至少要有一个1</p><p>那么我们可以把第一个串转化一下，将$A_i$变成原来的$A’_{i-k}-A’_{i+k}$中是否有1</p><p>对于这种条件比较奇怪的字符串匹配问题，一个比较常用的方法是<code>FFT</code></p><p>我们设差异函数$F(p)$代表$A$串在$p$这个位置的差异值</p><p>我们考虑什么时候会产生差异</p><p>如果当前$B_i=0$，那么$A_{i+p}$随意</p><p>如果当前$B_i=1$，那么$A_{i+p}$必须为1</p><p>所以定义差异函数为</p><script type="math/tex; mode=display">F(p)=\sum_{i=0}^m(B_i-A_{i+p})B_i</script><p>那么只要$F(p)\not=1$，$p$这个位置就不能匹配</p><p>把它化简一下</p><script type="math/tex; mode=display">F(p)=\sum_{i=0}^mB_i^2-\sum_{i=0}^mA_{i+p}B_i\\\=\sum_{i=0}^mB_i-\sum_{i=0}^mA_{i+p}B_i</script><p>根据套路，设$A’(x)=A(n-x)$</p><p>有</p><script type="math/tex; mode=display">G(p)=\sum_{i=0}^mA_{i+p}B_i\\\=\sum_{i=0}^mA'_{n-i-p}B_i\\\</script><p>令</p><script type="math/tex; mode=display">G'(n-p)=\sum_{i=0}^mA'_{n-i-p}B_i\\\G(p)=G'(n-p)</script><p>直接<code>NTT</code>即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 800010</span></span><br><span class="line"><span class="keyword">int</span> pre[N], ta[N], tb[N], n, m, k, tmp[N], r[N], ans[N]; <span class="keyword">char</span> A[N], B[N];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, w = <span class="number">1</span>, t;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w = (LL)w * Wn % mod)</span><br><span class="line">                t = (LL)w * a[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!type) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, inv = Pow(len, mod - <span class="number">2</span>);i &lt; len;i++)</span><br><span class="line">        a[i] = (LL)a[i] * inv % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, l = <span class="number">0</span>, len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) pre[i] = (i ? pre[i - <span class="number">1</span>] : <span class="number">0</span>) + (A[i] == s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) tb[i] = (B[i] == s), sum += tb[i] * tb[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = i - k - <span class="number">1</span>;</span><br><span class="line">        tmp[i] = (pre[min(n - <span class="number">1</span>, i + k)] - (t &gt;= <span class="number">0</span> ? pre[t] : <span class="number">0</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) ta[n - i] = tmp[i];</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n + m) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>;i &lt; len;i++) ta[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m;i &lt; len;i++) tb[i] = <span class="number">0</span>; ta[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    NTT(ta, len, <span class="number">1</span>), NTT(tb, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) ta[i] = (LL)ta[i] * tb[i] % mod;</span><br><span class="line">    NTT(ta, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n - m;i++) ans[i] &amp;= ta[n - i] == sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen("base1.in", "r", stdin);</span></span><br><span class="line">    freopen(<span class="string">"base.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"base.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%s%s"</span>, &amp;k, A, B), n = <span class="built_in">strlen</span>(A), m = <span class="built_in">strlen</span>(B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n - m;i++) ans[i] = <span class="number">1</span>;</span><br><span class="line">    solve(<span class="string">'Z'</span>), solve(<span class="string">'P'</span>), solve(<span class="string">'S'</span>), solve(<span class="string">'B'</span>);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n - m;i++) res += ans[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-小凯的疑惑"><a href="#T2-小凯的疑惑" class="headerlink" title="T2 小凯的疑惑"></a>T2 小凯的疑惑</h1><p><img src="https://i.loli.net/2019/03/13/5c88fb6082474.png" alt="1552481105547"></p><p><img src="https://i.loli.net/2019/03/13/5c88fb7fd5a04.png" alt="1552481142694"></p><p><img src="https://i.loli.net/2019/03/13/5c88fc05c8d8e.png" alt="1552481276343"></p><p>由于数据太水，暴力可以获得92分的高分</p><p>对于第一、三、四这几个<code>subtask</code>，可以预处理当所有点都加上某个值时的答案，注意如果没有询问是这个值时不需要计算答案</p><p>对于第二个<code>subtask</code>，直接使用完全图的最小生成树这道题的做法即可。</p><p>每次将所有点按照最高位分成两类，把这两类分别连成连通块后再选择一条连接这两个连通块的最优边</p><p>表示没看懂题解在说什么，先贴上来</p><p><img src="https://i.loli.net/2019/03/13/5c88fd11845f9.png" alt="1552481542615"></p><h1 id="T3-false-false-true"><a href="#T3-false-false-true" class="headerlink" title="T3 false-false-true"></a>T3 false-false-true</h1><p><img src="https://i.loli.net/2019/03/13/5c88fd8a69134.png" alt="1552481664470"></p><p><img src="https://i.loli.net/2019/03/13/5c88fdb35defc.png" alt="1552481701351"></p><p><img src="https://i.loli.net/2019/03/13/5c88fddfe11af.png" alt="1552481749049"></p><p>一道很妙的题</p><p>先考虑$20\%$怎么做</p><p>很简单，直接<code>dp</code>即可</p><p><code>dp[i][j]</code>表示当前已经有$i$道题是<code>true</code>，$j$道题是<code>false</code>，按照最优策略期望还能有多少道题可以答对</p><p>最优策略就是剩下的题中，是<code>true</code>的题多还是<code>false</code>的题多，哪个多就猜哪个</p><p>对于$40\%$，<del>可以<code>OEIS</code></del>我也不知道该怎么做</p><p>对于所有的数据，我们考虑将题目转化一下</p><p>有一个$n*m$的网格，现在要从$(1,1)$走到$(n,m)$。对于一条路径，往上走代表这道题是<code>false</code>，往右走代表这道题是<code>true</code>。你现在要在走的同时决策向上走还是向右走，问期望有多少个决策会和最终的答案一样</p><p>我们将这个网格分成两部分</p><p><img src="https://i.loli.net/2019/03/13/5c89006d8f13d.png" alt="1552482384724"></p><p>对于蓝色的部分，我们使用的策略是一直向右走，显然这样会更优秀，因为答对的概率更大</p><p>对于橙色的部分，有一些时候会向右走，有些时候会向上走。具体来说</p><p><img src="https://i.loli.net/2019/03/13/5c89010caafd8.png" alt="1552482562810"></p><p>在直线上方的部分会选择向右走，在直线下方的部分会选择向上走</p><p>我们先不考虑在直线上的情况</p><p>考虑一条路径的<strong>固定贡献</strong></p><p><img src="https://i.loli.net/2019/03/13/5c89021c29561.png" alt="1552482834082"></p><p>如果我们的策略只有向右走，那么绿色的路径一定会决策正确，黑色的路径一定会决策错误</p><p>最后决策正确的题目的数量是$n$</p><p>现在把位于虚线下方的路径都折到虚线上方，由于我们知道在虚线下方时，决策是一直向上走，折过来之后，就变成了一直向右走</p><p><img src="https://i.loli.net/2019/03/13/5c89031e33481.png" alt="1552483087960"></p><p>红色即为处理之后的路径</p><p>通过这张图我们知道，<strong>对于不在虚线上的点</strong>，它们在这条路径上的贡献一定是$n$</p><p>那么对于在虚线上的点，它们的贡献需要特殊考虑</p><p>我们考虑一个这样的点对最终答案的贡献是什么</p><p>首先枚举每一个在虚线上的点，一共只有$m$个</p><p>对于一条经过它的路径，在到达这个点的时候，它有$50\%$的概率向上走，有$50\%​$的概率向右走，因为此时选两边正确的概率都相等</p><p>也就是说，它对这条路径决策正确的次数的贡献是$\frac 12$</p><p>它对答案的贡献就是$\frac12$乘以它被经过的概率</p><p>我们知道经过一个点$(x,y)$的概率是</p><script type="math/tex; mode=display">\frac{C_{x+y}^yC_{n-x+m-y}^{n-x}}{C_{n+m}^n}</script><p>乘以$\frac12$之后求和就可以了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">int</span> frac[N], inv[N];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Go</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> C(n + m, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= N - <span class="number">10</span>;i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> n, m, res = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) swap(n, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) res = (res + (LL)Go(i, i) * Go(n - i, m - i)) % mod;</span><br><span class="line">    res = (LL)res * Pow(<span class="number">2</span> * Go(n, m) % mod, mod - <span class="number">2</span>) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (n + m - n - res + mod) % mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次考试一般，第二题有一个小地方写错了，导致丢了20分</p><p>感觉第二题和第三题如果没有做过的话我很难想出正解，做一道题记一道题吧</p><p>明天没有考试</p>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.12省选模拟</title>
      <link href="/2019/03/12/3-12%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/"/>
      <url>/2019/03/12/3-12%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-Mas的仙人掌"><a href="#T1-Mas的仙人掌" class="headerlink" title="T1 Mas的仙人掌"></a>T1 Mas的仙人掌</h1><p><img src="https://i.loli.net/2019/03/12/5c875640e1010.png" alt="1552373303468"></p><p><img src="https://i.loli.net/2019/03/12/5c8756409986a.png" alt="1552373270208"></p><p>考虑每一条非树边的贡献</p><p>首先它不能掉落$(1-p_i)$，而且所有与它有交的边都必须掉落$(p_i)$</p><p>那么显然有</p><script type="math/tex; mode=display">E_i=(1-p_i)\prod_{j与i有交}p_j</script><p>所以关键在于如何求所有与它有交的边的$\prod p_j$</p><p>首先我们考虑一个比较基础的问题：如何判断两条路径是否有交</p><p>假设这两条路径分别是$(a,b),(c,d)$</p><p>如果是判断点相交，那么我们有结论：</p><p><strong>如果两条路径有公共点，那么其中一条路径的$lca$一定在另一条路径上</strong></p><p>如果是判断边相交，我们可以将这个结论推广</p><p><strong>如果两条路径有公共边，那么其中一条路径的$lca$的左右两条边一定至少有一条也在另一条路径上</strong></p><p><img src="https://i.loli.net/2019/03/12/5c875be982e11.png" alt="1552374756301"></p><p>我们分两种情况讨论（假设当前需要求的路径是$u,v$）：</p><ol><li>$u,v$的$lca$的左右两边中至少有一条是在另一条路径上</li></ol><p>那么此时有三种可能：只有$l,lca$是公共边、只有$r,lca$是公共边、$(l,lca),(r,lca)$都是公共边</p><p>对于前两种可能，我们需要求出覆盖了$l,lca$或者$r,lca$的路径的$\prod p_i$，这个可以直接用树上差分维护</p><p>对于第三种可能，我们发现前两种可能都包含了这种情况，也就是说我们多乘了一个$p_i$。好在此时两条路径的$lca$一定是相同的，那么我们维护一个<code>map</code>，<code>map[l][r]</code>表示所有$u$所对应的儿子是$l$，$v$所对应的儿子是$r$的路径的$p$的乘积，把$(u,v)$的答案除以这个值</p><p>所以此时$W_{u,v}=\frac{V_{l,lca}*V_{r,lca}}{map[l][r]},V$即是边的权值</p><ol><li>另一条路径的$lca$的左右两边中至少有一条在$u,v$上，且不是$(l,lca),(r,lca) $</li></ol><p>那么我们知道此时这两条边不可能同时出现在$u,v$上</p><p>我们并不需要具体地知道究竟是那条边成为了公共点，我们只需要让这条公共边满足在$u,l$上，或者在$v,r$上</p><p>我们另外维护一个标记，每次加入一条路径$u,v$时，就把$(l,lca),(r,lca)$这两条路径的这个标记乘上$p_i$，最后再做一个前缀积，即我们只在这两条边上维护这条路径的贡献</p><p>查询的时候直接就查$u,l$路径上所有边这个标记的乘积，以及$v,r$路径上所有乘积就可以了</p><p>所以此时$W_{u,v}=\frac{V_{u,l}}{V_{v,r}}$，这里的$V$是树上前缀积的形式</p><p>把这两种情况的答案加起来即可</p><p>最后说一下如何更新</p><p>之前使用了两个标记，假设分别为<code>tag1, tag2</code></p><p>首先要将$u,v$这条路径上所有的边的<code>tag1</code>乘上$p_i$，这是覆盖了某条边的路径的概率乘积</p><p>然后求出$l,r$，将$(l,lca),(r,lca)$这两条边的<code>tag2</code>乘上$p_i$，即在这条边上处理情况2的乘积</p><p>最后再一遍<code>dfs</code>，求出<code>tag1</code>，同时将<code>tag2</code>处理成前缀积的形式</p><p>然后就可以了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000010</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> zero, mul;</span><br><span class="line">    Data() &#123;&#125;</span><br><span class="line">    Data(<span class="keyword">int</span> x) &#123;<span class="keyword">if</span> (x) zero = <span class="number">0</span>, mul = x; <span class="keyword">else</span> zero = mul = <span class="number">1</span>;&#125;</span><br><span class="line">    Data(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : zero(x), mul(y) &#123;&#125;</span><br><span class="line">    Data <span class="keyword">operator</span> * (<span class="keyword">const</span> Data &amp;b) &#123;<span class="keyword">return</span> Data(zero + b.zero, (LL)mul * b.mul % mod);&#125;</span><br><span class="line">    Data <span class="keyword">operator</span> / (<span class="keyword">const</span> Data &amp;b) &#123;<span class="keyword">return</span> Data(zero - b.zero, (LL)mul * Pow(b.mul, mod - <span class="number">2</span>) % mod);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> zero ? <span class="number">0</span> : mul;&#125;</span><br><span class="line">&#125; tag1[N], tag2[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fa[N][<span class="number">21</span>], dep[N]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    dep[u] = dep[f] + <span class="number">1</span>, fa[u][<span class="number">0</span>] = f, tag1[u] = tag2[u] = Data(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20</span>;i++) fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[a] &lt; dep[b]) swap(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>;i &gt;= <span class="number">0</span>;i--) <span class="keyword">if</span> (dep[fa[a][i]] &gt;= dep[b]) a = fa[a][i];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>;i &gt;= <span class="number">0</span>;i--) <span class="keyword">if</span> (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i];</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Jump</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>;i &gt;= <span class="number">0</span>;i--) <span class="keyword">if</span> (x &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">        a = fa[a][i];</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;lca, <span class="keyword">int</span> &amp;g1, <span class="keyword">int</span> &amp;g2)</span> </span>&#123;</span><br><span class="line">    lca = LCA(a, b), g1 = g2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a != lca) g1 = Jump(a, dep[a] - dep[lca] - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (b != lca) g2 = Jump(b, dep[b] - dep[lca] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) &#123;</span><br><span class="line">            tag2[e[i].to] = tag2[e[i].to] * tag2[u];</span><br><span class="line">            dfs2(e[i].to, u);</span><br><span class="line">            tag1[u] = tag1[u] * tag1[e[i].to];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, Data&gt; G[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Data x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lca, g1, g2; Get(a, b, lca, g1, g2);</span><br><span class="line">    tag1[a] = tag1[a] * x, tag1[b] = tag1[b] * x, tag1[lca] = tag1[lca] / (x * x);</span><br><span class="line">    <span class="keyword">if</span> (g1) tag2[g1] = tag2[g1] * x; <span class="keyword">if</span> (g2) tag2[g2] = tag2[g2] * x;</span><br><span class="line">    <span class="keyword">if</span> (g1 &amp;&amp; g2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g1 &gt; g2) swap(g1, g2);</span><br><span class="line">        <span class="keyword">if</span> (G[g1].count(g2)) G[g1][g2] = G[g1][g2] * x;</span><br><span class="line">        <span class="keyword">else</span> G[g1][g2] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> Data <span class="title">query</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lca, g1, g2; Get(a, b, lca, g1, g2); <span class="function">Data <span class="title">res</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (g1) res = res * tag1[g1] * tag2[a] / tag2[g1]; </span><br><span class="line">    <span class="keyword">if</span> (g2) res = res * tag1[g2] * tag2[b] / tag2[g2];</span><br><span class="line">    <span class="keyword">if</span> (g1 &amp;&amp; g2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g1 &gt; g2) swap(g1, g2);</span><br><span class="line">        <span class="keyword">if</span> (G[g1].count(g2)) res = res / G[g1][g2];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> A[N], B[N], C[N], __rd;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RD (read(__rd), __rd)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"cactus1.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>), freopen(<span class="string">"cactus.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n = RD, m = RD;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b;i &lt; n;i++) a = RD, b = RD, adde(a, b);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) A[i] = RD, B[i] = RD, C[i] = RD, update(A[i], B[i], C[i]);</span><br><span class="line">    dfs2(<span class="number">1</span>, <span class="number">0</span>); <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">        Data res = query(A[i], B[i]);</span><br><span class="line">        res = res / Data(C[i]) * Data((mod + <span class="number">1</span> - C[i]) % mod);</span><br><span class="line">        ans = (ans + res.get()) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-Z的礼物"><a href="#T2-Z的礼物" class="headerlink" title="T2 Z的礼物"></a>T2 Z的礼物</h1><p><img src="https://i.loli.net/2019/03/12/5c8760952348b.png" alt="1552375939793"></p><p><img src="https://i.loli.net/2019/03/12/5c8760b9ee9d8.png" alt="1552375985762"></p><p>首先将所有的$a$前缀和</p><p>那么根据题意，我们可以推出这样的式子</p><script type="math/tex; mode=display">b_n=\sum_{i=1}^n\begin{Bmatrix}n\\\ i\end{Bmatrix}a_i</script><p>现在已知$b$，求$a$，那么我们可以斯特林反演一下</p><script type="math/tex; mode=display">a_n=\sum_{i=1}^n(-1)^{n-i}\begin{bmatrix}n\\\ i\end{bmatrix}b_i</script><p>对于第一类斯特林数，它的生成函数是</p><script type="math/tex; mode=display">\sum_{i=0}^n\begin{bmatrix}n\\\ i\end{bmatrix}x^i=\prod_{i=0}^{n-1}(x+i)</script><p>联系它的递推式$\begin{bmatrix}n\\\ i\end{bmatrix}=\begin{bmatrix}n - 1\\\  i - 1\end{bmatrix}+(n-1)\begin{bmatrix}n - 1\\\ i\end{bmatrix}​$可以得到</p><p>对于$\prod\limits_{i=1}^{n-1}(x+i)$，可以使用倍增<code>FFT</code></p><p>计算出$l-1$的那一行斯特林数，然后暴力推下去即可</p><p>时间复杂度$T(n)=2T(\frac n2)+n\log n=n\log^2n$</p><p>没有代码</p><h1 id="T3-Mas和Z玩游戏"><a href="#T3-Mas和Z玩游戏" class="headerlink" title="T3 Mas和Z玩游戏"></a>T3 Mas和Z玩游戏</h1><p><img src="https://i.loli.net/2019/03/12/5c87961c9fa26.png" alt="1552389643490"></p><p><img src="https://i.loli.net/2019/03/12/5c8796429f0bd.png" alt="1552389686561"></p><p>这题我是真不会</p><p>还是先贴一下题解，之后再补吧</p><p><img src="https://i.loli.net/2019/03/12/5c879699907ef.png" alt="1552389777322"></p><p><img src="https://i.loli.net/2019/03/12/5c8796bb7707a.png" alt="1552389813455"></p><p><img src="https://i.loli.net/2019/03/12/5c8796e99a5f9.png" alt="1552389856504"></p><p>就这样吧</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次比赛一般，第一题没有写炸，但是第二题该拿的45分只拿了5分，是一个细节错误</p><p>本来第二题还是有希望想出正解的，但是我在想到那个生成函数之后以为计算它是$n^2$的，就没写</p><p>还是需要深入思考</p>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BJOI2018 治疗之雨</title>
      <link href="/2019/03/11/BJOI2018-%E6%B2%BB%E7%96%97%E4%B9%8B%E9%9B%A8/"/>
      <url>/2019/03/11/BJOI2018-%E6%B2%BB%E7%96%97%E4%B9%8B%E9%9B%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4457" target="_blank" rel="noopener">题目链接</a></p><p>表示并不会$n^2$高斯消元做法</p><p>如果用<code>dp[i]</code>表示当前为i，到0还需要进行操作数的期望值，那么显然有转移</p><script type="math/tex; mode=display">dp_0 = 0\\\dp_1 = G_{1,0}dp_0 + G_{1,1}dp_1 + G_{1,2}dp_2 + 1\\\\cdots\\\dp_{n-1} = G_{n-1,0}dp_0 + G_{n-1,1}dp_1 + \cdots + G_{n-1,n}dp_n + 1\\\dp_n = G_{n,0}dp_0 + G_{n,1}dp_1 + \cdots + G_{n,n}dp_n + 1</script><p>其中，G表示系数矩阵，<code>G[i][j]</code>表示进行一次操作后，i变成j的概率</p><p>首先预处理<code>f[i]</code>表示一次操作中，对第一个数减i的概率</p><p>那么有</p><script type="math/tex; mode=display">f[i]=\frac{C_i^km^{k-i}}{(m+1)^k}</script><p>这个式子的意思是，一共有k次-1的操作，其中选i次对第一个数-1，剩下的k-i次对剩余的m个数减，方案总数为$(m+1)^k$</p><p>然后求G就很方便了</p><p>这个dp转移的时候与后面的项有关系，所以使用高斯消元</p><p>等等，$n=1500$高斯消元？</p><p>观察到这个矩阵比较特殊，根据玄学方法可以将高斯消元优化成$n^2$，但是我不会</p><p>所以说一下另一个奇妙的方法</p><p>注意到<code>dp[i]</code>转移的时候与<code>dp[i+1]</code>有关系，所以把上面的转移方程移项，把右边的<code>dp[i+1]</code>移到左边来</p><p>此时就可以按照普通的<code>dp</code>进行转移了</p><p>但是有一个问题，就是无法求出<code>dp[1]</code></p><p>那么我们可以设<code>dp[1]=x</code></p><p>注意此时表示<code>dp[n]</code>的有两个方程，那么我们求出<code>dp[n]</code>的这两种表示，求一次一元一次方程就可以得到x了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1510</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">int</span> G[N][N], f[N]; <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    Data(<span class="keyword">int</span> _x = <span class="number">0</span>, <span class="keyword">int</span> _y = <span class="number">0</span>) : x(_x), y(_y) &#123;&#125;</span><br><span class="line">    Data <span class="keyword">operator</span> + (Data b) &#123;<span class="keyword">return</span> Data(((LL)mod + x + b.x) % mod, ((LL)mod + y + b.y) % mod);&#125;</span><br><span class="line">    Data <span class="keyword">operator</span> - (Data b) &#123;<span class="keyword">return</span> *<span class="keyword">this</span> + Data(-b.x, -b.y);&#125;</span><br><span class="line">    Data <span class="keyword">operator</span> * (<span class="keyword">int</span> b) &#123;<span class="keyword">return</span> Data((LL)x * b % mod, (LL)y * b % mod);&#125;</span><br><span class="line">    Data <span class="keyword">operator</span> / (<span class="keyword">int</span> b) &#123;<span class="keyword">return</span> *<span class="keyword">this</span> * Pow(b, mod - <span class="number">2</span>);&#125;</span><br><span class="line">&#125; dp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T), dp[<span class="number">1</span>] = Data(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, p, m, k; <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;p, &amp;m, &amp;k);</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">0</span>) &#123;<span class="built_in">printf</span>(<span class="string">"0\n"</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &lt;= <span class="number">1</span>) &#123;<span class="built_in">printf</span>(<span class="string">"-1\n"</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span> (p == n) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, max(<span class="number">1</span>, (p - <span class="number">2</span>) / (k - <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, max(<span class="number">1</span>, (p + k - <span class="number">2</span>) / (k - <span class="number">1</span>)));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) f[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, res = <span class="number">1</span>;i &lt;= min(k, n);i++, res = (LL)res * Pow(i, mod - <span class="number">2</span>) % mod * (k - i + <span class="number">1</span>) % mod) </span><br><span class="line">            f[i] = (LL)res * Pow(m, k - i) % mod * Pow(Pow(m + <span class="number">1</span>, k), mod - <span class="number">2</span>) % mod;</span><br><span class="line">        <span class="keyword">int</span> tmp = Pow(m + <span class="number">1</span>, mod - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= min(i + <span class="number">1</span>, n);++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == n) G[i][j] = f[i - j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j != i + <span class="number">1</span>) G[i][j] = ((LL)f[i - j] * (mod + <span class="number">1</span> - tmp) + (LL)f[i + <span class="number">1</span> - j] * tmp) % mod;</span><br><span class="line">                <span class="keyword">else</span> G[i][j] = (LL)f[i + <span class="number">1</span> - j] * tmp % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n &amp;&amp; flag;i++) &#123;</span><br><span class="line">            dp[i] = Data(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; i;j++) dp[i] = dp[i] + dp[j] * G[i - <span class="number">1</span>][j];</span><br><span class="line">            dp[i] = (dp[i] - dp[i - <span class="number">1</span>]) / (mod - G[i - <span class="number">1</span>][i]);</span><br><span class="line">            <span class="keyword">if</span> (!G[i - <span class="number">1</span>][i]) flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">Data <span class="title">other</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n &amp;&amp; flag;i++) other = other + dp[i] * G[n][i];</span><br><span class="line">        other = other / ((<span class="number">1</span> - G[n][n] + mod) % mod);</span><br><span class="line">        <span class="keyword">if</span> (G[n][n] == <span class="number">1</span> || dp[n].x == other.x) flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> X = (LL)(other.y - dp[n].y + mod) % mod * Pow((dp[n].x - other.x + mod) % mod, mod - <span class="number">2</span>) % mod;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ((LL)dp[p].x * X + dp[p].y) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高斯消元 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BJOI2017 喷式水战改</title>
      <link href="/2019/03/11/BJOI2017-%E5%96%B7%E5%BC%8F%E6%B0%B4%E6%88%98%E6%94%B9/"/>
      <url>/2019/03/11/BJOI2017-%E5%96%B7%E5%BC%8F%E6%B0%B4%E6%88%98%E6%94%B9/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3991" target="_blank" rel="noopener">题目链接</a></p><p>平衡树维护dp</p><p>对于平衡树上的一个点，维护<code>f[i][j]</code>表示它的子树所表示的这段区间内，从状态i开始，以状态j结束，能获得的最大收益</p><p>显然有一个结论，对于一段连续的、并且a、b、c值都相等的燃料，一定有一种最优的方案使得这一段燃料的状态都相同</p><p>所以对把每一次插入的区间压缩成一个点，同时分裂插入位置所在的节点</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">int</span> fa[N], ch[<span class="number">2</span>][N], ncnt, cnt[N];LL F[<span class="number">4</span>][<span class="number">4</span>][N], G[<span class="number">4</span>][<span class="number">4</span>][N], size[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>;len &lt;= <span class="number">4</span>;len++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>, end;start + len - <span class="number">1</span> &lt;= <span class="number">3</span>;start++)</span><br><span class="line">            end = start + len - <span class="number">1</span>, F[start][end][u] = G[start][end][u] = max(F[start][end - <span class="number">1</span>][u], F[start + <span class="number">1</span>][end][u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">create</span><span class="params">(LL val[], <span class="keyword">int</span> f, <span class="keyword">int</span> tot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = ++ncnt; fa[u] = f, cnt[u] = size[u] = tot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">3</span>;i++) F[i][i][u] = val[i % <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">return</span> calc(u), ncnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    size[u] = size[ch[<span class="number">0</span>][u]] + cnt[u] + size[ch[<span class="number">1</span>][u]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt;= <span class="number">3</span>; start++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = start; end &lt;= <span class="number">3</span>;end++) &#123;</span><br><span class="line">            G[start][end][u] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start;i &lt;= end;i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt;= end;j++)</span><br><span class="line">                    G[start][end][u] = max(G[start][end][u], G[start][i][ch[<span class="number">0</span>][u]] + F[i][j][u] + G[j][end][ch[<span class="number">1</span>][u]]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> son)</span> </span>&#123;fa[u] = f, ch[son][f] = u;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">child</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;<span class="keyword">return</span> u == ch[<span class="number">1</span>][fa[u]];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f = fa[u], ff = fa[f], tmp = child(u), tmp1 = child(f);</span><br><span class="line">    connect(ch[tmp ^ <span class="number">1</span>][u], f, tmp), connect(f, u, tmp ^ <span class="number">1</span>), connect(u, ff, tmp1);</span><br><span class="line">    pushup(f), pushup(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> f;fa[u];rotate(u)) <span class="keyword">if</span> (fa[f = fa[u]]) rotate(child(u) ^ child(f) ? u : f);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Kth</span><span class="params">(<span class="keyword">int</span> u, LL k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size[ch[<span class="number">0</span>][u]] &lt; k &amp;&amp; size[u] - size[ch[<span class="number">1</span>][u]] &gt;= k) <span class="keyword">return</span> splay(u), u;</span><br><span class="line">    <span class="keyword">return</span> k &lt;= size[ch[<span class="number">0</span>][u]] ? Kth(ch[<span class="number">0</span>][u], k) : Kth(ch[<span class="number">1</span>][u], k - size[u] + size[ch[<span class="number">1</span>][u]]);</span><br><span class="line">&#125;</span><br><span class="line">LL input[<span class="number">3</span>], tmp[<span class="number">3</span>], del1[<span class="number">3</span>], del2[<span class="number">3</span>], del3[<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ch[<span class="number">0</span>][<span class="number">0</span>] = create(input, <span class="number">0</span>, <span class="number">1</span>); <span class="keyword">int</span> q; LL ls = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        LL p; <span class="keyword">int</span> tot, now; <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld%d"</span>, &amp;p, &amp;input[<span class="number">0</span>], &amp;input[<span class="number">1</span>], &amp;input[<span class="number">2</span>], &amp;tot), p++, now = Kth(ch[<span class="number">0</span>][<span class="number">0</span>], p);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++) tmp[i] = F[i][i][now] / cnt[now];</span><br><span class="line">        LL slice = p - size[ch[<span class="number">0</span>][now]];<span class="comment">// size: 1 -&gt; slice - 1, slice -&gt; size</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++) del1[i] = tmp[i] * (slice - <span class="number">1</span>), del2[i] = input[i] * tot, del3[i] = tmp[i] * (cnt[now] - slice + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> a = create(del2, now, tot), b = create(del3, a, cnt[now] - slice + <span class="number">1</span>); ch[<span class="number">1</span>][a] = b;</span><br><span class="line">        cnt[now] = slice - <span class="number">1</span>, connect(ch[<span class="number">1</span>][now], b, <span class="number">1</span>), ch[<span class="number">1</span>][now] = a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">3</span>;i++) F[i][i][now] = del1[i % <span class="number">3</span>];</span><br><span class="line">        calc(now), pushup(b), pushup(a), pushup(now);</span><br><span class="line">        LL ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">3</span>;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt;= <span class="number">3</span>;j++) ans = max(ans, G[i][j][now]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans - ls), ls = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> splay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BJOI2017 树的难题</title>
      <link href="/2019/03/11/BJOI2017-%E6%A0%91%E7%9A%84%E9%9A%BE%E9%A2%98/"/>
      <url>/2019/03/11/BJOI2017-%E6%A0%91%E7%9A%84%E9%9A%BE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3714" target="_blank" rel="noopener">题目链接</a></p><p>边数在l到r之间。。。那么这题就是点分治跑不掉了</p><p>由于是统计的每一段颜色的权值之和，所以对于一条到分治中心的路径，我们需要保存路径长度、权值之和、顶端的颜色这三个值</p><p>如果直接合并的话，时间复杂度最坏是$n^2$，呵呵</p><p>所以我们考虑合并时的两种情况，分别进行优化</p><h2 id="1-两条路径的顶端颜色不同"><a href="#1-两条路径的顶端颜色不同" class="headerlink" title="1.两条路径的顶端颜色不同"></a>1.两条路径的顶端颜色不同</h2><p>由于顶端颜色不同，那么这两条路径一定来自于两棵不同的子树</p><p>如果我们按照路径的顶端颜色排序，那么对于路径i，它所应当匹配的另一条路径是排在i之前、顶端颜色与i不同、路径长度在一个区间之内的权值之和最大的路径</p><p>也就是说，我们需要实现一个东西，可以支持单点修改、区间查最大值</p><p>上线段树</p><h2 id="2-两条路径的顶端颜色相同"><a href="#2-两条路径的顶端颜色相同" class="headerlink" title="2.两条路径的顶端颜色相同"></a>2.两条路径的顶端颜色相同</h2><p>那么这时有两种情况：来自同一棵子树；来自不同子树</p><p>第一种情况显然是我们不希望统计到的，所以我们对于每一条路径多维护一个值，表示分治中心到这条链的顶端的那条边的编号</p><p>编号相同，则表示来自同一棵子树</p><p>模仿之前的方法，如果两条路径的顶端颜色一样，则对那条边的编号进行排序，这样就可以保证编号相同的路径排在一起。</p><p>然后再开一颗线段树维护区间最大值即可</p><p>注意，这是一棵需要实现$O(1)$清空的线段树</p><p>方法很简单，直接打个标记即可</p><p>时间复杂度$n\log^2 n$，然而貌似比很多$n\log n$的还要快</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">2e9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> mx, tag;&#125; T[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123;T[<span class="number">1</span>].mx = -INF, T[<span class="number">1</span>].tag = <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;T[rt &lt;&lt; <span class="number">1</span>].mx = T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].mx = -INF, T[rt &lt;&lt; <span class="number">1</span>].tag = T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].tag = <span class="number">1</span>, T[rt].tag = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> at, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;T[rt].mx = max(T[rt].mx, x); <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; T[rt].mx = max(T[rt].mx, x);</span><br><span class="line">        <span class="keyword">if</span> (T[rt].tag) pushdown(rt);</span><br><span class="line">        <span class="keyword">if</span> (at &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, at, x);</span><br><span class="line">        <span class="keyword">else</span> update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, at, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end &lt; l || start &gt; r) <span class="keyword">return</span> -INF;</span><br><span class="line">        <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) <span class="keyword">return</span> T[rt].mx;</span><br><span class="line">        <span class="keyword">if</span> (T[rt].tag) <span class="keyword">return</span> -INF;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, ans = -INF;</span><br><span class="line">        <span class="keyword">if</span> (start &lt;= mid) ans = max(ans, query(rt &lt;&lt; <span class="number">1</span>, l, mid, start, end));</span><br><span class="line">        <span class="keyword">if</span> (end &gt; mid) ans = max(ans, query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, start, end));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; A, B;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to, next, c;&#125; e[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from], c&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to], c&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> size[N], vis[N], val[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getsize</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    size[u] = vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to]) size[u] += Getsize(e[i].to);</span><br><span class="line">    <span class="keyword">return</span> vis[u] = <span class="number">0</span>, size[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getroot</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tot)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], tmp;i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to] &amp;&amp; (tmp = Getroot(e[i].to, tot))) </span><br><span class="line">            <span class="keyword">return</span> vis[u] = <span class="number">0</span>, tmp;</span><br><span class="line">    <span class="keyword">return</span> vis[u] = <span class="number">0</span>, size[u] &gt;= (tot &gt;&gt; <span class="number">1</span>) ? u : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span><span class="keyword">int</span> from, dis, len;&#125; q[N];</span><br><span class="line"><span class="keyword">int</span> qcnt = <span class="number">0</span>, mx, L, R, ans = -INF;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> from, <span class="keyword">int</span> ls, <span class="keyword">int</span> dis, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    q[++qcnt] = (Data)&#123;from, dis, len&#125;, vis[u] = <span class="number">1</span>, mx = max(mx, len);</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= len &amp;&amp; len &lt;= R) ans = max(ans, dis);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to])</span><br><span class="line">            DFS(e[i].to, from, e[i].c, ls == e[i].c ? dis : dis + val[e[i].c], len + <span class="number">1</span>);</span><br><span class="line">    vis[u] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    u = Getroot(u, Getsize(u)), vis[u] = <span class="number">1</span>, qcnt = mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to]) DFS(e[i].to, i, e[i].c, val[e[i].c], <span class="number">1</span>);</span><br><span class="line">    sort(q + <span class="number">1</span>, q + qcnt + <span class="number">1</span>, [=](Data a, Data b) &#123;<span class="keyword">return</span> e[a.from].c &lt; e[b.from].c || (e[a.from].c == e[b.from].c &amp;&amp; a.from &lt; b.from);&#125;), A.Clear(), B.Clear();</span><br><span class="line">    <span class="keyword">int</span> cur1 = <span class="number">0</span>, cur2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= qcnt;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[q[i].from].c != e[q[i - <span class="number">1</span>].from].c) B.Clear(), cur2 = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (q[cur2 + <span class="number">1</span>].from != q[i].from) cur2++, B.update(<span class="number">1</span>, <span class="number">1</span>, mx, q[cur2].len, q[cur2].dis);</span><br><span class="line">        <span class="keyword">while</span> (e[q[cur1 + <span class="number">1</span>].from].c != e[q[i].from].c) cur1++, A.update(<span class="number">1</span>, <span class="number">1</span>, mx, q[cur1].len, q[cur1].dis);</span><br><span class="line">        ans = max(ans, A.query(<span class="number">1</span>, <span class="number">1</span>, mx, L - q[i].len, R - q[i].len) + q[i].dis);</span><br><span class="line">        ans = max(ans, B.query(<span class="number">1</span>, <span class="number">1</span>, mx, L - q[i].len, R - q[i].len) + q[i].dis - val[e[q[i].from].c]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to]) Build(e[i].to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;L, &amp;R);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b, c;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c), adde(a, b, c);</span><br><span class="line">    Build(<span class="number">1</span>), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 点分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BJOI2017 魔法咒语</title>
      <link href="/2019/03/11/BJOI2017-%E9%AD%94%E6%B3%95%E5%92%92%E8%AF%AD/"/>
      <url>/2019/03/11/BJOI2017-%E9%AD%94%E6%B3%95%E5%92%92%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3715" target="_blank" rel="noopener">题目链接</a></p><p>感觉这题没啥好说的。。。就是对数据的分类讨论差评</p><p>首先对于所有的危险串建AC自动机，标记危险节点，转移的时候不从危险节点转移</p><p>然后预处理<code>to[i][j]</code>，即从自动机的i号节点出发，按照第j个基本串走，最后到达的节点，注意如果中途有危险节点就是-1</p><p>对于前60%的数据，直接dp即可，用<code>dp[i][j]</code>表示当前串长度为i，走到自动机的j号节点的方案数</p><p>对于后面40%的数据，没法直接dp了。注意到基本串的长度都特别小，直接上矩阵乘法</p><p>如果基本串的长度都为1，那么建一个$n*n$的矩阵就好了</p><p>否则要同时保存长度为$len-1,len-2$的方案，建一个$(2*n)^2$的矩阵</p><p>然后快速幂即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 110</span></span><br><span class="line"><span class="keyword">int</span> ncnt, trie[N][<span class="number">26</span>], val[N]; <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> s[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, c = s[i] - <span class="string">'a'</span>;i &lt;= len;i++, c = s[i] - <span class="string">'a'</span>) </span><br><span class="line">        <span class="keyword">if</span> (trie[now][c]) now = trie[now][c];</span><br><span class="line">        <span class="keyword">else</span> now = trie[now][c] = ++ncnt;</span><br><span class="line">    val[now] = <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> fail[N]; <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, now;i &lt; <span class="number">26</span>;i++)</span><br><span class="line">        <span class="keyword">if</span> (now = trie[<span class="number">0</span>][i]) q.push(now);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, f, son;i &lt; <span class="number">26</span>;i++) </span><br><span class="line">            <span class="keyword">if</span> (trie[now][i]) &#123;</span><br><span class="line">                f = fail[now]; <span class="keyword">while</span> (f &amp;&amp; !trie[f][i]) f = fail[f];</span><br><span class="line">                son = trie[now][i], fail[son] = trie[f][i], val[son] |= val[fail[son]], q.push(son);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">char</span> s[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, c;i &lt;= len;i++) &#123;</span><br><span class="line">        c = s[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">while</span> (now &amp;&amp; !trie[now][c]) now = fail[now]; now = trie[now][c];</span><br><span class="line">        <span class="keyword">if</span> (val[now]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> basic[<span class="number">51</span>][N], s[<span class="number">51</span>][N]; <span class="keyword">int</span> len[N], to[N][N], dp[N][N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span> * N][<span class="number">2</span> * N], n;</span><br><span class="line">    Matrix(<span class="keyword">int</span> _n = <span class="number">0</span>) : n(_n) &#123;<span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));&#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span> * (Matrix b) &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">c</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= n;j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= n;k++)</span><br><span class="line">                    c.a[i][j] = (c.a[i][j] + (LL)a[i][k] * b.a[k][j]) % mod;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Matrix <span class="title">Pow</span><span class="params">(Matrix x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">res</span><span class="params">(x.n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= res.n;i++) res.a[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = x * x) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = res * x;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve1</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">res</span><span class="params">(ncnt)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= ncnt;i++)</span><br><span class="line">        <span class="keyword">if</span> (!val[i]) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">            <span class="keyword">if</span> (~to[i][j]) res.a[to[i][j]][i]++;</span><br><span class="line">    res = Pow(res, l); <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= ncnt;i++) ans = (ans + res.a[i][<span class="number">0</span>]) % mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve2</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">res</span><span class="params">(<span class="number">2</span> * ncnt + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ncnt + <span class="number">1</span>;i &lt;= <span class="number">2</span> * ncnt + <span class="number">1</span>;i++) res.a[i][i - ncnt - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= ncnt;i++)</span><br><span class="line">        <span class="keyword">if</span> (!val[i]) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">            <span class="keyword">if</span> (~to[i][j]) res.a[to[i][j]][i + (len[j] == <span class="number">1</span> ? <span class="number">0</span> : ncnt + <span class="number">1</span>)]++;</span><br><span class="line">    res = Pow(res, l); <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= ncnt;i++) ans = (ans + res.a[i][<span class="number">0</span>]) % mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, l, mx = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;l);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, basic[i] + <span class="number">1</span>), len[i] = <span class="built_in">strlen</span>(basic[i] + <span class="number">1</span>), mx = max(mx, len[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i] + <span class="number">1</span>), insert(s[i], <span class="built_in">strlen</span>(s[i] + <span class="number">1</span>));</span><br><span class="line">    BFS();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= ncnt;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++) </span><br><span class="line">            to[i][j] = val[i] ? <span class="number">-1</span> : query(i, basic[j], len[j]);</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= l;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= ncnt;j++)</span><br><span class="line">                <span class="keyword">if</span> (!val[j] &amp;&amp; dp[i][j]) <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= n;k++)</span><br><span class="line">                    <span class="keyword">if</span> (~to[j][k] &amp;&amp; i + len[k] &lt;= l) (dp[i + len[k]][to[j][k]] += dp[i][j]) %= mod;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= ncnt;i++) (ans += dp[l][i]) %= mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mx == <span class="number">1</span> ? solve1(n, l) : solve2(n, l));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BJOI2017 机动训练</title>
      <link href="/2019/03/11/BJOI2017-%E6%9C%BA%E5%8A%A8%E8%AE%AD%E7%BB%83/"/>
      <url>/2019/03/11/BJOI2017-%E6%9C%BA%E5%8A%A8%E8%AE%AD%E7%BB%83/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3713" target="_blank" rel="noopener">题目链接</a></p><p>显然一条合法的机动路径就是一直朝某个象限走，可以走坐标轴的路径</p><p>对于每一条机动路径，它的权值是经过地形与它相同的机动路径条数</p><p>也就是每种机动路径数量的平方和</p><p>对于这个平方，我们可以换一种统计方案，即两条机动路径，相同的方案数</p><p>分别枚举两条机动路径的朝向</p><p>记<code>dp[i][j][p][q]</code>表示<strong>在当前枚举的方向上</strong>第一条机动路径从$(i,j)$出发，第二条机动路径从$(p,q)$出发，相同的方案数</p><p>由于可以走坐标轴，这样会重复统计一些路径</p><p>比如当前选定了第一条路径走第二象限，我们会发现统计出来的结果与第一条路径走第一象限有交集</p><p>怎么办呢？减去重复的即可，也就是第一条路径只沿y正半轴走的方案数</p><p>记<code>f[i][j][p][q]</code>为第一条路径的方向为$(i,j)$，第二条路径的方向为$(p,q)$时的答案</p><p>先处理一下第一条路径和第二条路径的合法位移即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 41</span></span><br><span class="line"><span class="keyword">char</span> G[N][N]; <span class="keyword">int</span> dx[<span class="number">2</span>][N], dy[<span class="number">2</span>][N], cnt1, cnt2, n, m;</span><br><span class="line"><span class="keyword">int</span> dp[N][N][N][N], f[<span class="number">3</span>][<span class="number">3</span>][<span class="number">3</span>][<span class="number">3</span>]; <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (min(min(x, y), min(p, q)) &lt; <span class="number">1</span> || max(x, p) &gt; n || max(y, q) &gt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (G[x][y] != G[p][q]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (~dp[x][y][p][q]) <span class="keyword">return</span> dp[x][y][p][q];</span><br><span class="line">    <span class="keyword">int</span> &amp;sum = dp[x][y][p][q]; sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= cnt1;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= cnt2;j++) </span><br><span class="line">            (sum += DP(x + dx[<span class="number">0</span>][i], y + dy[<span class="number">0</span>][i], p + dx[<span class="number">1</span>][j], q + dy[<span class="number">1</span>][j])) %= mod;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">AC</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;sum = f[x + <span class="number">1</span>][y + <span class="number">1</span>][p + <span class="number">1</span>][q + <span class="number">1</span>]; cnt1 = cnt2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (~sum) <span class="keyword">return</span> sum; <span class="keyword">else</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">-1</span>;i &lt;= <span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">if</span> ((!i) || i == x) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">-1</span>;j &lt;= <span class="number">1</span>;j++)</span><br><span class="line">            <span class="keyword">if</span> ((i | j) &amp;&amp; ((!j) || j == y)) </span><br><span class="line">                dx[<span class="number">0</span>][++cnt1] = i, dy[<span class="number">0</span>][cnt1] = j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">-1</span>;i &lt;= <span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">if</span> ((!i) || i == p) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">-1</span>;j &lt;= <span class="number">1</span>;j++)</span><br><span class="line">            <span class="keyword">if</span> ((i | j) &amp;&amp; ((!j) || j == q)) </span><br><span class="line">                dx[<span class="number">1</span>][++cnt2] = i, dy[<span class="number">1</span>][cnt2] = j;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k= <span class="number">1</span>;k &lt;= n;k++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>;l &lt;= m;l++)</span><br><span class="line">                    (sum += DP(i, j, k, l)) %= mod;</span><br><span class="line">    f[p + <span class="number">1</span>][q + <span class="number">1</span>][x + <span class="number">1</span>][y + <span class="number">1</span>] = f[-p + <span class="number">1</span>][-q + <span class="number">1</span>][-x + <span class="number">1</span>][-y + <span class="number">1</span>] = f[-x + <span class="number">1</span>][-y + <span class="number">1</span>][-p + <span class="number">1</span>][-q + <span class="number">1</span>] = sum;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">AC</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    sum = (sum + (LL)AC(x, y, <span class="number">1</span>, <span class="number">1</span>) + AC(x, y, <span class="number">1</span>, <span class="number">-1</span>) + AC(x, y, <span class="number">-1</span>, <span class="number">1</span>) + AC(x, y, <span class="number">-1</span>, <span class="number">-1</span>)) % mod;</span><br><span class="line">    sum = (sum - (LL)AC(x, y, <span class="number">1</span>, <span class="number">0</span>) - AC(x, y, <span class="number">-1</span>, <span class="number">0</span>) - AC(x, y, <span class="number">0</span>, <span class="number">1</span>) - AC(x, y, <span class="number">0</span>, <span class="number">-1</span>)) % mod;</span><br><span class="line">    <span class="keyword">return</span> (sum + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m), <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>, G[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    ans = (ans + (LL)AC(<span class="number">1</span>, <span class="number">-1</span>) + AC(<span class="number">1</span>, <span class="number">1</span>) + AC(<span class="number">-1</span>, <span class="number">-1</span>) + AC(<span class="number">-1</span>, <span class="number">1</span>)) % mod;</span><br><span class="line">    ans = (ans - (LL)AC(<span class="number">1</span>, <span class="number">0</span>) - AC(<span class="number">-1</span> ,<span class="number">0</span>) - AC(<span class="number">0</span>, <span class="number">1</span>) - AC(<span class="number">0</span>, <span class="number">-1</span>)) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (ans + mod) % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BJOI2017 开车</title>
      <link href="/2019/03/11/BJOI2017-%E5%BC%80%E8%BD%A6/"/>
      <url>/2019/03/11/BJOI2017-%E5%BC%80%E8%BD%A6/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3992" target="_blank" rel="noopener">题目链接</a></p><p>显然，最优的方案一定是将所有的加油站和车按照位置排序之后一一对应</p><p>但是如何考虑修改呢？这种东西是没法维护的</p><p>我们考虑另外一种统计答案的方式</p><p>将加油站和车都想象成数轴上的一些点，其中加油站是红点，车是黑点</p><p>单独考虑数轴上每一条线段的贡献</p><p>对于一条线段i，记这条线段的长度为$len_i$，前面一共有$a_i$个红点，$b_i$个黑点，那么这条线段对答案的贡献为</p><script type="math/tex; mode=display">len_i|a_i-b_i|</script><p>由于询问中涉及到更改点的位置这个操作，我们可以将询问离线下来，先把所有在询问中即将出现的点都标记出来就可以了</p><p>现在考虑每个询问都干了啥</p><p>将一辆车从A点挪到B点（A&lt;B），那么，对于区间$[A,B-1]$，$b_i$的值都减少了1</p><p>反之，如果A&gt;B，那么对于区间$[B,A-1]$，$b_i$的值将增加1</p><p>所以，我们要实现一个这样的东西：每个点有初始权值$w_i,a_i$，操作是区间将$a_i$的值加减1，维护$\sum w_i|a_i|$</p><p>这个绝对值的符号非常讨厌，不过幸好每次操作只会增减1</p><p>考虑对一段区间$[A,B]$进行修改，我们需要首先将这段区间的$a_i$排好序，然后二分找到零点，具体来说</p><p><img src="https://0x131cc05home.files.wordpress.com/2019/02/e697a0e6a087e9a298.png?w=700" alt=""></p><p>如果排好序之后的a是这样的，此时需要将这一串a全部加上1，那么A点右方的点的绝对值都增大1，左边的点的绝对值都减小1</p><p>此时，答案增加</p><script type="math/tex; mode=display">\sum_i^{[A,D]} w_i-\sum_i^{[B,A)} w_i</script><p>如果要减少1，那么C点左方的点的绝对值都增大1，右边的点的绝对值都减少1</p><p>此时，答案增加</p><script type="math/tex; mode=display">\sum_i^{[B,C]}w_i-\sum_i^{(C,D]}w_i</script><p>为了快速更新答案，我们需要预处理w在这一段中的前缀和，同时二分找到零点</p><p>线段树显然不行，所以考虑分块</p><p>对于每一块维护w在这一块中的前缀和，以及排好序后的a数组</p><p>对于修改，边角上的两个块暴力重构，中间完整的块用一个tag数组存一下有多少修改是没有下发到每个元素上的，重构时下放。然后二分找到零点，更新答案</p><p>代码还是挺好写的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SZ = <span class="number">400</span>, N = <span class="number">50010</span>, M = <span class="number">150010</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span><span class="keyword">int</span> sum;LL dis;&#125; t[M];</span><br><span class="line"><span class="keyword">int</span> sum[M], dis[M], tag[N]; LL ans;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Data a, Data b)</span> </span>&#123;<span class="keyword">return</span> a.sum &lt; b.sum;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rebuild</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x;i &lt; x + SZ;i++) t[i].sum = sum[i], t[i].dis = dis[i];</span><br><span class="line">    sort(t + x, t + x + SZ, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x + <span class="number">1</span>;i &lt; x + SZ;i++) t[i].dis += t[i - <span class="number">1</span>].dis;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bl = (l - <span class="number">1</span>) / SZ, br = (r - <span class="number">1</span>) / SZ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = bl * SZ + <span class="number">1</span>;i &lt;= (bl + <span class="number">1</span>) * SZ;i++) sum[i] += tag[bl]; tag[bl] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (bl == br) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l;i &lt;= r;i++) ans -= <span class="built_in">abs</span>(sum[i]) * dis[i], ans += <span class="built_in">abs</span>(sum[i] += x) * dis[i];</span><br><span class="line">        rebuild(bl * SZ + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = br * SZ + <span class="number">1</span>;i &lt;= (br + <span class="number">1</span>) * SZ;i++) sum[i] += tag[br]; tag[br] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l;i &lt;= (bl + <span class="number">1</span>) * SZ;i++) ans -= <span class="built_in">abs</span>(sum[i]) * dis[i], ans += <span class="built_in">abs</span>(sum[i] += x) * dis[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = br * SZ + <span class="number">1</span>;i &lt;= r;i++) ans -= <span class="built_in">abs</span>(sum[i]) * dis[i], ans += <span class="built_in">abs</span>(sum[i] += x) * dis[i];</span><br><span class="line">        rebuild(bl * SZ + <span class="number">1</span>), rebuild(br * SZ + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = bl + <span class="number">1</span>;i &lt; br;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> L = i * SZ + <span class="number">1</span>, R = (i + <span class="number">1</span>) * SZ, mid, res = <span class="number">0</span>; tag[i] += x;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">while</span> (L &lt;= R) </span><br><span class="line">                <span class="keyword">if</span> (t[mid = (L + R) &gt;&gt; <span class="number">1</span>].sum + tag[i] &lt; <span class="number">0</span>) res = mid, L = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> R = mid - <span class="number">1</span>;</span><br><span class="line">            ans -= t[(i + <span class="number">1</span>) * SZ].dis - <span class="number">2</span> * t[res].dis;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (L &lt;= R)</span><br><span class="line">                <span class="keyword">if</span> (t[mid = (L + R) &gt;&gt; <span class="number">1</span>].sum + tag[i] &lt;= <span class="number">0</span>) res = mid, L = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> R = mid - <span class="number">1</span>;</span><br><span class="line">            ans += t[(i + <span class="number">1</span>) * SZ].dis - <span class="number">2</span> * t[res].dis;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], ncnt, id[M], to[M];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen("in.txt", "r", stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]), dis[++ncnt] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]), dis[++ncnt] = b[i];</span><br><span class="line">    <span class="keyword">int</span> q; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= q;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;id[i], &amp;to[i]), dis[++ncnt] = to[i];</span><br><span class="line">    sort(dis + <span class="number">1</span>, dis + ncnt + <span class="number">1</span>), ncnt = unique(dis + <span class="number">1</span>, dis + ncnt + <span class="number">1</span>) - dis - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) sum[a[i] = lower_bound(dis + <span class="number">1</span>, dis + ncnt + <span class="number">1</span>, a[i]) - dis]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) sum[b[i] = lower_bound(dis + <span class="number">1</span>, dis + ncnt + <span class="number">1</span>, b[i]) - dis]--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= q;i++) to[i] = lower_bound(dis + <span class="number">1</span>, dis + ncnt + <span class="number">1</span>, to[i]) - dis;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= ncnt;i++) ans += <span class="built_in">abs</span>(sum[i] += sum[i - <span class="number">1</span>]) * (dis[i] = dis[i + <span class="number">1</span>] - dis[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= ncnt;i += SZ) rebuild(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= q;i++) &#123;</span><br><span class="line"><span class="comment">//    cout &lt;&lt; a[id[i]] &lt;&lt; ' ' &lt;&lt; to[i] &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span> (a[id[i]] &lt; to[i]) update(a[id[i]], to[i] - <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[id[i]] != to[i]) update(to[i], a[id[i]] - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        a[id[i]] = to[i], <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFT与NTT基础</title>
      <link href="/2019/03/11/FFT%E4%B8%8ENTT%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/03/11/FFT%E4%B8%8ENTT%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h1><h4 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h4><p>设$a, b$是实数，形如$a+bi$的数叫做复数，其中$i$叫做<strong>虚数单位</strong></p><p>我们可以用一个复平面上的向量表示一个复数。x轴代表实数，y轴代表虚数。比如：向量$(a,b)$就表示复数$a+bi$</p><p><strong>模长</strong>：就是这个向量的长度</p><p><strong>辐角</strong>：从x正半轴逆时针旋转到这个向量的角度</p><p>复数乘法的几何意义是，模长相乘，辐角相加</p><p>代数意义：</p><script type="math/tex; mode=display">(a+bi)\*(c+di)</script><script type="math/tex; mode=display">=ac+adi+cbi+bdi^2</script><script type="math/tex; mode=display">= (ac-bd)+(ad+cb)i</script><h4 id="单位根"><a href="#单位根" class="headerlink" title="单位根"></a>单位根</h4><p>在复平面上，以原点为圆心，半径为1画圆，得到的圆叫做单位圆</p><p>将这个圆做n等分，那么我们得到了n个向量，每个向量都对应了一个<strong>n次单位根</strong></p><p>我们分别记这些单位根为$\omega_n^1,\omega_n^2,\cdots,\omega_n^n$</p><p>其中，记$\omega_n^1$为<strong>主n次单位根</strong></p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><script type="math/tex; mode=display">\omega_n^k=\cos k\frac{2\pi}{n}+i\sin k\frac{2\pi}{n}</script><p>根据单位根的定义，显然有</p><ul><li>消去定理</li></ul><script type="math/tex; mode=display">\omega_{dn}^{dk}=\omega_n^k</script><ul><li>折半定理</li></ul><p>对于任意的大于0的整数n，都有n个n次单位复根的平方的集合，等于$\frac{n}{2}$个$\frac{n}{2}$次单位复根的集合</p><p>此时显然有</p><script type="math/tex; mode=display">(\omega_n^k)^2=\omega_{n/2}^k</script><script type="math/tex; mode=display">(\omega_n^{k+\frac{n}{2}})^2=\omega_{n}^{2k+n}=\omega_n^{2k}\times\omega_n^n=\omega_n^{2k}=(\omega_n^k)^2</script><h4 id="快速傅里叶变换-FFT"><a href="#快速傅里叶变换-FFT" class="headerlink" title="快速傅里叶变换(FFT)"></a>快速傅里叶变换(FFT)</h4><p>FFT的作用是，快速计算出两个多项式相乘的结果</p><p>按照朴素的算法，假如有两个次数为n的多项式，那么我们会遍历其中一个多项式的每一项，计算它与另一个多项式的乘积</p><p>然而这样的时间复杂度是$n^2$的，也没有什么可以显著优化的地方</p><h4 id="点值表示"><a href="#点值表示" class="headerlink" title="点值表示"></a>点值表示</h4><p>我们知道，一个多项式$f(x)$可以写成$a_0x^0+a_1x^1+\cdots+a_nx^n$的形式，这被称作系数表示</p><p>而一个n次的多项式可以被n个点唯一确定</p><p>那么我们可以将主单位根的0到n-1次幂依次带入这个多项式求值，然后通过插值再把点值表达还原成系数表示</p><p>直接做显然还是$n^2$，而且还多了一堆巨大无比的常数</p><p>但是我们可以优化</p><p>设</p><script type="math/tex; mode=display">A(x)=a_0+a_1x+a_2x^2+\cdots+a_nx^n</script><p>将这个多项式按照x的幂的奇偶性分类</p><script type="math/tex; mode=display">A_1(x)=a_0+a_2x^2+\cdots+a_{n-1}x^{n-1}</script><script type="math/tex; mode=display">A_2(x)=a_1x+a_3x^3+\cdots+a_{n}x^{n}</script><p>我们可以得到</p><script type="math/tex; mode=display">A(x)=A_1(x)+A_2(x)</script><p>设</p><script type="math/tex; mode=display">A^{[1]}(x)=a_0+a_2x+\cdots+a_{n-1}x^{\frac{n}{2}}</script><script type="math/tex; mode=display">A^{[2]}(x)=a_1+a_3x+\cdots+a_{n}x^{\frac{n}{2}}</script><p>那么我们有</p><script type="math/tex; mode=display">A(x)=A^{[1]}(x^2)+xA^{[2]}(x^2)</script><p>代入单位复根$\omega_n^k(k&lt;\frac{n}{2})$，得</p><script type="math/tex; mode=display">A(\omega_n^k)=A^{[1]}(\omega_{n/2}^k)+\omega_n^kA^{[2]}(\omega_{n/2}^k)</script><p>代入另一个单位复根$\omega_n^{k+\frac{n}{2}}$，得</p><script type="math/tex; mode=display">A(\omega_n^{k+\frac{n}{2}})=A^{[1]}(\omega_{n/2}^{k+\frac{n}{2}})-\omega_n^{k}A^{[2]}(\omega_{n/2}^{k+\frac{n}{2}})</script><script type="math/tex; mode=display">=A^{[1]}(\omega_{n/2}^{k})-\omega_n^{k}A^{[2]}(\omega_{n/2}^{k})</script><p>我们发现，这两个结果只有一个符合是不同的</p><p>这就意味着，在计算第一个点值的时候，我们可以$O(1)$得到第二个点值</p><p>加上分治，可以将原问题的规模缩小一半</p><p>现在，我们可以做到$O(n\log n)$计算点值表示了</p><h4 id="快速傅里叶逆变换-IFFT"><a href="#快速傅里叶逆变换-IFFT" class="headerlink" title="快速傅里叶逆变换(IFFT)"></a>快速傅里叶逆变换(IFFT)</h4><p>假如我们知道多项式A与多项式B的点值表达</p><p>那么我们可以直接求出$A*B$的点值表达</p><p>很明显，对应相乘即可</p><p>但是我们得到的终究还是一个点值</p><p>而点值表达是不常用的，要还原成系数表达</p><p>幸运的是，这个操纵同样能在$O(n\log n)$内解决。</p><p>假设原来的多项式系数分别为$a_0,a_1,\cdots,a_n$</p><p>点值表达为$y_0,y_1,\cdots,y_n$</p><p>将这个y强制看作系数</p><p>同时，设多项式c为y在$\omega_n^0,\omega_n^{-1},\cdots,\omega_n^{-n+1}$处的点值</p><p>那么有</p><script type="math/tex; mode=display">c_k=\sum_{i=0}^{n-1}y_i(\omega_n^{-k})^i</script><script type="math/tex; mode=display">y_k=\sum_{i=0}^{n-1}a_i(\omega_n^k)^i</script><script type="math/tex; mode=display">\therefore c_k=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}a_j(\omega_n^i)^j(\omega_n^{-k})^i</script><script type="math/tex; mode=display">=\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}a_j(\omega_n^j)^i(\omega_n^{-k})^i</script><script type="math/tex; mode=display">\sum_{i=0}^{n-1}a_j\sum_{j=0}^{n-1}(\omega_n^{j-k})^i</script><p>设</p><script type="math/tex; mode=display">S(x)=\sum_{i=0}^{n-1}x^i</script><p>代入$\omega_n^k$可得</p><script type="math/tex; mode=display">S(\omega_n^k)=1+\omega_n^k+(\omega_n^k)^2+\cdots+(\omega_n^k)^{n-1}</script><p>当$k\not =0$，可得</p><script type="math/tex; mode=display">\omega_n^kS(\omega_n^k)=\omega_n^k+(\omega_n^k)^2+\cdots+(\omega_n^k)^{n-1}+(\omega_n^k)^n</script><p>两式相减，得</p><script type="math/tex; mode=display">\omega_n^kS(\omega_n^k)-S(\omega_n^k)=(\omega_n^k)^n-1</script><script type="math/tex; mode=display">S(\omega_n^k)=\frac{(\omega_n^k)^n-1}{\omega_n^k-1}</script><script type="math/tex; mode=display">=\frac{(\omega_n^n)^k-1}{\omega_n^k-1}=0</script><p>当$k=0$时，显然$S(\omega_n^0)=1$</p><p>代入之前的式子，可以得到</p><script type="math/tex; mode=display">c_k=\sum_{i=0}^{n-1}a_j\sum_{j=0}^{n-1}(\omega_n^{j-k})^i</script><script type="math/tex; mode=display">=na_k</script><script type="math/tex; mode=display">a_k=\frac{c_k}{n}</script><p>至此，点值就成功转换成系数了</p><h4 id="关于迭代FFT"><a href="#关于迭代FFT" class="headerlink" title="关于迭代FFT"></a>关于迭代FFT</h4><p>这里记一下反转后的多项式在原多项式中的下标r</p><p>有</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="关于NTT"><a href="#关于NTT" class="headerlink" title="关于NTT"></a>关于NTT</h4><p>模意义下的单位根就是原根g</p><p>有</p><script type="math/tex; mode=display">\omega_n^1\equiv g^{\frac{mod-1}{n}}</script><p>然后像FFT一样即可</p><h4 id="关于complex"><a href="#关于complex" class="headerlink" title="关于complex"></a>关于complex</h4><p>好像还是很好用的</p><p>就是有点慢</p><p>需要的话可以手写一个</p><p>目测会快2到3倍的样子</p><h1 id="部分代码实现"><a href="#部分代码实现" class="headerlink" title="部分代码实现"></a>部分代码实现</h1><h4 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 400010</span></span><br><span class="line"><span class="keyword">int</span> r[N]; <span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> type, <span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; <span class="title">Wn</span><span class="params">(<span class="built_in">cos</span>(<span class="number">2</span> * PI / mid), type * <span class="built_in">sin</span>(<span class="number">2</span> * PI / mid))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid) &#123;</span><br><span class="line">            complex&lt;double&gt; w(1, 0), t;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w *= Wn) </span><br><span class="line">                t = w * a[j + (mid &gt;&gt; <span class="number">1</span>)], a[j + (mid &gt;&gt; <span class="number">1</span>)] = a[j] - t, a[j] += t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NTT"><a href="#NTT" class="headerlink" title="NTT"></a>NTT</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">int</span> r[N]; <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> type, <span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, t, w = <span class="number">1</span>;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w = (LL)w * Wn % mod)</span><br><span class="line">                t = (LL)w * a[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后别忘了除以<code>len</code></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.11省选模拟</title>
      <link href="/2019/03/11/3-11%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/"/>
      <url>/2019/03/11/3-11%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="T1-树上四次求和"><a href="#T1-树上四次求和" class="headerlink" title="T1 树上四次求和"></a>T1 树上四次求和</h1><p><img src="https://i.loli.net/2019/03/11/5c864659de9ef.png" alt=""></p><p>本来写的100分算法，结果只有80分</p><p>发现是链的情况挂了，原因是有一个取模的地方我把<code>%=</code>写成了<code>%</code>，然后就呵呵了</p><p>考虑如何化简那个式子</p><script type="math/tex; mode=display">\sum_{i=1}^k\sum_{j=i}^kw(i,j)\\\=\sum_{i=1}^k\sum_{j=i}^k\sum_{l=i}^j\sum_{r=l}^jdis(a_l,a_r)\\\</script><p>考虑后面每一个$dis(a_l,a_r)$对答案的贡献，就是把$\sum$提到前面来</p><script type="math/tex; mode=display">=\sum_{l=1}^k\sum_{r=l}^kdis(a_l,a_r)\*l\*(k-r+1)</script><p>但是这样仍然是$n^kq$，难以承受</p><p>那么我们考虑分开维护</p><script type="math/tex; mode=display">\sum_{i=1}^n\sum_{j=i}^ndis(a_i,a_j)\*i\*(n-j+1)\\\=(n+1)\sum_{i=1}^ni\sum_{j=i}^ndis(a_i,a_j)-\sum_{i=1}^ni\sum_{j=i}^nj\*dis(a_i,a_j)</script><p>考虑将询问离线，当$n$变成$n+1$时式子将会如何变化</p><p>注意到第一项的系数$n+1​$与$n​$有关，所以把它去掉，考虑维护$\sum\limits_{i=1}^ni\sum\limits_{j=i}^ndis(a_i,a_j)​$</p><p>那么有</p><script type="math/tex; mode=display">\sum\limits_{i=1}^{n+1}i\sum\limits_{j=i}^{n+1}dis(a_i,a_j)-\sum\limits_{i=1}^ni\sum\limits_{j=i}^ndis(a_i,a_j)\\=\sum_{i=1}^ni\*dis(a_i,a_{n+1})</script><p>而对于后一项</p><script type="math/tex; mode=display">\sum_{i=1}^{n+1}i\sum_{j=i}^{n+1}j\*dis(a_i,a_j)-\sum_{i=1}^ni\sum_{j=i}^nj\*dis(a_i,a_j)\\\=(n+1)\sum_{i=1}^ni\*dis(a_i,a_{n+1})</script><p>$n+1$是已知的，所以我们只需要维护$\sum\limits_{i=1}^ni*dis(a_i,a_{n+1})$就可以了</p><p>所以现在题目变成了给你一棵树，每个点有两种颜色，初始每个点都是黑色，有两种操作：</p><ol><li>询问某个点到所有黑点的距离乘以该点编号的和</li><li>将某个白点改成黑点</li></ol><p>那么很显然，直接动态点分治就可以了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100010</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">18</span>][N], dep[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    dep[u] = dep[f] + <span class="number">1</span>, fa[<span class="number">0</span>][u] = f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">17</span>;i++) fa[i][u] = fa[i - <span class="number">1</span>][fa[i - <span class="number">1</span>][u]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[a] &lt; dep[b]) swap(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>;i &gt;= <span class="number">0</span>;i--) <span class="keyword">if</span> (dep[fa[i][a]] &gt;= dep[b]) a = fa[i][a];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>;i &gt;= <span class="number">0</span>;i--) <span class="keyword">if</span> (fa[i][a] != fa[i][b]) a = fa[i][a], b = fa[i][b];</span><br><span class="line">    <span class="keyword">return</span> a == b ? a : fa[<span class="number">0</span>][a];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Dis</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dep[a] + dep[b] - <span class="number">2</span> * dep[LCA(a, b)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[N], size[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getsize</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    vis[u] = size[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to]) size[u] += Getsize(e[i].to);</span><br><span class="line">    <span class="keyword">return</span> vis[u] = <span class="number">0</span>, size[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getroot</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tot)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u],tmp;i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to] &amp;&amp; (tmp = Getroot(e[i].to, tot)))</span><br><span class="line">            <span class="keyword">return</span> vis[u] = <span class="number">0</span>, tmp;</span><br><span class="line">    <span class="keyword">return</span> vis[u] = <span class="number">0</span>, size[u] &gt;= (tot &gt;&gt; <span class="number">1</span>) ? u : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> F[<span class="number">18</span>][N], D[<span class="number">18</span>][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    u = Getroot(u, Getsize(u)), vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to]) F[<span class="number">0</span>][Build(e[i].to)] = u;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Construct</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span> (F[<span class="number">0</span>][i]) D[<span class="number">0</span>][i] = Dis(F[<span class="number">0</span>][i], i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">17</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++) &#123;</span><br><span class="line">            F[i][j] = F[i - <span class="number">1</span>][F[<span class="number">0</span>][j]];</span><br><span class="line">            <span class="keyword">if</span> (F[i][j]) D[i][j] = Dis(F[i][j], j);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt2[N], tot2[N], cnt1[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res2 = cnt2[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">17</span> &amp;&amp; F[i][u];i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ls = i ? F[i - <span class="number">1</span>][u] : u;</span><br><span class="line">        res2 = ((res2 + (LL)cnt2[F[i][u]] - cnt1[ls] + (LL)D[i][u] * (tot2[F[i][u]] - tot2[ls])) % mod + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    (tot2[u] += id) %= mod, (cnt1[u] += (LL)D[<span class="number">0</span>][u] * id % mod) %= mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">17</span> &amp;&amp; F[i][u];i++) &#123;</span><br><span class="line">        (cnt2[F[i][u]] += (LL)D[i][u] * id % mod) %= mod;</span><br><span class="line">        (tot2[F[i][u]] += id) %= mod;</span><br><span class="line">        (cnt1[F[i][u]] += (LL)D[i + <span class="number">1</span>][u] * id % mod) %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> A[N], q[N], id[N], ans[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[i] &lt; q[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen("sumsumsum.in", "r", stdin), freopen("sumsumsum.out", "w", stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>), Build(<span class="number">1</span>), Construct(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q[i]), id[i] = i;</span><br><span class="line">    sort(id + <span class="number">1</span>, id + m + <span class="number">1</span>, cmp); <span class="keyword">int</span> tmp1 = <span class="number">0</span>, tmp2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, cur = <span class="number">0</span>;i &lt;= m;i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; q[id[i]]) &#123;</span><br><span class="line">            <span class="keyword">int</span> res = query(A[++cur]);</span><br><span class="line">            (tmp1 += res) %= mod, (tmp2 += (LL)res * cur % mod) %= mod;</span><br><span class="line">            update(A[cur], cur);</span><br><span class="line">        &#125;</span><br><span class="line">        ans[id[i]] = ((LL)tmp1 * (q[id[i]] + <span class="number">1</span>) % mod - tmp2 + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2-Cubelia"><a href="#T2-Cubelia" class="headerlink" title="T2 Cubelia"></a>T2 Cubelia</h1><p><img src="https://i.loli.net/2019/03/11/5c864a849fe27.png" alt=""></p><p>随机函数无关紧要，所以没有贴上来</p><p>我们考虑对于一个区间$[l,r]$求最大前缀和，答案是什么</p><p>很显然，这等价于从1开始，下标在$[l,r]$之间最大的前缀和，减去下标为$l-1$的前缀和</p><p>对于减去的那个东西，它是确定的，而且很好算，所以先不管他</p><p>问题转化为，有$n$个数，给出一段区间$[l,r]$，询问它所有子区间中最大数的和</p><p>我们先找出$[l,r]$中最大的那个数，假设它在$pos$</p><p>那么我们可以把$[l,r]$所有的子区间分成3类</p><ol><li>跨过$pos$</li><li>左右端点都在$[l,pos)$中</li><li>左右端点都在$(pos,r]$中</li></ol><p>对于第一种区间，它的答案很好计算</p><p>很显然，每一个这样的区间对答案的贡献一定是$a_{pos}$，$a$是那个位置对应的前缀和</p><p>而这样的区间一共有$(pos-l+1)(r-pos+1)$个</p><p>对于第二种区间，我们考虑设$f(i)​$表示两个端点都在$[l,n]​$的区间的权值之和</p><p>那么它可以被表示为$f(l)-f(pos)-[左端点在[l,pos)，右端点在[pos,n]的区间答案]$</p><p>首先考虑$f$如何计算</p><p>很显然，这个$f$是可以预处理的</p><p>那么我们设$f_T(n)$表示左端点为$n$的区间的答案之和</p><p>那么显然有$f(n)=f(n+1)+f_T(n)$</p><p>我们考虑$a_n$对$f_T(n)$的贡献</p><p>假设在$[l,r]$中，$a_n$都是最大的那个</p><p>那么对于右端点在$[n,r]$的区间，它的权值一定是$a_n$</p><p>对于其它区间，$a_n$对它们已经没用了，因为有更大的数出现了</p><p>那么这些区间的答案就是$f_T(r+1)$，即左端点为$r+1$的区间权值总和</p><p>因为对于每一个被统计的区间，只要把$a_n,\cdots,a_r$拼在它的左边，就一定可以得到另一个区间，并且权值不变</p><p>所以有转移</p><script type="math/tex; mode=display">f_T(n)=a_n(r_n-n+1)+f_T(r+1)\\\f(n)=f(n+1)+f_T(n)</script><p>那么如何求这个$[左端点在[l,pos)，右端点在[pos,n]的区间答案]$呢</p><p>我们已经知道$pos$是$[l,r]$中最大值的位置，换句话说，$a_l,\cdots,a_{pos-1}$一定不会对这个值造成影响</p><p>我们把每个合法的区间从$pos$划分成两半</p><p>对于右半部分，答案就是$f_T(pos)$</p><p>对于左半部分，左端点可以随意选择</p><p>对于每一个从$pos$开始的区间，它的左端点可以为$[l,pos)$中的任意一个数，而权值不变</p><p>所以这个东西等于$(pos-l)f_T(pos)$</p><p>最后说一下细节</p><p>对于如何求$l_i,r_i$，单调栈即可</p><p>对于最后要减去什么，我们可以枚举区间左端点，即</p><script type="math/tex; mode=display">\sum_{i=l}^ra_{i-1}(r-i)</script><p>即对于每一个左端点，它会被选择$r-i$次</p><p>我们分别维护</p><script type="math/tex; mode=display">p_1(n)=\sum_{i=1}^na_{i-1}\\\p_2(n)=\sum_{i=1}^na_{i-1}i</script><p>即可</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line">LL pre[N], f[N], g[N], tf[N], tg[N], pre2[N], pre3[N]; <span class="keyword">int</span> cur[<span class="number">21</span>][N], lg[N], num[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre[a] &gt; pre[b] ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> st[N], top, tl[N], tr[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Construct</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        pre[i] = pre[i - <span class="number">1</span>] + num[i], cur[<span class="number">0</span>][i] = i, lg[i] = i == <span class="number">1</span> ? <span class="number">0</span> : lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        pre2[i] = pre2[i - <span class="number">1</span>] + pre[i - <span class="number">1</span>], pre3[i] = pre3[i - <span class="number">1</span>] + pre[i - <span class="number">1</span>] * i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= n;j++)  </span><br><span class="line">            cur[i][j] = Max(cur[i - <span class="number">1</span>][j], cur[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &amp;&amp; pre[st[top]] &lt; pre[i]) tr[st[top--]] = i - <span class="number">1</span>;</span><br><span class="line">        st[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (top) tr[st[top--]] = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n;i &gt;= <span class="number">1</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &amp;&amp; pre[st[top]] &lt; pre[i]) tl[st[top--]] = i + <span class="number">1</span>;</span><br><span class="line">        st[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (top) tl[st[top--]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        tf[i] = tf[tl[i] - <span class="number">1</span>] + pre[i] * (i - tl[i] + <span class="number">1</span>);</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] + tf[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n;i &gt;= <span class="number">1</span>;i--) &#123;</span><br><span class="line">        tg[i] = tg[tr[i] + <span class="number">1</span>] + pre[i] * (tr[i] - i + <span class="number">1</span>);</span><br><span class="line">        g[i] = g[i + <span class="number">1</span>] + tg[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = R - L + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Max(cur[lg[len]][L], cur[lg[len]][R - (<span class="number">1</span> &lt;&lt; lg[len]) + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">solve</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = query(L, R); LL res = <span class="number">0</span>;</span><br><span class="line">    res = pre[pos] * (R - pos + <span class="number">1</span>) * (pos - L + <span class="number">1</span>);</span><br><span class="line">    res = res + g[L] - g[pos] - tg[pos] * (pos - L);</span><br><span class="line">    res = res + f[R] - f[pos] - tf[pos] * (R - pos);</span><br><span class="line">    <span class="keyword">return</span> res - (pre2[R] - pre2[L - <span class="number">1</span>]) * (R + <span class="number">1</span>) + (pre3[R] - pre3[L - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> S, A, B, P, tp; LL lastans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Rand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    S = (S * A % P + (B ^ (tp * lastans))) % P;</span><br><span class="line">    S = S &lt; <span class="number">0</span> ? -S : S;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, q, l, r, res = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;S, &amp;A, &amp;B, &amp;P, &amp;tp);</span><br><span class="line">    Construct(n);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        l = Rand() % n + <span class="number">1</span>, r = Rand() % n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) swap(l, r);</span><br><span class="line">        lastans = solve(l, r), res = (res + lastans) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (res + mod) % mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3-Cuvelia"><a href="#T3-Cuvelia" class="headerlink" title="T3 Cuvelia"></a>T3 Cuvelia</h1><p><img src="https://i.loli.net/2019/03/11/5c864fe051c87.png" alt=""></p><p>这可能是这次比赛最简单的题吧</p><p>假设一次询问给出的点是$a_1,a_2,\cdots,a_k$</p><p>由于等于的传递性，我们只需要满足$dis(a_i,m)=dis(a_{i+1},m)$即可</p><p>所以我们一共有$k-1$个限制</p><p>如果每个限制我们能确定在树上有哪些节点合法，那么通过求他们的交集我们就能够确定最后的答案</p><p>考虑一个限制有哪些点合法</p><p>假设这两个点是$u,v$</p><p>如果这两个点的距离为奇数，那么显然不存在满足条件的点</p><p>我们考虑这样一种情况</p><p><img src="https://i.loli.net/2019/03/11/5c8651adde08b.png" alt=""></p><p>$u,v$两点的中点是$mid$，首先$mid$一定是合法的</p><p>其次，在以$mid$为根的树中，除$u,v$所在的子树都是合法的，即图中橙色的点</p><p>所以每次我们都是选定一个根，然后划去两棵子树</p><p>我们知道每棵子树的<code>dfs</code>序都是连续的，由于我们要求交集，所以可以使用线段树维护</p><p>具体来说，我们可以分两种情况：</p><ol><li>$mid$是$u,v$的$lca$</li></ol><p>此时直接找到$u,v$所对应的$lca$的两棵子树，划去这两棵子树即可</p><ol><li>$mid$不是$u,v$的$lca$</li></ol><p>那么以$mid$为根时，一定会划去它父亲所在的子树，假设$mid$在以1为根的树中对应的<code>dfs</code>序是<code>dfn[mid],end[mid]</code></p><p>此时<code>dfs</code>序在<code>[1, dfn[mid] - 1], [end[mid] + 1, n]</code>的点一定不合法，需要划去</p><p>也只有这两种情况了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300010</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, sum, lazy;</span><br><span class="line">&#125; T[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    T[rt].sum = T[rt &lt;&lt; <span class="number">1</span>].sum + T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T[rt].lazy == <span class="number">1</span>) T[rt &lt;&lt; <span class="number">1</span>].sum = T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum = <span class="number">0</span>, T[rt &lt;&lt; <span class="number">1</span>].lazy = T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lazy = <span class="number">1</span>, T[rt].lazy = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (T[rt].lazy == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        T[rt &lt;&lt; <span class="number">1</span>].sum = mid - l + <span class="number">1</span>, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum = r - mid;</span><br><span class="line">        T[rt &lt;&lt; <span class="number">1</span>].lazy = T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lazy = <span class="number">2</span>, T[rt].lazy = <span class="number">0</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    T[rt].l = l, T[rt].r = r; </span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; build(rt &lt;&lt; <span class="number">1</span>, l, mid), build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) &#123;</span><br><span class="line">        T[rt].sum = x ? r - l + <span class="number">1</span> : <span class="number">0</span>, T[rt].lazy = x + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (T[rt].lazy) pushdown(rt);</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) modify(rt &lt;&lt; <span class="number">1</span>, start, end, x); <span class="keyword">if</span> (end &gt; mid) modify(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, start, end, x);</span><br><span class="line">    pushup(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    modify(<span class="number">1</span>, start, end, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T[<span class="number">1</span>].sum = <span class="number">0</span>, T[<span class="number">1</span>].lazy = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> T[<span class="number">1</span>].r - T[<span class="number">1</span>].l + <span class="number">1</span> - T[<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">18</span>][N], dep[N], dfn[N], ed[N], dfsn;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    fa[<span class="number">0</span>][u] = f, dep[u] = dep[f] + <span class="number">1</span>, dfn[u] = ++dfsn;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">17</span>;i++) fa[i][u] = fa[i - <span class="number">1</span>][fa[i - <span class="number">1</span>][u]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u);</span><br><span class="line">    ed[u] = dfsn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[a] &lt; dep[b]) swap(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>;i &gt;= <span class="number">0</span>;i--) <span class="keyword">if</span> (dep[fa[i][a]] &gt;= dep[b]) a = fa[i][a];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>;i &gt;= <span class="number">0</span>;i--) <span class="keyword">if</span> (fa[i][a] != fa[i][b]) a = fa[i][a], b = fa[i][b];</span><br><span class="line">    <span class="keyword">return</span> fa[<span class="number">0</span>][a];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Jump</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span> (t &amp; (<span class="number">1</span> &lt;&lt; i)) a = fa[i][a];</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[a] &lt; dep[b]) swap(a, b);</span><br><span class="line">    <span class="keyword">if</span> ((dep[a] + dep[b]) &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> lca = LCA(a, b);</span><br><span class="line">    <span class="keyword">int</span> mid = (dep[a] + dep[b] - <span class="number">2</span> * dep[lca]) &gt;&gt; <span class="number">1</span>, cent = Jump(a, mid);</span><br><span class="line">    <span class="keyword">if</span> (cent == lca) &#123;</span><br><span class="line">        a = Jump(a, mid - <span class="number">1</span>), b = Jump(b, mid - <span class="number">1</span>);</span><br><span class="line">        mark(dfn[a], ed[a]), mark(dfn[b], ed[b]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        a = Jump(a, mid - <span class="number">1</span>);</span><br><span class="line">        mark(dfn[a], ed[a]), mark(<span class="number">1</span>, dfn[cent] - <span class="number">1</span>), mark(ed[cent] + <span class="number">1</span>, ed[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> node[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b;i &lt; n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b), adde(a, b);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>), build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        reset(); <span class="keyword">int</span> k, flag = <span class="number">1</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;node[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; k &amp;&amp; flag;i++) flag = solve(node[i], node[i + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次考试很不理想，主要范了两个错误</p><p>一是第一题把代码打错了，<code>%=</code>打成了<code>%</code>，丢了20分</p><p>二是第三题数组开小了，丢了40分</p><p>第三题没有深入思考，考试时只想到了相邻两个求交集，没有想到用线段树维护</p><p>对于第二题，我觉得需要多做一些这样的题，积累经验</p><p>orz WKR</p>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 点分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性递推</title>
      <link href="/2019/03/10/%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/"/>
      <url>/2019/03/10/%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/</url>
      
        <content type="html"><![CDATA[<p>求一个满足$k$阶齐次线性递推数列$a_i$的第$n​$项</p><p>即：$a_n=\sum\limits_{i=1}^kf_i\times a_{n-i}$</p><p>已知$f$，以及$a_0,a_1,\cdots,a_{k-1}$</p><script type="math/tex; mode=display">n\leq 10^9, k\leq 32000</script><p>如果$k$小一点，那么直接矩阵乘法是可以的</p><p>但是这个是$O(k^3\log n)$的，时间复杂度难以承受</p><p>注意到这个是其次线性递推，也就是说，我们构造出的矩阵只有第一行是$f​$，其余的行上全是1和0</p><p>我们设这个矩阵是$A$，现在有一个奇妙的序列$c$使得</p><script type="math/tex; mode=display">A^n=\sum_{i=0}^{k-1}c_iA^i</script><p>我们设初始列向量是$base$，那么有</p><script type="math/tex; mode=display">A^n\times base=\sum_{i=0}^{k-1}c_iA^i\times base\\</script><p>在矩阵运算中，我们只取第一行的值，那么有</p><script type="math/tex; mode=display">a_n=\sum_{i=0}^{k-1}c_ia_i</script><p>这也就是说，如果我们成功地构造出了这个$c$，那么我们就可以使用$a$的前$k$项推出$a_n$</p><p>我们重新考虑之前的那个式子</p><script type="math/tex; mode=display">A^n=\sum_{i=0}^{k-1}c_iA^i</script><p>它一定可以被写成这样的式子</p><script type="math/tex; mode=display">A^n=Q(A)G(A)+R(A)</script><p>即</p><script type="math/tex; mode=display">R(A)=A^n\mod G(A)</script><p>其中$Q,G,R$都是以矩阵为参数的函数</p><p>我们令这个$G$的次数为$k$，那么$R$的次数为$k-1$</p><p>如果存在一个函数$G$，使得对于$A$，有$G(A)=0$，那么前面的$Q(A)G(A)$就可以消去，从而使得$A^n=R(A)$</p><p>此时多项式$R$的每一项的系数，就对应着之前我们需要构造的$c$</p><p>所以实际上我们要构造一个序列$g$，使得</p><script type="math/tex; mode=display">\sum_{i=0}^kg_iA^i=0</script><p>这里先上结论：对于满足题意的递推系数$f$，有$g_i=-f_{k-i},g_k=1$</p><p>注意这里我们需要把这个$f$倒过来再取相反数，因为我们把列向量倒过来了，即从上到下分别为$a_0,a_1,\cdots,a_{k-1} $</p><p>注意$f$的下标是从1到$k$，$g$是从0到$k​$</p><p>计算的时候就像快速幂一样，只不过模的是一个多项式$G$</p><p>证明过程之后再补</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 202010</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> r[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, w = <span class="number">1</span>, t;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w = (LL)w * Wn % mod)</span><br><span class="line">                t = (LL)w * a[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!type) <span class="keyword">for</span> (<span class="keyword">int</span> inv = Pow(len, mod - <span class="number">2</span>), i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">        a[i] = (LL)a[i] * inv % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp[N];</span><br><span class="line"><span class="comment">// b[i] = 2 * b'[i] - a[i] * b'[i] * b'[i]</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">void</span>(b[<span class="number">0</span>] = Pow(a[<span class="number">0</span>], mod - <span class="number">2</span>));</span><br><span class="line">    Inv(a, b, (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>); <span class="keyword">int</span> l = <span class="number">0</span>, len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n * <span class="number">3</span>) l++, len &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) tmp[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n;i &lt; len;i++) tmp[i] = <span class="number">0</span>;</span><br><span class="line">    NTT(tmp, len, <span class="number">1</span>), NTT(b, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">        b[i] = (<span class="number">2</span> - (LL)tmp[i] * b[i] % mod + mod) % mod * b[i] % mod;</span><br><span class="line">    NTT(b, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n;i &lt; len;i++) b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmpa[N], tmpb[N], tmpc[N], binv[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Div</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a[], <span class="keyword">const</span> <span class="keyword">int</span> b[], <span class="keyword">int</span> c[], <span class="keyword">int</span> d[], <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="comment">//memset(tmpa, 0, sizeof(tmpa)), memset(tmpb, 0, sizeof(tmpb)), memset(tmpc, 0, sizeof(tmpc)), memset(binv, 0, sizeof(binv));</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n * <span class="number">6</span> - m * <span class="number">6</span> + <span class="number">1</span>;i++) tmpa[i] = tmpb[i] = tmpc[i] = binv[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n - m;i++) tmpa[i] = a[n - i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= m;i++) tmpb[i] = b[m - i];</span><br><span class="line">    Inv(tmpb, binv, n - m + <span class="number">1</span>); <span class="keyword">int</span> l = <span class="number">0</span>, len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n * <span class="number">2</span> - m * <span class="number">2</span>) l++, len &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    NTT(tmpa, len, <span class="number">1</span>), NTT(binv, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">        c[i] = (LL)tmpa[i] * binv[i] % mod;</span><br><span class="line">    NTT(c, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - m + <span class="number">1</span>;i &lt; len;i++) c[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i * <span class="number">2</span> &lt; n - m;i++) swap(c[i], c[n - m - i]);</span><br><span class="line">    l = <span class="number">0</span>, len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n) l++, len &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) tmpa[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= m;i++) tmpb[i] = b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n - m;i++) tmpc[i] = c[i];</span><br><span class="line">    NTT(tmpa, len, <span class="number">1</span>), NTT(tmpb, len, <span class="number">1</span>), NTT(tmpc, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">        d[i] = (tmpa[i] - (LL)tmpb[i] * tmpc[i] % mod + mod) % mod;</span><br><span class="line">    NTT(d, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m;i &lt; len;i++) d[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> base[N], f[N], res[N], del[N], A[N], rub[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">const</span> <span class="keyword">int</span> b[], <span class="keyword">const</span> <span class="keyword">int</span> c[], <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= k * <span class="number">2</span>) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= k;i++) tmpb[i] = b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k + <span class="number">1</span>;i &lt; len;i++) tmpb[i] = <span class="number">0</span>;</span><br><span class="line">    NTT(a, len, <span class="number">1</span>), NTT(tmpb, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) </span><br><span class="line">        del[i] = (LL)a[i] * tmpb[i] % mod;</span><br><span class="line">    NTT(del, len, <span class="number">0</span>), Div(del, c, rub, a, k * <span class="number">2</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, ans = <span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k), f[k] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= k;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;f[k - i]), (f[k - i] = mod - f[k - i]) %= mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]), (base[i] += mod) %= mod;</span><br><span class="line">    res[<span class="number">0</span>] = <span class="number">1</span>, A[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;n;n &gt;&gt;= <span class="number">1</span>, mul(A, A, f, k)) <span class="keyword">if</span> (n &amp; <span class="number">1</span>) mul(res, A, f, k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) ans = (ans + (LL)res[i] * base[i]) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式求逆 </tag>
            
            <tag> 多项式 </tag>
            
            <tag> 多项式除法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.8省选模拟 斐波那契树</title>
      <link href="/2019/03/09/3-8%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%A0%91/"/>
      <url>/2019/03/09/3-8%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><img src="http://auoj.net/upload/fetch_image/24241c165dc2855ae1d4ffecc5ae68f1.png" alt=""></p><script type="math/tex; mode=display">n,q\leq 2*10^5</script><p>不知道出题人怎么想的，模$10^9+7$而不是$10^9+9$，$5$在模$10^9+7$下没有二次剩余</p><p>我们知道斐波那契数列是可以叠加的，也就是一个斐波那契数列加上另一个斐波那契数列仍然是斐波那契数列</p><p>那么我们只需要维护这个数列的第0项和第1项就可以了</p><p>由于5没有二次剩余，所以可以通过预处理/矩阵乘法求得数列的第$k$项</p><p>考虑如何维护这两个操作</p><p>很显然，这是一个动态点分治</p><p>对于点分树上的每一个点，我们维护两个树状数组</p><p>两个数组都是根据深度建的，但是一个维护它对它自己子树的贡献，另一个维护它对它父亲的贡献</p><p>比如现在要处理第一个询问</p><p>将$u$往上跳，假设它的第$i$级祖先是<code>F[i][u]</code>，它距离这个祖先的距离是<code>D[i][u]</code></p><p>那么现在$u$可以经过这个祖先，到达这个祖先的其它子树</p><p>我们知道，距离$m$以内的点都会被更新</p><p>当$u$跳到这个祖先的时候，这个距离还剩下<code>m - D[i][u]</code></p><p>也就是说，这个祖先所有离它不超过<code>m - D[i][u]</code>的点都会被更新</p><p>这对应着树状数组上的一段前缀和</p><p>当然，我们还要算出$a,b$在这一级祖先变成了多少</p><p>查询的时候，也是跳它的祖先</p><p>对于每一级祖先，我们知道它距离这个祖先的距离，以及在它这个深度累加的答案</p><p>那么我们就可以算出这个祖先对它的贡献</p><p>但是这样会重复计数</p><p>我们考虑这样一种情况：$u$的某一级祖先是$f$，第一个询问更新了$u$，这导致$f$也更新了</p><p>现在要查询$v$，其中$v,u$在$f$的同一棵子树内</p><p>之前更新祖先时依据是$u$经过这个祖先，到达这个祖先其它子树的点</p><p>然而现在$u$不需要经过$f$，就可以到达$v$</p><p>当跳到$f$的时候，$u$的贡献又会被算一次，这样就重复计数了</p><p>解决方法是同时维护每个节点对它父亲的贡献</p><p>查询的时候，假设$u$的上一级祖先是$f$，那么我们查$f$对子树的贡献，减去$u$对其父亲$f$的贡献，就可以了</p><p>动态点分治要注意内存开销</p><p>还是<code>vector</code>+树状数组比较妥当</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 200010</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;x += y, x -= x &gt;= mod ? mod : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dec</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;x = x + mod - y, x -= x &gt;= mod ? mod : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(P &amp;x, P y)</span> </span>&#123;Inc(x.first, y.first), Inc(x.second, y.second);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dec</span><span class="params">(P &amp;x, P y)</span> </span>&#123;Dec(x.first, y.first), Dec(x.second, y.second);&#125;</span><br><span class="line"><span class="keyword">namespace</span> FIB &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">        Matrix() &#123;<span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));&#125;</span><br><span class="line">        Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp;b) &#123;</span><br><span class="line">            Matrix c;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">2</span>;i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">2</span>;j++)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= <span class="number">2</span>;k++)</span><br><span class="line">                        Inc(c.a[i][j], (LL)a[i][k] * b.a[k][j] % mod);</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> Matrix <span class="title">Pow</span><span class="params">(Matrix x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        Matrix res; res.a[<span class="number">1</span>][<span class="number">1</span>] = res.a[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = x * x) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = res * x;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Kth</span><span class="params">(P x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Matrix base; base.a[<span class="number">1</span>][<span class="number">1</span>] = base.a[<span class="number">1</span>][<span class="number">2</span>] = base.a[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> x.first; <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> x.second;</span><br><span class="line">        base = Pow(base, k - <span class="number">1</span>); </span><br><span class="line">        <span class="keyword">return</span> ((LL)base.a[<span class="number">1</span>][<span class="number">1</span>] * x.second + (LL)base.a[<span class="number">1</span>][<span class="number">2</span>] * x.first) % mod;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;P &gt; tree[<span class="number">2</span>][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> id, <span class="keyword">int</span> x, P y)</span> </span>&#123;</span><br><span class="line">    x = min(x + <span class="number">1</span>, (<span class="keyword">int</span>)tree[type][id].size() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (;x;x -= x &amp; -x) Inc(tree[type][id][x], y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> P <span class="title">que</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> id, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    P res; x++;</span><br><span class="line">    <span class="keyword">for</span> (;x &lt; tree[type][id].size();x += x &amp; -x) </span><br><span class="line">        Inc(res, tree[type][id][x]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dep[N], fa[<span class="number">20</span>][N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    fa[<span class="number">0</span>][u] = f, dep[u] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">19</span>;i++) fa[i][u] = fa[i - <span class="number">1</span>][fa[i - <span class="number">1</span>][u]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) dfs(e[i].to, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[a] &lt; dep[b]) swap(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>;i &gt;= <span class="number">0</span>;i--) <span class="keyword">if</span> (dep[fa[i][a]] &gt;= dep[b]) a = fa[i][a];</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>;i &gt;= <span class="number">0</span>;i--) <span class="keyword">if</span> (fa[i][a] != fa[i][b]) a = fa[i][a], b = fa[i][b];</span><br><span class="line">    <span class="keyword">return</span> fa[<span class="number">0</span>][a];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Dis</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dep[a] + dep[b] - <span class="number">2</span> * dep[LCA(a, b)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[N], size[N], mxd[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getsize</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    vis[u] = size[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to]) size[u] += Getsize(e[i].to);</span><br><span class="line">    <span class="keyword">return</span> vis[u] = <span class="number">0</span>, size[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getroot</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tot)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], tmp;i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to] &amp;&amp; (tmp = Getroot(e[i].to, tot)))</span><br><span class="line">            <span class="keyword">return</span> vis[u] = <span class="number">0</span>, tmp;</span><br><span class="line">    <span class="keyword">return</span> vis[u] = <span class="number">0</span>, size[u] &gt;= (tot &gt;&gt; <span class="number">1</span>) ? u : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getdep</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>; vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to]) res = max(res, Getdep(e[i].to) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> vis[u] = <span class="number">0</span>, res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> F[<span class="number">20</span>][N], D[<span class="number">20</span>][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    u = Getroot(u, Getsize(u)), vis[u] = <span class="number">1</span>; <span class="keyword">int</span> deep = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to]) deep = max(deep, Getdep(e[i].to));</span><br><span class="line">    tree[<span class="number">0</span>][u].resize(deep + <span class="number">2</span>), mxd[u] = deep;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to]) F[<span class="number">0</span>][Build(e[i].to)] = u;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Construct</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span> (F[<span class="number">0</span>][i]) </span><br><span class="line">        D[<span class="number">0</span>][i] = Dis(F[<span class="number">0</span>][i], i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">19</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;j++) &#123;</span><br><span class="line">            F[i][j] = F[i - <span class="number">1</span>][F[<span class="number">0</span>][j]];</span><br><span class="line">            <span class="keyword">if</span> (F[i][j]) D[i][j] = Dis(F[i][j], j);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        tree[<span class="number">1</span>][i].resize(mxd[F[<span class="number">0</span>][i]] + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> dis, P data)</span> </span>&#123;</span><br><span class="line">    add(<span class="number">0</span>, x, dis, data);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">19</span> &amp;&amp; F[i][x];i++) </span><br><span class="line">        <span class="keyword">if</span> (D[i][x] &lt;= dis) &#123;</span><br><span class="line">            <span class="keyword">int</span> ta = FIB::Kth(data, D[i][x]), tb = FIB::Kth(data, D[i][x] + <span class="number">1</span>);</span><br><span class="line">            add(<span class="number">0</span>, F[i][x], dis - D[i][x], P(ta, tb));</span><br><span class="line">            add(<span class="number">1</span>, i ? F[i - <span class="number">1</span>][x] : x, dis - D[i][x], P(ta, tb));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = que(<span class="number">0</span>, x, <span class="number">0</span>).first;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">19</span> &amp;&amp; F[i][x];i++) &#123;</span><br><span class="line">        Inc(res, FIB::Kth(que(<span class="number">0</span>, F[i][x], D[i][x]), D[i][x]));</span><br><span class="line">        Dec(res, FIB::Kth(que(<span class="number">1</span>, i ? F[i - <span class="number">1</span>][x] : x, D[i][x]), D[i][x]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> __rd;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RD (read(__rd), __rd)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    freopen("fibtree.in", "r", stdin);</span></span><br><span class="line">    <span class="keyword">int</span> n = RD, q = RD; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b;i &lt; n;i++) a = RD, b = RD, adde(a, b);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>), Build(<span class="number">1</span>), Construct(n);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> op = RD, a = RD, b, c, d; </span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) b = RD, c = RD, d = RD, update(a, b, P(c, d));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 点分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多项式除法</title>
      <link href="/2019/03/09/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%99%A4%E6%B3%95/"/>
      <url>/2019/03/09/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E9%99%A4%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>已知多项式$F(x),G(x)​$，求出多项式$Q(x),R(x)​$，使得在模$998244353​$意义下，有</p><script type="math/tex; mode=display">F(x)=Q(x)G(x)+R(x) \mod 998244353</script><p>其中$F$的次数为$n$，$G$的次数为$m$</p><p>那么我们知道$Q$是一个$n-m$次的多项式，而$R$是一个$m-1$次的多项式</p><p>我们定义变换$R$，满足</p><script type="math/tex; mode=display">F_R(x)=x^nF(\frac 1x)</script><p>我们考虑这个$R$是怎么得到的</p><p>假设有</p><script type="math/tex; mode=display">F(x)=a_0+a_1x+a_2x^2+\cdots+a_nx^n</script><p>代入$\frac 1x$之后我们得到</p><script type="math/tex; mode=display">F(\frac 1x)=a_0+\frac{a_1}{x}+\frac{a_2}{x^2}+\cdots+\frac{a_n}{x^n}</script><p>再乘以$x^n$</p><script type="math/tex; mode=display">x^nF(\frac 1x)=a_n+a_{n-1}x+a_{n-2}x^2+\cdots+a_0x^n</script><p>我们发现，得到的结果就是把原来多项式的系数反过来，就是$R​$变换</p><p>那么有</p><script type="math/tex; mode=display">F(x)=Q(x)G(x)+R(x)</script><p>代入$\frac 1x$</p><script type="math/tex; mode=display">F(\frac 1x)=Q(\frac 1x)G(\frac 1x)+R(\frac 1x)</script><p>同时乘以$x^n$</p><script type="math/tex; mode=display">x^nF(\frac 1x)=x^{n-m}Q(\frac 1x)x^mG(\frac 1x)+x^{n-m+1}\*x^{m-1}R(\frac 1x)\\\F_R(x)=Q_R(x)G_R(x)+x^{n-m+1}R_R(x)</script><p>考虑如何把最后那个余数$R$给搞掉</p><p>注意到它乘了一个系数</p><p>那么我们直接在模$x^{n-m+1}$下运算即可</p><p>此时有</p><script type="math/tex; mode=display">F_R(x)=Q_R(x)G_R(x)\mod x^{n-m+1}\\\Q_R(x)=\frac{F_R(x)}{G_R(x)}\mod x^{n-m+1}</script><p>所以我们求出$G_R$在模$x^{n-m+1}$下的逆，再乘上$F_R$就可以得到$G_R$ </p><p>由于$Q​$的次数就是$n-m​$，所以此时求出的模意义下的$Q_R​$等价于$Q_R​$</p><p>注意此时$F_R,G_R​$都是$n-m​$次多项式</p><p>我们求出了$Q_R​$，将它倒序可以得到$Q​$，然后将$Q​$代入$F(x)=Q(x)G(x)+R(x)​$，就可以求出$R​$了</p><p>代码如下<del>（有点毒瘤）</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 600010</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> r[N]; <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>,x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) <span class="keyword">if</span> (i &lt; r[i]) swap(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>;mid &lt;= len;mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i += mid) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i, w = <span class="number">1</span>, t;j &lt; i + (mid &gt;&gt; <span class="number">1</span>);j++, w = (LL)w * Wn % mod)</span><br><span class="line">                t = (LL)w * a[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, a[j + (mid &gt;&gt; <span class="number">1</span>)] = (a[j] - t + mod) % mod, a[j] = (a[j] + t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!type) &#123;</span><br><span class="line">        <span class="keyword">int</span> Inv = Pow(len, mod - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) a[i] = (LL)a[i] * Inv % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a[], <span class="keyword">int</span> b[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">void</span>(b[<span class="number">0</span>] = Pow(a[<span class="number">0</span>], mod - <span class="number">2</span>));</span><br><span class="line">    Inv(a, b, (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>); <span class="keyword">int</span> l = <span class="number">0</span>, len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n * <span class="number">3</span>) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) tmp[i] = a[i]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n;i &lt; len;i++) tmp[i] = <span class="number">0</span>;</span><br><span class="line">    NTT(tmp, len, <span class="number">1</span>), NTT(b, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) </span><br><span class="line">        b[i] = (<span class="number">2</span> - (LL)tmp[i] * b[i] % mod + mod) % mod * b[i] % mod;</span><br><span class="line">    NTT(b, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n;i &lt; len;i++) b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmpa[N], tmpb[N], binv[N], tmpc[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Div</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a[], <span class="keyword">const</span> <span class="keyword">int</span> b[], <span class="keyword">int</span> c[], <span class="keyword">int</span> d[], <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n - m;i++) tmpa[i] = a[n - i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= m;i++) tmpb[i] = b[m - i];</span><br><span class="line">    Inv(tmpb, binv, n - m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= <span class="number">2</span> * n - <span class="number">2</span> * m) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    NTT(tmpa, len, <span class="number">1</span>), NTT(binv, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)</span><br><span class="line">        c[i] = (LL)tmpa[i] * binv[i] % mod;</span><br><span class="line">    NTT(c, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - m + <span class="number">1</span>;i &lt; len;i++) c[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i * <span class="number">2</span> &lt; n - m;i++) swap(c[i], c[n - m - i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) tmpa[i] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= m;i++) tmpb[i] = b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n - m;i++) tmpc[i] = c[i];</span><br><span class="line">    l = <span class="number">0</span>, len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt;= n) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    NTT(tmpa, len, <span class="number">1</span>), NTT(tmpb, len, <span class="number">1</span>), NTT(tmpc, len, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++) </span><br><span class="line">        d[i] = (tmpa[i] - (LL)tmpb[i] * tmpc[i] % mod + mod) % mod;</span><br><span class="line">    NTT(d, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m;i &lt; len;i++) d[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> A[N], B[N], C[N], D[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= m;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;B[i]);</span><br><span class="line">    Div(A, B, C, D, n, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n - m;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, C[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, D[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式求逆 </tag>
            
            <tag> 多项式 </tag>
            
            <tag> 多项式除法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多项式求逆</title>
      <link href="/2019/03/09/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E9%80%86/"/>
      <url>/2019/03/09/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E9%80%86/</url>
      
        <content type="html"><![CDATA[<p>有$A(x)*B(x)\equiv1\mod x^n$，已知$A$，求$B$，每一项的系数模$998244353$</p><p>考虑分治，假设我们已经求出了$A$在模$x^{\lfloor\frac n2\rfloor}$下的逆$B’$</p><p>那么有</p><script type="math/tex; mode=display">A(x)B'(x)\equiv 1 \mod x^{\lceil\frac n2\rceil}</script><script type="math/tex; mode=display">A(x)B(x)\equiv 1 \mod x^{\lceil\frac n2\rceil}</script><p>可以推出</p><script type="math/tex; mode=display">B'(x)-B(x)\equiv 0\mod x^{\lceil\frac n2\rceil}</script><p>两边同时平方</p><script type="math/tex; mode=display">(B'(x)-B(x))^2\equiv 0\mod x^n</script><p>展开</p><script type="math/tex; mode=display">B(x)^2-2B'(x)B(x)+B'(x)^2\equiv 0\mod x^n</script><p>同时乘以A</p><script type="math/tex; mode=display">B(x)-2B'(x)+A(x)B'(x)^2\equiv 0\mod x^n</script><script type="math/tex; mode=display">B(x)\equiv 2B'(x)-A(x)B'(x)^2\mod x^n</script><p>注意分治的时候我们只关心所有多项式的前n项，大于n项的常数需要置0</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 600010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Poly</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> r[N], len, l; <span class="keyword">int</span> A[N];</span><br><span class="line">    Poly() &#123;<span class="built_in">memset</span>(A, <span class="number">0</span>, <span class="keyword">sizeof</span>(A));&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Reset</span><span class="params">(<span class="keyword">int</span> _n)</span> </span>&#123;</span><br><span class="line">        Poly::l = <span class="number">0</span>, Poly::len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (len &lt;= _n) len &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span> *= (<span class="keyword">int</span> type) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) <span class="keyword">if</span> (i &lt; r[i]) swap(A[i], A[r[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">2</span>; mid &lt;= len; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += mid) &#123;</span><br><span class="line">                <span class="keyword">int</span> Wn = Pow(<span class="number">3</span>, type ? (mod - <span class="number">1</span>) / mid : mod - <span class="number">1</span> - (mod - <span class="number">1</span>) / mid);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i, w = <span class="number">1</span>, t; j &lt; i + (mid &gt;&gt; <span class="number">1</span>); j++, w = (LL)w * Wn % mod)</span><br><span class="line">                    t = (LL)w * A[j + (mid &gt;&gt; <span class="number">1</span>)] % mod, A[j + (mid &gt;&gt; <span class="number">1</span>)] = (A[j] - t + mod) % mod, A[j] = (A[j] + t) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Poly::r[N], Poly::len, Poly::l;</span><br><span class="line"><span class="comment">// b(x) = 2b'(x) - a(x)b'(x) ^ 2</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inv</span><span class="params">(<span class="keyword">const</span> Poly &amp;a, Poly &amp;b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">void</span>(b.A[<span class="number">0</span>] = Pow(a.A[<span class="number">0</span>], mod - <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">else</span> Inv(a, b, (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>); <span class="function">Poly <span class="title">c</span><span class="params">(a)</span></span>;</span><br><span class="line">    Poly::Reset(n * <span class="number">3</span>); <span class="keyword">int</span> l = Poly::len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; l; i++) c.A[i] = <span class="number">0</span>;</span><br><span class="line">    c *= <span class="number">1</span>, b *= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; l;i++)</span><br><span class="line">        b.A[i] = (<span class="number">2</span> - (LL)c.A[i] * b.A[i] % mod + mod) % mod * b.A[i] % mod;</span><br><span class="line">    b *= <span class="number">0</span>; <span class="keyword">int</span> inv = Pow(l, mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; l;i++) b.A[i] = (LL)b.A[i] * inv % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n;i &lt; l;i++) b.A[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Poly a, b; <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a.A[i]);</span><br><span class="line">    Inv(a, b, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, b.A[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式求逆 </tag>
            
            <tag> 多项式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.8省选模拟 奇怪的树</title>
      <link href="/2019/03/08/3-8%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F-%E5%A5%87%E6%80%AA%E7%9A%84%E6%A0%91/"/>
      <url>/2019/03/08/3-8%E7%9C%81%E9%80%89%E6%A8%A1%E6%8B%9F-%E5%A5%87%E6%80%AA%E7%9A%84%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><img src="http://auoj.net/upload/fetch_image/897b88a0a79868286e07d5468c738e45.png" alt=""></p><script type="math/tex; mode=display">n\leq 3\*10^5</script><p>树链剖分好题，链上维护虚子树信息</p><p>我们考虑如何更新一条链</p><p><img src="https://s2.ax1x.com/2019/03/08/kzvvAs.jpg" alt=""></p><p>假设询问节点是$u$，$AC$是一条重链，$PB$是一条轻链，$P$是一个奇怪的节点</p><p>那么我们知道，此时$B$的点权加上了$P$</p><p>如果$A$的下方还连接着一个奇怪的点$P_1$，那么$B$也会加上$P_1$的权值</p><p>而此时$C$不会加上$P_1$的权值，因为它不是lca</p><p>所以当$u$从一条链的顶端跳到另一条链时，对于$u$的父亲我们需要特殊考虑贡献，对于这条链上其它的点，权值都会加上在其子树中，且不在其重儿子子树中的奇怪的点的编号之和</p><p>这个东西不是很好维护，那么我们考虑维护它所乘的系数，即它的权值加了多少次不在重儿子的奇怪的点的编号之和</p><p>这样的话，我们只需要实现区间加1就可以了</p><p>我们另开一个数组<code>ans</code>，表示每个点除了那个区间加1以外的贡献</p><p>比如之前提到的$u$的父亲，我们就将它的重儿子所在的子树中奇怪的点的编号之和加入<code>ans</code></p><p>假如一个点加了$a_i$次1，在它的子树中，且不在它重儿子的子树中的奇怪的点的编号之和为$b_i$，那么一个点最终的答案就是$a_ib_i+ans_i$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Tupdate1</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    ans[u] += query(<span class="number">1</span>, id[u], <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span> (u) &#123;</span><br><span class="line">        update(<span class="number">1</span>, id[top[u]], id[u], <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 区间ai + 1</span></span><br><span class="line">        u = top[u], ans[fa[u]] += query(<span class="number">1</span>, id[fa[u]], <span class="number">2</span>) - query(<span class="number">1</span>, id[u], <span class="number">1</span>) - query(<span class="number">1</span>, id[u], <span class="number">2</span>); <span class="comment">// 特殊处理链顶的父亲，注意要减去u自己所在的子树的贡献</span></span><br><span class="line">        u = fa[u]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们考虑如何实现询问2</p><p>我们记一个点的非重儿子子树中，奇怪的点的点权之和是$V_u$</p><p>其重儿子子树中，奇怪的点的点权之和是$W_u$</p><p>如果把$u$的状态改变了，那么这会影响一些点的$V_u$和$W_u$</p><p><img src="https://s2.ax1x.com/2019/03/08/kzvvAs.jpg" alt=""></p><p>仍然考虑这张图</p><p>对于$B$，它的$V$变化而$W$不变化</p><p>对于$C$，它的$W$变化而$V$不变化</p><p>对于$A$，它的$W$和$V$都不变化</p><p>我们仍然将$B$视为特殊点，特殊处理贡献</p><p>注意到之前我们维护了$V_u$的贡献系数</p><p>而这里$B$的$V$值更新了，那么这会导致答案多统计一部分</p><p>方法是，在更新$B$之前，将$a_bV_b$下放到<code>ans[b]</code>，然后将$a_b$清零</p><p>注意最开始$u$还没有向上爬的时候，$u$节点本身也是一个特殊点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Tupdate2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = mark[u] ? -u : u; mark[u] ^= <span class="number">1</span>; <span class="comment">// 权值更改的值</span></span><br><span class="line">    LL del = query(<span class="number">1</span>, id[u], <span class="number">0</span>); ans[u] += del * query(<span class="number">1</span>, id[u], <span class="number">1</span>), update(<span class="number">1</span>, id[u], id[u], <span class="number">0</span>, -del); <span class="comment">// 特殊处理u ：0代表a[u]，1代表V[u]，2代表W[u]，清空a[u]并更新V[u]</span></span><br><span class="line">    update(<span class="number">1</span>, id[u], id[u], <span class="number">1</span>, tmp);</span><br><span class="line">    <span class="keyword">while</span> (u) &#123;</span><br><span class="line">        update(<span class="number">1</span>, id[top[u]], id[fa[u]], <span class="number">2</span>, tmp), u = top[u];</span><br><span class="line">        del = query(<span class="number">1</span>, id[fa[u]], <span class="number">0</span>);</span><br><span class="line">        ans[fa[u]] += del * query(<span class="number">1</span>, id[fa[u]], <span class="number">1</span>), update(<span class="number">1</span>, id[fa[u]], id[fa[u]], <span class="number">0</span>, -del), update(<span class="number">1</span>, id[fa[u]], id[fa[u]], <span class="number">1</span>, tmp); <span class="comment">// 同理</span></span><br><span class="line">        u = fa[u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于动态<code>dp</code>，也是链上维护虚子树信息</p><p>去年四川省选D1T1也许可以<code>LCT</code>维护虚子树信息</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 300010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to, next;&#125; e[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], ecnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = (edge)&#123;to, head[from]&#125;, head[from] = ecnt;</span><br><span class="line">    e[++ecnt] = (edge)&#123;from, head[to]&#125;, head[to] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    LL sum, lazy, s1, s2, lazy1, lazy2; </span><br><span class="line">&#125; T[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    T[rt &lt;&lt; <span class="number">1</span>].sum += T[rt].lazy, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum += T[rt].lazy, T[rt &lt;&lt; <span class="number">1</span>].lazy += T[rt].lazy, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lazy += T[rt].lazy, T[rt].lazy = <span class="number">0</span>;</span><br><span class="line">    T[rt &lt;&lt; <span class="number">1</span>].s1 += T[rt].lazy1, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].s1 += T[rt].lazy1, T[rt &lt;&lt; <span class="number">1</span>].lazy1 += T[rt].lazy1, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lazy1 += T[rt].lazy1, T[rt].lazy1 = <span class="number">0</span>;</span><br><span class="line">    T[rt &lt;&lt; <span class="number">1</span>].s2 += T[rt].lazy2, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].s2 += T[rt].lazy2, T[rt &lt;&lt; <span class="number">1</span>].lazy2 += T[rt].lazy2, T[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].lazy2 += T[rt].lazy2, T[rt].lazy2 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> rk[N]; LL v1[N], v2[N], ans[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    T[rt].l = l, T[rt].r = r; <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;T[rt].s1 = v1[rk[l]], T[rt].s2 = v2[rk[l]]; <span class="keyword">return</span>;&#125;</span><br><span class="line">    build(rt &lt;&lt; <span class="number">1</span>, l, mid), build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> type, LL x)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (end &lt;= <span class="number">0</span> || start &gt; end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">0</span>) T[rt].lazy += x, T[rt].sum += x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">1</span>) T[rt].lazy1 += x, T[rt].s1 += x;</span><br><span class="line">        <span class="keyword">else</span> T[rt].lazy2 += x, T[rt].s2 += x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, start, end, type, x);</span><br><span class="line">    <span class="keyword">if</span> (end &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, start, end, type, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> at, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!at) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = T[rt].l, r = T[rt].r, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">0</span>) <span class="keyword">return</span> T[rt].sum;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">1</span>) <span class="keyword">return</span> T[rt].s1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> T[rt].s2;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(rt);</span><br><span class="line">    <span class="keyword">return</span> at &lt;= mid ? query(rt &lt;&lt; <span class="number">1</span>, at, type) : query(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, at, type);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dfsn, sz[N], top[N], id[N], fa[N], mark[N], son[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>, fa[u] = f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != f) &#123;</span><br><span class="line">            dfs1(e[i].to, u), sz[u] += sz[e[i].to];</span><br><span class="line">            <span class="keyword">if</span> (sz[son[u]] &lt; sz[e[i].to]) son[u] = e[i].to;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    id[u] = ++dfsn, top[u] = t, v1[u] = mark[u] ? u : <span class="number">0</span>, rk[id[u]] = u;</span><br><span class="line">    <span class="keyword">if</span> (son[u]) dfs2(son[u], t), v2[u] += v2[son[u]] + v1[son[u]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u];i;i = e[i].next)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != fa[u] &amp;&amp; e[i].to != son[u]) </span><br><span class="line">            dfs2(e[i].to, e[i].to), v1[u] += v1[e[i].to] + v2[e[i].to];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Tupdate1</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    ans[u] += query(<span class="number">1</span>, id[u], <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span> (u) &#123;</span><br><span class="line">        update(<span class="number">1</span>, id[top[u]], id[u], <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        u = top[u], ans[fa[u]] += query(<span class="number">1</span>, id[fa[u]], <span class="number">2</span>) - query(<span class="number">1</span>, id[u], <span class="number">1</span>) - query(<span class="number">1</span>, id[u], <span class="number">2</span>);</span><br><span class="line">        u = fa[u]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Tupdate2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = mark[u] ? -u : u; mark[u] ^= <span class="number">1</span>;</span><br><span class="line">    LL del = query(<span class="number">1</span>, id[u], <span class="number">0</span>); ans[u] += del * query(<span class="number">1</span>, id[u], <span class="number">1</span>), update(<span class="number">1</span>, id[u], id[u], <span class="number">0</span>, -del);</span><br><span class="line">    update(<span class="number">1</span>, id[u], id[u], <span class="number">1</span>, tmp);</span><br><span class="line">    <span class="keyword">while</span> (u) &#123;</span><br><span class="line">        update(<span class="number">1</span>, id[top[u]], id[fa[u]], <span class="number">2</span>, tmp), u = top[u];</span><br><span class="line">        del = query(<span class="number">1</span>, id[fa[u]], <span class="number">0</span>);</span><br><span class="line">        ans[fa[u]] += del * query(<span class="number">1</span>, id[fa[u]], <span class="number">1</span>), update(<span class="number">1</span>, id[fa[u]], id[fa[u]], <span class="number">0</span>, -del), update(<span class="number">1</span>, id[fa[u]], id[fa[u]], <span class="number">1</span>, tmp);</span><br><span class="line">        u = fa[u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ans[u] + query(<span class="number">1</span>, id[u], <span class="number">0</span>) * query(<span class="number">1</span>, id[u], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> __rd;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>, c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RD (read(__rd), __rd)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN(x) freopen(x<span class="meta-string">".in"</span>, <span class="meta-string">"r"</span>, stdin), freopen(x<span class="meta-string">".out"</span>, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    OPEN("strtree");</span></span><br><span class="line">    <span class="keyword">int</span> n = RD, m = RD; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) mark[i] = RD;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b;i &lt; n;i++) a = RD, b = RD, adde(a, b);</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>), dfs2(<span class="number">1</span>, <span class="number">1</span>), build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = RD, b = RD; </span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">1</span>) Tupdate1(b); <span class="keyword">else</span> Tupdate2(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[CodeChef] Adi and the Matrix</title>
      <link href="/2019/03/08/CodeChef-Adi-and-the-Matrix/"/>
      <url>/2019/03/08/CodeChef-Adi-and-the-Matrix/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.codechef.com/SNCKEL19/problems/ADIMAT/" target="_blank" rel="noopener">题目链接</a></p><p><img src="https://s2.ax1x.com/2019/03/08/kzOHcF.png" alt=""></p><p>有$N*M\leq 550$</p><p>注意到数据范围，它的含义是说，N和M中较小的那个不会超过23</p><p>我们考虑置换，首先假设$N\leq M$</p><p>枚举N的划分方案，注意要从小到大枚举，这个数不会太大</p><p>这个划分方案中每一个集合对应着一个循环</p><p>如果元素个数是$n$，划分方案为$(a_i,b_i)$，即长度为$a_i$的循环有$b_i$个</p><p>那么它对应的置换总数为</p><script type="math/tex; mode=display">\frac{n!}{\prod a_i^{b_i}b_i!}</script><p>这个式子的意思是说，将所有元素进行排列，每一个循环中都有$a_i$种等价方案，即旋转0次、旋转1次，……，旋转$a_i-1$次，长度相同的循环之间可以互换顺序</p><p>假如我们已经知道了M对应的循环，那么考虑如何计算不动点个数</p><p>对于一个格子，它在行内的循环假设长度为$a$，在列内的循环假设长度为$b$。那么我们知道，它在经过$a$次置换后会回到原来所在的行，在经过$b$次置换后会回到原来所在的列</p><p>所以，最少需要$lcm(a,b)$次置换才能回到原点</p><p>也就是说，每一种方案，都有$lcm(a,b)$种方案是与它等价的</p><p>对于这两个循环中，我们知道一共有$ab$个格子</p><p>所以，不动点的个数是$\frac{ab}{lcm(a,b)}=gcd(a,b)$</p><p>每个不动点都有两种染色方案，即0或1</p><p>我们考虑使用<code>dp</code>来计算贡献</p><p><code>dp[i][j]</code>表示还剩下<code>i</code>列没有分配，还没有分配循环长度<code>j</code>时所有方案的不动点个数之和</p><p>我们枚举长度为<code>j</code>的循环个数</p><p>求出之前枚举出来的$N$的划分中每一个$a_i$与<code>j</code>的$gcd$之和</p><p>注意循环对应的置换个数是$\frac{M!}{\prod a_i^{b_i}b_i!}$，这里我们把$M$提出来，在<code>dp</code>的时候顺便转移分母</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 600</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> dp[N][N], a[N], top, n, m, frac[N], inv[N], g[N][N], Pow2[N];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y &gt;&gt;= <span class="number">1</span>, x = (LL)x * x % mod) <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inc</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;x += y, x -= x &gt;= mod ? mod : <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> b ? gcd(b, a % b) : a;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp)), dp[m][m] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m;j &gt;= <span class="number">1</span>;j--)</span><br><span class="line">            <span class="keyword">if</span> (dp[i][j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> val = <span class="number">0</span>, tmp = dp[i][j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>;k &lt;= top;k++) </span><br><span class="line">                    val += g[j][a[k]];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;j * k &lt;= i;k++) &#123;</span><br><span class="line">                    Inc(dp[i - j * k][j - <span class="number">1</span>], (LL)tmp * inv[k] % mod);</span><br><span class="line">                    tmp = (LL)tmp * inv[j] % mod * frac[j - <span class="number">1</span>] % mod * Pow2[val] % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> (LL)dp[<span class="number">0</span>][<span class="number">0</span>] * frac[m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// for (int i = 1;i &lt;= top;i++) cout &lt;&lt; a[i] &lt;&lt; ' ';</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">int</span> res = frac[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= top;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= top &amp;&amp; a[i] == a[i + <span class="number">1</span>]) i++, cnt++;</span><br><span class="line">        res = (LL)res * Pow(Pow(a[i], cnt), mod - <span class="number">2</span>) % mod * inv[cnt] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (LL)res * solve() % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> cur, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!n) &#123;top = dep, Inc(ans, calc()); <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; cur) <span class="keyword">return</span>;</span><br><span class="line">    dfs(n, cur + <span class="number">1</span>, dep);</span><br><span class="line">    a[++dep] = cur, dfs(n - cur, cur, dep);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    frac[<span class="number">0</span>] = inv[<span class="number">0</span>] = Pow2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= N - <span class="number">10</span>;i++) frac[i] = (LL)frac[i - <span class="number">1</span>] * i % mod, inv[i] = Pow(frac[i], mod - <span class="number">2</span>), Pow2[i] = Pow2[i - <span class="number">1</span>] * <span class="number">2</span> % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= N - <span class="number">10</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= i;j++)</span><br><span class="line">            g[i][j] = g[j][i] = gcd(i, j);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) swap(n, m);</span><br><span class="line">    dfs(n, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (LL)ans * inv[n] % mod * inv[m] % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>inv[i]</code>表示i的阶乘的逆元，<code>g[i][j]</code>表示$gcd(i,j)$，<code>Pow2[i]</code>表示$2^i$，<code>frac[i]</code>表示$i!$</p><p>那个<code>inv[j] * frac[j - 1]</code>等价于除以<code>j</code></p><p>注意最后需要将答案除以置换总数$n!m!​$</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> Polya </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>置换专题</title>
      <link href="/2019/03/08/%E7%BD%AE%E6%8D%A2%E4%B8%93%E9%A2%98/"/>
      <url>/2019/03/08/%E7%BD%AE%E6%8D%A2%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="A-–-Necklace-of-Beads"><a href="#A-–-Necklace-of-Beads" class="headerlink" title="A – Necklace of Beads"></a>A – Necklace of Beads</h1><p><a href="https://en.wikipedia.org/wiki/Burnside%27s_lemma" target="_blank" rel="noopener">Burnside</a>定理模板</p><p>假设有n个条件$S$，每个条件都是形如“$A$与$B$等价”的形式，要求集合$X$在这些条件下的方案数</p><p>将条件分解成循环的形式，那么方案数</p><script type="math/tex; mode=display">=\frac{1}{n}\sum_{g\in S}|X^g|</script><p>其中，$X^g$是置换$g$作用于集合$X$之后的<strong>不动点个数</strong>，即不变的元素的个数</p><p>那么对于这道题，我们考虑两类置换</p><ul><li>1.旋转</li></ul><p>假设有一条长度为n的项链，旋转之后相同被视为相同方案，那么显然地，我们有n种对应的置换</p><p>即不旋转，旋转1次，旋转2次，…，旋转n-1次</p><p>考虑计算不动点个数</p><p>假设现在旋转了2次</p><p><img src="https://0x131cc05home.files.wordpress.com/2019/01/%E6%8D%95%E8%8E%B7-9.png?w=700" alt="img"></p><p>如果要求旋转之后不变（不动点），那么1号点、3号点、5号点的颜色必须相同</p><p>因为1号点转一次可以转到3号点，而3号点转一次可以转到5号点</p><p>如果这三个点的颜色不相同，那么旋转之后就变了，不能再称之为不动点</p><p>同理，2号点、4号点、6号点的颜色必须相同</p><p>总结一下：</p><blockquote><p>对于长度为n的项链，旋转i次之后得到的不动点个数为$gcd(i,n)$</p><p>不动点之间互不影响，假设有m种颜色，那么此时的染色方案为$m^{gcd(i,n)}$</p></blockquote><ul><li>2.翻转</li></ul><p>分奇偶考虑</p><p>先考虑奇数</p><p>一条对称轴必定穿过一个顶点，也就是说，一个顶点对应一条对称轴</p><p><img src="https://0x131cc05home.files.wordpress.com/2019/01/%E6%8D%95%E8%8E%B7-10.png?w=700" alt="img"></p><p>如果要满足变换之后不变，显然2、5号点必须相等，3、4号点必须相等，1号点随意</p><blockquote><p>如果有n个点，m种颜色，且n为奇数，那么这种置换一共有n个，每种置换有$m^{\frac{n+1}{2}}$种方案</p></blockquote><p>考虑偶数的情况</p><p>稍微麻烦一点</p><p>1.对称轴穿过一条边的中点，不穿过点</p><p>显然，此时有$m^{\frac{n}{2}}$种方案，共$\frac{n}{2}$种置换</p><p>2.对称轴穿过两个点</p><p>其它点两两配对，这两个点随便染色</p><p>共$m^{\frac{n-2}{2}+2}$种方案，共$\frac{n}{2}$种置换</p><p>最后除以置换总数2n即可</p><h1 id="B-–-Let-it-Bead"><a href="#B-–-Let-it-Bead" class="headerlink" title="B – Let it Bead"></a>B – Let it Bead</h1><p>和A题相同，将颜色数从3改为m即可</p><h1 id="C-–-Color"><a href="#C-–-Color" class="headerlink" title="C – Color"></a>C – Color</h1><p>N颗珠子，N种颜色，而且$N\leq 10^9$</p><p>显然枚举旋转方案i不行</p><p>考虑枚举gcd</p><p>假设gcd=x，那么实际上就是要计算有多少个i满足$i\leq n$且$gcd(i,n)=x$</p><p>首先，x必须是n的因数，而且是i的因数</p><p>假设$n=x*a,i=x*b$，那么a与b互质</p><p>所以，i的个数为$\varphi(\frac{n}{x})$</p><p>x只有$\sqrt n$种取值</p><p>筛一下2e5之内的质数即可</p><h1 id="D-–-Magic-Bracelet"><a href="#D-–-Magic-Bracelet" class="headerlink" title="D – Magic Bracelet"></a>D – Magic Bracelet</h1><p>n颗珠子，m种颜色，k种限制，每种限制形如“颜色a与颜色b不能放在一起”</p><p>先不管限制</p><p>考虑旋转i步之后的状态</p><p><img src="https://0x131cc05home.files.wordpress.com/2019/01/%E6%8D%95%E8%8E%B7-12.png?w=700" alt="img"></p><p>假设虚线中是一个循环节，显然，1号点和5号点的颜色应当相同，而与2、3、4、5号点的颜色无关</p><p>如果要求满足限制，那么在上图中的含义等价为“放5颗珠子，第1颗珠子与第5颗珠子颜色相同并且满足限制的方案数”</p><p>循环节长度为i，那么珠子数就为i+1</p><p>将这个过程想象成一张图</p><p>如果a与b不能相邻，那么点a到点b之间没有边，否则有一条双向边</p><p>最开始的图是一张完全图，每个条件会删去一条双向边</p><p>答案就等于<strong>在这张图上走i+1步，且起点与终点相同的方案数</strong></p><p>这张图的邻接矩阵是一个01矩阵，那么走i+1步就是取这个矩阵的i次方</p><p>答案为对角线上的数之和</p><p>由于又是$n\leq 10^9$，所以需要矩阵乘法</p><p>剩下的和上一道题一样，先筛质数然后求$\varphi$即可</p><h1 id="E-–-Who’s-Aunt-Zhang"><a href="#E-–-Who’s-Aunt-Zhang" class="headerlink" title="E – Who’s Aunt Zhang"></a>E – Who’s Aunt Zhang</h1><p>一个三阶魔方，给每个面、每个角、每条棱上色，共n中颜色，将魔方整体旋转之后相同的视为等价情况，问方案数</p><p>首先面数+棱数+角数=54+12+8=74</p><p>有4类置换</p><h4 id="1-不动"><a href="#1-不动" class="headerlink" title="1.不动"></a>1.不动</h4><p>方案数$n^{74}$</p><p>有1种置换</p><h4 id="2-以某个面的中心为轴旋转"><a href="#2-以某个面的中心为轴旋转" class="headerlink" title="2.以某个面的中心为轴旋转"></a>2.以某个面的中心为轴旋转</h4><p><img src="https://0x131cc05home.files.wordpress.com/2019/01/%E6%8D%95%E8%8E%B7-13.png?w=700" alt="img"></p><p>有3种方案：转90度、转180度、转270度</p><p>注意到第一种方案和第三种方案要求轴所在的那一面的四条棱都相等，而第二种方案仅要求两条棱相等</p><p>对于第一种和第三种方案，答案为$n^{20}$</p><p>正对着的两个面共有$3*2$)种方案</p><p>中心有1种，棱上的面有1种，角上的面有1种，这样的面有2个，所以有6种</p><p>剩下的四个面染色方案必须一样，但每个面中的颜色独立，共9种</p><p>正对着的两个面每个面上的棱只有1种方案，共2种</p><p>剩下的四条棱有1种</p><p>角分为两组，坐标一组，右边一组，每组颜色必须相同，共2种</p><p>所以共$6+9+3+2=20$种方案</p><p>置换个数为$2*3=6$种（以某两个面为轴，转90度或270度）</p><p>对于第二种方案，答案为$n^{38}​$</p><p>正对着的两个面上，将面两两分组，每组颜色必须相同</p><p>共$(2+2+1)*2=10​$种（角上的面两种，棱上的面两种，中心一种，共两个这样的面）</p><p>其余的四个面两两配对，每个面上颜色独立，共$9*2=18$种</p><p>将棱两两配对，每对的颜色必须相同，共6种</p><p>将角两两配对，每对的颜色必须相同，共4种</p><p>总方案数为$10+18+6+4=32$种</p><p>置换有3种（将面两两配对，每一对只有1种置换）</p><h4 id="以相对的两个角为中心旋转"><a href="#以相对的两个角为中心旋转" class="headerlink" title="以相对的两个角为中心旋转"></a>以相对的两个角为中心旋转</h4><p><img src="https://0x131cc05home.files.wordpress.com/2019/01/%E6%8D%95%E8%8E%B7-15.png?w=700" alt="img"></p><p>在这种情况下，旋转120度和旋转240度是等价的</p><p>都有$n^{26}$种方案</p><p>对着的两个角特殊考虑，其余的角、边、棱三个为一组，每组颜色互不影响，共$2+\frac{74-2}{3}=26$种</p><p>共$2*4=8​$种置换</p><h4 id="以相对的两条棱的中心为轴旋转"><a href="#以相对的两条棱的中心为轴旋转" class="headerlink" title="以相对的两条棱的中心为轴旋转"></a>以相对的两条棱的中心为轴旋转</h4><p><img src="https://0x131cc05home.files.wordpress.com/2019/01/%E6%8D%95%E8%8E%B7-16.png?w=700" alt="img"></p><p>选中的两条棱特殊考虑，其余元素两两配对</p><p>共$2+\frac{74-2}{2}=38$种方案</p><p>有$\frac{12}{2}=6$种置换</p><hr><p>所以总置换数为24，最后除以24即可</p><h1 id="F-–-Toy"><a href="#F-–-Toy" class="headerlink" title="F – Toy"></a>F – Toy</h1><p>前置题目<a href="https://www.luogu.org/problemnew/show/P2144" target="_blank" rel="noopener">轮状病毒</a></p><p>首先不考虑等价的情况</p><p>有两种方法</p><ol><li>矩阵树定理+打表(oeis)</li></ol><p>矩阵是度数矩阵-邻接矩阵，再随便去掉某一行和某一列</p><p>然后打表</p><ol><li>递推</li></ol><p>先不考虑连成环的情况</p><p>设$f(n)$表示除了中心点，还有n个点的生成树个数</p><p>那么有</p><script type="math/tex; mode=display">f(n)=\sum_{i=1}^{n}f(n-i)\*i</script><p>含义是，假设这次选取的连通块有i个节点，剩下的点共有$f(n-i)$种方案，这个连通块可以选择任意一个点连向中心点，共i种方案</p><p>化简这个式子</p><script type="math/tex; mode=display">f(n)=\sum_{i=0}^{n-1}f(i)\*(n-i)</script><script type="math/tex; mode=display">f(n-1)=\sum_{i=0}^{n-2}f(i)\*(n-i-1)</script><script type="math/tex; mode=display">f(n)=f(n-1)+\sum_{i=0}^{n-1}f(i)</script><script type="math/tex; mode=display">f(n-1)=f(n-2)+\sum_{i=0}^{n-2}f(i)</script><script type="math/tex; mode=display">f(n)-f(n-1)=f(n-1)-f(n-2)+f(n-1)</script><script type="math/tex; mode=display">f(n)=3f(n-1)-f(n-2)</script><p>注意这个式子仅当$n\geq 3$时成立</p><p>考虑连成环的情况</p><p>就是1号点和n号点连了起来</p><p>假设这个连通块有i个点</p><p>那么有i-1种连通块可以选择（包含1-n这条边的连通块数），随便选一个点连向中心点</p><p>设方案数为$g(n)$</p><p>那么</p><script type="math/tex; mode=display">g(n)=\sum_{i=2}^{n}i\*(i-1)\*f(n-i)</script><script type="math/tex; mode=display">=\sum_{i=1}^{n}i\*(i-1)\*f(n-i)</script><p>总方案数</p><script type="math/tex; mode=display">F(n)=f(n)+g(n)</script><script type="math/tex; mode=display">=\sum_{i=1}^{n}f(n-i)\*i^2</script><p>我们有$f(0)=1,f(1)=1,f(2)=3$</p><script type="math/tex; mode=display">\because \sum_{i=n-2}^nf(n-i)\*i^2=3\*(n-2)^2+(n-1)^2+n^2</script><script type="math/tex; mode=display">=3\*(n-1)^2+2\*(n-2)^2+2</script><script type="math/tex; mode=display">\therefore F(n)=\sum_{i=1}^{n-3}f(n-i)\*i^2+3\*(n-1)^2+2\*(n-2)^2+2</script><script type="math/tex; mode=display">\because n-i\geq 3</script><script type="math/tex; mode=display">\therefore F(n)=\sum_{i=1}^{n-3}[3\*f(n-i-1)-f(n-i-2)]\*i^2+3\*(n-1)^2\*f(0)+(n-2)^2\*[3\*f(1)-f(0)]+2</script><script type="math/tex; mode=display">=\sum_{i=1}^{n-2}[3\*f(n-i-1)-f(n-i-2)]\*i^2+3\*(n-1)^2\*f(0)+2</script><script type="math/tex; mode=display">=3\*\sum_{i=1}^{n-1}f(n-i-1)\*i^2-\sum_{i=1}^{n-2}f(n-i-2)+2</script><script type="math/tex; mode=display">=3\*F(n-1)-F(n-2)+2</script><p>写成矩阵的形式就是</p><script type="math/tex; mode=display">\begin{bmatrix}3&-1&2\\\1&0&0\\\0&0&1\end{bmatrix}^{n-2}\*\begin{bmatrix}F(2)\\\F(1)\\\1\end{bmatrix}</script><p>然后再求欧拉函数，枚举gcd即可</p><h1 id="G-–-Birthday-Toy"><a href="#G-–-Birthday-Toy" class="headerlink" title="G – Birthday Toy"></a>G – Birthday Toy</h1><p>考虑n个位置，m种颜色，要求相邻颜色不同，并且首位颜色一样的方案数（$n,m\leq 10^9$）</p><p>先考虑朴素的dp:<code>dp[i][j][k]</code>表示到了第i个位置，这一位颜色为j，最开始的颜色为k的方案数</p><p>转移很好转移</p><p>考虑优化：我们并不关心当前位置的颜色是什么，我们只关心它与首位颜色相不相同，所以可以简化状态</p><p><code>dp[i][0/1]</code>表示到了第i位，与当前首位颜色相同/不相同的方案数</p><p>那么有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][0]&#x3D;dp[i-1][1]</span><br><span class="line">dp[i][1]&#x3D;dp[i-1][0]*(m-1)+dp[i-2][1]*(m-2)</span><br></pre></td></tr></table></figure><p>矩阵乘法加速即可</p><h1 id="I-–-Leonardo’s-Notebook"><a href="#I-–-Leonardo’s-Notebook" class="headerlink" title="I – Leonardo’s Notebook"></a>I – Leonardo’s Notebook</h1><p>结论：</p><blockquote><p>两个长度为n的相同循环相乘，当n为奇数是结果是一个长为n的循环，否则是两个长度为$\frac{n}{2}$的循环的乘积</p></blockquote><p>所以长度为奇数的循环一定可以被拆成两个相同循环的乘积，长度为偶数的循环需要两两配对，如果能配对上就可以</p><h1 id="K-–-Find-the-Permutations"><a href="#K-–-Find-the-Permutations" class="headerlink" title="K – Find the Permutations"></a>K – Find the Permutations</h1><p>下标与序列构成了一个置换</p><p>将置换分解，注意到每个循环所需要的交换次数是循环长度-1</p><p>加起来就是n-循环节个数</p><p>所以dp，<code>dp[i][j]</code>表示到第i个位置，一共有j个循环的方案数</p><p>i这个数可以新开一个循环，也可以插入到前面任意一个数的后面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]&#x3D;dp[i-1][j-1]+dp[i-1][j]*(i-1)</span><br></pre></td></tr></table></figure><h1 id="L-–-Necklace"><a href="#L-–-Necklace" class="headerlink" title="L – Necklace"></a>L – Necklace</h1><p>每种颜色的珠子有限制个数</p><p>还是枚举gcd，但是要求$\frac{n}{gcd}$必须是每种珠子个数的因数</p><p>然后可重排列</p><p>翻转有点毒瘤，考虑两种情况：n为奇数或是偶数</p><p>奇数比较简单，偶数又要分两种情况</p><p>注意细节，还是比较模板的</p><h1 id="M-–-Cubes"><a href="#M-–-Cubes" class="headerlink" title="M – Cubes"></a>M – Cubes</h1><p>L + E</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> polya </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>莫比乌斯反演与杜教筛专题</title>
      <link href="/2019/03/08/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E4%B8%8E%E6%9D%9C%E6%95%99%E7%AD%9B%E4%B8%93%E9%A2%98/"/>
      <url>/2019/03/08/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E4%B8%8E%E6%9D%9C%E6%95%99%E7%AD%9B%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="A-–-GCD"><a href="#A-–-GCD" class="headerlink" title="A – GCD"></a>A – GCD</h1><p>莫比乌斯反演模板，注意去重</p><p>当$i\leq min(n,m)$时，每个gcd都被计算了两遍，除以2即可</p><h1 id="B-–-CA-Loves-GCD"><a href="#B-–-CA-Loves-GCD" class="headerlink" title="B – CA Loves GCD"></a>B – CA Loves GCD</h1><p>见<a href="/2019/03/07/莫比乌斯反演">莫比乌斯反演</a> CA Loves GCD</p><h1 id="C-–-Hillan-and-the-girl"><a href="#C-–-Hillan-and-the-girl" class="headerlink" title="C – Hillan and the girl"></a>C – Hillan and the girl</h1><p>首先转化成总数-gcd是完全平方数的个数</p><script type="math/tex; mode=display">\sum_{i=1}^{n}\sum_{j=1}^{n}[gcd(i,j)\in sqrt\ number]</script><p>按照套路，先枚举gcd，此处是gcd的平方根</p><script type="math/tex; mode=display">=\sum_{d=1}^{\sqrt n}\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=d^2]</script><p>莫比乌斯反演</p><script type="math/tex; mode=display">=\sum_{d=1}^{\sqrt n}\sum_{l=1}^{\lfloor\frac{n}{d^2}\rfloor}\mu(l)\lfloor\frac{n}{d^2l}\rfloor\lfloor\frac{m}{d^2l}\rfloor</script><p>然后换T</p><script type="math/tex; mode=display">T=d^2l</script><p>改写式子</p><script type="math/tex; mode=display">=\sum_{T=1}^{n}\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor\sum_{l|T}\mu(l)</script><p>最后那个可以预处理</p><p>对于每一个$\mu$，枚举一个完全平方数更新，最后算一下前缀和即可</p><h1 id="D-–-Trick-GCD"><a href="#D-–-Trick-GCD" class="headerlink" title="D – Trick GCD"></a>D – Trick GCD</h1><p>很经典的一道题</p><p>题目要求$gcd\geq 2$，转化成求$gcd=1$的方案数，再用总数去减</p><p>设$f(x)$为gcd恰好为x的方案数，$g(x)$为gcd为x的倍数的方案数</p><p>显然有</p><script type="math/tex; mode=display">g(x)=\sum_{x|d}f(d)</script><script type="math/tex; mode=display">f(x)=\sum_{x|d}g(d)\mu(\frac{d}{x})</script><p>此时f中的x是1</p><p>现在关键是要求出g</p><p>假设当前是$g(x)$</p><p>对于每一个$A_i$，有$\lfloor\frac{A_i}{x}\rfloor$的贡献，注意到一段区间内的$A_i$贡献相同，所以对A整体分块计算贡献，然后乘起来就好了</p><p>一部分代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), buk[a]++, mn = min(mn, a), mx = max(mx, a);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= mx * <span class="number">2</span>;i++) buk[i] += buk[i - <span class="number">1</span>]; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= mn;i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = -mu[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt;= mx;j += i) </span><br><span class="line">        tmp = (LL)tmp * Pow(j / i, buk[j + i - <span class="number">1</span>] - buk[j - <span class="number">1</span>]) % mod;</span><br><span class="line">        ans = (ans + tmp) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-F-G-–-GCD-Extreme-x"><a href="#E-F-G-–-GCD-Extreme-x" class="headerlink" title="E,F,G – GCD Extreme(x)"></a>E,F,G – GCD Extreme(x)</h1><p>直接用$\varphi$替换gcd即可</p><p>经典题目</p><h1 id="H-–-Zap"><a href="#H-–-Zap" class="headerlink" title="H – Zap"></a>H – Zap</h1><p>莫比乌斯反演模板</p><p>上界同时除以d即可</p><h1 id="I-–-数表"><a href="#I-–-数表" class="headerlink" title="I – 数表"></a>I – 数表</h1><p>求</p><script type="math/tex; mode=display">\sum_{i=1}^{n}\sum_{j=1}^{m}\sigma(gcd(i,j))[\sigma(gcd(i,j))\leq a]</script><p>先莫比乌斯反演一波</p><script type="math/tex; mode=display">=\sum_{i=1}^{n}\sum_{j=1}^{m}\sigma(gcd(i,j))[\sigma(gcd(i,j))\leq a]</script><script type="math/tex; mode=display">=\sum_{d=1}^{n}\sigma(d)[\sigma(d)\leq a]\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=d]</script><script type="math/tex; mode=display">=\sum_{d=1}^{n}\sigma(d)[\sigma(d)\leq a]\sum_{l=1}^{\lfloor\frac{n}{d}\rfloor}\mu(l)\lfloor\frac{n}{dl}\rfloor\lfloor\frac{m}{dl}\rfloor</script><p>设</p><script type="math/tex; mode=display">T=dl</script><p>改写式子</p><script type="math/tex; mode=display">=\sum_{T=1}^{n}\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor\sum_{d|T}\sigma(d)\mu(\frac{T}{d})[\sigma(d)\leq a]</script><p>约数和这个函数是可以直接求的</p><p>考虑将询问按照限制大小从小到大排序</p><p>将约数和也从小到大排序</p><p>当一个约数和达到限制以下后，枚举它的倍数更新</p><p>由于计算要用到前缀和，使用树状数组维护即可</p><h1 id="J-–-Crash的数字表格"><a href="#J-–-Crash的数字表格" class="headerlink" title="J – Crash的数字表格"></a>J – Crash的数字表格</h1><p>见<a href="/2019/03/07/莫比乌斯反演">莫比乌斯反演</a></p><h1 id="K-–-DZY-Loves-Math"><a href="#K-–-DZY-Loves-Math" class="headerlink" title="K – DZY Loves Math"></a>K – DZY Loves Math</h1><p>神仙题</p><p>先来反演一波</p><script type="math/tex; mode=display">\sum_{i=1}^{n}\sum_{j=1}^{m}f(gcd(i,j))</script><script type="math/tex; mode=display">=\sum_{d=1}^{n}f(d)\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=d]</script><script type="math/tex; mode=display">=\sum_{d=1}^{n}f(d)\sum_{l=1}^{\lfloor\frac{n}{d}\rfloor}\mu(l)\lfloor\frac{n}{dl}\rfloor\lfloor\frac{m}{dl}\rfloor</script><p>设</p><script type="math/tex; mode=display">T=dl</script><p>则有</p><script type="math/tex; mode=display">=\sum_{T=1}^{n}\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor\sum_{d|T}f(d)\mu(\frac{T}{d})</script><p>关键就是要求最后的那个东西</p><p>假设有$T=\prod p_i^{k_i}$，要想最后的那个$\mu$不为0，d的每一个质数的次数最少不会少于T中所对应的次数-1</p><p>也就是说，假如$f(T)=x$，那么$x-1\leq f(d)\leq x$</p><p>进一步考虑，最后可能影响答案的只有那些次数最高的项。如果T中质数的次数不全相等，那么对于$f(d)=x$的每一种方案，其它的项可以乱选，方案数是2的这些项的个数次方（要么次数不减，要么次数减1）</p><p>注意到$\mu(\frac{T}{d})$的值在上述的这两种情况中取值互为相反数，仅当T中质数的次数全部相等时，剩余项的方案数是$2^0$，在这一步中不能被抵消，其余情况均可两两抵消，这个$\sum$的值永远是0</p><p>考虑所有次数相等的情况</p><p>假设T的质因子个数为k</p><p>每个数仍然可以选或不选，$\mu$的和为0</p><p>但是对于所有质数都不选的情况，$f(d)$的值并不是x，而是x-1，所以答案要减去$-1*(-1)^k$，那个$(-1)^l$是$\mu(\frac{T}{d})$</p><p>所以此时的答案为</p><script type="math/tex; mode=display">(-1)^{k+1}</script><p>假设当前要求的是</p><script type="math/tex; mode=display">\sum_{d|T}f(d)\mu(\frac{T}{d})</script><p>那么：</p><p>假设存在x，使得$\mu(x)\not=0$，且T是x的k次方，那么$\sum_{d|T}f(d)\mu(\frac{T}{d})=-\mu(x)]$</p><p>否则这个值为0</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">int</span> prime[N], ncnt, mu[N], sum[N], flag[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= N - <span class="number">10</span>;i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!flag[i]) prime[++ncnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= ncnt &amp;&amp; i * prime[j] &lt;= N - <span class="number">10</span>;j++) &#123;</span><br><span class="line">flag[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">mu[i * prime[j]] = -mu[i];</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= N - <span class="number">10</span>;i++)</span><br><span class="line"><span class="keyword">if</span> (mu[i] != <span class="number">0</span>) <span class="keyword">for</span> (LL j = i;j &lt;= N - <span class="number">10</span>;j *= i) </span><br><span class="line">sum[j] = -mu[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= N - <span class="number">10</span>;i++) sum[i] += sum[i - <span class="number">1</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &gt; m) swap(n, m);</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r;l &lt;= n;l = r + <span class="number">1</span>) &#123;</span><br><span class="line">r = min(n / (n / l), m / (m / l));</span><br><span class="line">ans += (LL)(n / l) * (m / l) * (sum[r] - sum[l - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T), sieve();</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="keyword">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, solve(a, b));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="L-–-Sum"><a href="#L-–-Sum" class="headerlink" title="L – Sum"></a>L – Sum</h1><p>杜教筛模板</p><p>见<a href="/2019/03/08/杜教筛">杜教筛</a></p><h1 id="M-–-能量采集"><a href="#M-–-能量采集" class="headerlink" title="M – 能量采集"></a>M – 能量采集</h1><p>讲一讲求</p><script type="math/tex; mode=display">\sum_{i=1}^{n}\sum_{j=1}^{m}gcd(i,j)</script><p>的两种求法</p><p>以前已经写过了，直接贴上来</p><p><img src="https://0x131cc05home.files.wordpress.com/2019/01/%E6%8D%95%E8%8E%B7-3.png?w=700" alt="img"></p><p><img src="https://0x131cc05home.files.wordpress.com/2019/01/%E6%8D%95%E8%8E%B7-4.png?w=700" alt="img"></p><p><img src="https://0x131cc05home.files.wordpress.com/2019/01/%E6%8D%95%E8%8E%B7-5.png?w=700" alt="img"></p><p>第二种方法</p><p><img src="https://0x131cc05home.files.wordpress.com/2019/01/%E6%8D%95%E8%8E%B7-6.png?w=700" alt="img"></p><p>可以看出选择合适的解法的重要性</p><h1 id="N-–-DZY-Loves-Math-VI"><a href="#N-–-DZY-Loves-Math-VI" class="headerlink" title="N – DZY Loves Math VI"></a>N – DZY Loves Math VI</h1><p>还是套路，先设出gcd，然后反演，最后换T</p><p>精雕细琢即可</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫比乌斯反演 </tag>
            
            <tag> 杜教筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的数学题</title>
      <link href="/2019/03/08/%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98/"/>
      <url>/2019/03/08/%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>求</p><script type="math/tex; mode=display">\sum_{i=1}^{n}\sum_{j=1}^{n}ijgcd(i,j)</script><script type="math/tex; mode=display">n\leq 10^{10}</script><p>根据$\varphi$的性质</p><script type="math/tex; mode=display">\sum_{i|d}\varphi(i)=d</script><p>可以改写上面那个式子</p><script type="math/tex; mode=display">=\sum_{i=1}^{n}\sum_{j=1}^{n}ij\sum_{d|gcd(i,j)}\varphi(d)</script><p>把d提到前面来</p><script type="math/tex; mode=display">=\sum_{i=1}^{n}\sum_{j=1}^{n}ij\sum_{d|gcd(i,j)}\varphi(d)</script><p>为了方便快捷，设</p><script type="math/tex; mode=display">F(n)=\sum_{i=1}^{n}i</script><p>那么原式就改写为</p><script type="math/tex; mode=display">=\sum_{d=1}^{n}\varphi(d)\*d^2\*F(\lfloor\frac{n}{d}\rfloor)^2</script><p>注意到后面的那个F括号内只有$\sqrt n$种取值，直接分块</p><p>现在关键就是要求前面那个的前缀和</p><p>但是有$n\leq 10^{10}$，直接筛显然不行，所以上杜教筛</p><p>设</p><script type="math/tex; mode=display">S(n)=\sum_{i=1}^{n}\varphi(i)\*i^2</script><p>现在关键就是要找一个函数g来与$f(i)=\varphi(i)*i^2$卷积</p><p>观察到有$\sum_{i|d}\varphi(i)=d$，所以中间的那个$\varphi$可以不管</p><p>但是那个$i^2$很烦，要弄掉这个</p><p>所以考虑使用$g(x)=x^2$这个函数来卷积</p><p>根据杜教筛的公式</p><script type="math/tex; mode=display">g(1)S(n)=\sum_{i=1}^{n}(g\*f)(i)-\sum_{i=2}^{n}g(i)S(\lfloor\frac{n}{i}\rfloor)</script><p>这个$(g*f)(i)$其实就是</p><script type="math/tex; mode=display">\sum_{j=1}^{i}\varphi(j)\*j^2\*\frac{n^2}{j^2}=n^3</script><p>而$g(1)=1^2=1$</p><p>所以</p><script type="math/tex; mode=display">S(n)=\sum_{i=1}^{n}i^3-\sum_{i=2}^{n}i^2S(\lfloor\frac{n}{i}\rfloor)</script><p>有神仙公式</p><script type="math/tex; mode=display">\sum_{i=1}^{n}i^3=(\sum_{i=1}^{n}i)^2</script><p>以及</p><script type="math/tex; mode=display">\sum_{i=1}^{n}i^2=\frac{1}{6}n\*(n+1)\*(2n+1)</script><p>记忆化一波就可以了</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫比乌斯反演 </tag>
            
            <tag> 杜教筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杜教筛</title>
      <link href="/2019/03/08/%E6%9D%9C%E6%95%99%E7%AD%9B/"/>
      <url>/2019/03/08/%E6%9D%9C%E6%95%99%E7%AD%9B/</url>
      
        <content type="html"><![CDATA[<p>假设有一道题：求</p><script type="math/tex; mode=display">\sum_{i=1}^{n}\mu(i)</script><p>然后$n\leq 10^9$</p><p>线筛大家都知道怎么做</p><p>考虑把这个东西转化</p><p>设</p><script type="math/tex; mode=display">S(n)=\sum_{i=1}^{n}\mu(n)</script><p>我们知道</p><script type="math/tex; mode=display">\sum_{i|d}\mu(i)=[d=1]</script><p>如何利用这个性质呢？考虑用另一个函数来与这个$\mu$卷积</p><p>我们使用1来卷，因为<strong>没有什么要抵消的</strong></p><script type="math/tex; mode=display">\sum_{i|d}\mu(i)\*1 = [d=1]=(\mu\*1)(d)</script><script type="math/tex; mode=display">1=\sum_{d=1}^{n}\sum_{i|d}\mu(\frac{d}{i})\*1</script><script type="math/tex; mode=display">=\sum_{i=1}^{n}\sum_{d=1}^{\lfloor\frac{n}{i}\rfloor}\mu(d)=\sum_{i=1}^{n}S(\lfloor\frac{n}{i}\rfloor)</script><p>我们已经将这个东西转化成了$S$，移一下项</p><script type="math/tex; mode=display">1=\sum_{i=1}^{n}S(\lfloor\frac{n}{i}\rfloor)</script><script type="math/tex; mode=display">1-\sum_{i=2}^{n}S(\lfloor\frac{n}{i}\rfloor)=S(n)</script><p>注意到$\lfloor\frac{n}{i}\rfloor$的取值不超过$\sqrt n$个，直接分块即可</p><p>然后<code>DFS</code></p><p>记得要记忆化！！！</p><h1 id="一般式"><a href="#一般式" class="headerlink" title="一般式"></a>一般式</h1><p>假设要求一个积性函数$f(x)$的前缀和$S(n)$</p><p>先找到另一个积性函数$g(x)$，与f做卷积</p><p>这个g函数的要求有几点：</p><p>1.前缀和很好求，要不然找g之后反而更慢</p><p>2.与f的卷积的前缀和很好求</p><p>开始</p><script type="math/tex; mode=display">(g*f)(d)=\sum_{i|d}g(i)f(\frac{d}{i})</script><script type="math/tex; mode=display">\sum_{i=1}^{n}(g*f)(i)=\sum_{i=1}^{n}\sum_{d|i}g(d)f(\frac{i}{d})</script><p>枚举d</p><script type="math/tex; mode=display">=\sum_{d=1}^{n}g(d)\sum_{d|i}f(\frac{i}{d})</script><script type="math/tex; mode=display">=\sum_{d=1}^{n}g(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}f(i)</script><script type="math/tex; mode=display">=\sum_{d=1}^{n}g(d)S(\lfloor\frac{n}{d}\rfloor)</script><p>移项</p><script type="math/tex; mode=display">g(1)S(n)=\sum_{i=1}^{n}(g*f)(i)-\sum_{i=2}^{n}g(i)S(\lfloor\frac{n}{i}\rfloor)</script><p>然后开始分块即可</p><p>代码其实很短</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="comment">// sum[N - 10] 是预处理的前缀和，一般大小为3e6</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 算 sum mu</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= N - <span class="number">10</span>) <span class="keyword">return</span> sum[n];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m.count(n)) <span class="keyword">return</span> m[n]; <span class="comment">// 记忆化</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (LL l = <span class="number">2</span>, r;l &lt;= n;l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = n / (n / l);</span><br><span class="line">        res -= (r - l + <span class="number">1</span>) * calc1(n / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m1[n] = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杜教筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>莫比乌斯反演</title>
      <link href="/2019/03/07/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
      <url>/2019/03/07/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
      
        <content type="html"><![CDATA[<h1 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h1><ul><li>$\mu(i)$ 莫比乌斯函数</li></ul><p>设$i=p_1^{k_1} p_2^{k_2} p_3^{k_3} \cdots p_m^{k_m}$</p><p>当$max(k) &gt; 1$时$\mu(i)=0$</p><p>否则$\mu(i)=(-1)^{\sum k}$</p><ul><li>$\varphi(i)$ 欧拉函数，为$[1,i]$内与i互质的数的个数</li></ul><p>设$n=p_1^{k_1} p_2^{k_2} p_3^{k_3} \cdots p_m^{k_m}$</p><p>则$\varphi(n)=n*\prod{(1-\frac{1}{p_i})}$</p><p>关于<a href="https://baike.baidu.com/item/%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E4%B9%98%E7%A7%AF/18903903?fr=aladdin" target="_blank" rel="noopener">狄利克雷卷积</a></p><ul><li>定义二元关系$*$，$f*g $的狄利克雷卷积为</li></ul><script type="math/tex; mode=display">(f*g)(n)=\sum_{d|n}f(d)g(\frac{n}{d})​</script><ul><li>卷积满足交换律</li></ul><script type="math/tex; mode=display">f\*g=g\*f</script><ul><li>结合律</li></ul><script type="math/tex; mode=display">(f\*g)\*h=f\*(g\*h)</script><ul><li>单位元</li></ul><script type="math/tex; mode=display">e(n)=[n=1]</script><script type="math/tex; mode=display">\displaystyle f*e=f</script><ul><li>逆元</li></ul><script type="math/tex; mode=display">f*f^{-1}=e</script><h1 id="一些性质"><a href="#一些性质" class="headerlink" title="一些性质"></a>一些性质</h1><script type="math/tex; mode=display">\sum_{d|n}\mu(d)=[n=1]</script><script type="math/tex; mode=display">\displaystyle \sum_{d|n}\varphi(d)=n</script><p>$\mu$与$\varphi$都是积性函数，可以线性筛</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000010</span></span><br><span class="line"><span class="keyword">int</span> flag[N], prime[N], mu[N], ncnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= N - <span class="number">10</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag[i]) mu[i] = <span class="number">-1</span>, prime[++ncnt] = i;</span><br><span class="line">        <span class="comment">//i是质数，mu[i]为-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= ncnt &amp;&amp; i * prime[j] &lt;= N;j++) &#123;</span><br><span class="line">            flag[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//筛质数用</span></span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//此时根据定义，mu为0</span></span><br><span class="line">            mu[i * prime[j]] = -mu[i];</span><br><span class="line">            <span class="comment">//mu[i * prime[j]] = mu[i] * mu[prime[j]] = -mu[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>积性函数都可以线性筛</strong></p><h1 id="莫比乌斯反演："><a href="#莫比乌斯反演：" class="headerlink" title="莫比乌斯反演："></a>莫比乌斯反演：</h1><ul><li>定理1</li></ul><p>若</p><script type="math/tex; mode=display">F(n)=\sum_{d|n}f(d)</script><p>则</p><script type="math/tex; mode=display">f(n)=\sum_{d|n}F(d)\mu(\frac{n}{d})</script><ul><li>定理2</li></ul><p>若</p><script type="math/tex; mode=display">F(n)=\sum_{n|d}f(d)</script><p>则</p><script type="math/tex; mode=display">f(n)=\sum_{n|d}F(d)\mu(\frac{n}{d})</script><ul><li>证明</li></ul><script type="math/tex; mode=display">F=f*1</script><p>有</p><script type="math/tex; mode=display">\mu(n)\*1=\sum_{d|n}\mu(d)\*1=[n=1]=e</script><p>所以</p><script type="math/tex; mode=display">\mu^{-1}=1</script><script type="math/tex; mode=display">F=f\*1=f\*\mu^{-1}</script><script type="math/tex; mode=display">F*\mu=f</script><script type="math/tex; mode=display">f(n)=(F*\mu)(n)=\sum_{d|n}F(d)\mu(\frac{n}{d})</script><h1 id="一些套路"><a href="#一些套路" class="headerlink" title="一些套路"></a>一些套路</h1><p>以<a href="https://www.luogu.org/problemnew/show/P1829" target="_blank" rel="noopener">Crash的数字表格</a>为例</p><p>求</p><script type="math/tex; mode=display">\sum_{i=1}^{n}\sum_{j=1}^{m}lcm(i,j)</script><h2 id="套路1-设出-gcd-，然后按照-gcd-分类"><a href="#套路1-设出-gcd-，然后按照-gcd-分类" class="headerlink" title="套路1.设出$gcd$，然后按照$gcd$分类"></a>套路1.设出$gcd$，然后按照$gcd$分类</h2><script type="math/tex; mode=display">\sum_{k=1}^{n}\sum_{i=1}^{n}\sum_{j=1}^{m}\frac{i*j}{k}[gcd(i,j)=k]</script><h4 id="方法1-凑出-gcd-i-j-1-然后使用-mu-函数的性质换元"><a href="#方法1-凑出-gcd-i-j-1-然后使用-mu-函数的性质换元" class="headerlink" title="方法1.凑出$[gcd(i,j)=1]$然后使用$\mu$函数的性质换元"></a>方法1.凑出$[gcd(i,j)=1]$然后使用$\mu$函数的性质换元</h4><p>将i,j同时除以k，注意$\frac{i*j}{k}$需要乘回去</p><script type="math/tex; mode=display">\sum_{k=1}^{n}\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}i\*j\*k[gcd(i,j)=1]</script><p>有</p><script type="math/tex; mode=display">\sum_{d|n}\mu(d)=[n=1]</script><p>所以</p><script type="math/tex; mode=display">[gcd(i,j)=1]=\sum_{d|gcd(i,j)}\mu(d)</script><h4 id="方法2-使用莫比乌斯反演基本公式"><a href="#方法2-使用莫比乌斯反演基本公式" class="headerlink" title="方法2.使用莫比乌斯反演基本公式"></a>方法2.使用莫比乌斯反演基本公式</h4><p>设</p><script type="math/tex; mode=display">f(x)=\sum_{i=1}^{n}\sum_{j=1}^{m}\frac{i*j}{x}[gcd(i,j)=x]</script><script type="math/tex; mode=display">\displaystyle F(x)=\sum_{i=1}^{n}\sum_{j=1}^{m}\frac{i*j}{x}[x|gcd(i,j)]</script><p>改写一下$F$</p><p>由于$gcd$是x的倍数，所以n,m都是x的倍数</p><p>同时除以x</p><script type="math/tex; mode=display">F(x)=\sum_{x|d}f(x)=\sum_{i=1}^{\lfloor\frac{n}{x}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{x}\rfloor}i\*j\*x</script><p>套用反演公式</p><script type="math/tex; mode=display">f(x)=\sum_{x|d}F(d)\mu(\frac{d}{x})</script><p>得到</p><script type="math/tex; mode=display">f(x)=\sum_{x|d}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}i\*j\*d\*\mu(\frac{d}{x})</script><p>代入原式即可</p><p>个人推荐推式子的时候用第一种方法，使用莫比乌斯反演容斥的时候使用第二种方法</p><p>从方法1的最后一步继续</p><script type="math/tex; mode=display">\sum_{k=1}^{n}\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}i\*j\*k[gcd(i,j)=1]</script><script type="math/tex; mode=display">=\sum_{k=1}^{n}\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}i\*j\*k\sum_{d|gcd(i,j)}\mu(d)</script><h2 id="套路2-枚举d，并放到前面去"><a href="#套路2-枚举d，并放到前面去" class="headerlink" title="套路2.枚举d，并放到前面去"></a>套路2.枚举d，并放到前面去</h2><p>此时i,j都应该是d的倍数</p><p>同样，注意要乘回去</p><script type="math/tex; mode=display">=\sum_{k=1}^{n}k\sum_{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d)\sum_{i=1}^{\lfloor\frac{n}{kd}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{kd}\rfloor}i\*j\*d^2</script><p>整理一下</p><script type="math/tex; mode=display">=\sum_{k=1}^{n}k\sum_{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d)*d^2\sum_{i=1}^{\lfloor\frac{n}{kd}\rfloor}i\sum_{j=1}^{\lfloor\frac{m}{kd}\rfloor}j</script><p>为了方便快捷，设</p><script type="math/tex; mode=display">F(n)=\sum_{i=1}^{n}i</script><p>将原式替换成</p><script type="math/tex; mode=display">=\sum_{k=1}^{n}k\sum_{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d)\*d^2\*F(\lfloor\frac{n}{kd}\rfloor)\*F(\lfloor\frac{m}{kd}\rfloor)</script><h2 id="套路3-换T大法"><a href="#套路3-换T大法" class="headerlink" title="套路3.换T大法"></a>套路3.换T大法</h2><p>为了提升时间复杂度，我们需要设一个神奇的T</p><p>设</p><script type="math/tex; mode=display">T=kd</script><p>所以原式等于</p><script type="math/tex; mode=display">\sum_{k=1}^{n}k\sum_{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d)\*d^2\*F(\lfloor\frac{n}{T}\rfloor)\*F(\lfloor\frac{m}{T}\rfloor)</script><p>枚举T，放到最前面</p><script type="math/tex; mode=display">\sum_{T=1}^{n}F(\lfloor\frac{n}{T}\rfloor)\*F(\lfloor\frac{m}{T}\rfloor)\sum_{d|T}\mu(d)\*\frac{T}{d}\*d^2</script><script type="math/tex; mode=display">\sum_{T=1}^{n}F(\lfloor\frac{n}{T}\rfloor)\*F(\lfloor\frac{m}{T}\rfloor)\*T\sum_{d|T}\mu(d)\*d</script><p>考虑优化最后那一坨的求法</p><p>直接求显然是$n\ log\ n$的</p><h2 id="套路4-设出积性函数"><a href="#套路4-设出积性函数" class="headerlink" title="套路4.设出积性函数"></a>套路4.设出积性函数</h2><p>观察到$\mu$以及$f(x)=x$（它还有个名字叫id）都是积性函数</p><p>两个积性函数的狄利克雷卷积以及直接对应相乘的结果都是积性函数</p><p>也就是说，这个东西是可以线性筛的</p><p>设</p><script type="math/tex; mode=display">g(x)=\sum_{d|x}\mu(d)*d</script><p>对x分类</p><ul><li>x是质数</li></ul><p>此时显然有$g(x)=1-x$</p><ul><li>x被表示成了$i*prime[j]$，其中$prime[j]\bot i$</li></ul><p>此时根据积性函数性质，$g(i<em>prime[j])=g(i)</em>g(prime[j])$，直接乘即可</p><ul><li>x被表示成了$i*prime[j]$，其中$prime[j]|i$</li></ul><p>考虑乘之后多出来的因数</p><p>由于多出来的因数<code>prime[j]</code>这个质数的次数至少是2，而根据$\mu$的定义此时$\mu$为0，对g没有贡献，直接忽略即可</p><p>所以此时$g(i*prime[j])=g(i)$</p><h2 id="套路5-数论分块"><a href="#套路5-数论分块" class="headerlink" title="套路5.数论分块"></a>套路5.数论分块</h2><p>预处理完了g，我们再来说说最后答案怎么求</p><p>答案等于</p><script type="math/tex; mode=display">\sum_{T=1}^{n}F(\lfloor\frac{n}{T}\rfloor)\*F(\lfloor\frac{m}{T}\rfloor)\*T\*g(T)</script><p>考虑从$\lfloor\frac{n}{T}\rfloor$,$\lfloor\frac{m}{T}\rfloor$ 开始优化</p><p>可以发现对于某一段的T，上面的两个式子的值都是不变的</p><p>这种不变的值的段数一共有$\sqrt n$段</p><p>考虑一段一段地枚举，而不是一个一个的枚举</p><p>此时变化的就只有$g(T)$</p><p>对$g(T)$求一下前缀和，算的时候直接求区间的和就好了</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> LL mod=<span class="number">20101009</span>;</span><br><span class="line"><span class="keyword">int</span> flag[<span class="number">10000010</span>],prime[<span class="number">10000010</span>],cnt,f[<span class="number">10000010</span>],sum[<span class="number">10000010</span>];</span><br><span class="line"><span class="comment">// sum是前缀和，f就是g</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f[<span class="number">1</span>]=sum[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">10000000</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag[i]) prime[++cnt]=i,f[i]=(<span class="number">1</span>-i+mod)%mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=<span class="number">10000000</span>;j++) &#123;</span><br><span class="line">            flag[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i%prime[j]==<span class="number">0</span>) &#123;</span><br><span class="line">                f[i*prime[j]]=f[i]%mod;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            f[i*prime[j]]=(LL)f[i]*f[prime[j]]%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        sum[i]=(sum[i<span class="number">-1</span>]+(LL)f[i]*i%mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">zjk</span><span class="params">(LL n,LL m)</span> </span>&#123;</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n&gt;m) swap(n,m);</span><br><span class="line">    <span class="keyword">for</span> (LL l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>) &#123;</span><br><span class="line">        r=min(n/(n/l),m/(m/l));</span><br><span class="line">        <span class="comment">// 分块：[l,r]</span></span><br><span class="line">        ans=(ans+((n/l*(n/l+<span class="number">1</span>)/<span class="number">2</span>)%mod*((m/l*(m/l+<span class="number">1</span>)/<span class="number">2</span>)%mod))%mod*(LL)(sum[r]-sum[l<span class="number">-1</span>]))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sieve();</span><br><span class="line">    <span class="keyword">int</span> n,m;<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,zjk(n,m));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>%%% ZJK</p><p>下面讨论一下使用莫比乌斯反演来容斥的题</p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5656" target="_blank" rel="noopener">CA Loves GCD</a></p><p>题意：给出n个[1,1000]的数，问所有选法中所选择的数的gcd的和</p><ul><li>$n \leq 1000$</li></ul><p>首先，还是对gcd分类，$f(i)$表示gcd为i的方案数</p><p>发现<code>f</code>好像很不好求，考虑设辅助函数</p><p>设$g(i)$表示gcd<strong>是i的倍数</strong>的方案数</p><p>很显然，在一个gcd为i的集合中，每一个数都是i的倍数</p><p>那么我们假设在这n个数中，i的倍数一共有k个</p><p>每个数可以选或者不选，一共有$2^k$种方案</p><p>减去所有数都不选的情况，就这一种</p><p>之后得到的就是$g(i)$的值</p><p>将<code>g</code>转化成<code>f</code></p><p>显然有</p><script type="math/tex; mode=display">g(i)=\sum_{i|d}f(i)</script><p>反演得</p><script type="math/tex; mode=display">f(i)=\sum_{i|d}g(d)\mu(\frac{i}{d})</script><p>对于每一个i，枚举每一个i的倍数转移即可</p><p>对于如何求i的倍数的个数，可以开一个桶。先预处理每个数的约数，当输入一个数a时，就把a的所有约数在桶中加一，最后桶中的第i个位置就是i的倍数的个数</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1010</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Div[N];</span><br><span class="line"><span class="keyword">int</span> flag[N], prime[N], ncnt, mu[N], Pow[N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e8</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Pow[<span class="number">0</span>] = <span class="number">1</span>, Pow[<span class="number">1</span>] = <span class="number">2</span>, mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= N - <span class="number">10</span>;i++) &#123;</span><br><span class="line">        Pow[i] = Pow[i - <span class="number">1</span>] * <span class="number">2</span> % mod;</span><br><span class="line">        <span class="keyword">if</span> (!flag[i]) mu[i] = <span class="number">-1</span>, prime[++ncnt] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= ncnt &amp;&amp; i * prime[j] &lt;= N - <span class="number">10</span>;j++) &#123;</span><br><span class="line">            flag[i * prime[j]] = <span class="number">1</span>; <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            mu[i * prime[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt;= N - <span class="number">10</span>;j += i) Div[j].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= N - <span class="number">10</span>;i++) Div[i].push_back(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> buk[N], ans[N], tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T), sieve();</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), <span class="built_in">memset</span>(buk, <span class="number">0</span>, <span class="keyword">sizeof</span>(buk)), <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a;i &lt;= n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a), tmp[a]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1000</span>;i++)</span><br><span class="line">            <span class="keyword">if</span> (tmp[i]) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; Div[i].size();j++) </span><br><span class="line">                buk[Div[i][j]] += tmp[i];</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1000</span>;i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt;= <span class="number">1000</span>;j += i) </span><br><span class="line">                ans[i] = (ans[i] + (Pow[buk[j]] - <span class="number">1</span>) * mu[j / i] + mod) % mod;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1000</span>;i++) </span><br><span class="line">            res = (res + (LL)i * ans[i] % mod) % mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫比乌斯反演 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后缀数组</title>
      <link href="/2019/03/07/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
      <url>/2019/03/07/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="一些约定"><a href="#一些约定" class="headerlink" title="一些约定"></a>一些约定</h2><ul><li><em>sa[i]</em> 排名为<em>i</em>的后缀在原串中的编号</li><li><em>rk[i]</em> 原串中第<em>i</em>个后缀所对应的排名</li><li><em>height[i]</em> <strong>排名</strong>为<em>i</em>的后缀与<strong>排名</strong>为<em>i – 1</em>的后缀的最长公共前缀</li></ul><h2 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h2><p>字符串<em>S = bacaab</em> 中，<em>sa，rk，height</em>分别为</p><p><img src="https://0x131cc05home.files.wordpress.com/2019/01/%E6%8D%95%E8%8E%B7.png?w=700" alt="捕获"></p><h2 id="一些解释"><a href="#一些解释" class="headerlink" title="一些解释"></a>一些解释</h2><p>在<em>S</em>中，所有的后缀分别为<em>bacaab, acaab, caab, aab, ab, b</em></p><p>将这些串按照字典序排序，可以得到<em>aab, ab, acaab, b, bacaab, caab</em></p><p>对应出来的<em>rk</em>值就是5, 3, 6, 1, 2, 4</p><p>根据上面的定义可以得出<em>sa[rk[i]] = i, rk[sa[i]] = i</em></p><p><em>sa[1] = 4</em> 对应后缀<em>aab</em>，<em>sa[2] = 5</em> 对应后缀<em>ab</em></p><p>因此<em>height[2]</em> = <em>lcp(sa[1],  sa[2]) = lcp(aab, ab) = 1</em></p><p>注：<em>height[1]</em> 没有意义，约定其等于0</p><h2 id="倍增"><a href="#倍增" class="headerlink" title="倍增"></a>倍增</h2><p>直接暴力求<em>sa</em>显然不行，由于涉及到后缀排序，所以考虑倍增</p><p>假设对于<strong>每个后缀的前k个字符</strong>，我们已经排好了序，考虑进一步的转移</p><p>如果直接比较每个后缀的第<em>k + 1</em>个字符，忽视了太多已经求出的信息</p><p>对于两个后缀<em>s1 = S[i, …], s2 = S[j,</em> …]，如果它们的前<em>k</em>个字母不全相同，那么我们在之前的比较中就已经确定好了这两个后缀的顺序</p><p>如果这两个后缀的前<em>k</em>个字母都相同，我们这次就比较<em>s1[k + 1, 2k], s2[k + 1, 2k]</em>的大小</p><p>显然，这两个串的长度都是<em>k</em>，这意味着我们已经比较过这两个串</p><p><img src="https://0x131cc05home.files.wordpress.com/2019/01/%E6%8D%95%E8%8E%B7-1.png?w=700" alt="捕获"></p><p>图中括号中的数字表示当前层中此串的排名，注意相同串的排名相同。</p><p>第一次比较将串<em>s1</em>与<em>s2</em>拼在一起，将串<em>s2</em>与<em>s3</em>拼在一起…</p><p>第二次比较将串<em>s1</em>与<em>s3</em>拼在一起，将串<em>s2</em>与<em>s4</em>拼在一起…</p><p>第三次比较将串<em>s1</em>与<em>s5</em>拼在一起，将串<em>s2</em>与<em>s6</em>拼在一起…</p><p>直到不同的串的个数为原串长度</p><p>那么问题来了，如何高效地比较？</p><p>首先利用好已得出的信息，将这次比较前各个串的排名作为<strong>第一关键字</strong></p><p>在这次比较中，每个字符串都将添加<em>k</em>个字符，对于串<em>s[i, …]</em>来说，将串<em>s[i + k, …]</em>的排名作为<strong>第二关键字</strong></p><p>注意空串的字典序最小，假设原串长度为<em>n</em>，注意到在<em>n – k + 1</em>到<em>n</em>位置的第二关键字都是空串，我们约定此时<em>n</em>位置的第二关键字最小，其次是<em>n – 1</em>，然后以此类推</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n;i &gt;= n - k + <span class="number">1</span>;i--) y[++num] = i; </span><br><span class="line"><span class="comment">// 添加的串为空</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span> (sa[i] &gt; k) y[++num] = sa[i] - k; </span><br><span class="line"><span class="comment">// 此时的i就是串sa[i] - k的第二关键字，注意枚举的i代表排名</span></span><br><span class="line"><span class="comment">// sa[i] &lt;= k时没有串会在后面添加串sa[i]，所以无视</span></span><br><span class="line"><span class="comment">// y[i] 表示排名为i的第二关键字对应的是哪个串</span></span><br></pre></td></tr></table></figure><p>对此时的所有串重新排序，第一关键字小的排前面，如果第一关键字相同，则第二关键字小的排前面</p><p>不能直接$n \log n$排序，这样的总时间复杂度与直接用哈希构造无异，因此选择桶排序</p><p>我们开一个桶<em>c</em>，将所有的第一关键字放进去，然后做一遍前缀和，可以得出每个元素的最大排名</p><p>由于第一关键字相同时，第二关键字较小的排名较前，因此我们从大到小枚举第二关键字，更新每个桶此时的最大排名和当前的<em>sa</em>数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) c[i] = <span class="number">0</span>; </span><br><span class="line"><span class="comment">// 先清空， m是当前第一关键字大小</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) c[x[i]]++; </span><br><span class="line"><span class="comment">// 将每个第一关键字加入桶</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) c[i] += c[i - <span class="number">1</span>]; </span><br><span class="line"><span class="comment">// 获得每个值的最大排名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n;i &gt;= <span class="number">1</span>;i--) sa[c[x[y[i]]]--] = y[i]; </span><br><span class="line"><span class="comment">// 第一关键字相同时，第二关键字越大排名越靠后</span></span><br></pre></td></tr></table></figure><p>最后，我们需要更新此时的第一关键字</p><p>用一个<em>num</em>表示当前不同元素个数，仅当<em>sa[i], sa[i – 1]</em>至少有一个关键字不同时，<em>num</em>才会累加1，更新<em>x</em>数组</p><p>用<em>m</em>更新<em>num</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(y, x, <span class="keyword">sizeof</span>(x)), num = x[sa[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 这个memcpy只是临时存一下，后面那个是初值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">    x[sa[i]] = (y[sa[i - <span class="number">1</span>]] == y[sa[i]] &amp;&amp; y[sa[i - <span class="number">1</span>] + k] == y[sa[i] + k]) ? num : ++num; </span><br><span class="line"><span class="comment">// 更新此时的第一关键字</span></span><br><span class="line"><span class="keyword">if</span> (num == n) <span class="keyword">break</span>; <span class="keyword">else</span> m = num; </span><br><span class="line"><span class="comment">// 更新第一关键字的最大值</span></span><br><span class="line"><span class="comment">// 如果m等于n，则代表已经分清了所有后缀的排名，没有必要继续比较下去</span></span><br></pre></td></tr></table></figure><p>最后总代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">GetSA</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) c[x[i] = s[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n;i &gt;= <span class="number">1</span>;i--) sa[c[x[i]]--] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, num = <span class="number">0</span>;k &lt;= n;k &lt;&lt;= <span class="number">1</span>, num = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n;i &gt;= n - k + <span class="number">1</span>;i--) y[++num] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) <span class="keyword">if</span> (sa[i] &gt; k) y[++num] = sa[i] - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) c[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) c[x[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) c[i] += c[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n;i &gt;= <span class="number">1</span>;i--) sa[c[x[y[i]]]--] = y[i];</span><br><span class="line">        <span class="built_in">memcpy</span>(y, x, <span class="keyword">sizeof</span>(x)), num = x[sa[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">            x[sa[i]] = (y[sa[i - <span class="number">1</span>]] == y[sa[i]] &amp;&amp; y[sa[i - <span class="number">1</span>] + k] == y[sa[i] + k]) ? num : ++num;</span><br><span class="line">        <span class="keyword">if</span> (num == n) <span class="keyword">break</span>; <span class="keyword">else</span> m = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于DC3"><a href="#关于DC3" class="headerlink" title="关于DC3"></a>关于DC3</h2><p>时间复杂度$O(n)$，但是实现较为繁琐，不推荐</p><p><del>其实是我不会233333</del></p><h2 id="关于height"><a href="#关于height" class="headerlink" title="关于height"></a>关于<em>height</em></h2><blockquote><p>$LCP$ 的几条定理</p><p>定义$LCP(i, j)​$为<strong>排名</strong>为<em>i</em>的后缀与<strong>排名</strong>为<em>j</em>的后缀的最长公共前缀长度</p><p>根据<em>height</em>数组的定义，$height[i] = LCP(i – 1, i)​$</p><ol><li>$LCP(i, j) = LCP(j, i)$ // 显然</li><li>$LCP(i, i) = LCP(i, i)$ // 同上</li><li>$LCP(i, j) = \min\{LCP(i, k), LCP(k, j)\}$ //  对于任意<em>i ≤</em> <em>k ≤ j</em>，即$LCP​$具有传递性</li><li>设$h[i] = height[rk[i]]$，即$height[i] = h[sa[i]]$，有$h[i] ≥ h[i – 1] – 1$</li></ol></blockquote><p>第4条定理的证明：</p><p><img src="https://0x131cc05home.files.wordpress.com/2019/01/%E6%8D%95%E8%8E%B7-2.png?w=700" alt="捕获.PNG"></p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Getheight</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) rk[sa[i]] = i;</span><br><span class="line"><span class="comment">// 根据定义，给rk赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k = <span class="number">0</span>;i &lt;= n;i++) &#123;</span><br><span class="line"><span class="comment">// k表示h[i - 1]，注意i是编号</span></span><br><span class="line">        <span class="keyword">if</span> (rk[i] == <span class="number">1</span>) <span class="keyword">continue</span>; <span class="keyword">if</span> (k) k--;</span><br><span class="line"><span class="comment">// height[1]没有意义，且h[i] &gt;= h[i - 1] - 1</span></span><br><span class="line">        <span class="keyword">int</span> at = sa[rk[i] - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (at + k &lt;= n &amp;&amp; i + k &lt;= n &amp;&amp; s[at + k] == s[i + k]) k++;</span><br><span class="line"><span class="comment">// 暴力向后匹配</span></span><br><span class="line">        height[rk[i]] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于最长公共前缀"><a href="#关于最长公共前缀" class="headerlink" title="关于最长公共前缀"></a>关于最长公共前缀</h2><p>由$LCP$的第三条定理可以快速确定任意两个后缀的最长公共前缀，具体地</p><p>$LCP(rk[i], rk[j]) = \min\{height[rk[i] + 1], height[rk[i] + 2], \cdots ,height[rk[j]]\}​$</p><p>使用ST表查找区间最小值即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">GetST</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(mn, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(mn));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) mn[<span class="number">0</span>][i] = height[i]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= n;j++) </span><br><span class="line">            mn[i][j] = min(mn[i - <span class="number">1</span>][j], mn[i - <span class="number">1</span>][j + (<span class="number">1</span> &lt;&lt; i - <span class="number">1</span>)]); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">GetLCP</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123; <span class="comment">// rank 为 L, R </span></span><br><span class="line">    <span class="keyword">if</span> (L &gt; R) swap(L, R);</span><br><span class="line">    L++; <span class="keyword">int</span> len = R - L + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!len) <span class="keyword">return</span> <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">return</span> min(mn[lg[len]][L], mn[lg[len]][R - (<span class="number">1</span> &lt;&lt; lg[len]) + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后缀数组 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
